/** @file
  File name:    DUNIT.h
  Input File:   DNV_MRC.xlsx

  THIS FILE IS AUTO-GENERATED BY THE MSP TOOL. DO NOT CHANGE THIS CODE.

  If edits are needed in this file, they must be done via the MSP tool.

  If there is additional project-specific data required by the MSP, it
  can be placed in DUNIT.h, which is used for non-tool-generated
  data

  Includes register defines specific to a project.

  Copyright (c) 2005-2018 Intel Corporation. All rights reserved
  This software and associated documentation (if any) is furnished
  under a license and may only be used or copied in accordance
  with the terms of the license. Except as permitted by such
  license, no part of this software or documentation may be
  reproduced, stored in a retrieval system, or transmitted in any
  form or by any means without the express written consent of
  Intel Corporation.
**/
#ifndef _DUNIT_H_
#define _DUNIT_H_

#include "DataTypes.h"

#if USE_64_BIT_VARIABLES
#define UINTX UINT64
#else
#define UINTX UINT32
#endif

#define DRAM_CMD_DDR4_DUNIT_REG                            0x00000098
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Command (RAS#,CAS#,WE#): Sets the value to be driven on the RAS#, CAS# and WE#
    // pins, respectively. 
    // 
    // Bits[2:0], WO, default = 0x0
    //
    UINTX command : 3;
    //
    // ACT_N
    // 
    // Bits[3:3], WO, default = 0x0
    //
    UINTX act_n : 1;
    //
    // Bank Address: Sets the value of BA[1:0].
    // 
    // Bits[5:4], WO, default = 0x0
    //
    UINTX bankaddress : 2;
    //
    // Bank Group: Sets the value of BG[1:0]
    // 
    // Bits[7:6], WO, default = 0x0
    //
    UINTX bankgroup : 2;
    //
    // Memory Address: Sets the value of MA[17:0]
    // 
    // Bits[25:8], WO, default = 0x0
    //
    UINTX memoryaddress : 18;
    //
    // Rank Select: 00 = Rank0, 01 = Rank1, 10 = Rank2, 11 = Rank3
    // 
    // Bits[27:26], WO, default = 0x0
    //
    UINTX rankselect : 2;
    //
    // BA[1:0] to be used by read command when the MPR mode sequence is selected (bit
    // 30 = 1) 
    // 
    // Bits[29:28], WO, default = 0x0
    //
    UINTX ba : 2;
    //
    // MPR Mode Sequence
    // 
    // Bits[30:30], WO, default = 0x0
    //
    UINTX mpr : 1;
    //
    // PREA issued prior to the command; intended to be used with an MRS command. (Functionality
    // not implemented in Dunit) 
    // 
    // Bits[31:31], WO, default = 0x0
    //
    UINTX prea : 1;
  } Bits;
  UINTX Data;
} DRAM_CMD_DDR4_DUNIT_STRUCT;
#endif // ASM_INC

#define DRAM_CMD_DDR3_DUNIT_REG                            0x00000098
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Command (RAS#,CAS#,WE#): Sets the value to be driven on the RAS#, CAS# and WE#
    // pins, respectively. 
    // 
    // Bits[2:0], WO, default = 0x0
    //
    UINTX command : 3;
    //
    // Bank Address: Sets the value of BA[2:0].
    // 
    // Bits[5:3], WO, default = 0x0
    //
    UINTX bankaddress : 3;
    //
    // Memory Address: Sets the value of MA[15:0]
    // 
    // Bits[21:6], WO, default = 0x0
    //
    UINTX memoryaddress : 16;
    //
    // Rank Select: 00 = Rank0, 01 = Rank1, 10 = Rank2, 11 = Rank3
    // 
    // Bits[23:22], WO, default = 0x0
    //
    UINTX rankselect : 2;
    //
    // Reserved
    // 
    // Bits[31:24], WO, default = 0x0
    //
    UINTX reserved : 8;
  } Bits;
  UINTX Data;
} DRAM_CMD_DDR3_DUNIT_STRUCT;
#endif // ASM_INC

#define DMAP_MISC_DUNIT_REG                                0x00000174
#ifndef ASM_INC
typedef union {
  struct {
    //
    // DMAP_MISC
    // 
    // Bits[31:0], RW/P, default = 0x0
    //
    UINTX data : 32;
  } Bits;
  UINTX Data;
} DMAP_MISC_DUNIT_STRUCT;
#endif // ASM_INC

#define DMAP1_MISC_DUNIT_REG                               0x000000B4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // DMAP1_MISC
    // 
    // Bits[31:0], RW/P, default = 0x0
    //
    UINTX data : 32;
  } Bits;
  UINTX Data;
} DMAP1_MISC_DUNIT_STRUCT;
#endif // ASM_INC

#define DMAP2_MISC_DUNIT_REG                               0x00000148
#ifndef ASM_INC
typedef union {
  struct {
    //
    // DMAP2_MISC
    // 
    // Bits[31:0], RW/P, default = 0x0
    //
    UINTX data : 32;
  } Bits;
  UINTX Data;
} DMAP2_MISC_DUNIT_STRUCT;
#endif // ASM_INC

#define DMAP3_MISC_DUNIT_REG                               0x0000014C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // DMAP3_MISC
    // 
    // Bits[31:0], RW/P, default = 0x0
    //
    UINTX data : 32;
  } Bits;
  UINTX Data;
} DMAP3_MISC_DUNIT_STRUCT;
#endif // ASM_INC

#define DMAP4_MISC_DUNIT_REG                               0x00000150
#ifndef ASM_INC
typedef union {
  struct {
    //
    // DMAP4_MISC
    // 
    // Bits[31:0], RW/P, default = 0x0
    //
    UINTX data : 32;
  } Bits;
  UINTX Data;
} DMAP4_MISC_DUNIT_STRUCT;
#endif // ASM_INC

#define DMAP5_MISC_DUNIT_REG                               0x00000154
#ifndef ASM_INC
typedef union {
  struct {
    //
    // DMAP5_MISC
    // 
    // Bits[31:0], RW/P, default = 0x0
    //
    UINTX data : 32;
  } Bits;
  UINTX Data;
} DMAP5_MISC_DUNIT_STRUCT;
#endif // ASM_INC

#define DRP_DATA_DUNIT_REG                                 0x00000158
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Data31_0
    // 
    // Bits[31:0], RW, default = 0x0
    //
    UINTX data : 32;
  } Bits;
  UINTX Data;
} DRP_DATA_DUNIT_STRUCT;
#endif // ASM_INC

#define DPMC0_DATA_DUNIT_REG                               0x00000178
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Data31_0
    // 
    // Bits[31:0], RW, default = 0x0
    //
    UINTX data : 32;
  } Bits;
  UINTX Data;
} DPMC0_DATA_DUNIT_STRUCT;
#endif // ASM_INC

#define DECCCTRL_DATA_DUNIT_REG                            0x00000180
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Data31_0
    // 
    // Bits[31:0], RW, default = 0x0
    //
    UINTX data : 32;
  } Bits;
  UINTX Data;
} DECCCTRL_DATA_DUNIT_STRUCT;
#endif // ASM_INC

#define DPATROL_SCRUB_CFG_DATA_DUNIT_REG                   0x000000B0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Data31_0
    // 
    // Bits[31:0], RW, default = 0x0
    //
    UINTX data : 32;
  } Bits;
  UINTX Data;
} DPATROL_SCRUB_CFG_DATA_DUNIT_STRUCT;
#endif // ASM_INC

#define DCS_DATA_DUNIT_REG                                 0x00000170
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Data31_0
    // 
    // Bits[31:0], RW, default = 0x0
    //
    UINTX data : 32;
  } Bits;
  UINTX Data;
} DCS_DATA_DUNIT_STRUCT;
#endif // ASM_INC

#define DRAPLCTL_DATA_DUNIT_REG                            0x0000003C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Data31_0
    // 
    // Bits[31:0], RW, default = 0x0
    //
    UINTX data : 32;
  } Bits;
  UINTX Data;
} DRAPLCTL_DATA_DUNIT_STRUCT;
#endif // ASM_INC

#define DRAPLPWR0_DATA_DUNIT_REG                           0x00000044
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Data31_0
    // 
    // Bits[31:0], RW, default = 0x0
    //
    UINTX data : 32;
  } Bits;
  UINTX Data;
} DRAPLPWR0_DATA_DUNIT_STRUCT;
#endif // ASM_INC

#define DRAPLPWR1_DATA_DUNIT_REG                           0x00000048
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Data31_0
    // 
    // Bits[31:0], RW, default = 0x0
    //
    UINTX data : 32;
  } Bits;
  UINTX Data;
} DRAPLPWR1_DATA_DUNIT_STRUCT;
#endif // ASM_INC

#define DPDA_ENTRY_DRAM_CMD_MISC_DUNIT_REG                 0x000000B8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // 
    // 
    // Bits[31:0], RW, default = 0x0
    //
    UINTX dpda_entry_dram_cmd : 32;
  } Bits;
  UINTX Data;
} DPDA_ENTRY_DRAM_CMD_MISC_DUNIT_STRUCT;
#endif // ASM_INC

#define DPDA_DRAM_CMD_MISC_DUNIT_REG                       0x000000BC
#ifndef ASM_INC
typedef union {
  struct {
    //
    // 
    // 
    // Bits[31:0], RW, default = 0x0
    //
    UINTX dpda_dram_cmd : 32;
  } Bits;
  UINTX Data;
} DPDA_DRAM_CMD_MISC_DUNIT_STRUCT;
#endif // ASM_INC

#define DPDA_EXIT_DRAM_CMD_MISC_DUNIT_REG                  0x000000C0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // 
    // 
    // Bits[31:0], RW, default = 0x0
    //
    UINTX dpda_exit_dram_cmd : 32;
  } Bits;
  UINTX Data;
} DPDA_EXIT_DRAM_CMD_MISC_DUNIT_STRUCT;
#endif // ASM_INC

#define MCI_CTL_DUNIT_REG                                  0x00000000
#ifndef ASM_INC
typedef union {
  struct {
    //
    // When set, enables MCA error reporting for write data parity errors
    // 
    // Bits[0:0], RW/P, default = 0x0
    //
    UINTX wpe : 1;
    //
    // When set, enables MCA error reporting for DDR4 address parity errors
    // 
    // Bits[1:1], RW/P, default = 0x0
    //
    UINTX ape : 1;
    //
    // When set, enables MCA error reporting for patrol scrubs
    // 
    // Bits[2:2], RW/P, default = 0x0
    //
    UINTX uce_pat : 1;
    //
    // When set, enables MCA error reporting for demand scrubs
    // 
    // Bits[3:3], RW/P, default = 0x0
    //
    UINTX uce_dem : 1;
    //
    // Reserved
    // 
    // Bits[63:4], RSV, default = 0x0
    //
    UINTX reg_rsvd : 60;
  } Bits;
  UINTX Data;
} MCI_CTL_DUNIT_STRUCT;
#endif // ASM_INC

#define MCI_STATUS_DUNIT_REG                               0x00000008
#ifndef ASM_INC
typedef union {
  struct {
    //
    // MCA error code
    // 
    // Bits[15:0], RO/V/P, default = 0x0
    //
    UINTX mca_err_code : 16;
    //
    // Error code of detected error
    // 
    // Bits[31:16], RW/V/P, default = 0x0
    //
    UINTX model_specific_err_code : 16;
    //
    // Reserved
    // 
    // Bits[37:32], RSV, default = 0x0
    //
    UINTX reg_rsvd : 6;
    //
    // Total number of corrected errors
    // 
    // Bits[52:38], RW/V/P, default = 0x0
    //
    UINTX corrected_err_count : 15;
    //
    // Reserved
    // 
    // Bits[56:53], RSV, default = 0x0
    //
    UINTX reg_rsvd2 : 4;
    //
    // Processor Context Corrupt.  Set to 1 when an uncorrected error is detected.
    // 
    // Bits[57:57], RW/V/P, default = 0x0
    //
    UINTX pcc : 1;
    //
    // Set when the MCA ADDRV register is valid.  This is not implemented for DNV and
    // is tied to '0. 
    // 
    // Bits[58:58], RW/V/P, default = 0x0
    //
    UINTX status_addrv : 1;
    //
    // Set when the MCA misc register is valid
    // 
    // Bits[59:59], RW/V/P, default = 0x0
    //
    UINTX status_miscv : 1;
    //
    // Error reporting has been enabled by the MCA_CTL register.  This refers to the
    // error reporting for uncorrectable errors. 
    // 
    // Bits[60:60], RW/V/P, default = 0x0
    //
    UINTX err_enabled : 1;
    //
    // Indicates that an uncorrected error was received
    // 
    // Bits[61:61], RW/V/P, default = 0x0
    //
    UINTX uncorrected_err : 1;
    //
    // Indicates a second error was received while the MCi_Status Valid bit is set. 
    // The Dunit supports the machine check overwrite rules for a machine check overflow.
    //  For the purpose of dunit error reporting, corrected errors will be overwritten
    // by any new errors received.  The first uncorrected error received will not be
    // overwritten by any new errors received. 
    // 
    // Bits[62:62], RW/V/P, default = 0x0
    //
    UINTX err_overflow : 1;
    //
    // When set, this bit indicates that the information in the IA32_MCA_STATUS register
    // is valid.  Software is responsible for clearing this bit. 
    // 
    // Bits[63:63], RW/V/P, default = 0x0
    //
    UINTX valid : 1;
  } Bits;
  UINTX Data;
} MCI_STATUS_DUNIT_STRUCT;
#endif // ASM_INC

#define MCI_MISC_DUNIT_REG                                 0x00000010
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Reserved
    // 
    // Bits[29:0], RSV, default = 0x0
    //
    UINTX reg_rsvd : 30;
    //
    // Set to 0 if DIMM flip is enabled.  This is used by the DRAM when the DIMM 0 has
    // lower capacity than DIMM1. 
    // 
    // Bits[30:30], RW/V/P, default = 0x0
    //
    UINTX mca_dimm_flip : 1;
    //
    // Column address bits 11,9:2
    // 
    // Bits[39:31], RW/V/P, default = 0x0
    //
    UINTX mca_col : 9;
    //
    // Row address (18 bits)
    // 
    // Bits[57:40], RW/V/P, default = 0x0
    //
    UINTX mca_row : 18;
    //
    // Bank ID
    // 
    // Bits[61:58], RW/V/P, default = 0x0
    //
    UINTX mca_bank : 4;
    //
    // Rank address.  For DIMM flip set to 0, rank 0 and 1 are in DIMM 0 and rank 2 and
    // rank 3 are in DIMM 1.  DIMM flip set to 1 has rank 0 and rank 1 in DIMM 0 and
    // rank 2 and rank 3 in DIMM 1. 
    // 
    // Bits[63:62], RW/V/P, default = 0x0
    //
    UINTX mca_rank : 2;
  } Bits;
  UINTX Data;
} MCI_MISC_DUNIT_STRUCT;
#endif // ASM_INC

#define MCI_CTL2_DUNIT_REG                                 0x00000018
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Specifies the threshold of corrected errors when to signal an MCA event.  If the
    // number of corrected errors recorded in MCiStatus.CORRECTED_ERR_COUNT is equal
    // to this value, dunit will trigger an MCA event if ENABLE_MC_CORRECTED_SIGNAL is
    // also set. if set to 0 no MCA will be sent. Firmware is resposible for clearing
    // the error count before it wraps around to prevent signaling additional MCAs 
    // 
    // Bits[14:0], RW/P, default = 0x0
    //
    UINTX correct_err_thrshold : 15;
    //
    // Reserved
    // 
    // Bits[29:15], RSV, default = 0x0
    //
    UINTX reg_rsvd : 15;
    //
    // Enables signaling of a CMCI event for corrected errors detected from DRAM ECC
    // logic 
    // 
    // Bits[30:30], RW/P, default = 0x0
    //
    UINTX enable_mc_corrected_signal : 1;
    //
    // Reserved
    // 
    // Bits[63:31], RSV, default = 0x0
    //
    UINTX reg_rsvd2 : 33;
  } Bits;
  UINTX Data;
} MCI_CTL2_DUNIT_STRUCT;
#endif // ASM_INC

#define DRAPLCTL_DUNIT_REG                                 0x0000003C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Rank Selection for the DRAM RAPL CKE counter (DRAPLCCNT), read command counter
    // (DRAPLRCNT) and the write command counter (DRAPLWCNT).  This field should be set
    // to Fh to select all ranks, but it can be configured to select any/all ranks for
    // debug or performance monitoring. 
    // 
    // Bits[3:0], RW/P, default = 0x0
    //
    UINTX ranksel : 4;
    //
    // CKE Counter Enable: Setting this to 1 enables the CKE counter (DRAPLCCNT).
    // 
    // Bits[4:4], RW/P, default = 0x0
    //
    UINTX ccnten : 1;
    //
    // Read Command Counter Enable: Setting this to 1 enables the read command counter
    // (DRAPLRCNT). 
    // 
    // Bits[5:5], RW/P, default = 0x0
    //
    UINTX rcnten : 1;
    //
    // Write Command Counter Enable: Setting this to 1 enables the write command counter
    // (DRAPLWCNT). 
    // 
    // Bits[6:6], RW/P, default = 0x0
    //
    UINTX wcnten : 1;
    //
    // Energy Counter Enable: Setting this bit to 1 enables the energy counter to accumulate
    // the weighted command energy counts. Setting this bit to 0 disables the energy
    // counter. 
    // 
    // Bits[7:7], RW/P, default = 0x0
    //
    UINTX ncnten : 1;
    //
    // CKE Counter Clear on Read: Setting this bit to 1 will cause the DRAPLCCNT register
    // to clear after being read via IOSF-Sideband.  Otherwise this counter will continuously
    // count the CKE events and eventually wrap around back to 0. 
    // 
    // Bits[8:8], RW/P, default = 0x0
    //
    UINTX ccntclr : 1;
    //
    // Read Counter Clear on Read: Setting this bit to 1 will cause the DAPLRCNT register
    // to clear after being read via IOSF-Sideband.  Otherwise this counter will continuously
    // count the read command events and eventually wrap around back to 0. 
    // 
    // Bits[9:9], RW/P, default = 0x0
    //
    UINTX rcntclr : 1;
    //
    // Write Counter Clear on Read: Setting this bit to 1 will cause the DRAPLWCNT register
    // to clear after being read via IOSF-Sideband.  Otherwise this counter will continuously
    // count the write command events and eventually wrap around back to 0. 
    // 
    // Bits[10:10], RW/P, default = 0x0
    //
    UINTX wcntclr : 1;
    //
    // Energy Counter Clear on Read: Setting this bit to 1 will cause the energy counter
    // to clear after being read via IOSF-Sideband.  Otherwise this counter will continuously
    // count the weighted energy events and eventually wrap around back to 0. 
    // 
    // Bits[11:11], RW/P, default = 0x0
    //
    UINTX ncntclr : 1;
    //
    // Rsvd
    // 
    // Bits[13:12], RSV, default = 0x0
    //
    UINTX rsvd_draplctl_0 : 2;
    //
    // Dunit Clock Counter Enable: Setting this bit to 1 enables the Dunit clock counter
    // (DRAPLDCNT). 
    // 
    // Bits[14:14], RW/P, default = 0x0
    //
    UINTX dcnten : 1;
    //
    // Dunit Clock Counter Clear on Read: Setting this bit to 1 will cause the DRAPLDCNT
    // register to clear after being read via IOSF-Sideband.  Otherwise this counter
    // will continuously count the Dunit clock cycles and eventually wrap around back
    // to 0. 
    // 
    // Bits[15:15], RW/P, default = 0x0
    //
    UINTX dcntclr : 1;
    //
    // Rsvd
    // 
    // Bits[31:16], RSV, default = 0x0
    //
    UINTX rsvd_draplctl_1 : 16;
  } Bits;
  UINTX Data;
} DRAPLCTL_DUNIT_STRUCT;
#endif // ASM_INC

#define DRAPLPWR0_DUNIT_REG                                0x00000044
#ifndef ASM_INC
typedef union {
  struct {
    //
    // The power contribution of a read command issued to DIMM0. When a read command
    // is issued, the DRAPLNCNT will be increased by this amount. 
    // 
    // Bits[3:0], RW/P, default = 0x0
    //
    UINTX rdcmd_cnt : 4;
    //
    // The power contribution of a write command issued to DIMM0. When a write command
    // is issued, the DRAPLNCNT will be increased by this amount. 
    // 
    // Bits[7:4], RW/P, default = 0x0
    //
    UINTX wrcmd_cnt : 4;
    //
    // The power contribution of a 1x refresh command or a self refresh entry (SRE) command
    // issued to DIMM0. The 8-bit refresh weight defined here is actually being multiplied
    // by 8 (shift left by 3 bits) before being added to the energy counter (DRAPLNCNT)
    //  
    // 
    // Bits[15:8], RW/P, default = 0x0
    //
    UINTX refcmd_cnt : 8;
    //
    // The power contribution of an activate command and the associated (implicit or
    // explicit) precharge command issued to DIMM0. When an activate command is issued,
    // the DRAPLNCNT will be increased by this amount. 
    // 
    // Bits[21:16], RW/P, default = 0x0
    //
    UINTX actcmd_cnt : 6;
    //
    // The number of DIMM0 CKE assertions in DRAM clock cycles required to increment
    // the energy counter (DRAPLNCNT) by 4. There are two CKE signals per DIMM and the
    // Dunit operates at x the DRAM clock frequency, so there will be 0 to 4 CKE assertions
    // per Dunit clock cycle. Valid values for this field are greater than or equal to
    // 2.  Programming this field to 0 will disable the CKE assertions from being counted.
    //  All other values are reserved. 
    // 
    // Bits[26:22], RW/P, default = 0x0
    //
    UINTX numcke_inc : 5;
    //
    // The number of DIMM0 ODT assertions in DRAM clock cycles required to increment
    // the energy counter (DRAPLNCNT) by 16. There are two ODT signals per DIMM, but
    // at most only one will be asserted.  The Dunit operates a x the DRAM clock frequency,
    // so there will be 0 to 2 ODT assertions per Dunit clock cycle. Valid values for
    // this field are greater than or equal to 4. Programming this field to a value of
    // 0 will disable the ODT assertions from being counted. All other values are reserved.
    // 
    // Bits[31:27], RW/P, default = 0x0
    //
    UINTX numodt_inc : 5;
  } Bits;
  UINTX Data;
} DRAPLPWR0_DUNIT_STRUCT;
#endif // ASM_INC

#define DRAPLPWR1_DUNIT_REG                                0x00000048
#ifndef ASM_INC
typedef union {
  struct {
    //
    // The power contribution of a read command issued to DIMM1. When a read command
    // is issued, the DRAPLNCNT will be increased by this amount. 
    // 
    // Bits[3:0], RW/P, default = 0x0
    //
    UINTX rdcmd_cnt : 4;
    //
    // The power contribution of a write command issued to DIMM1. When a write command
    // is issued, the DRAPLNCNT will be increased by this amount. 
    // 
    // Bits[7:4], RW/P, default = 0x0
    //
    UINTX wrcmd_cnt : 4;
    //
    // The power contribution of a 1x refresh command or a self refresh entry (SRE) command
    // issued to DIMM1. The 8-bit refresh weight defined here is actually being multiplied
    // by 8 (shift left by 3 bits) before being added to the energy counter (DRAPLNCNT)
    // 
    // Bits[15:8], RW/P, default = 0x0
    //
    UINTX refcmd_cnt : 8;
    //
    // The power contribution of an activate command and the associated (implicit or
    // explicit) precharge command issued to DIMM1. When an activate command is issued,
    // the DRAPLNCNT will be increased by this amount. 
    // 
    // Bits[21:16], RW/P, default = 0x0
    //
    UINTX actcmd_cnt : 6;
    //
    // The number of DIMM1 CKE assertions in DRAM clock cycles required to increment
    // the energy counter (DRAPLNCNT) by 4. There are two CKE signals per DIMM and the
    // Dunit operates at x the DRAM clock frequency, so there will be 0 to 4 CKE assertions
    // per Dunit clock cycle. Valid values for this field are greater than or equal to
    // 2.  Programming this field to 0 will disable the CKE assertions from being counted.
    //  All other values are reserved. 
    // 
    // Bits[26:22], RW/P, default = 0x0
    //
    UINTX numcke_inc : 5;
    //
    // The number of DIMM1 ODT assertions in DRAM clock cycles required to increment
    // the energy counter (DRAPLNCNT) by 16. There are two ODT signals per DIMM, but
    // at most only one will be asserted.  The Dunit operates a x the DRAM clock frequency,
    // so there will be 0 to 2 ODT assertions per Dunit clock cycle. Valid values for
    // this field are greater than or equal to 4. Programming this field to a value of
    // 0 will disable the ODT assertions from being counted. All other values are reserved.
    // 
    // Bits[31:27], RW/P, default = 0x0
    //
    UINTX numodt_inc : 5;
  } Bits;
  UINTX Data;
} DRAPLPWR1_DUNIT_STRUCT;
#endif // ASM_INC

#define DRAPLNCNT_DUNIT_REG                                0x0000004C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // The DRAM RAPL energy counter accumulates all of the weighted command/CKE/ODT counts
    // as defined in the DRAPLPWR[1:0] registers. This register is read-only by SW and
    // the contents are maintained/updated/cleared by HW. This counter will clear to
    // 0 on a read if DRAPLCTL.NCNTCLR=1. This counter is enabled to accumulate the configured
    // energy events if enabled by setting DRAPLCTL.NCNTEN=1. 
    // 
    // Bits[31:0], RO/V, default = 0x0
    //
    UINTX nrgycnt : 32;
  } Bits;
  UINTX Data;
} DRAPLNCNT_DUNIT_STRUCT;
#endif // ASM_INC

#define DRAPLCCNT_DUNIT_REG                                0x00000054
#ifndef ASM_INC
typedef union {
  struct {
    //
    // The DRAM RAPL CKE counter counts the number of CKE assertions in terms of DRAM
    // clocks; since there are 4 CKE signals, this counter can increase by at most 4
    // per DRAM clock cycle, or by at most 8 per Dunit clock cycle. This register is
    // read-only by SW and the contents are maintained/updated/cleared by HW. This counter
    // can be configured to self-clear after being read by SW by setting DRAPLCTL.CCNTCLR=1.
    // Note that this counter only counts the CKE signals that are associated with the
    // ranks selected by DRAPLCTL.RANKSEL[3:0].  This counter is enabled to accumulate
    // the configured CKE events if enabled by setting DRAPLCTL.CCNTEN=1. 
    // 
    // Bits[31:0], RO/V, default = 0x0
    //
    UINTX ckecnt : 32;
  } Bits;
  UINTX Data;
} DRAPLCCNT_DUNIT_STRUCT;
#endif // ASM_INC

#define DRAPLRCNT_DUNIT_REG                                0x00000058
#ifndef ASM_INC
typedef union {
  struct {
    //
    // The DRAM RAPL read command counter counts the number of read commands issued by
    // the scheduler. This register is read-only by SW and the contents are maintained/updated/cleared
    // by HW. This counter can be configured to self-clear after being read by SW by
    // setting DRAPLCTL.RCNTCLR=1. Note that this counter only counts the read commands
    // that are issued to the ranks selected by DRAPLCTL.RANKSEL[3:0]. This counter is
    // enabled to accumulate the configured read command events if enabled by setting
    // DRAPLCTL.RCNTEN=1. 
    // 
    // Bits[31:0], RO/V, default = 0x0
    //
    UINTX readcnt : 32;
  } Bits;
  UINTX Data;
} DRAPLRCNT_DUNIT_STRUCT;
#endif // ASM_INC

#define DRAPLWCNT_DUNIT_REG                                0x0000005C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // The DRAM RAPL write command counter counts the number of write commands issued
    // by the scheduler. This register is read-only by SW and the contents are maintained/updated/cleared
    // by HW. This counter can be configured to self-clear after being read by SW by
    // setting DRAPLCTL.WCNTCLR=1. Note that this counter only counts the write commands
    // that are issued to the ranks selected by DRAPLCTL.RANKSEL[3:0]. This counter is
    // enabled to accumulate the configured write command events if enabled by setting
    // DRAPLCTL.WCNTEN=1. 
    // 
    // Bits[31:0], RO/V, default = 0x0
    //
    UINTX writecnt : 32;
  } Bits;
  UINTX Data;
} DRAPLWCNT_DUNIT_STRUCT;
#endif // ASM_INC

#define DRAPLDCNT_DUNIT_REG                                0x00000060
#ifndef ASM_INC
typedef union {
  struct {
    //
    // The DRAM RAPL Dunit clock cycle counter increments every CZ clock cycle when enabled.
    // This register is read-only by SW and the contents are maintained/updated/cleared
    // by HW. This counter can be configured to self-clear after being read by SW by
    // setting DRAPLCTL.DCNTCLR=1. This counter is enabled by setting DRAPLCTL.DCNTEN=1.
    // 
    // Bits[31:0], RO/V, default = 0x0
    //
    UINTX dclkcnt : 32;
  } Bits;
  UINTX Data;
} DRAPLDCNT_DUNIT_STRUCT;
#endif // ASM_INC

#define UCELOG_DUNIT_REG                                   0x00000064
#ifndef ASM_INC
typedef union {
  struct {
    //
    // ECC Syndrome: This is the 8-bit syndrome output of the ECC checker logic.  For
    // DNV, this field does not provide useful information and is not reliable. 
    // 
    // Bits[7:0], RO/V/P, default = 0x0
    //
    UINTX ucesynd : 8;
    //
    // Burst Offset: This is the burst number that contained the error.  Note that all
    // 8 bursts are always numbered starting from 0.  Thus, even when the critical chunk
    // causes the bursts to occur in the logical order of 4,5,6,7,0,1,2,3, UCEBOFF will
    // still number these starting from 0.  So, for example, if an error is detected
    // on logical byte 0, it is possible that this may be recorded as byte offset 4 with
    // critical chunk reordering. 
    // 
    // Bits[10:8], RO/V/P, default = 0x0
    //
    UINTX uceboff : 3;
    //
    // Burst Length 8: 0 = Burst Chop 4, 1 = Burst Length 8.  This will always be 1 for
    // DNV. 
    // 
    // Bits[11:11], RO/V/P, default = 0x1
    //
    UINTX ucebl8 : 1;
    //
    // Address bit 5: This is A[5] from the original request
    // 
    // Bits[12:12], RO/V/P, default = 0x0
    //
    UINTX ucea5 : 1;
    //
    // First Burst: If this bit is set, then the error occurred within the first four
    // DQ bus bursts after a DQ bus turn-around cycle. 
    // 
    // Bits[13:13], RO/V/P, default = 0x0
    //
    UINTX ucefirst : 1;
    //
    // Last Burst: If this bit is set, then the error occurred within that last four
    // DQ bus bursts before a DQ bus turn-around cycle. 
    // 
    // Bits[14:14], RO/V/P, default = 0x0
    //
    UINTX ucelast : 1;
    //
    // Auto Pre-charge was issued on the read that contained the error. This will always
    // be 0 since AP is not supported. 
    // 
    // Bits[15:15], RO/V/P, default = 0x0
    //
    UINTX uceap : 1;
    //
    // Bank Address: This is the bank address that contained the error.
    // DDR3:	UCEBNK[3] will always be 0
    // 	UCEBNK[2:0] = BA[2:0]
    // DDR4:	UCEBNK[3:2] = BG[1:0]
    // 	UCEBNK[1:0] = BA[1:0]
    // 
    // Bits[19:16], RO/V/P, default = 0x0
    //
    UINTX ucebnk : 4;
    //
    // Rank Address: This is the rank address that contained the error
    // 
    // Bits[21:20], RO/V/P, default = 0x0
    //
    UINTX ucernk : 2;
    //
    // Reserved
    // 
    // Bits[31:22], RSV, default = 0x0
    //
    UINTX rsvd_ucelog_1 : 10;
  } Bits;
  UINTX Data;
} UCELOG_DUNIT_STRUCT;
#endif // ASM_INC

#define UCEADDR_DUNIT_REG                                  0x00000068
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Address Log: Captures the PMI address A[35:6] of the UCE error location.
    // 
    // Bits[31:0], RO/V/P, default = 0x0
    //
    UINTX uceaddr : 32;
  } Bits;
  UINTX Data;
} UCEADDR_DUNIT_STRUCT;
#endif // ASM_INC

#define SBELOG_DUNIT_REG                                   0x0000006C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // ECC Syndrome: This is the 8-bit syndrome output of the ECC checker logic 
    // 
    // Bits[7:0], RO/V/P, default = 0x0
    //
    UINTX sbesynd : 8;
    //
    // Burst Offset: This is the burst number that contained the error.  Note that all
    // 8 bursts are always numbered starting from 0.  Thus, even when the critical chunk
    // causes the bursts to occur in the logical order of 4,5,6,7,0,1,2,3, SBEBOFF will
    // still number these starting from 0.  So, for example, if an error is detected
    // on logical byte 0, it is possible that this may be recorded as byte offset 4 with
    // critical chunk reordering. 
    // 
    // Bits[10:8], RO/V/P, default = 0x0
    //
    UINTX sbeboff : 3;
    //
    // Burst Length 8: 0 = Burst Chop 4, 1 = Burst Length 8.  This will always be 1 for
    // DNV. 
    // 
    // Bits[11:11], RO/V/P, default = 0x1
    //
    UINTX sbebl8 : 1;
    //
    // Address bit 5: This is A[5] from the original request
    // 
    // Bits[12:12], RO/V/P, default = 0x0
    //
    UINTX sbea5 : 1;
    //
    // First Burst: If this bit is set, then the error occurred within the first four
    // DQ bus bursts after a DQ bus turn-around cycle. 
    // 
    // Bits[13:13], RO/V/P, default = 0x0
    //
    UINTX sbefirst : 1;
    //
    // Last Burst: If this bit is set, then the error occurred within that last four
    // DQ bus bursts before a DQ bus turn-around cycle. 
    // 
    // Bits[14:14], RO/V/P, default = 0x0
    //
    UINTX sbelast : 1;
    //
    // Auto Pre-charge was issued on the read that contained the error. This will always
    // be 0 since AP is not supported. 
    // 
    // Bits[15:15], RO/V/P, default = 0x0
    //
    UINTX sbeap : 1;
    //
    // Bank Address: This is the bank address that contained the error.
    // DDR3:	UCEBNK[3] will always be 0
    // 	UCEBNK[2:0] = BA[2:0]
    // DDR4:	UCEBNK[3:2] = BG[1:0]
    // 	UCEBNK[1:0] = BA[1:0]
    // 
    // Bits[19:16], RO/V/P, default = 0x0
    //
    UINTX sbebnk : 4;
    //
    // Rank Address: This is the rank address that contained the error
    // 
    // Bits[21:20], RO/V/P, default = 0x0
    //
    UINTX sbernk : 2;
    //
    // Reserved
    // 
    // Bits[31:22], RSV, default = 0x0
    //
    UINTX rsvd_sbelog_1 : 10;
  } Bits;
  UINTX Data;
} SBELOG_DUNIT_STRUCT;
#endif // ASM_INC

#define SBEADDR_DUNIT_REG                                  0x00000070
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Address Log: Captures the PMI address A[35:6] of the SBE error location.
    // 
    // Bits[31:0], RO/V/P, default = 0x0
    //
    UINTX sbeaddr : 32;
  } Bits;
  UINTX Data;
} SBEADDR_DUNIT_STRUCT;
#endif // ASM_INC

#define SBECNT0_DUNIT_REG                                  0x00000074
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Single Bit Error Count for Rank 0. Any write to this register will clear the counter
    // to 0. 
    // 
    // Bits[15:0], RW/C/V/P, default = 0x0
    //
    UINTX cnt : 16;
    //
    // The per rank status bits are set when a rank's error count equals the threshold.
    //  The status bits are what tell the BIOS/BMC what caused SMI/ERR[0] to get triggered.
    //  Once the status bits are set, they will remain set until cleared by BIOS and
    // will cause the SMI/ERR[0] to get signaled to the cores. 
    // 
    // Bits[16:16], RW/C/V/P, default = 0x0
    //
    UINTX correrrorstatus : 1;
    //
    // Reserved
    // 
    // Bits[31:17], RSV, default = 0x0
    //
    UINTX rsvd_sbecnt0_0 : 15;
  } Bits;
  UINTX Data;
} SBECNT0_DUNIT_STRUCT;
#endif // ASM_INC

#define SBECNT1_DUNIT_REG                                  0x00000078
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Single Bit Error Count for Rank 1. Any write to this register will clear the counter
    // to 0. 
    // 
    // Bits[15:0], RW/C/V/P, default = 0x0
    //
    UINTX cnt : 16;
    //
    // The per rank status bits are set when a rank's error count equals the threshold.
    //  The status bits are what tell the BIOS/BMC what caused SMI/ERR[0] to get triggered.
    //  Once the status bits are set, they will remain set until cleared by BIOS and
    // will cause the SMI/ERR[0] to get signaled to the cores. 
    // 
    // Bits[16:16], RW/C/V/P, default = 0x0
    //
    UINTX correrrorstatus : 1;
    //
    // Reserved
    // 
    // Bits[31:17], RSV, default = 0x0
    //
    UINTX rsvd_sbecnt1_0 : 15;
  } Bits;
  UINTX Data;
} SBECNT1_DUNIT_STRUCT;
#endif // ASM_INC

#define SBECNT2_DUNIT_REG                                  0x0000007C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Single Bit Error Count for Rank 2. Any write to this register will clear the counter
    // to 0. 
    // 
    // Bits[15:0], RW/C/V/P, default = 0x0
    //
    UINTX cnt : 16;
    //
    // The per rank status bits are set when a rank's error count equals the threshold.
    //  The status bits are what tell the BIOS/BMC what caused SMI/ERR[0] to get triggered.
    //  Once the status bits are set, they will remain set until cleared by BIOS and
    // will cause the SMI/ERR[0] to get signaled to the cores. 
    // 
    // Bits[16:16], RW/C/V/P, default = 0x0
    //
    UINTX correrrorstatus : 1;
    //
    // Reserved
    // 
    // Bits[31:17], RSV, default = 0x0
    //
    UINTX rsvd_sbecnt2_0 : 15;
  } Bits;
  UINTX Data;
} SBECNT2_DUNIT_STRUCT;
#endif // ASM_INC

#define SBECNT3_DUNIT_REG                                  0x00000080
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Single Bit Error Count for Rank 3. Any write to this register will clear the counter
    // to 0. 
    // 
    // Bits[15:0], RW/C/V/P, default = 0x0
    //
    UINTX cnt : 16;
    //
    // The per rank status bits are set when a rank's error count equals the threshold.
    //  The status bits are what tell the BIOS/BMC what caused SMI/ERR[0] to get triggered.
    //  Once the status bits are set, they will remain set until cleared by BIOS and
    // will cause the SMI/ERR[0] to get signaled to the cores. 
    // 
    // Bits[16:16], RW/C/V/P, default = 0x0
    //
    UINTX correrrorstatus : 1;
    //
    // Reserved
    // 
    // Bits[31:17], RSV, default = 0x0
    //
    UINTX rsvd_sbecnt3_0 : 15;
  } Bits;
  UINTX Data;
} SBECNT3_DUNIT_STRUCT;
#endif // ASM_INC

#define SBEACC0_DUNIT_REG                                  0x00000084
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Single Bit Accumulator per Nibble Lane: This allows for identification of the
    // failing x4 or x8 device. 
    // This value is cleared by any write to this register.  This value is also cleared
    // when read if C[1:0]DECCCTRL.RD2CLRACC=1. 
    // Device	LANE[17:0]
    //    x4 	DQS[17,8,16,7,15,6,14,5,13,4,12,3,11,2,10,1,9,0]
    //    x8	DQS[8,8,7,7,6,6,5,5,4,4,3,3,2,2,1,1,0,0]
    // 
    // Bits[17:0], RW/C/V/P, default = 0x0
    //
    UINTX lane : 18;
    //
    // Reserved
    // 
    // Bits[31:18], RSV, default = 0x0
    //
    UINTX rsvd_sbeacc0_0 : 14;
  } Bits;
  UINTX Data;
} SBEACC0_DUNIT_STRUCT;
#endif // ASM_INC

#define SBEACC1_DUNIT_REG                                  0x00000088
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Single Bit Accumulator per Nibble Lane: This allows for identification of the
    // failing x4 or x8 device. 
    // This value is cleared by any write to this register.  This value is also cleared
    // when read if C[1:0]DECCCTRL.RD2CLRACC=1. 
    // Device	LANE[17:0]
    //    x4 	DQS[17,8,16,7,15,6,14,5,13,4,12,3,11,2,10,1,9,0]
    //    x8	DQS[8,8,7,7,6,6,5,5,4,4,3,3,2,2,1,1,0,0]
    // 
    // Bits[17:0], RW/C/V/P, default = 0x0
    //
    UINTX lane : 18;
    //
    // Reserved
    // 
    // Bits[31:18], RSV, default = 0x0
    //
    UINTX rsvd_sbeacc1_0 : 14;
  } Bits;
  UINTX Data;
} SBEACC1_DUNIT_STRUCT;
#endif // ASM_INC

#define SBEACC2_DUNIT_REG                                  0x0000008C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Single Bit Accumulator per Nibble Lane: This allows for identification of the
    // failing x4 or x8 device. 
    // This value is cleared by any write to this register.  This value is also cleared
    // when read if C[1:0]DECCCTRL.RD2CLRACC=1. 
    // Device	LANE[17:0]
    //    x4 	DQS[17,8,16,7,15,6,14,5,13,4,12,3,11,2,10,1,9,0]
    //    x8	DQS[8,8,7,7,6,6,5,5,4,4,3,3,2,2,1,1,0,0]
    // 
    // Bits[17:0], RW/C/V/P, default = 0x0
    //
    UINTX lane : 18;
    //
    // Reserved
    // 
    // Bits[31:18], RSV, default = 0x0
    //
    UINTX rsvd_sbeacc2_0 : 14;
  } Bits;
  UINTX Data;
} SBEACC2_DUNIT_STRUCT;
#endif // ASM_INC

#define SBEACC3_DUNIT_REG                                  0x00000090
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Single Bit Accumulator per Nibble Lane: This allows for identification of the
    // failing x4 or x8 device. 
    // This value is cleared by any write to this register.  This value is also cleared
    // when read if C[1:0]DECCCTRL.RD2CLRACC=1. 
    // Device	LANE[17:0]
    //    x4 	DQS[17,8,16,7,15,6,14,5,13,4,12,3,11,2,10,1,9,0]
    //    x8	DQS[8,8,7,7,6,6,5,5,4,4,3,3,2,2,1,1,0,0]
    // 
    // Bits[17:0], RW/C/V/P, default = 0x0
    //
    UINTX lane : 18;
    //
    // Reserved
    // 
    // Bits[31:18], RSV, default = 0x0
    //
    UINTX rsvd_sbeacc3_0 : 14;
  } Bits;
  UINTX Data;
} SBEACC3_DUNIT_STRUCT;
#endif // ASM_INC

#define DRAM_SR_CMD_DUNIT_REG                              0x00000094
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Wakes the DRAM out of Self Refresh mode. The bit is cleared by hardware only when
    // the DRAM has exited out of Self Refresh mode and is accessible. 
    // 
    // Bits[0:0], RW/V, default = 0x0
    //
    UINTX wake : 1;
    //
    // Reserved
    // 
    // Bits[1:1], RSV, default = 0x0
    //
    UINTX rsvd_dram_sr_cmd_0 : 1;
    //
    // A SUSPEND message will put the DRAM into Self-Refresh mode. The D-unit will complete
    // servicing outstanding memory requests and flush all queued Refresh commands to
    // DRAM before putting the DRAM in Self Refresh mode. Finally, a PM message will
    // be sent to the PHY. The bit is cleared by hardware only after the PHY indicates
    // the transition requested in the PM message has been completed. In AVN, the Dunit
    // would also withdraw PMI credits when a suspend message was sent. This is not possible
    // with the current protocol. 
    // 
    // Bits[2:2], RW/V, default = 0x0
    //
    UINTX suspend : 1;
    //
    // Reserved
    // 
    // Bits[31:3], RSV, default = 0x0
    //
    UINTX rsvd_dram_sr_cmd_1 : 29;
  } Bits;
  UINTX Data;
} DRAM_SR_CMD_DUNIT_STRUCT;
#endif // ASM_INC

#define DRAM_CMD_DUNIT_REG                                 0x00000098
#ifndef ASM_INC
typedef union {
  struct {
    //
    // DDR4 definition:
    // [br] 31:28 Reserved (set to 0)
    // [br] 27:26 Rank Select: 00 = Rank0, 01 = Rank1, 10 = Rank2, 11 = Rank3
    // [br] 25:8  Memory Address: Sets the value of MA[17:0].
    // [br] 7:6   Bank Group: Sets the value of BG[1:0].
    // [br] 5:4   Bank Address: Sets the value of BA[1:0].
    // [br] 3:3   ACT_N
    // [br] 2:0   Command (RAS#,CAS#,WE#): Sets the value to be driven on the RAS#, CAS#
    // and WE# pins, respectively. 
    // [br] 
    // [br] DDR3 definition:
    // [br] 
    // [br] 31:24    Reserved (set to 0)
    // [br] 23:22    Rank Select: 00 = Rank0, 01 = Rank1, 10 = Rank2, 11 = Rank3
    // [br] 21:6     Memory Address: Sets the value of MA[15:0].
    // [br] 5:3   Bank Address: Sets the value of BA[2:0].
    // [br] 2:0   Command (RAS#,CAS#,WE#): Sets the value to be driven on the RAS#, CAS#
    // and WE# pins, respectively. 
    // 
    // 
    // Bits[31:0], WO, default = 0x0
    //
    UINTX dram_cmd : 32;
  } Bits;
  UINTX Data;
} DRAM_CMD_DUNIT_STRUCT;
#endif // ASM_INC

#define DTR5_DUNIT_REG                                     0x0000009C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Timing constraint to specify delay between back-to-back refreshes to the same
    // stack for a QRDIMM setup. Value is specified in DCLKs. Typically expected to be
    // tRFC/4 or tRFC/3. Listed below are tRFC values for the various DDR4 speedbins.
    // [br] Frequency Density tRFC(ns) tRFC(CK)
    // [br] DDR4 1600     2Gb      160      128
    // [br]      1866                       150
    // [br]      2133                       171
    // [br]      2400                       192
    // [br]      2667                       214
    // [br] DDR4 1600     4Gb      260      208
    // [br]      1866                       243
    // [br]      2133                       278
    // [br]      2400                       312
    // [br]      2667                       347
    // [br] DDR4 1600     8Gb      350      280
    // [br]      1866                       327
    // [br]      2133                       374
    // [br]      2400                       420
    // [br]      2667                       467
    // [br] DDR4-1600    16Gb     -TBD- (Not in JEDEC Spec yet)
    // [br]      1866
    // [br]      2133
    // [br]      2400
    // 
    // Bits[10:0], RW/P, default = 0x0
    //
    UINTX trfc_dlr : 11;
    //
    // Four Bank Activation Window.
    // [br] For all logical ranks in a 3DS device, the tFAW_dlr timing constraint applies,
    // i.e. no more than four bank ACTIVATE commands to the whole 3DS SDRAM may be issued
    // in a given tFAW_dlr (MIN) period 
    // [br] Expected Value:16 nCK.
    // 
    // Bits[16:11], RW/P, default = 0x0
    //
    UINTX tfaw_dlr : 6;
    //
    // Four Bank Activation Window.
    // [br] A rolling DRAM clock (CK) time-frame in which a maximum of four Activate
    // commands can be issued to the same rank.  This is to limit the peak current draw
    // from the DRAM devices. 
    // [br] 0 to 18h: 16 + nCK; where n is this field value
    // [br] Others - Reserved
    // [br] 
    // [br] DDR3 tFAW table by frequency and page size:
    // [br] Frequency	1KB Page(x8 1, 2, 4Gb devices)	2KB Page(x8 8Gb device)
    // [br] DDR3-1333	                         20 CK	                  30 CK
    // [br] DDR3-1600	                         24 CK	                  32 CK
    // [br] DDR3-1866	                         26 CK	                  33 CK
    // [br] 
    // [br] DDR4 tFAW table by frequency and page size:
    // [br] Frequency	512B Page(x4 devices)	1KB Page(x8 devices)
    // [br] DDR4-1600	                16 CK	               20 CK
    // [br] DDR4-1866	                16 CK	               22 CK
    // [br] DDR4-2133	                16 CK	               23 CK
    // [br] DDR4-2400	                16 CK	               26 CK
    // [br] DDR4-2667	                16 CK	               26 CK
    // [br] 
    // [br] For QRDIMM: Based on 3DS spec addendum of Jan 2011
    // [br] Frequency	tFAW_slr
    // [br] DDR4-1600	   23 CK
    // [br] DDR4-1866	   24 CK
    // [br] DDR4-2133	   27 CK 
    // 
    // Bits[21:17], RW/P, default = 0x0
    //
    UINTX tfaw : 5;
    //
    // Command Rate Limit
    // [br] When enabled (CRL>0), the scheduler can only issue the specified number of
    // back-to-back commands after which there will be a delay of 1 CK.  The command
    // rate limit feature is used to limit the number of back-to-back commands that can
    // be issued by the scheduler in order to improve the signal integrity of the command
    // signals.  This feature should only be enabled when operating in 1N command timing
    // modes. 
    // [br] 0h - Disabled; No limit on the command issue rate.
    // [br] 1h to 7h - Enabled; Equal to the maximum number of consecutive commands that
    // the scheduler can issue. 
    // 
    // Bits[24:22], RW/P, default = 0x0
    //
    UINTX crl : 3;
    //
    // Additional Latency:
    // [br] This field adds additional read/write latency due to command/address parity
    // for RDIMMs.  Only command address parity is officially supported, which is a DDR4
    // only feature. 
    // [br] For DDR3 this field should be programmed to 0.
    // [br] For DDR4 this field should be programmed as following:
    // [br] 0h: Command/address parity disabled; no additional latency is added.
    // [br] 1h: 1 CK  DDR4-1600, 1866, 2133, 2400 RDIMMs
    // [br] 2h: 2 CK  DDR4-2667 RDIMMs
    // [br] 4h: 4 CK  DDR4-1600, 1866, 2133 SODIMMs/UDIMMs
    // [br] 5h: 5 CK  DDR4-2400, 2666 SODIMMs/UDIMMs  FIXME need to put the real setting
    // for 2666 this once it is defined 
    // [br] All other encodings are reserved.
    // 
    // Bits[28:25], RW/P, default = 0x0
    //
    UINTX addlat : 4;
    //
    // Number of memory command cycles after command that the parity needs to be sent
    // out after. 
    // [br] 0: Send command and parity in same DRAM command cycle. Used for SODIMMs.
    // [br] 1CK: Send parity 1 DRAM command cycle after parity.
    // [br] Used for RDIMMs.
    // 
    // Bits[29:29], RW/P, default = 0x0
    //
    UINTX parity_dly : 1;
    //
    // Spare
    // 
    // Bits[30:30], RW/P, default = 0x0
    //
    UINTX timing_dly : 1;
    //
    // Reserved
    // 
    // Bits[31:31], RSV, default = 0x0
    //
    UINTX rsvd_dtr5_0 : 1;
  } Bits;
  UINTX Data;
} DTR5_DUNIT_STRUCT;
#endif // ASM_INC

#define DTR6_DUNIT_REG                                     0x000000A0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // CKE Minimum Pulse Width:
    // [br] Specifies the minimum number of DRAM clocks (CK) between transitions on the
    // CKE signals. 
    // [br] 0h:  4 CK   DDR3-1600 DDR4-1600
    // [br] 1h:  5 CK   DDR3-1866 DDR4-1866
    // [br] 2h:  6 CK             DDR4-2133, 2400
    // [br] 3h:  7 CK             DDR4-2667
    // [br] All other encodings are reserved.
    // 
    // Bits[2:0], RW/P, default = 0x0
    //
    UINTX tcke : 3;
    //
    // 0 - Fast exit from pre-charge power down is selected (MR0 A12=1)
    // [br] 1 - Slow exit from pre-charge power down is selected (MR0 A12=0).
    // [br] Slow exit from pre-charge power down is not supported on DDR4.
    // [br] Note that this can only be set to 1 for single DIMM per channel configurations.
    // 
    // Bits[3:3], RW/P, default = 0x0
    //
    UINTX slowexit : 1;
    //
    // Exit Precharge Power Down with DLL frozen to commands requiring a locked DLL.
    //  This should be set to 24ns for DDR3 and DDR4 for all frequencies. 
    // [br] 00h: 15 CK
    // [br] 01h: 16 CK
    // [br] 02h: 17 CK
    // [br] 03h: 18 CK
    // [br] 04h: 19 CK
    // [br] 05h: 20 CK   DDR3-1600,
    // [br] 06h: 21 CK
    // [br] 07h: 22 CK
    // [br] 08h: 23 CK   DDR3-1866,
    // [br] 09h: 24 CK
    // [br] 0Ah: 25 CK
    // [br] 0Bh: 26 CK
    // [br] 0Ch: 27 CK
    // [br] 0Dh: 28 CK
    // [br] 0Eh: 29 CK
    // [br] 0Fh: 30 CK
    // [br] 10h: 31 CK
    // [br] All other encodings are reserved.
    // 
    // Bits[8:4], RW/P, default = 0x0
    //
    UINTX txpdll : 5;
    //
    // PDX to Any Command Delay:
    // [br] Specifies the number of DRAM clocks (CK) from the DRAM Power-Down Exit (PDX)
    // command to any valid command. Note for 1N and 3N timing this is equal to tXP from
    // the SPEC. For 2N timing, the value maps to tXP -1. 
    // [br] 0h:    3 CK tCMD=2N:
    // [br] 1h:    4 CK tCMD=1N:
    // [br]             tCMD=2N: DDR3-1600, DDR4-1600
    // [br] 2h:    5 CK tCMD=1N: DDR3-1600, DDR4-1600
    // [br]             tCMD=2N: DDR3-1866, DDR4-1866
    // [br] 3h:    6 CK tCMD=1N: DDR3-1866, DDR4-1866
    // [br]             tCMD=2N: DDR4-2133
    // [br] 4h:    7 CK tCMD=1N: DDR4-2133
    // [br]             tCMD=2N: DDR4-2400
    // [br] 5h:    8 CK tCMD=1N: DDR4-2400
    // [br] 6h:    9 CK
    // [br] 7h:   10 CK
    // 
    // Bits[11:9], RW/P, default = 0x0
    //
    UINTX txp : 3;
    //
    // Enable using tXPDLL for Power Down Exit to Entry:
    // [br] 0: tXPDLL is not used for restricting PDX to PDE; tCKE limits the minimum
    // CKE high pulse width. 
    // [br] 1: tXPDLL is used for limiting the minimum CKE high pulse width instead of
    // tCKE. 
    // 
    // Bits[12:12], RW/P, default = 0x0
    //
    UINTX txpdll_pd : 1;
    //
    // Reserved
    // 
    // Bits[31:13], RSV, default = 0x0
    //
    UINTX rsvd_dtr6_0 : 19;
  } Bits;
  UINTX Data;
} DTR6_DUNIT_STRUCT;
#endif // ASM_INC

#define DQUEUE_DUNIT_REG                                   0x000000A4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Read pending queue size. Dunit will expose one less credit to the SA. This credit
    // is used for Patrol Scrubs. 
    // 
    // Bits[6:0], RW/P, default = 0x20
    //
    UINTX rdcredit : 7;
    //
    // Write credits from D-unit to System Agent.  Dunit will expose one less credit
    // to the SA. This credit is used for Patrol Scrubs. 
    // 
    // Bits[13:7], RW/P, default = 0x28
    //
    UINTX wrcredit : 7;
    //
    // Reserved
    // 
    // Bits[31:14], RSV, default = 0x0
    //
    UINTX rsvd_dqueue_0 : 18;
  } Bits;
  UINTX Data;
} DQUEUE_DUNIT_STRUCT;
#endif // ASM_INC

#define DWMM_DUNIT_REG                                     0x000000A8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // WMM Entry Watermark. When the number of entries in WPQ are greater than or equal
    // to this value, the D-unit will switch to Write Major Mode (WMM) 
    // 
    // Bits[6:0], RW/P, default = 0x20
    //
    UINTX wmmentry : 7;
    //
    // WMM Exit. When the number of entries in WPQ are less than this value, the D-unit
    // will switch back to Read Major Mode (and clear the 'Starved WMM Exit' flag if
    // asserted) 
    // 
    // Bits[13:7], RW/P, default = 0x10
    //
    UINTX wmmexit : 7;
    //
    // Starved WMM Exit Count: Maximum number of writes D-unit can send in WMM mode,
    // if WPQ never falls under the exit threshold and there are entries in the RPQ.
    // D-unit will exit back to RMM mode, but will set the 'Starved WMM Exit' flag to
    // return back to WMM based on the 'Starved WMM Entry Count' : STWMMENC, and not
    // the WMM Entry Watermark. 
    // 
    // Bits[21:14], RW/P, default = 0x30
    //
    UINTX stwmmexc : 8;
    //
    // Starved WMM Entry Count: After 'starved WMM exit', maximum number of reads that
    // will be serviced before entering WMM again. 
    // 
    // Bits[29:22], RW/P, default = 0x30
    //
    UINTX stwmmenc : 8;
    //
    // Reserved
    // 
    // Bits[31:30], RSV, default = 0x0
    //
    UINTX rsvd_dwmm_1 : 2;
  } Bits;
  UINTX Data;
} DWMM_DUNIT_STRUCT;
#endif // ASM_INC

#define DSCH_AGING_DUNIT_REG                               0x000000AC
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Enable CAS-based Age Tick Selects between CAS-based or timer-based aging mechanism.
    //  If CAS-based, an age tick is generated when a configurable number (TICKSIZE)
    // of CASs are issued. If timer-based, an age tick is generated after a configurable
    // number of 30ns periods. 
    // 
    // Bits[0:0], RW/P, default = 0x0
    //
    UINTX casaging : 1;
    //
    // 30ns time periods or CAS commands per Age Tick. Requests are aged one tick after
    // this many number of 30ns periods or CAS commands are issued. Encoded a value of
    // 0 will disable aging. 
    // 
    // Bits[8:1], RW/P, default = 0x8
    //
    UINTX ticksize : 8;
    //
    // If enabled, write CASs are also counted in the CAS-based aging mechanism.
    // 
    // Bits[9:9], RW/P, default = 0x0
    //
    UINTX incwrcas : 1;
    //
    // Initial priority of a read transaction that comes into the channel. There are
    // total of 2 priority levels and the read ages from one level to the next. Priority
    // level zero is the lowest. 
    // 
    // Bits[10:10], RW/P, default = 0x0
    //
    UINTX readip : 1;
    //
    // Number of age ticks that read requests will stay in zero priority before being
    // bumped to the next level.  This count is maintained per RPQ entry. 
    // 
    // Bits[15:11], RW/P, default = 0x10
    //
    UINTX read_residency : 5;
    //
    // Reserved
    // 
    // Bits[31:16], RSV, default = 0x0
    //
    UINTX rsvd_dsch_aging_1 : 16;
  } Bits;
  UINTX Data;
} DSCH_AGING_DUNIT_STRUCT;
#endif // ASM_INC

#define DPATROL_SCRUB_CFG_DUNIT_REG                        0x000000B0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Maximum number of debit patrol scrub operations. Once the patrol scrub debit counter
    // exceeds this value, patrol scrubs will be issued until the debit counter reaches
    // 0. Set 0 to disable debit mode. 
    // 
    // Bits[15:0], RW/P, default = 0x0
    //
    UINTX max_patscrub_debit_cnt : 16;
    //
    // When set to 1, force write back of data with no errors.  When set to 0, don't
    // write back data that had no errors. 
    // 
    // Bits[16:16], RW/P, default = 0x0
    //
    UINTX patscrub_force_writeback : 1;
    //
    // Maximum row address for DIMM0 - bits 17 to 12.  Bits 11:0 are assumed to all be
    // 1. 
    // 
    // Bits[22:17], RW/P, default = 0x0
    //
    UINTX dimm0_max_row_addr : 6;
    //
    // Maximum row address for DIMM1 - bits 17 to 12.  Bits 11:0 are assumed to all be
    // 1. 
    // 
    // Bits[28:23], RW/P, default = 0x0
    //
    UINTX dimm1_max_row_addr : 6;
    //
    // Total number of column bits for devices on rank 0 = 10 + DIMM0_COL_ADDR_BITS
    // [br] 0: DDR4 and DDR3
    // [br] 1: Only DDR3
    // 
    // Bits[29:29], RW/P, default = 0x0
    //
    UINTX dimm0_col_addr_bits : 1;
    //
    // Total number of column bits for devices on rank 0 = 10 + DIMM1_COL_ADDR_BITS
    // [br] 0: DDR4 and DDR3
    // [br] 1: Only DDR3
    // 
    // Bits[30:30], RW/P, default = 0x0
    //
    UINTX dimm1_col_addr_bits : 1;
    //
    // Bit to enable/disable patrol scrub
    // [br] 0: Disable patrol scrub
    // [br] 1: Enable patrol scrub
    // 
    // Bits[31:31], RW/P, default = 0x0
    //
    UINTX pat_scrub_enable : 1;
  } Bits;
  UINTX Data;
} DPATROL_SCRUB_CFG_DUNIT_STRUCT;
#endif // ASM_INC

#define DMAP1_DUNIT_REG                                    0x000000B4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Column Address Bit 11: This field select which PMI address bit is used for CA11
    // for DDR3 and is not used (disabled) for DDR4. 
    // [br] DDR3 : Only when 8Gb devices are used.
    // [br] A[13 + CA11]
    // [br] D: 13 : When all populated ranks support this. Requires that BG0/BG1 are
    // not low. 
    // [br] Below values are used when asymmetric DIMM configurations.
    // [br] 1E: 30 :
    // [br] 1F: 31
    // [br] 20 : 32
    // [br] 21 : 33
    // [br] 3F: Disabled
    // [br] DDR4:
    // [br] 3F: Disabled
    // 
    // Bits[5:0], RW/P, default = 0x0
    //
    UINTX ca11 : 6;
    //
    // Enable and disable bank group XOR. 0: Disable Bank XOR
    // [br] 1: Enable Bank XOR
    // [br] For 64 bit mode
    // [br] DDR3: BA2 xor col[3];                 BA0 xor Row[2]; BA1 xor Row[6] 
    // [br] DDR4: BG0 xor col[3]; BG1 xor Row[2]; BA0 xor Row[6]; BA1 xor Row[7]
    // [br] For 32 bit mode
    // [br] DDR3: BA2 xor col[4];                 BA0 xor Row[2]; BA1 xor Row[6] 
    // [br] DDR4: BG0 xor col[4]; BG1 xor Row[2]; BA0 xor Row[6]; BA1 xor Row[7]
    // 
    // Bits[6:6], RW/P, default = 0x0
    //
    UINTX bxor : 1;
    //
    // Reserved
    // 
    // Bits[31:7], RSV, default = 0x0
    //
    UINTX rsvd_dmap1_0 : 25;
  } Bits;
  UINTX Data;
} DMAP1_DUNIT_STRUCT;
#endif // ASM_INC

#define DPDA_ENTRY_DRAM_CMD_DUNIT_REG                      0x000000B8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Command (RAS#,CAS#,WE#): Sets the value to be driven on the RAS#, CAS# and WE#
    // pins, respectively. 
    // 
    // Bits[2:0], RW/P, default = 0x0
    //
    UINTX cmd : 3;
    //
    // Sets the value to be driven on ACT_N
    // 
    // Bits[3:3], RW/P, default = 0x0
    //
    UINTX act_n : 1;
    //
    // Bank Address: Sets the value of BA[1:0].
    // 
    // Bits[5:4], RW/P, default = 0x0
    //
    UINTX bank_addr : 2;
    //
    // Bank Group: Sets the value of BG[1:0].
    // 
    // Bits[7:6], RW/P, default = 0x0
    //
    UINTX bank_group : 2;
    //
    // Memory Address: Sets the value of MA[17:0].
    // 
    // Bits[25:8], RW/P, default = 0x0
    //
    UINTX ma : 18;
    //
    // Rank Select: 00 = Rank0, 01 = Rank1, 10 = Rank2, 11 = Rank3.
    // 
    // Bits[27:26], RW/P, default = 0x0
    //
    UINTX rank_select : 2;
    //
    // Reserved
    // 
    // Bits[31:28], RSV, default = 0x0
    //
    UINTX rsvd_dpda_entry_dram_cmd : 4;
  } Bits;
  UINTX Data;
} DPDA_ENTRY_DRAM_CMD_DUNIT_STRUCT;
#endif // ASM_INC

#define DPDA_DRAM_CMD_DUNIT_REG                            0x000000BC
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Command (RAS#,CAS#,WE#): Sets the value to be driven on the RAS#, CAS# and WE#
    // pins, respectively. 
    // 
    // Bits[2:0], RW/P, default = 0x0
    //
    UINTX cmd : 3;
    //
    // Sets the value to be driven on ACT_N
    // 
    // Bits[3:3], RW/P, default = 0x0
    //
    UINTX act_n : 1;
    //
    // Bank Address: Sets the value of BA[1:0].
    // 
    // Bits[5:4], RW/P, default = 0x0
    //
    UINTX bank_addr : 2;
    //
    // Bank Group: Sets the value of BG[1:0].
    // 
    // Bits[7:6], RW/P, default = 0x0
    //
    UINTX bank_group : 2;
    //
    // Memory Address: Sets the value of MA[17:0].
    // 
    // Bits[25:8], RW/P, default = 0x0
    //
    UINTX ma : 18;
    //
    // Rank Select: 00 = Rank0, 01 = Rank1, 10 = Rank2, 11 = Rank3.  This field must
    // be the same as DPDA_ENTRY_DRAM_CMD.RANK_SELECT. 
    // 
    // Bits[27:26], RW/P, default = 0x0
    //
    UINTX rank_select : 2;
    //
    // Reserved
    // 
    // Bits[31:28], RSV, default = 0x0
    //
    UINTX rsvd_dpda_dram_cmd : 4;
  } Bits;
  UINTX Data;
} DPDA_DRAM_CMD_DUNIT_STRUCT;
#endif // ASM_INC

#define DPDA_EXIT_DRAM_CMD_DUNIT_REG                       0x000000C0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Command (RAS#,CAS#,WE#): Sets the value to be driven on the RAS#, CAS# and WE#
    // pins, respectively. 
    // 
    // Bits[2:0], RW/P, default = 0x0
    //
    UINTX cmd : 3;
    //
    // Sets the value to be driven on ACT_N
    // 
    // Bits[3:3], RW/P, default = 0x0
    //
    UINTX act_n : 1;
    //
    // Bank Address: Sets the value of BA[1:0].
    // 
    // Bits[5:4], RW/P, default = 0x0
    //
    UINTX bank_addr : 2;
    //
    // Bank Group: Sets the value of BG[1:0].
    // 
    // Bits[7:6], RW/P, default = 0x0
    //
    UINTX bank_group : 2;
    //
    // Memory Address: Sets the value of MA[17:0].
    // 
    // Bits[25:8], RW/P, default = 0x0
    //
    UINTX ma : 18;
    //
    // Rank Select: 00 = Rank0, 01 = Rank1, 10 = Rank2, 11 = Rank3.  This field must
    // be the same as DPDA_ENTRY_DRAM_CMD.RANK_SELECT. 
    // 
    // Bits[27:26], RW/P, default = 0x0
    //
    UINTX rank_select : 2;
    //
    // Reserved
    // 
    // Bits[31:28], RSV, default = 0x0
    //
    UINTX rsvd_dpda_exit_dram_cmd : 4;
  } Bits;
  UINTX Data;
} DPDA_EXIT_DRAM_CMD_DUNIT_STRUCT;
#endif // ASM_INC

#define DPDA_MODE_CONTROL_DUNIT_REG                        0x000000C4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Per DRAM Addressability Lane Mask Bit Array:
    // [br] For x4 devices, each PDAMASK bit is used to mask the MRS command at a specific
    // x4 device (18 total). 
    // [br] For x8 devices, each even/odd bit pair is used to mask the MRS command at
    // a specific x8 device (9 total).  Both bits should be driven to the same value
    // to allow for varying DQ swizzling within the byte lane on the motherboard. 
    // [br] PDAMASK[0] is driven on DQ[3:0]
    // [br] PDAMASK[1] is driven on DQ[7:4]
    // [br] PDAMASK[2] is driven on DQ[11:8]
    // [br] PDAMASK[3] is driven on DQ[15:12]
    // [br] PDAMASK[4] is driven on DQ[19:16]
    // [br] PDAMASK[5] is driven on DQ[23:20]
    // [br] PDAMASK[6] is driven on DQ[27:24]
    // [br] PDAMASK[7] is driven on DQ[31:28]
    // [br] PDAMASK[8] is driven on DQ[35:32]
    // [br] PDAMASK[9] is driven on DQ[39:36]
    // [br] PDAMASK[10] is driven on DQ[43:40]
    // [br] PDAMASK[11] is driven on DQ[47:44]
    // [br] PDAMASK[12] is driven on DQ[51:48]
    // [br] PDAMASK[13] is driven on DQ[55:52]
    // [br] PDAMASK[14] is driven on DQ[59:56]
    // [br] PDAMASK[15] is driven on DQ[63:60]
    // [br] PDAMASK[16] is driven on DQ[67:64] (ECC Lower Nibble)
    // [br] PDAMASK[17] is driven on DQ[71:68] (ECC Upper Nibble)
    // [br] Value encodings:
    // [br] 0: Device will execute the MRS command
    // [br] 1: Device will ignore (mask) the MRS command
    // 
    // Bits[17:0], RW/P, default = 0x0
    //
    UINTX pdamask : 18;
    //
    // When set to zero, PDA mode is disabled.
    // [br] When set to 1, the Dunit enters PDA mode and then issues the command sequence
    // associated with PDA_ENTRY_DRAM_CMD, PDA_DRAM_CMD (with the PDAMASK command) and
    // PDA_EXIT_DRAM_CMD (with the DQ set to 0 for all Devices). When the Dunit completes
    // issuing the PDA commands, it will clear this bit. 
    // 
    // Bits[18:18], RW/V/P, default = 0x0
    //
    UINTX pda_mode_enable : 1;
    //
    // Reserved
    // 
    // Bits[31:19], RSV, default = 0x0
    //
    UINTX rsvd_dpda_mode_control_0 : 13;
  } Bits;
  UINTX Data;
} DPDA_MODE_CONTROL_DUNIT_STRUCT;
#endif // ASM_INC

#define DSCRMBL_DUNIT_REG                                  0x000000C8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // 16-bit Data Scrambler Key:
    // [br] This is a random 16-bit value written by BIOS that is used to randomize the
    // data scrambler seed.  BIOS should generate the key from the DRNG. Note that this
    // value needs to be stored (encrypted) in NVRAM during S3 and then restored after
    // resume from S3. 
    // [br] In addition to being write locked, this field is also read locked.
    // 
    // Bits[15:0], RW/P, default = 0x0
    //
    UINTX key : 16;
    //
    // Reserved
    // 
    // Bits[31:16], RSV, default = 0x0
    //
    UINTX rsvd_dscrmbl_0 : 16;
  } Bits;
  UINTX Data;
} DSCRMBL_DUNIT_STRUCT;
#endif // ASM_INC

#define UCELOG1_DUNIT_REG                                  0x000000CC
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Row bits
    // 
    // Bits[17:0], RO/V/P, default = 0x0
    //
    UINTX uce_row : 18;
    //
    // Column address bits above A[5]
    // 
    // Bits[26:18], RO/V/P, default = 0x0
    //
    UINTX uce_col : 9;
    //
    // Reserved
    // 
    // Bits[31:27], RSV, default = 0x0
    //
    UINTX reg_rsvd : 5;
  } Bits;
  UINTX Data;
} UCELOG1_DUNIT_STRUCT;
#endif // ASM_INC

#define SBELOG1_DUNIT_REG                                  0x000000D0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Row bits
    // 
    // Bits[17:0], RO/V/P, default = 0x0
    //
    UINTX sbe_row : 18;
    //
    // Column bits [11,9:2]
    // 
    // Bits[26:18], RO/V/P, default = 0x0
    //
    UINTX sbe_col : 9;
    //
    // Reserved
    // 
    // Bits[31:27], RSV, default = 0x0
    //
    UINTX reg_rsvd : 5;
  } Bits;
  UINTX Data;
} SBELOG1_DUNIT_STRUCT;
#endif // ASM_INC

#define RHP_LFSR_THRESHOLD0_DUNIT_REG                      0x000000D4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // 16 bit value to compare against the XOR of LFSR1 and LFSR2 everytime an ACT command
    // wins (probability match). The TRR/TRA is written into the RHP FIFO if the compared
    // values match. Note that the value programmed in this field is completely arbitrary
    // and should be randomized by BIOS/MRC. 
    // 
    // Bits[15:0], RW/P, default = 0x0
    //
    UINTX threshold0 : 16;
    //
    // 16 bit mask to ignore each bit of the LFSRs used in the comparison with the threshold
    // (makes it don't care and increases the number of matching values). This field
    // should be modified to change the probability of TRR/TRA injection 
    // 
    // Bits[31:16], RW/P, default = 0x0
    //
    UINTX lfsr_mask0 : 16;
  } Bits;
  UINTX Data;
} RHP_LFSR_THRESHOLD0_DUNIT_STRUCT;
#endif // ASM_INC

#define RHP_LFSR_THRESHOLD1_DUNIT_REG                      0x000000D8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // 16 bit value to compare against the XOR of LFSR1 and LFSR2 everytime an ACT command
    // wins (probability match). The TRR/TRA is written into the RHP FIFO if the compared
    // values match. Note that the value programmed in this field is completely arbitrary
    // and should be randomized by BIOS/MRC. 
    // 
    // Bits[15:0], RW/P, default = 0x0
    //
    UINTX threshold1 : 16;
    //
    // 16 bit mask to ignore each bit of the LFSRs used in the comparison with the threshold
    // (makes it don't care and increases the number of matching values). This field
    // should be modified to change the probability of TRR/TRA injection 
    // 
    // Bits[31:16], RW/P, default = 0x0
    //
    UINTX lfsr_mask1 : 16;
  } Bits;
  UINTX Data;
} RHP_LFSR_THRESHOLD1_DUNIT_STRUCT;
#endif // ASM_INC

#define RHP_LFSR_SEEDS_DUNIT_REG                           0x000000DC
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Seed for LFSR1. If non-zero, LFSR1 will shift everytime an ACT wins.
    // 
    // Bits[15:0], RW/P, default = 0x0
    //
    UINTX seed1 : 16;
    //
    // Seed for LFSR2. If non-zero, LFSR2 will shift everytime LFSR1 has cycled through
    // an entire pattern and an ACT wins. 
    // 
    // Bits[31:16], RW/P, default = 0x0
    //
    UINTX seed2 : 16;
  } Bits;
  UINTX Data;
} RHP_LFSR_SEEDS_DUNIT_STRUCT;
#endif // ASM_INC

#define RHP_CONTROL_DUNIT_REG                              0x000000E0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Global Enable bit for the Row Hammering Prevention Feature. If enabled, on a winning
    // ACT command each mask will be applied to the XOR of LFSR1 and LFSR2 and the post-mask
    // values will be compared against each of the respective thresholds. If there is
    // a match, a TRR/TRA request to that row address will be written into the next empty
    // entry of the 8 deep RHP FIFO (overflow requests are dropped). A pending TRR/TRA
    // request in the RHP FIFO will cause a TRR sequence (if supported) or a TRA sequence
    // (if no TRR supported) to be issued to the DRAM's row address (and +1/-1 victims,
    // if supported) that is being hammered. Note that if this bit is set to 1 at least
    // one of the thresholds/masks must be enabled in RHP_LFSR_THRESHOLD CSRs. 
    // 
    // Bits[0:0], RW/P, default = 0x0
    //
    UINTX rhp_enable : 1;
    //
    // Set to 1 for DDR4 Targeted Row Refresh Mode.
    // 
    // Bits[1:1], RW/P, default = 0x0
    //
    UINTX trr_mode : 1;
    //
    // Set to 1 to inject a row hammer refresh. This bit will self-clear when the injection
    // has finished.  The address refreshed is specified by reusing rh_lfsr_threshold0
    // and rh_lfsr_mask0 as follows: 
    // [br] Rank = rh_lfsr_mask0[7:6]
    // [br] BankGroup = rh_lfsr_mask0[5:4]
    // [br] BankAddress = rh_lfsr_mask0[3:2]
    // [br] Row = { rh_lfsr_mask0[1:0], rh_lfsr_threshold0[15:0]}
    // 
    // Bits[2:2], RW/V/P, default = 0x0
    //
    UINTX rh_inject : 1;
    //
    // Set to 1 to enable manual injections.
    // 
    // Bits[3:3], RW/P, default = 0x0
    //
    UINTX rh_inject_enable : 1;
    //
    // Reserved
    // 
    // Bits[5:4], RSV, default = 0x0
    //
    UINTX rsvd_rhp_control_2 : 2;
    //
    // Set bit 1 to 1 if DIMM1 is an inverted DIMM and set bit 0 to 1 if DIMM0 is an
    // inverted DIMM. 
    // [br] 0: Dimm0 and Dimm1 are not inverted.
    // [br] 1: Dimm0 is an inverted DIMM.
    // [br] 2: Dimm1 is an inverted DIMM.
    // [br] 3: Dimm0 and Dimm1 are inverted DIMMs.
    // 
    // Bits[7:6], RW/P, default = 0x0
    //
    UINTX inverted_dimm : 2;
    //
    // DDR devices are in use that have internal DRAM address bit swizzling. Hardware
    // will apply the following mapping to the row address before performing the +1/-1
    // required for the pTRR sequence and will perform a deswizzle before sending the
    // ACT commands for the pTRR. This setting is valid only when TRR_MODE is set to
    // zero. 
    // [br] Swizzled RA1 = RA1 ^ RA3
    // [br] Swizzled RA2 = RA2 ^ RA3
    // [br] Set bit 1 to 1 if DIMM1 has a vendor specific swizzle and set bit 0 to 1
    // if DIMM0 has a vendor specific swizzle. 
    // [br] 0: Dimm0 and Dimm1 are not swizzled.
    // [br] 1: Dimm0 is a swizzled DIMM.
    // [br] 2: Dimm1 is a swizzled DIMM.
    // [br] 3: Dimm0 and Dimm1 are swizzled DIMMs
    // 
    // Bits[9:8], RW/P, default = 0x0
    //
    UINTX swizzled_dimm : 2;
    //
    // When this bit is written to 1 the RHP FIFO is forced empty. Software must clear
    // this bit to 0 before re-enabling row hammering prevention 
    // 
    // Bits[10:10], RW/P, default = 0x0
    //
    UINTX reset_fifo : 1;
    //
    // When this bit is written to 1 the LFSR is cleared (written to all 0's). Software
    // must clear this bit to 0 before re-enabling row hammering prevention. 
    // 
    // Bits[11:11], RW/P, default = 0x0
    //
    UINTX reset_lfsr : 1;
    //
    // The TRR logic must wait an additional tRAS * 0.5 between the ACT command issued
    // to Row N and the PRE command. Sets the value of .5 TRAS.  This field is programmed
    // in DCLKs. 
    // 
    // Bits[17:12], RW/P, default = 0x0
    //
    UINTX half_tras : 6;
    //
    // The number of Dclks after the last PREcharge of a TRR sequence to wait for the
    // DRAMs to exit TRR mode.  This should be set equal to tMOD + tRP. 
    // 
    // Bits[23:18], RW/P, default = 0x0
    //
    UINTX rh_exit : 6;
    //
    // The minimum number of Dclks to pause between row hammer refresh sequences.  This
    // is used to allow normal work-load traffic to make progress between refresh sequences.
    // 
    // Bits[30:24], RW/P, default = 0x0
    //
    UINTX rh_pause : 7;
    //
    // Reserved
    // 
    // Bits[31:31], RSV, default = 0x0
    //
    UINTX rsvd_rhp_control_1 : 1;
  } Bits;
  UINTX Data;
} RHP_CONTROL_DUNIT_STRUCT;
#endif // ASM_INC

#define RHP_MR2_SHADOW_REGISTERS_DUNIT_REG                 0x000000E4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Reserved
    // 
    // Bits[2:0], RSV, default = 0x0
    //
    UINTX rsvd_rhp_mr2_shadow_registers_5 : 3;
    //
    // Shadow copy of MR2 bits 7:3 for DIMM0. Bios updates this after MRC.
    // 
    // Bits[7:3], RW/P, default = 0x0
    //
    UINTX bits7_3_dimm0 : 5;
    //
    // Reserved
    // 
    // Bits[8:8], RSV, default = 0x0
    //
    UINTX rsvd_rhp_mr2_shadow_registers_4 : 1;
    //
    // Shadow copy of MR2 bits 12:9 for DIMM0. Bios updates this after MRC.
    // 
    // Bits[12:9], RW/P, default = 0x0
    //
    UINTX bits12_9_dimm0 : 4;
    //
    // Reserved
    // 
    // Bits[18:13], RSV, default = 0x0
    //
    UINTX rsvd_rhp_mr2_shadow_registers_3 : 6;
    //
    // Shadow copy of MR2 bits 7:3 for DIMM1. Bios updates this after MRC.
    // 
    // Bits[23:19], RW/P, default = 0x0
    //
    UINTX bits7_3_dimm1 : 5;
    //
    // Reserved
    // 
    // Bits[24:24], RSV, default = 0x0
    //
    UINTX rsvd_rhp_mr2_shadow_registers_2 : 1;
    //
    // Shadow copy of MR2 bits 12:9 for DIMM1. Bios updates this after MRC.
    // 
    // Bits[28:25], RW/P, default = 0x0
    //
    UINTX bits12_9_dimm1 : 4;
    //
    // Reserved
    // 
    // Bits[31:29], RSV, default = 0x0
    //
    UINTX rsvd_rhp_mr2_shadow_registers_1 : 3;
  } Bits;
  UINTX Data;
} RHP_MR2_SHADOW_REGISTERS_DUNIT_STRUCT;
#endif // ASM_INC

#define DPATROL_SCRUB_UPD0_DUNIT_REG                       0x000000E8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Override the current patrol scrub rank address.
    // 
    // Bits[1:0], RW/V/P, default = 0x0
    //
    UINTX rankaddr : 2;
    //
    // Override the current patrol scrub row address.
    // 
    // Bits[19:2], RW/V/P, default = 0x0
    //
    UINTX rowaddr : 18;
    //
    // Override the current patrol scrub column address. LSB should always be set to
    // 0 in 32 bit mode 
    // 
    // Bits[27:20], RW/V/P, default = 0x0
    //
    UINTX coladdr : 8;
    //
    // Override the current patrol scrub bank address.
    // 
    // Bits[31:28], RW/V/P, default = 0x0
    //
    UINTX bankaddr : 4;
  } Bits;
  UINTX Data;
} DPATROL_SCRUB_UPD0_DUNIT_STRUCT;
#endif // ASM_INC

#define DPATROL_SCRUB_UPD1_DUNIT_REG                       0x000000EC
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Override the current patrol scrub timer count value.
    // 
    // Bits[31:0], RW/V/P, default = 0x0
    //
    UINTX counter : 32;
  } Bits;
  UINTX Data;
} DPATROL_SCRUB_UPD1_DUNIT_STRUCT;
#endif // ASM_INC

#define DSBFT_CTL_DUNIT_REG                                0x000000F0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Contains the final checksum value for all data written to this DUNIT channel.
    // 
    // Bits[15:0], RO/V, default = 0x0
    //
    UINTX data_checksum : 16;
    //
    // Contains the final checksum value for all addresses read from and written to this
    // DUNIT channel. 
    // 
    // Bits[23:16], RO/V, default = 0x0
    //
    UINTX addr_checksum : 8;
    //
    // Reserved
    // 
    // Bits[27:24], RSV, default = 0x0
    //
    UINTX rsvd_dsbft_ctl_0 : 4;
    //
    // When set to a 1, the parity lines are included in the data checksum.
    // 
    // Bits[28:28], RW/P, default = 0x0
    //
    UINTX enable_parity_checksum : 1;
    //
    // Resets the checksum registers when written to 1.  Bit automatically resets to
    // 0. 
    // 
    // Bits[29:29], RW/V, default = 0x0
    //
    UINTX reset : 1;
    //
    // Enables checksum calculation.
    // 
    // Bits[30:30], RW/P, default = 0x0
    //
    UINTX enable_checksum : 1;
    //
    // Enables pseudo-random data return.
    // 
    // Bits[31:31], RW/P, default = 0x0
    //
    UINTX enable_prdr : 1;
  } Bits;
  UINTX Data;
} DSBFT_CTL_DUNIT_STRUCT;
#endif // ASM_INC

#define DSBFT_CMASK_DUNIT_REG                              0x000000F4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Mask AND'ed with pseudo-random data.  Reset's to all 1's - setting bit 'n' to
    // 0 in this register will force every nth bit in the data to be set to 0. 
    // 
    // Bits[31:0], RW/P, default = 0xFFFFFFFF
    //
    UINTX clear_mask : 32;
  } Bits;
  UINTX Data;
} DSBFT_CMASK_DUNIT_STRUCT;
#endif // ASM_INC

#define DSBFT_SMASK_DUNIT_REG                              0x000000F8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Mask OR'ed with pseudo-random data.  Reset's to all 0's - setting bit 'n' to 1
    // in this register will force every nth bit in the data to be set to 1. 
    // 
    // Bits[31:0], RW/P, default = 0x0
    //
    UINTX set_mask : 32;
  } Bits;
  UINTX Data;
} DSBFT_SMASK_DUNIT_STRUCT;
#endif // ASM_INC

#define DSBFT_SEED_DUNIT_REG                               0x000000FC
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Seed XOR'ed with address bits to produce pseudo-random data.  Use this to statically
    // produce different pseudo-random data streams for the same set of request addresses.
    // 
    // Bits[31:0], RW/P, default = 0x0
    //
    UINTX seed : 32;
  } Bits;
  UINTX Data;
} DSBFT_SEED_DUNIT_STRUCT;
#endif // ASM_INC

#define CORRERRTHRSHLD0_DUNIT_REG                          0x00000100
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Correctable error threshold for rank 0.  When the error accumulation in SBECNT0
    // hits this value, then the CORRERRSTATUS is set and a DO_SMI message is sent if
    // the threshold value is greater than 0. 
    // 
    // Bits[15:0], RW/P, default = 0x0
    //
    UINTX thrsh_rnk : 16;
    //
    // Reserved
    // 
    // Bits[31:16], RSV, default = 0x0
    //
    UINTX rsvd_correrrthrshld0_0 : 16;
  } Bits;
  UINTX Data;
} CORRERRTHRSHLD0_DUNIT_STRUCT;
#endif // ASM_INC

#define CORRERRTHRSHLD1_DUNIT_REG                          0x00000104
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Correctable error threshold for rank 1.  When the error accumulation in SBECNT1
    // hits this value, then the CORRERRSTATUS is set and a DO_SMI message is sent if
    // the threshold value is greater than 0. 
    // 
    // Bits[15:0], RW/P, default = 0x0
    //
    UINTX thrsh_rnk : 16;
    //
    // Reserved
    // 
    // Bits[31:16], RSV, default = 0x0
    //
    UINTX rsvd_correrrthrshld1_0 : 16;
  } Bits;
  UINTX Data;
} CORRERRTHRSHLD1_DUNIT_STRUCT;
#endif // ASM_INC

#define CORRERRTHRSHLD2_DUNIT_REG                          0x00000108
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Correctable error threshold for rank 2.  When the error accumulation in SBECNT2
    // hits this value, then the CORRERRSTATUS is set and a DO_SMI message is sent if
    // the threshold value is greater than 0. 
    // 
    // Bits[15:0], RW/P, default = 0x0
    //
    UINTX thrsh_rnk : 16;
    //
    // Reserved
    // 
    // Bits[31:16], RSV, default = 0x0
    //
    UINTX rsvd_correrrthrshld2_0 : 16;
  } Bits;
  UINTX Data;
} CORRERRTHRSHLD2_DUNIT_STRUCT;
#endif // ASM_INC

#define CORRERRTHRSHLD3_DUNIT_REG                          0x0000010C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Correctable error threshold for rank 3.  When the error accumulation in SBECNT3
    // hits this value, then the CORRERRSTATUS is set and a DO_SMI message is sent if
    // the threshold value is greater than 0. 
    // 
    // Bits[15:0], RW/P, default = 0x0
    //
    UINTX thrsh_rnk : 16;
    //
    // Reserved
    // 
    // Bits[31:16], RSV, default = 0x0
    //
    UINTX rsvd_correrrthrshld3_0 : 16;
  } Bits;
  UINTX Data;
} CORRERRTHRSHLD3_DUNIT_STRUCT;
#endif // ASM_INC

#define LEAKY_BUCKET_CFG0_DUNIT_REG                        0x00000110
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Units for this register are 8192 DRAM clocks.  When greater than zero, leaky bucket
    // is enabled.  This is the unit for the high order counter for rank 0, CNTR_HI.
    // 
    // Bits[15:0], RW/P, default = 0x0
    //
    UINTX cntr_lo : 16;
    //
    // Specifies the leaky bucket leak rat in CNTR_LO ticks.  When the leaky bucket counter
    // counts through CNTR_HI, the correctable error count for rank 0 is decremented
    // by one. 
    // 
    // Bits[31:16], RW/P, default = 0x0
    //
    UINTX cntr_hi : 16;
  } Bits;
  UINTX Data;
} LEAKY_BUCKET_CFG0_DUNIT_STRUCT;
#endif // ASM_INC

#define LEAKY_BUCKET_CFG1_DUNIT_REG                        0x00000114
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Units for this register are 8192 DRAM clocks.  When greater than zero, leaky bucket
    // is enabled.  This is the unit for the high order counter for rank 1, CNTR_HI.
    // 
    // Bits[15:0], RW/P, default = 0x0
    //
    UINTX cntr_lo : 16;
    //
    // Specifies the leaky bucket leak rat in CNTR_LO ticks.  When the leaky bucket counter
    // counts through CNTR_HI, the correctable error count for rank 1 is decremented
    // by one. 
    // 
    // Bits[31:16], RW/P, default = 0x0
    //
    UINTX cntr_hi : 16;
  } Bits;
  UINTX Data;
} LEAKY_BUCKET_CFG1_DUNIT_STRUCT;
#endif // ASM_INC

#define LEAKY_BUCKET_CFG2_DUNIT_REG                        0x00000118
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Units for this register are 8192 DRAM clocks.  When greater than zero, leaky bucket
    // is enabled.  This is the unit for the high order counter for rank 2, CNTR_HI.
    // 
    // Bits[15:0], RW/P, default = 0x0
    //
    UINTX cntr_lo : 16;
    //
    // Specifies the leaky bucket leak rat in CNTR_LO ticks.  When the leaky bucket counter
    // counts through CNTR_HI, the correctable error count for rank 2 is decremented
    // by one. 
    // 
    // Bits[31:16], RW/P, default = 0x0
    //
    UINTX cntr_hi : 16;
  } Bits;
  UINTX Data;
} LEAKY_BUCKET_CFG2_DUNIT_STRUCT;
#endif // ASM_INC

#define LEAKY_BUCKET_CFG3_DUNIT_REG                        0x0000011C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Units for this register are 8192 DRAM clocks.  When greater than zero, leaky bucket
    // is enabled.  This is the unit for the high order counter for rank 3, CNTR_HI.
    // 
    // Bits[15:0], RW/P, default = 0x0
    //
    UINTX cntr_lo : 16;
    //
    // Specifies the leaky bucket leak rat in CNTR_LO ticks.  When the leaky bucket counter
    // counts through CNTR_HI, the correctable error count for rank 3 is decremented
    // by one. 
    // 
    // Bits[31:16], RW/P, default = 0x0
    //
    UINTX cntr_hi : 16;
  } Bits;
  UINTX Data;
} LEAKY_BUCKET_CFG3_DUNIT_STRUCT;
#endif // ASM_INC

#define FERRNERR_DUNIT_REG                                 0x00000120
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Next Error Correctable Read Error Detected:
    // When set, the second error detected was a single bit error on the read data from
    // memory and the error was corrected. 
    // 
    // Bits[0:0], RO/V/P, default = 0x0
    //
    UINTX nerrsbe : 1;
    //
    // Next Error Uncorrectable Read Error Detected:
    // When set, the second error detected was an uncorrectable (multiple bit) error
    // on the read data from memory. 
    // 
    // Bits[1:1], RO/V/P, default = 0x0
    //
    UINTX nerruce : 1;
    //
    // Next Error Uncorrectable Write Parity Error Detected:
    // When set, the second error detected was an uncorrectable (parity) error on the
    // write data received from the Bunit. 
    // 
    // Bits[2:2], RO/V/P, default = 0x0
    //
    UINTX nerrwpe : 1;
    //
    // Next Error Uncorrectable DDR4 Command Address Parity Error: When set, the second
    // error detected was the assertion of the xxDDR3_0_ALERT_N pin indicating that one
    // or more DRAMs detected a Command/Address parity error.  Note that this bit can
    // never be set as the same time as FERRAPE 
    // 
    // Bits[3:3], RO/V/P, default = 0x0
    //
    UINTX nerrape : 1;
    //
    // Next Error Uncorrectable Patrol Scrub Read Error: When set, the second error detected
    // was an uncorrectable (mutliple bit) error on the patrol scrub read data from memory.
    // 
    // Bits[4:4], RO/V/P, default = 0x0
    //
    UINTX nerrucepat : 1;
    //
    // Reserved
    // 
    // Bits[15:5], RSV, default = 0x0
    //
    UINTX rsvd_ferrnerr_1 : 11;
    //
    // First Error Correctable Read Error Detected:
    // When set, the first error detected was a single bit error on the read data from
    // memory and the error was corrected. 
    // 
    // Bits[16:16], RO/V/P, default = 0x0
    //
    UINTX ferrsbe : 1;
    //
    // First Error Uncorrectable Read Error Detected:
    // When set, the first error detected was an uncorrectable (multiple bit) error on
    // the read data from memory. 
    // 
    // Bits[17:17], RO/V/P, default = 0x0
    //
    UINTX ferruce : 1;
    //
    // First Error Uncorrectable Write Parity Error Detected:
    // When set, the first error detected was an uncorrectable (parity) error on the
    // write data received from the Bunit. 
    // 
    // Bits[18:18], RO/V/P, default = 0x0
    //
    UINTX ferrwpe : 1;
    //
    // First Error Uncorrectable DDR4 Command Address Parity Error: When set, the first
    // error detected was the assertion of the xxDDR3_0_ALERT_N pin indicating that one
    // or more DRAMs detected a Command/Address parity error. 
    // 
    // Bits[19:19], RO/V/P, default = 0x0
    //
    UINTX ferrape : 1;
    //
    // First Error Uncorrectable Patrol Scrub Read Error Detected:
    // When set, the first error detected was an uncorrectable (multiple bit) error on
    // the patrol scrub read from memory. 
    // 
    // Bits[20:20], RO/V/P, default = 0x0
    //
    UINTX ferrucepat : 1;
    //
    // Reserved
    // 
    // Bits[31:21], RSV, default = 0x0
    //
    UINTX rsvd_ferrnerr_3 : 11;
  } Bits;
  UINTX Data;
} FERRNERR_DUNIT_STRUCT;
#endif // ASM_INC

#define DERRSTS_DUNIT_REG                                  0x00000124
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Correctable (Single Bit) Read Error:
    // When set, a single bit error was detected on the read data from memory and the
    // error was corrected. 
    // 
    // Bits[0:0], RW/1C/V/P, default = 0x0
    //
    UINTX sbe : 1;
    //
    // Uncorrectable (Double Bit) Read Error:
    // When set, a double bit error was detected on the read data from memory.
    // 
    // Bits[1:1], RW/1C/V/P, default = 0x0
    //
    UINTX uce : 1;
    //
    // Uncorrectable (Parity) Write Error:
    // When set, an uncorrectable (parity) error was detected on the write data received
    // from the Bunit. 
    // 
    // Bits[2:2], RW/1C/V/P, default = 0x0
    //
    UINTX wpe : 1;
    //
    // Uncorrectable DDR4 Command/Address Parity Error:
    // When set, an uncorrectable DDR4 command/address parity error was detected by one
    // or more of the DRAMs on channel 0. 
    // 
    // Bits[3:3], RW/1C/V/P, default = 0x0
    //
    UINTX ape : 1;
    //
    // Uncorrectable (multiple bit) patrol scrub error:  When set, an uncorrectable (multiple
    // bit error was detected on the read data from memory. 
    // 
    // Bits[4:4], RW/1C/V/P, default = 0x0
    //
    UINTX ucepat : 1;
    //
    // Current state of the channel ALERT_N pin, captured here as active high:
    // 1 = Error being driven by at least one DRAM device	
    // 0 = No error currently detected by any DRAM device
    // 
    // Bits[5:5], RO/V/P, default = 0x0
    //
    UINTX alert : 1;
    //
    // Channel Command Address Parity Error State.
    // 1 = CAP error seen, error state entered.  All PMI reads will be returned with
    // bad parity. 
    // 0 = No CAP error seen.  Normal PMI operation.
    // 
    // Bits[6:6], RW/1C/V/P, default = 0x0
    //
    UINTX cap_err_state : 1;
    //
    // Reserved
    // 
    // Bits[31:7], RSV, default = 0x0
    //
    UINTX rsvd_derrsts_1 : 25;
  } Bits;
  UINTX Data;
} DERRSTS_DUNIT_STRUCT;
#endif // ASM_INC

#define DERRMSKSEV_DUNIT_REG                               0x00000128
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Reserved
    // 
    // Bits[0:0], RSV, default = 0x0
    //
    UINTX rsvd_derrmsksev_0 : 1;
    //
    // Uncorrectable (Multiple Bit) Read Error Severity:
    // When set, UCE errors logged in DERRSTS[1] will be escalated to the global error
    // logic as a fatal error; otherwise it will be escalated as a non-fatal error. 
    // 
    // Bits[1:1], RW/P, default = 0x0
    //
    UINTX sev_uce : 1;
    //
    // Uncorrectable (Parity) Write Error Severity:
    // When set, WPE errors logged in DERRSTS[2] will be escalated to the global error
    // logic as a fatal error; otherwise it will be escalated as a non-fatal error. 
    // 
    // Bits[2:2], RW/P, default = 0x0
    //
    UINTX sev_wdbr : 1;
    //
    // Uncorrectable DDR4 Command/Address Parity Error Severity: When set, APE errors
    // logged in DERRSTS[3] will be escalated to the global error logic as a fatal error;
    // otherwise it will be escalated as a non-fatal error. 
    // 
    // Bits[3:3], RW/P, default = 0x0
    //
    UINTX sev_ape : 1;
    //
    // Uncorrectable (Multiple Bit) Patrol Scrub Read Error Severity: When set, UCE errors
    // logged in DERRSTS[5] will be escalated to the global error logic as a fatal error;
    // otherwise it will be escalated as a non-fatal error. 
    // 
    // Bits[4:4], RW/P, default = 0x0
    //
    UINTX sev_ucepat : 1;
    //
    // Reserved
    // 
    // Bits[15:5], RSV, default = 0x0
    //
    UINTX rsvd_derrmsksev_1 : 11;
    //
    // Correctable (single bit) error mask:  When set, correctable (single bit) read
    // and patrol scrub errors will not be logged in DERRESTS[0] and DO_SERR_SEV messages
    // will not be sent to the IEH. 
    // 
    // Bits[16:16], RW/P, default = 0x0
    //
    UINTX msk_sbe : 1;
    //
    // Uncorrectable (multiple bit) error mask:  When set, uncorrectable (multiple bit)
    // read and patrol scrub errors will not be logged in DERRESTS[0], DO_SERR_SEV messages
    // will not be sent to the IEH, and derrcnt will not count for this error. 
    // 
    // Bits[17:17], RW/P, default = 0x0
    //
    UINTX msk_uce : 1;
    //
    // Uncorrectable (parity) write data buffer read error mask:  When set, uncorrectable
    // (pairty) write data buffer read errors will not be logged in DERRESTS[0], DO_SERR_SEV
    // messages will not be sent to the IEH, and derrcnt will not count for this error.
    // 
    // Bits[18:18], RW/P, default = 0x0
    //
    UINTX msk_wdbr : 1;
    //
    // Uncorrectable command/address parity error mask:  When set, uncorrectable DDR4
    // command/address parity errors will not be logged in DERRESTS[0], DO_SERR_SEV messages
    // will not be sent to the IEH, and derrcnt will not count for this error. 
    // 
    // Bits[19:19], RW/P, default = 0x0
    //
    UINTX msk_ape : 1;
    //
    // Uncorrectable patrol scrub error mask:  When set, uncorrectable patrol scrub ECC
    // data errors will not be logged in DERRESTS[0], DO_SERR_SEV messages will not be
    // sent to the IEH, and derrcnt will not count for this error. 
    // 
    // Bits[20:20], RW/P, default = 0x0
    //
    UINTX msk_ucepat : 1;
    //
    // Reserved
    // 
    // Bits[31:21], RSV, default = 0x0
    //
    UINTX rsvd_derrmsksev_2 : 11;
  } Bits;
  UINTX Data;
} DERRMSKSEV_DUNIT_STRUCT;
#endif // ASM_INC

#define DERRCNTSEL_DUNIT_REG                               0x0000012C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Reserved
    // 
    // Bits[0:0], RSV, default = 0x0
    //
    UINTX rsvd_derrcntsel_0 : 1;
    //
    // Uncorrectable (Multiple Bit) Read Error Count Select:
    // When set, UCE0 errors logged in DERRSTS[1] will be counted in DERRCNT.UNCCNT0.
    // 
    // Bits[1:1], RW/P, default = 0x0
    //
    UINTX sel_uce : 1;
    //
    // Uncorrectable (Parity) Write Error Count Select:
    // When set, WPE0 errors logged in DERRSTS[2] will be counted in DERRCNT.UNCCNT0.
    // 
    // Bits[2:2], RW/P, default = 0x0
    //
    UINTX sel_wpe : 1;
    //
    // Uncorrectable DDR4 Command/Address Parity Error Count Select:
    // When set, APE0 errors logged in DERRSTS[3] will be counted in DERRCNT.UNCCNT0.
    // 
    // Bits[3:3], RW/P, default = 0x0
    //
    UINTX sel_ape : 1;
    //
    // Uncorrectable (Multiple Bit) Patrol Scrub Read Error Count Select:
    // When set, UCE errors logged in DERRSTS[1] will be counted in DERRCNT.UNCCNT1.
    // 
    // Bits[4:4], RW/P, default = 0x0
    //
    UINTX sel_ucepat : 1;
    //
    // Reserved
    // 
    // Bits[31:5], RSV, default = 0x0
    //
    UINTX rsvd_derrcntsel_2 : 27;
  } Bits;
  UINTX Data;
} DERRCNTSEL_DUNIT_STRUCT;
#endif // ASM_INC

#define DERRCNT_DUNIT_REG                                  0x00000130
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Uncorrectable Error Count:
    // The count of uncorrectable errors that have occurred since the last time the count
    // was cleared. The count limit is 128 (80h) and the count is cleared by writing
    // ones to all bits (FFh). The type of uncorrectable errors that are counted is determined
    // by the DERRCNTSEL register.  Additionally, if two uncorrectable errors occur in
    // the same clock cycle, only one type will be counted, even if multiple types are
    // selected. 
    // 
    // Bits[7:0], RW/1C/V/P, default = 0x0
    //
    UINTX unccnt : 8;
    //
    // Reserved
    // 
    // Bits[31:8], RSV, default = 0x0
    //
    UINTX rsvd_derrcnt : 24;
  } Bits;
  UINTX Data;
} DERRCNT_DUNIT_STRUCT;
#endif // ASM_INC

#define ERRINJCTL_DUNIT_REG                                0x00000134
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Error Injection Enable:
    // 0 - Error injection is disabled
    // 1 - Error injection is enabled. This bit is self clearing when inject once is
    // selected and the single error injection has been performed.  This bit should be
    // set to 0 when INJTRIGSEL is set to 1X.  Upon assertion, the trigger will automatically
    // set the INJEN field. 
    // 
    // Bits[0:0], RW/V/P, default = 0x0
    //
    UINTX injen : 1;
    //
    // Error Injection Once:
    // When set, a single error will be injected after error injection is enabled. Otherwise,
    // error injection will be continuous until disabled.  Note that error injection
    // has a minimum temporal granularity of one dunit clock cycle.  Thus, if the address
    // match/match bits allow injections on multiple bursts, it is possible to inject
    // up to 4 errors (across the 4 bursts per dunit cycle) even with this bit set. 
    // 
    // Bits[1:1], RW/P, default = 0x0
    //
    UINTX injonce : 1;
    //
    // Error Injection Address Enable:
    // When set, the error injection will be performed only for addresses that match
    // the address specified in the ERRINJADDR and ERRINJAMSK registers. 
    // 
    // Bits[2:2], RW/P, default = 0x0
    //
    UINTX injadren : 1;
    //
    // Error Injection Source Enable:
    // When set, the error injection will be performed only for the specified requestor
    // source. 
    // 
    // Bits[3:3], RW/P, default = 0x0
    //
    UINTX injsrcen : 1;
    //
    // Error Injection in ECC or Parity Path Selection:
    // 0 = Inject in the Data/Parity Path
    // 1 = Inject in the Data/ECC Path
    // 
    // Bits[4:4], RW/P, default = 0x0
    //
    UINTX injecc : 1;
    //
    // Error Injection in the Write Data Path:
    // 0 = Disable
    // 1 = Enabled
    // 
    // Bits[5:5], RW/P, default = 0x0
    //
    UINTX injwrite : 1;
    //
    // Error Injection in the Read Data Path:
    // 0 = Disable
    // 1 = Enabled
    // 
    // Bits[6:6], RW/P, default = 0x0
    //
    UINTX injread : 1;
    //
    // Inject on patrol scrub request.  Address match/mask logic is not used here.  Error
    // injection will occur on the next patrol scrub once INJEN is set. 
    // 
    // Bits[7:7], RW/P, default = 0x0
    //
    UINTX injpat : 1;
    //
    // Error Injection Source[3:0]:
    // The selected requestor source ID match against when selecting the transaction
    // for error injection. 
    // 
    // Bits[11:8], RW/P, default = 0x0
    //
    UINTX injsrc : 4;
    //
    // Command address parity injection per dclk half
    // 
    // Bits[13:12], RW/P, default = 0x0
    //
    UINTX injcap : 2;
    //
    // Error Injection Trigger Selection:
    // 0x = Disable error injection trigger sources
    // 10 = Enable error injection when trigger source 0 (ddr_fsta_trigev[0]) is asserted
    // 11 = Enable error injection when trigger source 1 (ddr_fsta_trigev[1]) is asserted.
    //  When setting this field to 1X, the INJEN field should be set to 0 since it will
    // be set automatically when the trigger asserts. 
    // 
    // Bits[15:14], RW/P, default = 0x0
    //
    UINTX injtrigsel : 2;
    //
    // Error Injection Address[3]:
    // This is error injection address bit 3; address bits 35:4 are located in the ERRINJADDR
    // register. 
    // 
    // Bits[16:16], RW/P, default = 0x0
    //
    UINTX injaddr3 : 1;
    //
    // Error Injection Address Mask[3]:
    // This is the mask bit for error injection address bit 3; address mask bits 36:5
    // are located in the ERRINJAMSK register. 
    // 
    // Bits[17:17], RW/P, default = 0x0
    //
    UINTX injamsk3 : 1;
    //
    // Error Injection Address[4]:
    // This is error injection address bit 4; address bits 36:5 are located in the ERRINJADDR
    // register. 
    // 
    // Bits[18:18], RW/P, default = 0x0
    //
    UINTX injaddr4 : 1;
    //
    // Error Injection Address Mask[4]:
    // This is the mask bit for error injection address bit 4; address mask bits 36:5
    // are located in the ERRINJAMSK register. 
    // 
    // Bits[19:19], RW/P, default = 0x0
    //
    UINTX injamsk4 : 1;
    //
    // Reserved
    // 
    // Bits[23:20], RSV, default = 0x0
    //
    UINTX rsvd_errinjctl_2 : 4;
    //
    // Error Injection ECC/Parity[7:0]:
    // Error injection ECC/parity. Zero bits indicate no injection; one bits indicate
    // that the corresponding read/write ECC or parity bit should be inverted. 
    // 
    // Bits[31:24], RW/P, default = 0x0
    //
    UINTX injeccpar : 8;
  } Bits;
  UINTX Data;
} ERRINJCTL_DUNIT_STRUCT;
#endif // ASM_INC

#define ERRINJADDR_DUNIT_REG                               0x00000138
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Error Injection PMI Address[36:5]
    // 
    // Bits[31:0], RW/P, default = 0x0
    //
    UINTX injaddr : 32;
  } Bits;
  UINTX Data;
} ERRINJADDR_DUNIT_STRUCT;
#endif // ASM_INC

#define ERRINJAMSK_DUNIT_REG                               0x0000013C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Error Injection PMI Address Mask[36:5]:
    // For each bit that is 0 in the address mask, the corresponding PMI address bit
    // will be compared against the same bit in ERRINJADDR. 
    // 
    // Bits[31:0], RW/P, default = 0x0
    //
    UINTX injamsk : 32;
  } Bits;
  UINTX Data;
} ERRINJAMSK_DUNIT_STRUCT;
#endif // ASM_INC

#define ERRINJDATA0_DUNIT_REG                              0x00000140
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Error Injection Data[31:0]:
    // Zero bits indicate no injection; one bits indicate that the corresponding read/write
    // data bit should be inverted. 
    // 
    // Bits[31:0], RW/P, default = 0x0
    //
    UINTX injdata0 : 32;
  } Bits;
  UINTX Data;
} ERRINJDATA0_DUNIT_STRUCT;
#endif // ASM_INC

#define ERRINJDATA1_DUNIT_REG                              0x00000144
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Error Injection Data[63:32]:
    // Zero bits indicate no injection; one bits indicate that the corresponding read/write
    // data bit should be inverted. 
    // 
    // Bits[31:0], RW/P, default = 0x0
    //
    UINTX injdata1 : 32;
  } Bits;
  UINTX Data;
} ERRINJDATA1_DUNIT_STRUCT;
#endif // ASM_INC

#define DMAP2_DUNIT_REG                                    0x00000148
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Row 0 for DDR3/ DDR4: This field selects which PMI address bit is used for Row0.
    // Cannot be unused. 
    // [br] For 0h to 33 (0 to 21H):
    // [br]   Row0 bit = A[6 + ROW0]
    // 
    // Bits[4:0], RW/P, default = 0x0
    //
    UINTX row0 : 5;
    //
    // Row 1 for DDR3/ DDR4: This field selects which PMI address bit is used for Row1.
    // Cannot be unused. 
    // [br] For 0h to 33 (0 to 21H):
    // [br]   Row1 bit = A[6 + ROW1]
    // 
    // Bits[9:5], RW/P, default = 0x0
    //
    UINTX row1 : 5;
    //
    // Row 2 for DDR3/ DDR4: This field selects which PMI address bit is used for Row2.
    // Cannot be unused. 
    // [br] For 0h to 33 (0 to 21H):
    // [br]   Row2 bit = A[6 + ROW2]
    // 
    // Bits[14:10], RW/P, default = 0x0
    //
    UINTX row2 : 5;
    //
    // Row 3 for DDR3/ DDR4: This field selects which PMI address bit is used for Row3.
    // Cannot be unused. 
    // [br] For 0h to 33 (0 to 21H):
    // [br]   Row3 bit = A[6 + ROW3]
    // 
    // Bits[19:15], RW/P, default = 0x0
    //
    UINTX row3 : 5;
    //
    // Row 4 for DDR3/ DDR4: This field selects which PMI address bit is used for Row4.
    // Cannot be unused. 
    // [br] For 0h to 33 (0 to 21H):
    // [br]   Row4 bit = A[6 + ROW4]
    // 
    // Bits[24:20], RW/P, default = 0x0
    //
    UINTX row4 : 5;
    //
    // Row 5 for DDR3/ DDR4: This field selects which PMI address bit is used for Row5.
    // Cannot be unused. 
    // [br] For 0h to 33 (0 to 21H):
    // [br]   Row5 bit = A[6 + ROW5]
    // 
    // Bits[29:25], RW/P, default = 0x0
    //
    UINTX row5 : 5;
    //
    // Reserved
    // 
    // Bits[31:30], RSV, default = 0x0
    //
    UINTX rsvd_dmap2_0 : 2;
  } Bits;
  UINTX Data;
} DMAP2_DUNIT_STRUCT;
#endif // ASM_INC

#define DMAP3_DUNIT_REG                                    0x0000014C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Row 6 for DDR3/ DDR4: This field selects which PMI address bit is used for Row6.
    // Cannot be unused. 
    // [br] For 0h to 33 (0 to 21H):
    // [br]   Row6 bit = A[6 + ROW6]
    // 
    // Bits[4:0], RW/P, default = 0x0
    //
    UINTX row6 : 5;
    //
    // Row 7 for DDR3/ DDR4: This field selects which PMI address bit is used for Row7.
    // Cannot be unused. 
    // [br] For 0h to 33 (0 to 21H):
    // [br]   Row7 bit = A[6 + ROW7]
    // 
    // Bits[9:5], RW/P, default = 0x0
    //
    UINTX row7 : 5;
    //
    // Row 8 for DDR3/ DDR4: This field selects which PMI address bit is used for Row8.
    // Cannot be unused. 
    // [br] For 0h to 33 (0 to 21H):
    // [br]   Row8 bit = A[6 + ROW8]
    // 
    // Bits[14:10], RW/P, default = 0x0
    //
    UINTX row8 : 5;
    //
    // Row 9 for DDR3/ DDR4: This field selects which PMI address bit is used for Row9.
    // Cannot be unused. 
    // [br] For 0h to 33 (0 to 21H):
    // [br]   Row9 bit = A[6 + ROW9]
    // 
    // Bits[19:15], RW/P, default = 0x0
    //
    UINTX row9 : 5;
    //
    // Row 10 for DDR3/ DDR4: This field selects which PMI address bit is used for Row10.
    // Cannot be unused. 
    // [br] For 0h to 33 (0 to 21H):
    // [br]   Row10 bit = A[6 + ROW10]
    // 
    // Bits[24:20], RW/P, default = 0x0
    //
    UINTX row10 : 5;
    //
    // Row 11 for DDR3/ DDR4: This field selects which PMI address bit is used for Row11.
    // Cannot be unused. 
    // [br] For 0h to 33 (0 to 21H):
    // [br]   Row11 bit = A[6 + ROW11]
    // 
    // Bits[29:25], RW/P, default = 0x0
    //
    UINTX row11 : 5;
    //
    // Reserved
    // 
    // Bits[31:30], RSV, default = 0x0
    //
    UINTX rsvd_dmap3_0 : 2;
  } Bits;
  UINTX Data;
} DMAP3_DUNIT_STRUCT;
#endif // ASM_INC

#define DMAP4_DUNIT_REG                                    0x00000150
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Row 12 for DDR3/ DDR4: This field selects which PMI address bit is used for Row12.
    // Cannot be unused. 
    // [br] For 0h to 33 (0 to 21H):
    // [br]   Row12 bit = A[6 + ROW12]
    // 
    // Bits[4:0], RW/P, default = 0x0
    //
    UINTX row12 : 5;
    //
    // Row 13 for DDR3/ DDR4: This field selects which PMI address bit is used for Row13.
    // Cannot be unused. 
    // [br] For 0h to 33 (0 to 21H):
    // [br]   Row13 bit = A[6 + ROW13]
    // 
    // Bits[9:5], RW/P, default = 0x0
    //
    UINTX row13 : 5;
    //
    // Row 14 for DDR3/ DDR4: This field selects which PMI address bit is used for Row14.
    // If set to all 1's, this field is disabled. 
    // [br] For 0h to 33 (0 to 21H):
    // [br]   Row14 bit = A[6 + ROW14]
    // 
    // Bits[14:10], RW/P, default = 0x0
    //
    UINTX row14 : 5;
    //
    // Row 15 for DDR3/ DDR4: This field selects which PMI address bit is used for Row15.
    // If set to all 1's, this field is disabled. 
    // [br] For 0h to 33 (0 to 21H):
    // [br]   Row15 bit = A[6 + ROW15]
    // 
    // Bits[19:15], RW/P, default = 0x0
    //
    UINTX row15 : 5;
    //
    // Row 16 for DDR3/ DDR4: This field selects which PMI address bit is used for Row16.
    // If set to all 1's, this field is disabled. 
    // [br] For 0h to 33 (0 to 21H):
    // [br]   Row16 bit = A[6 + ROW16]
    // 
    // Bits[24:20], RW/P, default = 0x0
    //
    UINTX row16 : 5;
    //
    // Row 17 for DDR3/ DDR4: This field selects which PMI address bit is used for Row17.
    // If set to all 1's, this field is disabled. 
    // [br] For 0h to 33 (0 to 21H):
    // [br]   Row17 bit = A[6 + ROW17]
    // 
    // Bits[29:25], RW/P, default = 0x0
    //
    UINTX row17 : 5;
    //
    // Reserved
    // 
    // Bits[31:30], RSV, default = 0x0
    //
    UINTX rsvd_dmap4_0 : 2;
  } Bits;
  UINTX Data;
} DMAP4_DUNIT_STRUCT;
#endif // ASM_INC

#define DMAP5_DUNIT_REG                                    0x00000154
#ifndef ASM_INC
typedef union {
  struct {
    //
    // CA3 for DDR3/ DDR4: This field selects which PMI address bit is used for Column
    // 3. Cannot be unused. 
    // [br] For 0h to 15 (0 to FH):
    // [br]   Column Address bit 3 bit = A[6 + CA3]
    // [br] This field is ignored in 32 bit mode
    // 
    // Bits[3:0], RW/P, default = 0x0
    //
    UINTX ca3 : 4;
    //
    // CA4 for DDR3/ DDR4: This field selects which PMI address bit is used for Column
    // 4. Cannot be unused. 
    // [br] For 0h to 15 (0 to FH):
    // [br]   Column Address bit 4 bit = A[6 + CA4]
    // 
    // Bits[7:4], RW/P, default = 0x0
    //
    UINTX ca4 : 4;
    //
    // CA5 for DDR3/ DDR4: This field selects which PMI address bit is used for Column
    // 5. Cannot be unused. 
    // [br] For 0h to 15 (0 to FH):
    // [br]   Column Address bit 5 bit = A[6 + CA5]
    // 
    // Bits[11:8], RW/P, default = 0x0
    //
    UINTX ca5 : 4;
    //
    // CA6 for DDR3/ DDR4: This field selects which PMI address bit is used for Column
    // 6. Cannot be unused. 
    // [br] For 0h to 15 (0 to FH):
    // [br]   Column Address bit 6 bit = A[6 + CA6]
    // 
    // Bits[15:12], RW/P, default = 0x0
    //
    UINTX ca6 : 4;
    //
    // CA7 for DDR3/ DDR4: This field selects which PMI address bit is used for Column
    // 7. Cannot be unused. 
    // [br] For 0h to 15 (0 to FH):
    // [br]   Column Address bit 7 bit = A[6 + CA7]
    // 
    // Bits[19:16], RW/P, default = 0x0
    //
    UINTX ca7 : 4;
    //
    // CA8 for DDR3/ DDR4: This field selects which PMI address bit is used for Column
    // 8. Cannot be unused. 
    // [br] For 0h to 15 (0 to FH):
    // [br]   Column Address bit 8 bit = A[6 + CA8]
    // 
    // Bits[23:20], RW/P, default = 0x0
    //
    UINTX ca8 : 4;
    //
    // CA9 for DDR3/ DDR4: This field selects which PMI address bit is used for Column
    // 9. Cannot be unused. 
    // [br] For 0h to 15 (0 to FH):
    // [br]   Column Address bit 9 bit = A[6 + CA9]
    // 
    // Bits[27:24], RW/P, default = 0x0
    //
    UINTX ca9 : 4;
    //
    // Reserved
    // 
    // Bits[31:28], RSV, default = 0x0
    //
    UINTX rsvd_dmap5_0 : 4;
  } Bits;
  UINTX Data;
} DMAP5_DUNIT_STRUCT;
#endif // ASM_INC

#define DRP_DUNIT_REG                                      0x00000158
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Enable Rank 0 (DIMM 0 Rank 0): Should be set to 1 when DIMM0 is populated with
    // either a single or dual rank DIMM.  Otherwise, must be set to 0. 
    // 
    // Bits[0:0], RW/P, default = 0x0
    //
    UINTX rken0 : 1;
    //
    // Enable Rank 1 (DIMM 0 Rank 1): Should be set to 1 when DIMM0 is populated with
    // a dual rank DIMM. Otherwise, must be set to 0. 
    // 
    // Bits[1:1], RW/V/P, default = 0x0
    //
    UINTX rken1 : 1;
    //
    // Enable Rank 2 (DIMM 1 Rank 0): Should be set to 1 when DIMM1 is populated with
    // either a single or dual rank DIMM.  Otherwise, must be set to 0. 
    // 
    // Bits[2:2], RW/V/P, default = 0x0
    //
    UINTX rken2 : 1;
    //
    // Enable Rank 3 (DIMM 1 Rank 1): Should be set to 1 when DIMM1 is populated with
    // a dual rank DIMM. Otherwise, must be set to 0. 
    // 
    // Bits[3:3], RW/V/P, default = 0x0
    //
    UINTX rken3 : 1;
    //
    // DIMM 0 - DRAM Device Data Width. Data width of the DRAM devices populated on DIMM
    // 0 for both Ranks 0 and 1. 0: x8 1: x4 2: x16 Notice: All populated DRAM devices
    // for both Ranks of DIMM 0 must have the same data width. 
    // 
    // Bits[5:4], RW/V/P, default = 0x0
    //
    UINTX dimmdwid0 : 2;
    //
    // DIMM 0 - DRAM Device Density. Density of the DRAM devices populated on DIMM 0
    // for both Ranks 0 and 1. 0:  2Gbit 1:  4Gbit 2:  8Gbit 3: 16Gbit (DDR4 Only) Notice:
    // All populated DRAM devices for both Ranks of DIMM 0 must have the same density.
    // 
    // Bits[7:6], RW/V/P, default = 0x0
    //
    UINTX dimmdden0 : 2;
    //
    // DIMM 1 - DRAM Device Data Width. Data width of the DRAM devices populated on DIMM
    // 1 for both Ranks 0 and 1. 0: x8 1: x4 2: x16  Notice: All populated DRAM devices
    // for both Ranks of DIMM 1 must have the same data width. 
    // 
    // Bits[9:8], RW/V/P, default = 0x0
    //
    UINTX dimmdwid1 : 2;
    //
    // DIMM 1 - DRAM Device Density. Density of the DRAM devices populated on DIMM 1
    // for both Ranks 0 and 1. 0:  2Gbit 1:  4Gbit 2:  8Gbit 3: 16Gbit (DDR4 Only) Notice:
    // All populated DRAM devices for both Ranks of DIMM 1 must have the same density.
    // 
    // Bits[11:10], RW/V/P, default = 0x0
    //
    UINTX dimmdden1 : 2;
    //
    // Reserved
    // 
    // Bits[15:12], RSV, default = 0x0
    //
    UINTX rsvd_drp_0 : 4;
    //
    // DIMM Flip Required. BIOS must set this bit to 1 if the total size of DIMM1 is
    // greater than the total size of DIMM0.  DIMM Flipping simplifies rank decoding
    // in dual-DIMM configuration when the DIMMs are not equal in size by mapping the
    // low addresses to the larger DIMM. 
    // 
    // Bits[16:16], RW/P, default = 0x0
    //
    UINTX dimmflip : 1;
    //
    // Reserved
    // 
    // Bits[19:17], RSV, default = 0x0
    //
    UINTX rsvd_drp_1 : 3;
    //
    // Address mapping to DIMM0 is mirrored. BIOS writes value defined in SPD Byte 63.
    //  Used by row hammer logic.  0: Standard 1: Mirrored 
    // 
    // Bits[20:20], RW/P, default = 0x0
    //
    UINTX dimm0mirr : 1;
    //
    // Address mapping to DIMM1 is mirrored. BIOS writes value defined in SPD Byte 63.
    //  Used by row hammer logic.  0: Standard 1: Mirrored 
    // 
    // Bits[21:21], RW/P, default = 0x0
    //
    UINTX dimm1mirr : 1;
    //
    // Reserved
    // 
    // Bits[31:22], RSV, default = 0x0
    //
    UINTX rsvd_drp_2 : 10;
  } Bits;
  UINTX Data;
} DRP_DUNIT_STRUCT;
#endif // ASM_INC

#define DTR0_DUNIT_REG                                     0x0000015C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Precharge to Activate Command Delay.
    // [br] Specifies the number of DRAM clocks (CK) between a DRAM Precharge command
    // and a DRAM Activate command to the same bank.  The grayed out values indicate
    // optional support as specified in the JEDEC component spec. 
    // [br]     CK  DDR3:               DDR4:
    // [br] 0h:  7
    // [br] 1h:  8  _1600_
    // [br] 2h:  9   1600
    // [br] 3h: 10   1600, _1866_       _1600_
    // [br] 4h: 11   1600,  1866         1600
    // [br] 5h: 12          1866         1600, _1866_
    // [br] 6h: 13         _1866_               1866
    // [br] 7h: 14                              1866, _2133_
    // [br] 8h: 15                                     2133, _2400_
    // [br] 9h: 16                                     2133,  2400
    // [br] Bh: 18                                            2400
    // [br] Dh: 20                                                   2667
    // [br] Fh: 22
    // [br] All other encodings are reserved.
    // 
    // Bits[4:0], RW/P, default = 0x0
    //
    UINTX trp : 5;
    //
    // Activate (RAS) to CAS Command Delay for Reads. Specifies the number of DRAM clocks
    // (CK) between a DRAM Activate command and a DRAM Read command to the same bank.
    // Same encodings as tRP. 
    // 
    // Bits[9:5], RW/P, default = 0x0
    //
    UINTX trcd_rd : 5;
    //
    // Read CAS Latency. Specifies the number of DRAM clocks (CK) between a DRAM Read
    // command and the return of data on the DRAM DQ bus. Same encodings as tRP. 
    // 
    // Bits[14:10], RW/P, default = 0x0
    //
    UINTX tcl : 5;
    //
    // Write CAS Latency.
    // [br] The delay in DRAM clocks (CK) between the write command and the first burst
    // of write data. 
    // [br]     CK  DDR3:               DDR4:
    // [br] 0h:  Not supported.
    // [br] 1h:  8   1600
    // [br] 2h:  9          1866         1600
    // [br] 3h: 10                              1866
    // [br] 4h: 11                       1600          2133
    // [br] 5h: 12                              1866          2400
    // [br] 7h: 14                                     2133
    // [br] 9h: 16                                            2400
    // [br] Bh: 18                                                   2667
    // [br] Eh: 21
    // [br] All other encodings are reserved.
    // 
    // Bits[19:15], RW/P, default = 0x0
    //
    UINTX twcl : 5;
    //
    // Burst-Idle-Burst Limit:
    // [br] This configures the scheduler to limit the minimum duration of the DQ idle
    // cycles between write bursts.  This can help reduce the worst case resonance noise
    // by adding/reducing the idle cycles.  By adding idle cycles between non-back-to-back
    // writes, this avoids the minimum sized idles cycles and causes future write bursts
    // to be back-to-back through better scheduling. 
    // [br] 0: No scheduling limitation
    // [br] 1: Disallow the 1 CK of idle between write bursts
    // [br] 2: Disallow 1 to 2 CK of idle between write bursts
    // [br] 3: Disallow 1 to 3 CK of idle between write bursts
    // [br] 4: Disallow 1 to 4 CK of idle between write bursts
    // [br] All other encodings are reserved.
    // 
    // Bits[22:20], RW/P, default = 0x0
    //
    UINTX biblim : 3;
    //
    // Activate (RAS) to WRCAS Command Delay.
    //       Specifies the number of DRAM clocks (CK) between a DRAM Activate command
    // and a DRAM Write command to the same bank. 
    // Same encodings as tRCD_RD for DDR3. DDR4 can potentially have lower values. Lower
    // values TBD. 
    // 
    // Bits[27:23], RW/P, default = 0x0
    //
    UINTX trcd_wr : 5;
    //
    // Read to Precharge Delay.
    // [br] Specifies the minimum number of DRAM clocks (CK) between the Read and Precharge
    // commands to the same bank. 
    // [br] tRTP = max ( 4nCK, 7.5ns )
    // [br] 1h:  6 CK  (DDR3-1600,  DDR4-1600)
    // [br] 2h:  7 CK  (DDR3-1866,  DDR4-1866)
    // [br] 3h:  8 CK  (            DDR4-2133)
    // [br] 4h:  9 CK  (            DDR4-2400)
    // [br] 5h: 10 CK  (            DDR4-2667)
    // [br] 6h: 11 CK
    // [br] All other encodings are reserved.
    // 
    // Bits[30:28], RW/P, default = 0x0
    //
    UINTX trtp : 3;
    //
    // Stretch mode is not validated and not supported.  DFX Stretch Mode (8x) Enable
    // 0h: DFX Stretch mode disabled.  1h: DFX stretch mode (8x) for DDR3 and DDR4; The
    // minimum number of DRAM clocks (CK) from any Read Command to any Read/Write Command
    // is 40 clocks.  This allows for 32 clocks for the stretched read data, which is
    // normally 4 CK that is 8x stretched to 32 clocks.  This also allows for 8 additional
    // clocks for the DQS preamble, bus turn-around time, and Read-to-Write pull-in due
    // to differences in the read and write latencies (CL-WCL). 
    // 
    // Bits[31:31], RW/P, default = 0x0
    //
    UINTX stretch : 1;
  } Bits;
  UINTX Data;
} DTR0_DUNIT_STRUCT;
#endif // ASM_INC

#define DTR1_DUNIT_REG                                     0x00000160
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Row Activation Period.
    // [br] Specifies the minimum number of DRAM clocks (CK) between the Activate and
    // Precharge commands to the same bank. 
    // [br] 00h: 24 CK
    // [br] 01h: 25 CK
    // [br] 02h: 26 CK
    // [br] 03h: 27 CK
    // [br] 04h: 28 CK   DDR3-1600, DDR4-1600 (35ns)
    // [br] 05h: 29 CK
    // [br] 06h: 30 CK
    // [br] 07h: 31 CK
    // [br] 08h: 32 CK   DDR3-1866, DDR4-1866 (34ns)
    // [br] 09h: 33 CK
    // [br] 0Ah: 34 CK
    // [br] 0Bh: 35 CK
    // [br] 0Ch: 36 CK              DDR4-2133 (33ns)
    // [br] 0Dh: 37 CK
    // [br] 0Eh: 38 CK
    // [br] 0Fh: 39 CK              DDR4-2400 (32ns)
    // [br] 10h: 40 CK
    // [br] 11h: 41 CK
    // [br] 12h: 42 CK
    // [br] 13h: 43 CK
    // [br] 14h: 44 CK              DDR4-2667 (33ns)
    // [br] 15h: 45 CK
    // [br] 16h: 46 CK
    // [br] 17h: 47 CK
    // [br] 18h: 48 CK
    // [br] 19h: 49 CK
    // [br] All other encodings are reserved.
    // 
    // Bits[4:0], RW/P, default = 0x0
    //
    UINTX tras : 5;
    //
    // Write Recovery Time (15ns)
    // [br]       Specifies the minimum number of DRAM clocks (CK) needed for the 15ns
    // write recovery time.  This value is used to determine to write to pre-charge command
    // delay (tWTP = WCL + BL/2 + tWR). 
    // [br]       Vendors are requesting a tWR of 45ns.
    // [br] 0h:  10 CK
    // [br] 2h:  12 CK DDR3-1600 DDR4-1600
    // [br] 4h:  14 CK DDR3-1866 DDR4-1866
    // [br] 6h:  16 CK           DDR4-2133
    // [br] 8h:  18 CK           DDR4-2400
    // [br] Ah:  20 CK           DDR4-2667
    // [br] 10h: 26 CK           DDR4-1600 (45ns)
    // [br] 16h: 32 CK           DDR4-1866 (45ns)
    // [br] 1Ch: 38 CK           DDR4-2133 (45ns)
    // [br] 22h: 44 CK           DDR4-2400 (45ns)
    // [br] 28h: 50 CK           DDR4-2667 (45ns)
    // [br] 2Eh: 56 CK
    // [br] All other encodings are reserved.
    // 
    // Bits[11:5], RW/P, default = 0x0
    //
    UINTX twr : 7;
    //
    // REF command to ACT or REF command time for DIMM0.
    // [br] The value entered into this field should be equal to tRFC-2 for DIMM0.
    // [br] Frequency Density tRFC(ns)  tRFC(CK)  tRFC0minus2
    // [br] DDR3          2Gb      160
    // [br]      1600                        128   126 (07Dh)
    // [br]      1866                        150   148 (093h)
    // [br] DDR3          4Gb      300
    // [br]      1600                        240   238 (0EDh)
    // [br]      1866                        280   278 (115h)
    // [br] DDR3          8Gb      350
    // [br]      1600                        280   278 (115h)
    // [br]      1866                        327   325 (144h)
    // [br] 
    // [br] DDR4-1600     2Gb      160       128   126 (07Dh)
    // [br]      1866                        150   148 (093h)
    // [br]      2133                        171   169 (0A8h)
    // [br]      2400                        192   190 (0BDh)
    // [br]      2667                        214   212 (0D3h)
    // [br] DDR4 1600     4Gb      260       208   206 (0CDh)
    // [br]      1866                        243   241 (0F0h)
    // [br]      2133                        278   276 (113h)
    // [br]      2400                        312   310 (135h)
    // [br]      2667                        347   345 (158h)
    // [br] DDR4 1600     8Gb      350       280   278 (115h)
    // [br]      1866                        327   325 (144h)
    // [br]      2133                        374   372 (173h)
    // [br]      2400                        420   418 (1A1h)
    // [br]      2667                        467   465 (1D0h)
    // [br] DDR4 1600    16Gb     -TBD- (Not in JEDEC Spec yet)
    // [br]      1866
    // [br]      2133
    // [br]      2400
    // [br]      2667
    // 
    // 
    // Bits[21:12], RW/P, default = 0x0
    //
    UINTX trfc0minus2 : 10;
    //
    // REF command to ACT or REF command time for DIMM1. The value entered into this
    // field should be equal to tRFC-2 for DIMM1; Refer to tRFC0minus2 for details. 
    // 
    // Bits[31:22], RW/P, default = 0x0
    //
    UINTX trfc1minus2 : 10;
  } Bits;
  UINTX Data;
} DTR1_DUNIT_STRUCT;
#endif // ASM_INC

#define DTR2_DUNIT_REG                                     0x00000164
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Read to Read DQ delay, different ranks, same DIMM:
    // [br] Specifies the number of DRAM clocks (CK) from the start of a Read data burst
    // of one rank to the Start of a Read data burst of a different rank within the same
    // DIMM. 
    // [br] The number specified is (BL/2) + adddional delay
    // [br] Note that this is also the read to read command delay.
    // [br] The legal encodings are:
    // [br] 2h:   6 CK
    // [br] 3h:   7 CK
    // [br] 4h:   8 CK
    // [br] 5h:   9 CK
    // [br] 6h:  10 CK
    // [br] 7h:  11 CK
    // [br] 8h:  12 CK
    // [br] 9h:  13 CK
    // [br] All other encodings are reserved.
    // 
    // Bits[3:0], RW/P, default = 0x0
    //
    UINTX trrdr : 4;
    //
    // Read to Read DQ delay, different DIMMs:
    // [br] Specifies the number of DRAM clocks (CK) from the start of a Read data burst
    // of one DIMM to the Start of a Read data burst of a different DIMM. 
    // [br] The number specified is (BL/2) + adddional delay
    // [br] Note that this is also the read to read command delay.
    // [br] The legal encodings are:
    // [br] 2h:   6 CK
    // [br] 3h:   7 CK
    // [br] 4h:   8 CK
    // [br] 5h:   9 CK
    // [br] 6h:  10 CK
    // [br] 7h:  11 CK
    // [br] 8h:  12 CK
    // [br] 9h:  13 CK
    // [br] All other encodings are reserved.
    // 
    // Bits[7:4], RW/P, default = 0x0
    //
    UINTX trrdd : 4;
    //
    // Read to Write DQ delay, different ranks, same DIMM:
    // [br] Specifies the number of DRAM clocks (CK) from the start of a Read data burst
    // of one rank to the Start of a Write data burst of a different rank within the
    // same DIMM. 
    // [br] The number specified is (BL/2) + adddional delay.  The hardware will automatically
    // add (tCL - tWCL) to the value specified. 
    // [br] Note that this is also the read to write command delay when CL=WCL.
    // [br] The legal encodings are:
    // [br] 0h:   6 CK
    // [br] 1h:   7 CK
    // [br] 2h:   8 CK
    // [br] 3h:   9 CK
    // [br] 4h:  10 CK
    // [br] 5h:  11 CK
    // [br] 6h:  12 CK
    // [br] 7h:  13 CK
    // [br] 8h:  14 CK
    // [br] All other encodings are reserved.
    // 
    // Bits[11:8], RW/P, default = 0x0
    //
    UINTX trwdr : 4;
    //
    // Read to Write DQ delay, different DIMMs:
    // [br] Specifies the number of DRAM clocks (CK) from the start of a Read data burst
    // of one DIMMto the Start of a Write data burst of a different DIMM. 
    // [br] The number specified is (BL/2) + adddional delay.  The hardware will automatically
    // add (tCL - tWCL) to the value specified. 
    // [br] Note that this is also the read to write command delay when CL=WCL.
    // [br] The legal encodings are:
    // [br] 0h:   6 CK
    // [br] 1h:   7 CK
    // [br] 2h:   8 CK
    // [br] 3h:   9 CK
    // [br] 4h:  10 CK
    // [br] 5h:  11 CK
    // [br] 6h:  12 CK
    // [br] 7h:  13 CK
    // [br] 8h:  14 CK
    // [br] All other encodings are reserved.
    // 
    // Bits[15:12], RW/P, default = 0x0
    //
    UINTX trwdd : 4;
    //
    // Read to Write DQ delay, same rank, different bank group:
    // [br] Specifies the number of DRAM clocks (CK) from the start of a Read data burst
    // to the Start of a Write data burst to the same. 
    // [br] The number specified is (BL/2) + adddional delay.  The hardware will automatically
    // add (tCL - tWCL) to the value specified. 
    // [br] Note that this is also the read to write command delay when CL=WCL.
    // [br] The legal encodings are:
    // [br] 0h:   6 CK
    // [br] 1h:   7 CK
    // [br] 2h:   8 CK
    // [br] 3h:   9 CK
    // [br] 4h:  10 CK
    // [br] 5h:  11 CK
    // [br] 6h:  12 CK
    // [br] 7h:  13 CK
    // [br] 8h:  14 CK
    // [br] 9h:  15 CK
    // [br] All other encodings are reserved.
    // 
    // Bits[19:16], RW/P, default = 0x0
    //
    UINTX trwsr_s : 4;
    //
    // Read to Write DQ delay, same rank, same bank group:
    // [br] Specifies the number of DRAM clocks (CK) from the start of a Read data burst
    // to the Start of a Write data burst to the same. 
    // [br] The number specified is (BL/2) + adddional delay.  The hardware automatically
    // will add (tCL - tWCL) to the value specified. 
    // [br] Note that this is also the read to write command delay when CL=WCL.
    // [br] The legal encodings are:
    // [br] 0h:   6 CK
    // [br] 1h:   7 CK
    // [br] 2h:   8 CK
    // [br] 3h:   9 CK
    // [br] 4h:  10 CK
    // [br] 5h:  11 CK
    // [br] 6h:  12 CK
    // [br] 7h:  13 CK
    // [br] 8h:  14 CK
    // [br] 9h:  15 CK
    // [br] All other encodings are reserved.
    // 
    // Bits[23:20], RW/P, default = 0x0
    //
    UINTX trwsr_l : 4;
    //
    // Reserved
    // 
    // Bits[29:24], RSV, default = 0x0
    //
    UINTX rsvd_dtr2_0 : 6;
    //
    // Set to 1 when DDR4 2 clock preamble is used.
    // [br] 0: No restriction.
    // [br] 1: Do not allow 5 cycle RD CAS to RD CAS separation for back to back RD CAS
    // to same rank. 
    // 
    // Bits[30:30], RW/P, default = 0x0
    //
    UINTX rar_restriction_5cycle : 1;
    //
    // Set to 1 when DDR4 2 clock preamble is used.
    // [br] 0: No restriction.
    // [br] 1: Do not allow 5 cycle WR CAS to WR CAS separation for back to back WR CAS
    // to same rank. 
    // 
    // Bits[31:31], RW/P, default = 0x0
    //
    UINTX waw_restriction_5cycle : 1;
  } Bits;
  UINTX Data;
} DTR2_DUNIT_STRUCT;
#endif // ASM_INC

#define DTR3_DUNIT_REG                                     0x00000168
#ifndef ASM_INC
typedef union {
  struct {
    //
    // DRAM Command Valid Duration.
    // [br] Specifies the number of DRAM clocks a command is held valid on the DRAM Address
    // and Control buses. 1N mode provides the best performance (less latency, lower
    // command BW required).  However, 2N mode will be required for the higher frequencies
    // with higher loadings (ranks/DIMMs per channel).  The configuration matrix that
    // determines when 2N mode is required is owned by the DDR Kit Team and the Post-Si
    // EV Team. 
    // [br] Note that in 2N mode, a 0% page hit rate will limit the read/write data to
    // 66.7% of the maximum BW because every read/write will require 3 commands (Activate,
    // Read/Write, Pre-Charge).  At a 50% page hit rate, the command BW is matched to
    // the read/write data BW. 
    // [br] 0:  1 CK (1N)
    // [br] 1:  2 CK (2N)
    // [br] 2:  3 CK (3N)
    // [br] 3:  Reserved
    // 
    // Bits[1:0], RW/V/P, default = 0x2
    //
    UINTX tcmd : 2;
    //
    // DIMM Type:
    // [br] 0: Unbuffered DIMM (Any form factor)
    // [br] 1: RDIMM
    // [br] All other encodings are reserved
    // 
    // Bits[3:2], RW/P, default = 0x0
    //
    UINTX dimmtype : 2;
    //
    // Write command to ODT assert delay.
    // [br] JEDEC requires ODT to be asserted high when the DRAM Write command is issued.
    // WRODTSTRT can be set to enable asserting ODT 1 DRAM clock (CK) earlier than the
    // Write command for 2N, or 2 CK earlier than the Write command for 3N. 
    // [br] For normal operation this should be set to 0.
    // [br] 
    // [br] 	tCMD=1N	tCMD=2N	tCMD=3N
    // [br] 0	WR-0	WR-0	WR-0
    // [br] 1	WR-0	WR-1	WR-1
    // [br] 2	Reserved
    // [br] 3	WR-0	WR-1	WR-2
    // 
    // Bits[5:4], RW/P, default = 0x0
    //
    UINTX wrodtstrt : 2;
    //
    // Write command to ODT de-assert delay:
    // [br] For normal operation this should be set to 0.
    // [br] 0:  WR+6
    // [br] 1:  WR+7
    // [br] 2:  WR+8
    // [br] 3:  WR+9
    // 
    // Bits[7:6], RW/P, default = 0x0
    //
    UINTX wrodtstop : 2;
    //
    // Read command to ODT assert delay.
    // [br] For normal operation this should be set to 0.
    // [br] 
    // [br] 	tCMD=1N	tCMD=2N	tCMD=3N
    // [br] 0	RD+CL-WCL-0	RD+CL-WCL-0	RD+CL-WCL-0
    // [br] 1	RD+CL-WCL-0	RD+CL-WCL-1	RD+CL-WCL-1
    // [br] 2	Reserved
    // [br] 3	RD+CL-WCL-0	RD+CL-WCL-1	RD+CL-WCL-2
    // 
    // Bits[9:8], RW/P, default = 0x0
    //
    UINTX rdodtstrt : 2;
    //
    // Read command to ODT de-assert delay:
    // [br] For normal operation this should be set to 0.
    // [br] 0:  RD+CL-WCL+6
    // [br] 1:  RD+CL-WCL+7
    // [br] 2:  RD+CL-WCL+8
    // [br] 3:  RD+CL-WCL+9
    // 
    // Bits[11:10], RW/P, default = 0x0
    //
    UINTX rdodtstop : 2;
    //
    // Row (Activate) to Row (Activate) Delay Long
    // [br] DDR3: Not used.
    // [br] DDR4: Specifies the minimum number of DRAM clocks (CK) between two Activate
    // commands to the same rank but to a different bank in the same bank group. 
    // [br] 
    // [br]      CK   DDR4 (x4/x8 Devices):
    // [br] 1:    5   1600, 1866
    // [br] 2:    6   2133, 2400
    // [br] 3:    7   2667
    // [br] 4:    8
    // [br] All other encodings are reserved.
    // 
    // Bits[14:12], RW/P, default = 0x0
    //
    UINTX trrd_l : 3;
    //
    // Row (Activate) to Row (Activate) Delay Short
    // [br] DDR3: Specifies the minimum number of DRAM clocks (CK) between two Activate
    // commands to the same rank but to a different bank. 
    // [br] DDR4: Specifies the minimum number of DRAM clocks (CK) between two Activate
    // commands to the same rank but to different bank groups. 
    // [br] QRDIMM: This register configures tRRD_dlr which is the time between successive
    // ACTIVATE commands to different logical ranks. 
    // [br] 
    // [br]     CK  DDR3:
    // [br] 1:   5  1600, 1KB Page (1,2,4 Gb x8 devices)
    // [br] 2:   6  1600, 2KB Page (      8 Gb x8 devices)
    // [br]         1866, 1KB Page (1,2,4 Gb x8 devices)
    // [br] 3:   7  1866, 2KB Page (      8 Gb x8 devices)
    // [br] 
    // [br]     CK  DDR4 (x4/x8 Devices):
    // [br] 0:   4  1600, 1866, 2133, 2400
    // [br] All other encodings are reserved.
    // 
    // Bits[17:15], RW/P, default = 0x0
    //
    UINTX trrd_s : 3;
    //
    // Column (CAS) to Column (CAS) Command Delay for reads to the same bank group.
    // [br] DDR3: Not Used (tCCD=4)
    // [br] DDR4: Specifies the minimum number of DRAM clocks (CK) between read Commands
    // to the same rank and to the same bank group (tCCD_L for reads) 
    // [br] 0h:  4 CK
    // [br] 1h:  5 CK   DDR4-1600, 1866
    // [br] 2h:  6 CK   DDR4-2133, 2400
    // [br] 3h:  7 CK
    // [br] 4h:  8 CK
    // [br] All other encodings are reserved.
    // 
    // Bits[20:18], RW/P, default = 0x2
    //
    UINTX tccd_l_rd : 3;
    //
    // Column (CAS) to Column (CAS) Command Delay for writes to the same bank group.
    // [br] DDR3: Not Used (tCCD=4)
    // [br] DDR4: Specifies the minimum number of DRAM clocks (CK) between write Commands
    // to the same rank and to the same bank group (tCCD_L for writes) 
    // [br] 0h:  4 CK
    // [br] 1h:  5 CK   DDR4-1600, 1866
    // [br] 2h:  6 CK   DDR4-2133, 2400
    // [br] 3h:  7 CK
    // [br] 4h:  8 CK
    // [br] All other encodings are reserved.
    // 
    // Bits[23:21], RW/P, default = 0x2
    //
    UINTX tccd_l_wr : 3;
    //
    // Column (CAS) to Column (CAS) Command Delay for reads to different bank groups.
    // [br] DDR3: tCCD=4
    // [br] DDR4: Specifies the minimum number of DRAM clocks (CK) between read Commands
    // to the same rank and to different bank groups 
    // [br] tCCD value for reads = tCCD_RD + 4
    // [br] Expected value is 0 i.e. use tCCD = 4.  Non-zero values may be used during
    // Electrical Validation and if there are any issues discovered post-silicon that
    // require this spacing. 
    // 
    // Bits[25:24], RW/P, default = 0x0
    //
    UINTX tccd_rd : 2;
    //
    // Column (CAS) to Column (CAS) Command Delay for writes to different bank groups.
    // [br] DDR3: tCCD=4
    // [br] DDR4: Specifies the minimum number of DRAM clocks (CK) between writes Commands
    // to the same rank and to different bank groups 
    // [br] tCCD value for writes = tCCD_WR + 4
    // [br] Expected value is 0 i.e. use tCCD = 4.  Non-zero values may be used during
    // Electrical Validation and if there are any issues discovered post-silicon that
    // require this spacing. 
    // 
    // Bits[27:26], RW/P, default = 0x0
    //
    UINTX tccd_wr : 2;
    //
    // Reserved
    // 
    // Bits[31:28], RSV, default = 0x0
    //
    UINTX rsvd_dtr3_0 : 4;
  } Bits;
  UINTX Data;
} DTR3_DUNIT_STRUCT;
#endif // ASM_INC

#define DTR4_DUNIT_REG                                     0x0000016C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Which ODT[3:0] signal to assert during a read to rank 0
    // 
    // Bits[3:0], RW/P, default = 0x4
    //
    UINTX rdodt_rank0 : 4;
    //
    // Which ODT[3:0] signal to assert during a read to rank 1
    // 
    // Bits[7:4], RW/P, default = 0x4
    //
    UINTX rdodt_rank1 : 4;
    //
    // Which ODT[3:0] signal to assert during a read to rank 2
    // 
    // Bits[11:8], RW/P, default = 0x1
    //
    UINTX rdodt_rank2 : 4;
    //
    // Which ODT[3:0] signal to assert during a read to rank 3
    // 
    // Bits[15:12], RW/P, default = 0x1
    //
    UINTX rdodt_rank3 : 4;
    //
    // Which ODT[3:0] signal to assert during a write to rank 0
    // 
    // Bits[19:16], RW/P, default = 0x5
    //
    UINTX wrodt_rank0 : 4;
    //
    // Which ODT[3:0] signal to assert during a write to rank 1
    // 
    // Bits[23:20], RW/P, default = 0x6
    //
    UINTX wrodt_rank1 : 4;
    //
    // Which ODT[3:0] signal to assert during a write to rank 2
    // 
    // Bits[27:24], RW/P, default = 0x5
    //
    UINTX wrodt_rank2 : 4;
    //
    // Which ODT[3:0] signal to assert during a write to rank 3
    // 
    // Bits[31:28], RW/P, default = 0x9
    //
    UINTX wrodt_rank3 : 4;
  } Bits;
  UINTX Data;
} DTR4_DUNIT_STRUCT;
#endif // ASM_INC

#define DCS_DUNIT_REG                                      0x00000170
#ifndef ASM_INC
typedef union {
  struct {
    //
    // CKE Control Value: Each bit of CKEVAL directly controls a CKE pin, when CKEMODE
    // is set to 1. Used only during init flow by BIOS. 
    // 
    // Bits[3:0], RW/P, default = 0x0
    //
    UINTX ckeval : 4;
    //
    // CKE Control Mode: 0 - Dunit auto controls the CKE pins based on Power-Down and
    // Self Refresh entry and exit. 1 - The value of CKEVAL above directly controls the
    // CKE pins. 
    // 
    // Bits[4:4], RW/P, default = 0x0
    //
    UINTX ckemode : 1;
    //
    // Reserved
    // 
    // Bits[7:5], RSV, default = 0x0
    //
    UINTX rsvd_dcs_0 : 3;
    //
    // ODT Control Value: Each bit of ODTVAL directly controls an ODT pin, when ODTMODE
    // is set to 1. Used only during init flow by BIOS. 
    // 
    // Bits[11:8], RW/P, default = 0x0
    //
    UINTX odtval : 4;
    //
    // ODT Control Mode:
    // [br] 0 - Dunit auto controls the ODT pins based on DRAM Write transactions.
    // [br] 1 - The value of ODTVAL above directly controls the ODT pins.
    // 
    // Bits[12:12], RW/P, default = 0x0
    //
    UINTX odtmode : 1;
    //
    // Reserved
    // 
    // Bits[15:13], RSV, default = 0x0
    //
    UINTX rsvd_dcs_1 : 3;
    //
    // ECC Byte Lane Swap:
    // [br] 0h - Normal mode
    // [br] 1h - Swap ECC and Data Byte 0, this mode is not supported in 32 bit mode
    // [br] 2h - Reserved
    // [br] 3h - Reserved
    // 
    // Bits[17:16], RW/P, default = 0x0
    //
    UINTX ecclaneswap : 2;
    //
    // Reserved
    // 
    // Bits[19:18], RSV, default = 0x0
    //
    UINTX rsvd_dcs_2 : 2;
    //
    // Block Phase_B Commands:
    // [br] The Dunit runs at half the frequency of the DRAM clock to save power. In
    // order to issue back-to-back commands on every DRAM clock cycles, the Dunit has
    // to schedule two commands per Dunit clock. Therefore, it processes requests thru
    // two separate arbitration paths labeled as Phase_A and Phase_B. Setting this bit
    // to a 1 will disable Phase_B completely, and all memory requests will be processed
    // thru Phase_A arbitration path. With only Phase_A, the DRAM devices will never
    // see back-to-back commands. The best it will see is a command every other DRAM
    // clock cycle. 
    // [br] 0 - No block; 1 - Block
    // 
    // Bits[20:20], RW/P, default = 0x0
    //
    UINTX blkphaseb : 1;
    //
    // Mask Chip-Selects for all commands except read commands and MRS commands
    // 
    // Bits[21:21], RW/P, default = 0x0
    //
    UINTX mprmode : 1;
    //
    // Reserved
    // 
    // Bits[22:22], RSV, default = 0x0
    //
    UINTX rsvd_dcs_3 : 1;
    //
    // Data Scrambler Enable:
    // [br] When set to 1 the data lanes (DDR3_DQ[63:0]) and the ECC lanes (DDR3_DQECC[7:0])
    // will be scrambled, otherwise no scrambling will occur. 
    // 
    // Bits[23:23], RW/V/P, default = 0x0
    //
    UINTX scramble_enable : 1;
    //
    // Reserved
    // 
    // Bits[27:24], RSV, default = 0x0
    //
    UINTX rsvd_dcs_4 : 4;
    //
    // PMI Control:
    // [br] 0: Connect to the Bunit
    // [br] 1: Connect to CPGC
    // [br] When this field is changed, the Dunit will only switch after all previous
    // transactions from the previous unit have been completed. Since the Dunit is a
    // slave to the PMI interface and it cannot prevent the Bunit or CPGC from sendign
    // transactions, the initiatior of this request will have to make sure that the Bunit/CPGC
    // are configured appropriately. 
    // [br] Status of this operation from the Dunit perspective is provided in the PMI
    // STAT register. 
    // 
    // Bits[28:28], RW, default = 0x0
    //
    UINTX pmictl : 1;
    //
    // Reserved
    // 
    // Bits[31:29], RSV, default = 0x0
    //
    UINTX rsvd_dcs_5 : 3;
  } Bits;
  UINTX Data;
} DCS_DUNIT_STRUCT;
#endif // ASM_INC

#define DMAP_DUNIT_REG                                     0x00000174
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Bank Address Bit 0 for DDR3/DDR4: This field selects which PMI address bit is
    // used for BA0. 
    // [br] BA Bit 0:	A[6 + BA0]
    // [br] Valid PMI address values for BA0: A[14]-A[22]
    // 
    // Bits[4:0], RW/P, default = 0x9
    //
    UINTX ba0 : 5;
    //
    // Bank Address Bit 1 for DDR3/DDR4: This field selects which PMI address bit is
    // used for BA1. 
    // [br] BA Bit 1: A[6 + BA1]
    // [br] Valid PMI address values for BA0: A[15]-A[23]
    // 
    // Bits[9:5], RW/P, default = 0xA
    //
    UINTX ba1 : 5;
    //
    // Bank Group Bit 0 (DDR4), Bank Address Bit 2 (DDR3): This field selects which PMI
    // address bit is used for BA2 for DDR3 or BG0 for DDR4. 
    // [br] Bank Address Bit 2/BG0 bits : A[6 + BG0]
    // [br] For DDR4 Valid PMI address values for BG0: A[6]-A[7], A[13]-A[18]
    // [br] For DDR3 Valid PMI address values A[14]-A[18]
    // 
    // Bits[14:10], RW/P, default = 0x0
    //
    UINTX bg0 : 5;
    //
    // Bank Group Bit 1 for DDR4: This field selects which PMI address bit is used for
    // BG1 for DDR4 and is not used (disabled) for DDR3. 
    // [br] DDR4:  A[6 + BG1],
    // [br] DDR3: 1Fh: Disabled
    // [br] Valid PMI address values for BG0: A[7]-A[8], A[14]-A[19]
    // 
    // Bits[19:15], RW/P, default = 0x8
    //
    UINTX bg1 : 5;
    //
    // Rank Select Bit 0: This field selects which PMI address bit is used to select
    // between rank 0 and 1 of both DIMMs 0 and 1 (even/odd rank selection). 
    // [br] 0h to 16h:  A[13 + RS0], Range: A[13] to A[16]; A[25] to A[35]
    // [br] 1Fh:        Disabled; No dual rank DIMMs populated.
    // [br] Other values are reserved.
    // 
    // Bits[24:20], RW/P, default = 0x1
    //
    UINTX rs0 : 5;
    //
    // Rank Select Bit 1
    // [br] This field selects which PMI address bit is used to select between DIMM 0
    // and 1 (rank 1:0 versus rank 3:2 selection). 
    // [br] 0h to 17h:  A[13 + RS1], Range: A[13] to A[16]; A[26] to A[36]
    // [br] 1Fh:        Disabled; No dual rank DIMMs populated.
    // [br] Other values are reserved.
    // 
    // Bits[29:25], RW/P, default = 0x1
    //
    UINTX rs1 : 5;
    //
    // Reserved
    // 
    // Bits[31:30], RSV, default = 0x0
    //
    UINTX rsvd_dmap_0 : 2;
  } Bits;
  UINTX Data;
} DMAP_DUNIT_STRUCT;
#endif // ASM_INC

#define DPMC0_DUNIT_REG                                    0x00000178
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Self-Refresh Entry delay.
    // [br] Specifies the number of dram command clocks the Dunit will wait before it
    // enters Dynamic Self-Refresh mode, when there are no requests in the queue. 
    // [br] Unit: 16 DRAM Clocks
    // 
    // Bits[15:0], RW/P, default = 0x0
    //
    UINTX sredly : 16;
    //
    // Dynamic Self-Refresh Enable:
    // [br] When set to 1, the Dunit will automatically control DRAM Self Refresh entry
    // and exit based on PMI status and request. When there's no pending request on the
    // PMI and its status is less than 2, then the Dunit will place the DRAM devices
    // in Self Refresh mode. The DRAM devices will be brought out of Self-Refresh when
    // there's a request on PMI with a status of 2 or 3. 
    // 
    // Bits[16:16], RW/P, default = 0x0
    //
    UINTX dynsren : 1;
    //
    // DDRIO PHY Power Mode Opcode during dynamic self-refresh:
    // [br] After the Dunit has placed the DRAM devices in Self Refresh mode, it sends
    // this 5-bit value to the DDRIO PHY to tell it which power saving mode it should
    // enter.  Changes to this field during suspend/dynamic self-refresh directed self-refresh
    // will not result in a change in the DDRIO pm opcode. 
    // [br] This register field can be changed on the fly.
    // [br] PMOP Encodings:
    // [br] 0: All Features On
    // [br] -TBD-: Need to get this info from the DDRIO HIP team
    // 
    // Bits[21:17], RW/P, default = 0x0
    //
    UINTX dynpmop : 5;
    //
    // Reserved
    // 
    // Bits[23:22], RSV, default = 0x0
    //
    UINTX rsvd_dpmc0_0 : 2;
    //
    // DDRIO PHY Power Mode Opcode for suspend message:
    // [br] After the Dunit has placed the DRAM devices in Self Refresh mode in response
    // to a suspend message, it sends this 5-bit value to the DDRIO PHY to tell it which
    // power saving mode it should enter. Changes to this field during suspend/dynamic
    // self-refresh directed self-refresh will not result in a change in the DDRIO pm
    // opcode. 
    // [br] This register field can be changed on the fly.
    // [br] PMOP Encodings:
    // [br] 0: All Features On
    // [br] -TBD-: Need to get this info from the DDRIO HIP team
    // 
    // Bits[28:24], RW/P, default = 0x0
    //
    UINTX susp_pmop : 5;
    //
    // Reserved
    // 
    // Bits[31:29], RSV, default = 0x0
    //
    UINTX rsvd_dpmc0_1 : 3;
  } Bits;
  UINTX Data;
} DPMC0_DUNIT_STRUCT;
#endif // ASM_INC

#define DPMC1_DUNIT_REG                                    0x0000017C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // CKE Delay for SR with PMOP Opcode of 0:
    // [br] Delay between Dunit receiving a PM ack from the DDRIO and sending a SRX command,
    // when the PMOP sent to the PHY was zero. 
    // [br] At a minimum this has to be set to tCKSRX which is 10ns.
    // [br] The granularity of this register field is DRAM Command Clocks.
    // [br] 8: DDR3 1600/DDR4 1600
    // [br] 10: DDR3 1867/DDR4 1867
    // [br] 11 : DDR4 2133
    // [br] 12: DDR4 2400
    // [br] 14: DDR4 2667
    // [br] JEDEC defines tCKSRX = 10ns.
    // [br] The final tCKSRX delay = (CKEDLY DRAM Command Clocks)
    // [br] Range of register is higher because AVN had a much larger programmable value
    // for this. 
    // 
    // Bits[10:0], RW/P, default = 0xA
    //
    UINTX ckedly_pmop0 : 11;
    //
    // CKE Delay for SR with nonzero PMOP Opcode:
    // [br] Delay between Dunit receiving a PM ack from the DDRIO and sending a SRX command,
    // when the PMOP sent to the PHY was >= PMOP_LONG. 
    // [br] Expect to use this only for RDIMMs and not SODIMMs. For RDIMMs this should
    // be set to tSTAB. 
    // [br] tSTAB: Stabilization time for the clock in RDIMMs. This parameter applies
    // only RDIMMs. 
    // [br] When the dimms are put into self-refresh with a non-zero PM opcode the DDRIO
    // will float the clocks. For RDIMMs, this results in the register being placed in
    // clock stop mode. 
    // [br] The Dunit initiates self-refresh exit by sending a zero PM opcode to the
    // PHY. The PHY then enables the clocks as part of its self-refresh exit sequence.
    // If the clocks were turned off during self-refresh the Dunit has to wait for tSTAB
    // duration after the PHY acknowledges having exited self-refresh before sending
    // the SRE command to the DRAM. 
    // [br] Unit is in 16 DRAM Clocks Reserved.
    // [br] 
    // [br] For SODIMMs
    // [br] At a minimum this has to be set to tCKSRX which is 10ns.
    // [br] 1: DDR3 1600/DDR4 1600/ DDR3 1867/DDR4 1867/DDR42400/DDR4 2667
    // [br] JEDEC defines tCKSRX = 10ns.
    // [br] For RDIMMs (DDR4 only) this register has to be set to tSTAB which is 5 micro-seconds
    // [br] FAH: DDR4 1600
    // [br] 124 H: DDR4 1867
    // [br] 14EH: DDR4 2400
    // [br] 1A1H : DDR4 2667
    // 
    // Bits[22:11], RW/P, default = 0x0
    //
    UINTX ckedly_pmop1 : 12;
    //
    // Minimum PMOP setting for applying DPMC1.CKEDLY_PMOP1.
    // 
    // Bits[27:23], RW/P, default = 0x1
    //
    UINTX pmop_long : 5;
    //
    // Reserved
    // 
    // Bits[31:28], RSV, default = 0x0
    //
    UINTX rsvd_dpmc1_0 : 4;
  } Bits;
  UINTX Data;
} DPMC1_DUNIT_STRUCT;
#endif // ASM_INC

#define DECCCTRL_DUNIT_REG                                 0x00000180
#ifndef ASM_INC
typedef union {
  struct {
    //
    // ECC Enable: When set, single bit error correction and double bit error detection
    // (SEC/DED ECC) is enabled. The ECC is an 8 bit protection code for every 64 bits
    // of data stored in DRAM. ECC is generated on writes and checked on reads, requiring
    // a 72 bit DDR3 data bus width. 
    // 
    // Bits[0:0], RW/V/P, default = 0x0
    //
    UINTX eccen : 1;
    //
    // Enable Correctable Error Notification: When set, correctable ECC errors are signalled
    // to the Bunit and patrol scrub which indicates that the read data needs to be written
    // back to memory. This causes the DRAM cell with the single bit error to be scrubbed.
    // 
    // Bits[1:1], RW/P, default = 0x0
    //
    UINTX serren : 1;
    //
    // Enable Uncorrectable Error Notification: When set, uncorrectable ECC errors are
    // signalled to the Bunit and patrol scrub. 
    // 
    // Bits[2:2], RW/P, default = 0x0
    //
    UINTX derren : 1;
    //
    // Enable Command Address Parity Error Detection: When set, command address parity
    // errors are detected and signalled to the Bunit. 
    // 
    // Bits[3:3], RW/P, default = 0x0
    //
    UINTX caperren : 1;
    //
    // Data Parity Enable: When set, data path parity is enabled. The write data parity
    // is checked at the point when ECC is generated and read data parity is generated
    // at the point that ECC is checked. 
    // 
    // Bits[4:4], RW/P, default = 0x0
    //
    UINTX dparen : 1;
    //
    // Uncorrectable Error Filter:
    // [br] 000: Normal mode; All 8 byte ECC checks/corrections are performed independently,
    // no anti-aliasing filters are applied. 
    // [br] 011: An uncorrectable error that is detected in any 8 byte ECC check will
    // cause all four parallel 8 byte ECC checks to be treated as uncorrectable errors.
    // In addition, any two or more of the 8 byte ECC checks that result in correctable
    // errors from different x8 devices will cause all four parallel 8 byte ECC checks
    // to be treated as uncorrectable errors. 
    // In addition any two or more of the 8 byte ECC checks that result in correctable
    // errors from different bit lanes will cause all four parallel 8 byte ECC checks
    // to be treated as uncorrectable errors. 
    // [br] All other encodings are undefined.
    // 
    // Bits[7:5], RW/P, default = 0x0
    //
    UINTX uce_filter : 3;
    //
    // ECC Check Bits Override Value: The ECC override code to be used on writes if enabled
    // by ECCOVREN. 
    // 
    // Bits[15:8], RW/P, default = 0x0
    //
    UINTX eccovr : 8;
    //
    // ECC Check Bits Override Enable: 0 - Normal ECC is generated. 1 - ECC override
    // enabled, the value in ECCOVR will be used for the ECC code. 
    // 
    // Bits[16:16], RW/P, default = 0x0
    //
    UINTX eccovren : 1;
    //
    // Enable Generation of ECC Check Bits:
    // [br] 0 - Disable generation of ECC Check Bits
    // [br] ECC for Bunit is 0
    // [br] ECC for CPGC is generated by the CPCC
    // [br] 1 - Enable generation of ECC Check Bits
    // [br] ECC is generated for both the Bunit and the CPGC
    // 
    // Bits[17:17], RW/P, default = 0x0
    //
    UINTX encbgen : 1;
    //
    // Reserved
    // 
    // Bits[24:18], RSV, default = 0x0
    //
    UINTX rsvd_deccctrl_0 : 7;
    //
    // Read to Clear C[1:0]SBEACC Registers:
    // [br] 0 = C[1:0]SBEACC Registers are cleared when written
    // [br] 1 = C[1:0]SBEACC Registers are cleared when written or read
    // 
    // Bits[25:25], RW/P, default = 0x0
    //
    UINTX rd2clracc : 1;
    //
    // Reserved
    // 
    // Bits[31:26], RSV, default = 0x0
    //
    UINTX rsvd_deccctrl_1 : 6;
  } Bits;
  UINTX Data;
} DECCCTRL_DUNIT_STRUCT;
#endif // ASM_INC

#define PMSTS_DUNIT_REG                                    0x00000184
#ifndef ASM_INC
typedef union {
  struct {
    //
    // DRAM In Self-Refresh Status:
    // [br] The Dunit sets this bit to a 1 after it has placed the DRAM devices in Self
    // Refresh mode. The Dunit clears this bit when it brings the DRAM devices out of
    // Self Refresh mode. Writing a 1 to this bit will also clear it. This will not clear
    // with system (warm) reset, but will clear when powergood=0 (cold reset). 
    // [br] 0: DRAM not guaranteed to be in Self-Refresh.
    // [br] 1: DRAM in Self-Refresh
    // 
    // Bits[0:0], RW/1C/V/P, default = 0x0
    //
    UINTX disr : 1;
    //
    // Reserved
    // 
    // Bits[7:1], RSV, default = 0x0
    //
    UINTX rsvd_pmsts_0 : 7;
    //
    // Warm Reset Occurred: Punit write a 1 to this bit to indicate to BIOS a warm reset
    // has just occurred. The Punit can also write a 0 to clear it. This is also cleared
    // when powergood = 0. This bit will not clear with warm reset.  This bit is only
    // used by Punit/BIOS; it is not used internally by the Dunit. 
    // 
    // Bits[8:8], RW/P, default = 0x0
    //
    UINTX wro : 1;
    //
    // Reserved
    // 
    // Bits[31:9], RSV, default = 0x0
    //
    UINTX rsvd_pmsts_1 : 23;
  } Bits;
  UINTX Data;
} PMSTS_DUNIT_STRUCT;
#endif // ASM_INC

#define DSTAT_DUNIT_REG                                    0x00000188
#ifndef ASM_INC
typedef union {
  struct {
    //
    // In-Progress RPQ Requests: This is the current number of valid entries in the read
    // pending queue. 
    // 
    // Bits[4:0], RO/V, default = 0x0
    //
    UINTX rpqreq : 5;
    //
    // In-Progress WPQ Requests: This is the current number of valid entries in the write
    // pending queue. 
    // 
    // Bits[10:5], RO/V, default = 0x0
    //
    UINTX wpqreq : 6;
    //
    // Dunit Maintenance FSM State:
    // [br] 01h: MNT_ACT: Active normal operation
    // [br] 02h: MNT_QTE: DDRIO Quiet time request for Rcomp update
    // [br] 03h: MNT_QT: Quiet time granted from Dunit
    // [br] 04h: MNT_SREGO: SR entry go
    // [br] 05h: MNT_SRE0: SR entry step 0 - 1 Dunit clock delay
    // [br] 06h: MNT_SRE1: SR entry step 1 - Place Ranks 1:0 into SR
    // [br] 07h: MNT_SRE2: SR entry step 2 - Place Ranks 3:2 into SR
    // [br] 08h: MNT_PMDL: Issue Power Mode Opcode (PMOP) to DDRIO
    // [br] 09h: MNT_PME: Wait for DDRIO to Ack receiving PMOP
    // [br] 0Ah: MNT_SR: In Self Refresh (SR) mode
    // [br] 0Bh: MNT_PMX: SR exit, Dunit issue PMOP to DDRIO
    // [br] 0Ch: MNT_CKEDLY: CKEDLY delay before going to MNT_SRX
    // [br] 0Dh: MNT_SRX: Wait more cycles before raising the CKE pins
    // [br] 0Eh: MNT_TXS: Wait for tXS delay.
    // [br] 0Fh: MNT_ZQCLPARGO: Parallel ZQCL go during SRX
    // [br] 11h: MNT_ZQCLPAR0: Rank 1:0 ZQCL during SRX
    // [br] 12h: MNT_ZQCLPAR1: Rank 3:2 ZQCL during SRX
    // [br] 13h: MNT_XSDLL: Wait for 2nd half of tXSDLL delay.
    // [br] 14h: MNT_ZQCLSER0: Serial ZQCL during SRX - Rank 0
    // [br] 15h: MNT_ZQCLSER1: Serial ZQCL during SRX - Rank 1
    // [br] 16h: MNT_ZQCLSER2: Serial ZQCL during SRX - Rank 2
    // [br] 17h: MNT_ZQCLSER3: Serial ZQCL during SRX - Rank 3
    // [br] 18h: MNT_ZQCS: Periodic ZQCS
    // 
    // Bits[16:11], RO/V, default = 0xA
    //
    UINTX mntstate : 6;
    //
    // Open Pages: One bit per rank, 0 indicates that all pages are closed and 1 indicates
    // that at least one page is open. 
    // 
    // Bits[20:17], RO/V, default = 0x0
    //
    UINTX openpgs : 4;
    //
    // PMI Status:
    // [br] This field can be polled by MRC to ensure that the PMI state change has completed
    // before proceeding. 
    // [br] 0: Connected to the Bunit.
    // [br] 1: Connected to CPGC.
    // 
    // Bits[21:21], RO/V, default = 0x0
    //
    UINTX pmistat : 1;
    //
    // A refresh debit counter has overflowed since last cold reset
    // 
    // Bits[22:22], RO/V/P, default = 0x0
    //
    UINTX refcnt_overflow : 1;
    //
    // A 9xTREFI counter has overflowed since last cold reset
    // 
    // Bits[23:23], RO/V/P, default = 0x0
    //
    UINTX ninetrefi_overflow : 1;
    //
    // Refresh Debit: The current state of refresh per rank; The bit number corresponds
    // to the rank number. 
    // [br] 0: Caught up or ahead on refresh
    // [br] 1: Behind by at least one refresh
    // 
    // Bits[27:24], RO/V, default = 0x0
    //
    UINTX refdbt : 4;
    //
    // Panic Refresh: The current state of refresh per rank; The bit number corresponds
    // to the rank number. 
    // [br] 0: Below the panic watermark level.
    // [br] 1: At or above the panic watermark level
    // 
    // Bits[31:28], RO/V, default = 0x0
    //
    UINTX refpanic : 4;
  } Bits;
  UINTX Data;
} DSTAT_DUNIT_STRUCT;
#endif // ASM_INC

#define LEAKY_BUCKET_CNTR_UPPER_DUNIT_REG                  0x0000018C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Rank 0 CNTR_UPPER configuration.
    // [br] Total Leak Rate = (CNTR_UPPER_RANK0 + 1)* (LEAKY_BUCKET_CFG0.CNTR_HI + 1)
    // * (LEAKY_BUCKET_CFG0.CNTR_LO + 1) * 8192 DRAM clocks. Setting CNTR_LO to zero
    // will disable the leaky bucket. 
    // 
    // Bits[7:0], RW/P, default = 0x0
    //
    UINTX cntr_upper_rank0 : 8;
    //
    // Rank 1 CNTR_UPPER configuration.
    // [br] Total Leak Rate = (CNTR_UPPER_RANK1 + 1)* (LEAKY_BUCKET_CFG1.CNTR_HI + 1)
    // * (LEAKY_BUCKET_CFG1.CNTR_LO + 1) * 8192 DRAM clocks. Setting CNTR_LO to zero
    // will disable the leaky bucket. 
    // 
    // Bits[15:8], RW/P, default = 0x0
    //
    UINTX cntr_upper_rank1 : 8;
    //
    // Rank 2 CNTR_UPPER configuration.
    // [br] Total Leak Rate = (CNTR_UPPER_RANK2 + 1)* (LEAKY_BUCKET_CFG2.CNTR_HI + 1)
    // * (LEAKY_BUCKET_CFG2.CNTR_LO + 1) * 8192 DRAM clocks. Setting CNTR_LO to zero
    // will disable the leaky bucket. 
    // 
    // Bits[23:16], RW/P, default = 0x0
    //
    UINTX cntr_upper_rank2 : 8;
    //
    // Rank 3 CNTR_UPPER configuration.
    // [br] Total Leak Rate = (CNTR_UPPER_RANK3 + 1)* (LEAKY_BUCKET_CFG3.CNTR_HI + 1)
    // * (LEAKY_BUCKET_CFG3.CNTR_LO + 1) * 8192 DRAM clocks. Setting CNTR_LO to zero
    // will disable the leaky bucket. 
    // 
    // Bits[31:24], RW/P, default = 0x0
    //
    UINTX cntr_upper_rank3 : 8;
  } Bits;
  UINTX Data;
} LEAKY_BUCKET_CNTR_UPPER_DUNIT_STRUCT;
#endif // ASM_INC

#define MISC_CHANNEL_CFG_DUNIT_REG                         0x00000190
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Channel level clock gate disable.  Disables clock gating for this channel.
    // 
    // Bits[0:0], RW/P, default = 0x0
    //
    UINTX channel_clkgtdis : 1;
    //
    // Nine trefi count, zqcs decrement enable.  Enables a zqcs to decrement the nine
    // trefi count. 
    // 
    // Bits[1:1], RW/P, default = 0x0
    //
    UINTX nine_trefi_cnt_zqcs_dec_en : 1;
    //
    // Refresh count, zqcs decrement enable.  Enables a zqcs from decrement the refresh
    // counts. 
    // 
    // Bits[2:2], RW/P, default = 0x0
    //
    UINTX ref_cnt_zqcs_dec_en : 1;
    //
    // Miscellaneous Channel Config Fields
    // 
    // Bits[31:3], RW/P, default = 0x0
    //
    UINTX misc_channel_cfg : 29;
  } Bits;
  UINTX Data;
} MISC_CHANNEL_CFG_DUNIT_STRUCT;
#endif // ASM_INC

#define DPATROL_SCRUB_TMR_DUNIT_REG                        0x00000194
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Patrol scrub interval timer in DCLKs.  A new patrol scrub is scheduled every time
    // the timer ticks to the value in this register.  Any non zero value is valid 
    // 
    // Bits[31:0], RW/P, default = 0xFFFFFFFF
    //
    UINTX patscrtimer : 32;
  } Bits;
  UINTX Data;
} DPATROL_SCRUB_TMR_DUNIT_STRUCT;
#endif // ASM_INC

#define DPATROL_SCRUB_UPD2_DUNIT_REG                       0x00000198
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Override the current patrol scrub debit count value.
    // 
    // Bits[16:0], RW/V/P, default = 0x0
    //
    UINTX debit_counter : 17;
    //
    // Reserved
    // 
    // Bits[31:17], RSV, default = 0x0
    //
    UINTX rsvd_dpatrol_scrub_upd2_0 : 15;
  } Bits;
  UINTX Data;
} DPATROL_SCRUB_UPD2_DUNIT_STRUCT;
#endif // ASM_INC

#define DTR7_DUNIT_REG                                     0x0000019C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write to Write DQ delay, different ranks, same DIMM
    // [br] Specifies the number of DRAM clocks (CK) from the start of a Write data burst
    // of one rank to the Start of a Write data burst of a different rank within the
    // same DIMM. 
    // [br] The number specified is (BL/2) + adddional delay
    // [br] Note that this is also the write to write command delay.
    // [br] The legal encodings are:
    // [br] 2h:   6 CK
    // [br] 3h:   7 CK
    // [br] 4h:   8 CK
    // [br] 5h:   9 CK
    // [br] 6h:  10 CK
    // [br] 7h:  11 CK
    // [br] 8h:  12 CK
    // [br] 9h:  13 CK
    // [br] All other encodings are reserved.
    // 
    // Bits[3:0], RW/P, default = 0x0
    //
    UINTX twwdr : 4;
    //
    // Write to Write DQ delay, different DIMMs:
    // [br] Specifies the number of DRAM clocks (CK) from the start of a Write data burst
    // of one DIMM to the Start of a Write data burst of a different DIMM. 
    // [br] The number specified is (BL/2) + adddional delay
    // [br] Note that this is also the write to write command delay.
    // [br] The legal encodings are:
    // [br] 2h:   6 CK
    // [br] 3h:   7 CK
    // [br] 4h:   8 CK
    // [br] 5h:   9 CK
    // [br] 6h:  10 CK
    // [br] 7h:  11 CK
    // [br] 8h:  12 CK
    // [br] 9h:  13 CK
    // [br] All other encodings are reserved.
    // 
    // Bits[7:4], RW/P, default = 0x0
    //
    UINTX twwdd : 4;
    //
    // Write to Read DQ delay, different ranks, same DIMM:
    // [br] Specifies the number of DRAM clocks (CK) from the start of a Write data burst
    // of one rank to the Start of a Read data burst of a different rank within the same
    // DIMM. 
    // [br] The number specified is (BL/2) + adddional delay.  The hardware will NOT
    // automatically subtract (tCL - tWCL). 
    // [br] Note that this is also the write to read command delay when CL=WCL.
    // [br] The legal encodings are:
    // [br] 0h:   6 CK
    // [br] 1h:   7 CK
    // [br] 2h:   8 CK
    // [br] 3h:   9 CK
    // [br] 4h:  10 CK
    // [br] 5h:  11 CK
    // [br] 6h:  12 CK
    // [br] 7h:  13 CK
    // [br] All other encodings are reserved.
    // 
    // Bits[11:8], RW/P, default = 0x0
    //
    UINTX twrdr : 4;
    //
    // Write to Read DQ delay, different DIMMs:
    // [br] Specifies the number of DRAM clocks (CK) from the start of a Write data burst
    // of one DIMM to the Start of a Read data burst of a different DIMM. 
    // [br] The number specified is (BL/2) + adddional delay.  The hardware will NOT
    // automatically subtract (tCL - tWCL). 
    // [br] Note that this is also the write to read command delay when CL=WCL.
    // [br] The legal encodings are:
    // [br] 0h:   6 CK
    // [br] 1h:   7 CK
    // [br] 2h:   8 CK
    // [br] 3h:   9 CK
    // [br] 4h:  10 CK
    // [br] 5h:  11 CK
    // [br] 6h:  12 CK
    // [br] 7h:  13 CK
    // [br] All other encodings are reserved.
    // 
    // Bits[15:12], RW/P, default = 0x0
    //
    UINTX twrdd : 4;
    //
    // Internal Write to Read Delay Short
    // [br] DDR3: The number of DRAM clocks (CK) from the start of the DRAM internal
    // write transaction to the internal read command for the same rank. 
    // [br] 	tWTR = max ( 4nCK, 7.5ns)
    // [br] DDR4: The number of DRAM clocks (CK) from the start of the DRAM internal
    // write transaction to the internal read command for the same rank but different
    // bank group. 
    // [br] 	tWTR_s = max ( 2nCK, 2.5ns)
    // [br] The number specified is the additional delay.  The hardware will automatically
    // add (BL/2 + tWCL) to the value specified.. 
    // [br] The legal encodings are:
    // [br] 0h:  2 CK DDR4-1600
    // [br] 1h:  3 CK DDR4-1866, 2133, 2400
    // [br] 2h:  4 CK DDR4-2667
    // [br] 3h:  5
    // [br] 4h:  6 CK DDR3-1600
    // [br] 5h:  7 CK DDR3-1866
    // [br] All other encodings are reserved.
    // 
    // Bits[19:16], RW/P, default = 0x0
    //
    UINTX twtr_s : 4;
    //
    // Internal Write to Read Delay Long
    // [br] DDR3: Not used.
    // [br] DDR4: The number of DRAM clocks (CK) from the start of the DRAM internal
    // write transaction to the internal read command for the same rank and bank group.
    // [br] 	tWTR_L = max ( 4nCK, 7.5ns)
    // [br] The number specified is the additional delay.  The hardware will automatically
    // add (BL/2 + tWCL) to the value specified.. 
    // [br] The legal encodings are:
    // [br] 0h:   6 CK	DDR4-1600
    // [br] 1h:   7 CK	DDR4-1866
    // [br] 2h:   8 CK	DDR4-2133
    // [br] 3h:   9 CK	DDR4-2400
    // [br] 4h:  10 CK	DDR4-2667
    // [br] 5h:  11 CK
    // [br] 6h:  12 CK
    // [br] All other encodings are reserved.
    // 
    // Bits[24:20], RW/P, default = 0x0
    //
    UINTX twtr_l : 5;
    //
    // Write Data Early.  If set, the dunit sends write data 1 dram command clock earlier
    // than the tWCL value. 
    // 
    // Bits[25:25], RW/P, default = 0x0
    //
    UINTX wrdata_early : 1;
    //
    // Reserved
    // 
    // Bits[31:26], RSV, default = 0x0
    //
    UINTX rsvd_dtr7_0 : 6;
  } Bits;
  UINTX Data;
} DTR7_DUNIT_STRUCT;
#endif // ASM_INC


#endif // _DUNIT_H_
