/** @file
  File name:    CPGC.h
  Input File:   DNV_MRC.xlsx

  THIS FILE IS AUTO-GENERATED BY THE MSP TOOL. DO NOT CHANGE THIS CODE.

  If edits are needed in this file, they must be done via the MSP tool.

  If there is additional project-specific data required by the MSP, it
  can be placed in CPGC.h, which is used for non-tool-generated
  data

  Includes register defines specific to a project.

  Copyright (c) 2005-2018 Intel Corporation. All rights reserved
  This software and associated documentation (if any) is furnished
  under a license and may only be used or copied in accordance
  with the terms of the license. Except as permitted by such
  license, no part of this software or documentation may be
  reproduced, stored in a retrieval system, or transmitted in any
  form or by any means without the express written consent of
  Intel Corporation.
**/
#ifndef _CPGC_H_
#define _CPGC_H_

#include "DataTypes.h"

#if USE_64_BIT_VARIABLES
#define UINTX UINT64
#else
#define UINTX UINT32
#endif

#define CPGC_DPAT_EXTBUF0_REG_CPGC_REG                     0x00000200
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Ext Buffer General Register
    // 
    // Bits[31:0], AA, default = 0x0
    //
    UINTX data : 32;
  } Bits;
  UINTX Data;
} CPGC_DPAT_EXTBUF0_REG_CPGC_STRUCT;
#endif // ASM_INC

#define CPGC_DPAT_EXTBUF1_REG_CPGC_REG                     0x00000204
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Ext Buffer General Register
    // 
    // Bits[31:0], AA, default = 0x0
    //
    UINTX data : 32;
  } Bits;
  UINTX Data;
} CPGC_DPAT_EXTBUF1_REG_CPGC_STRUCT;
#endif // ASM_INC

#define CPGC_DPAT_EXTBUF2_REG_CPGC_REG                     0x00000208
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Ext Buffer General Register
    // 
    // Bits[31:0], AA, default = 0x0
    //
    UINTX data : 32;
  } Bits;
  UINTX Data;
} CPGC_DPAT_EXTBUF2_REG_CPGC_STRUCT;
#endif // ASM_INC

#define CPGC_DPAT_EXTBUF3_REG_CPGC_REG                     0x0000020C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Ext Buffer General Register
    // 
    // Bits[31:0], AA, default = 0x0
    //
    UINTX data : 32;
  } Bits;
  UINTX Data;
} CPGC_DPAT_EXTBUF3_REG_CPGC_STRUCT;
#endif // ASM_INC

#define CPGC_DPAT_EXTBUF4_REG_CPGC_REG                     0x00000210
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Ext Buffer General Register
    // 
    // Bits[31:0], AA, default = 0x0
    //
    UINTX data : 32;
  } Bits;
  UINTX Data;
} CPGC_DPAT_EXTBUF4_REG_CPGC_STRUCT;
#endif // ASM_INC

#define CPGC_DPAT_EXTBUF5_REG_CPGC_REG                     0x00000214
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Ext Buffer General Register
    // 
    // Bits[31:0], AA, default = 0x0
    //
    UINTX data : 32;
  } Bits;
  UINTX Data;
} CPGC_DPAT_EXTBUF5_REG_CPGC_STRUCT;
#endif // ASM_INC

#define CPGC_DPAT_EXTBUF6_REG_CPGC_REG                     0x00000218
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Ext Buffer General Register
    // 
    // Bits[31:0], AA, default = 0x0
    //
    UINTX data : 32;
  } Bits;
  UINTX Data;
} CPGC_DPAT_EXTBUF6_REG_CPGC_STRUCT;
#endif // ASM_INC

#define CPGC_DPAT_EXTBUF7_REG_CPGC_REG                     0x0000021C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Ext Buffer General Register
    // 
    // Bits[31:0], AA, default = 0x0
    //
    UINTX data : 32;
  } Bits;
  UINTX Data;
} CPGC_DPAT_EXTBUF7_REG_CPGC_STRUCT;
#endif // ASM_INC

#define CPGC_DPAT_EXTBUF8_REG_CPGC_REG                     0x00000220
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Ext Buffer General Register
    // 
    // Bits[31:0], AA, default = 0x0
    //
    UINTX data : 32;
  } Bits;
  UINTX Data;
} CPGC_DPAT_EXTBUF8_REG_CPGC_STRUCT;
#endif // ASM_INC

#define CPGC_DPAT_EXTBUF9_REG_CPGC_REG                     0x00000224
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Ext Buffer General Register
    // 
    // Bits[31:0], AA, default = 0x0
    //
    UINTX data : 32;
  } Bits;
  UINTX Data;
} CPGC_DPAT_EXTBUF9_REG_CPGC_STRUCT;
#endif // ASM_INC

#define CPGC_DPAT_EXTBUF10_REG_CPGC_REG                    0x00000228
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Ext Buffer General Register
    // 
    // Bits[31:0], AA, default = 0x0
    //
    UINTX data : 32;
  } Bits;
  UINTX Data;
} CPGC_DPAT_EXTBUF10_REG_CPGC_STRUCT;
#endif // ASM_INC

#define CPGC_DPAT_EXTBUF11_REG_CPGC_REG                    0x0000022C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Ext Buffer General Register
    // 
    // Bits[31:0], AA, default = 0x0
    //
    UINTX data : 32;
  } Bits;
  UINTX Data;
} CPGC_DPAT_EXTBUF11_REG_CPGC_STRUCT;
#endif // ASM_INC

#define CPGC_DPAT_EXTBUF12_REG_CPGC_REG                    0x00000230
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Ext Buffer General Register
    // 
    // Bits[31:0], AA, default = 0x0
    //
    UINTX data : 32;
  } Bits;
  UINTX Data;
} CPGC_DPAT_EXTBUF12_REG_CPGC_STRUCT;
#endif // ASM_INC

#define CPGC_DPAT_EXTBUF13_REG_CPGC_REG                    0x00000234
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Ext Buffer General Register
    // 
    // Bits[31:0], AA, default = 0x0
    //
    UINTX data : 32;
  } Bits;
  UINTX Data;
} CPGC_DPAT_EXTBUF13_REG_CPGC_STRUCT;
#endif // ASM_INC

#define CPGC_DPAT_EXTBUF14_REG_CPGC_REG                    0x00000238
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Ext Buffer General Register
    // 
    // Bits[31:0], AA, default = 0x0
    //
    UINTX data : 32;
  } Bits;
  UINTX Data;
} CPGC_DPAT_EXTBUF14_REG_CPGC_STRUCT;
#endif // ASM_INC

#define CPGC_DPAT_EXTBUF15_REG_CPGC_REG                    0x0000023C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Ext Buffer General Register
    // 
    // Bits[31:0], AA, default = 0x0
    //
    UINTX data : 32;
  } Bits;
  UINTX Data;
} CPGC_DPAT_EXTBUF15_REG_CPGC_STRUCT;
#endif // ASM_INC

#define CPGC_DPAT_EXTBUF0B_REG_CPGC_REG                    0x00000240
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Ext Buffer General Register
    // 
    // Bits[31:0], AA, default = 0x0
    //
    UINTX data : 32;
  } Bits;
  UINTX Data;
} CPGC_DPAT_EXTBUF0B_REG_CPGC_STRUCT;
#endif // ASM_INC

#define CPGC_DPAT_EXTBUF1B_REG_CPGC_REG                    0x00000244
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Ext Buffer General Register
    // 
    // Bits[31:0], AA, default = 0x0
    //
    UINTX data : 32;
  } Bits;
  UINTX Data;
} CPGC_DPAT_EXTBUF1B_REG_CPGC_STRUCT;
#endif // ASM_INC

#define CPGC_DPAT_EXTBUF2B_REG_CPGC_REG                    0x00000248
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Ext Buffer General Register
    // 
    // Bits[31:0], AA, default = 0x0
    //
    UINTX data : 32;
  } Bits;
  UINTX Data;
} CPGC_DPAT_EXTBUF2B_REG_CPGC_STRUCT;
#endif // ASM_INC

#define CPGC_DPAT_EXTBUF3B_REG_CPGC_REG                    0x0000024C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Ext Buffer General Register
    // 
    // Bits[31:0], AA, default = 0x0
    //
    UINTX data : 32;
  } Bits;
  UINTX Data;
} CPGC_DPAT_EXTBUF3B_REG_CPGC_STRUCT;
#endif // ASM_INC

#define CPGC_DPAT_EXTBUF4B_REG_CPGC_REG                    0x00000250
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Ext Buffer General Register
    // 
    // Bits[31:0], AA, default = 0x0
    //
    UINTX data : 32;
  } Bits;
  UINTX Data;
} CPGC_DPAT_EXTBUF4B_REG_CPGC_STRUCT;
#endif // ASM_INC

#define CPGC_DPAT_EXTBUF5B_REG_CPGC_REG                    0x00000254
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Ext Buffer General Register
    // 
    // Bits[31:0], AA, default = 0x0
    //
    UINTX data : 32;
  } Bits;
  UINTX Data;
} CPGC_DPAT_EXTBUF5B_REG_CPGC_STRUCT;
#endif // ASM_INC

#define CPGC_DPAT_EXTBUF6B_REG_CPGC_REG                    0x00000258
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Ext Buffer General Register
    // 
    // Bits[31:0], AA, default = 0x0
    //
    UINTX data : 32;
  } Bits;
  UINTX Data;
} CPGC_DPAT_EXTBUF6B_REG_CPGC_STRUCT;
#endif // ASM_INC

#define CPGC_DPAT_EXTBUF7B_REG_CPGC_REG                    0x0000025C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Ext Buffer General Register
    // 
    // Bits[31:0], AA, default = 0x0
    //
    UINTX data : 32;
  } Bits;
  UINTX Data;
} CPGC_DPAT_EXTBUF7B_REG_CPGC_STRUCT;
#endif // ASM_INC

#define CPGC_DPAT_EXTBUF8B_REG_CPGC_REG                    0x00000260
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Ext Buffer General Register
    // 
    // Bits[31:0], AA, default = 0x0
    //
    UINTX data : 32;
  } Bits;
  UINTX Data;
} CPGC_DPAT_EXTBUF8B_REG_CPGC_STRUCT;
#endif // ASM_INC

#define CPGC_DPAT_EXTBUF9B_REG_CPGC_REG                    0x00000264
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Ext Buffer General Register
    // 
    // Bits[31:0], AA, default = 0x0
    //
    UINTX data : 32;
  } Bits;
  UINTX Data;
} CPGC_DPAT_EXTBUF9B_REG_CPGC_STRUCT;
#endif // ASM_INC

#define CPGC_DPAT_EXTBUF10B_REG_CPGC_REG                   0x00000268
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Ext Buffer General Register
    // 
    // Bits[31:0], AA, default = 0x0
    //
    UINTX data : 32;
  } Bits;
  UINTX Data;
} CPGC_DPAT_EXTBUF10B_REG_CPGC_STRUCT;
#endif // ASM_INC

#define CPGC_DPAT_EXTBUF11B_REG_CPGC_REG                   0x0000026C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Ext Buffer General Register
    // 
    // Bits[31:0], AA, default = 0x0
    //
    UINTX data : 32;
  } Bits;
  UINTX Data;
} CPGC_DPAT_EXTBUF11B_REG_CPGC_STRUCT;
#endif // ASM_INC

#define CPGC_DPAT_EXTBUF12B_REG_CPGC_REG                   0x00000270
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Ext Buffer General Register
    // 
    // Bits[31:0], AA, default = 0x0
    //
    UINTX data : 32;
  } Bits;
  UINTX Data;
} CPGC_DPAT_EXTBUF12B_REG_CPGC_STRUCT;
#endif // ASM_INC

#define CPGC_DPAT_EXTBUF13B_REG_CPGC_REG                   0x00000274
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Ext Buffer General Register
    // 
    // Bits[31:0], AA, default = 0x0
    //
    UINTX data : 32;
  } Bits;
  UINTX Data;
} CPGC_DPAT_EXTBUF13B_REG_CPGC_STRUCT;
#endif // ASM_INC

#define CPGC_DPAT_EXTBUF14B_REG_CPGC_REG                   0x00000278
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Ext Buffer General Register
    // 
    // Bits[31:0], AA, default = 0x0
    //
    UINTX data : 32;
  } Bits;
  UINTX Data;
} CPGC_DPAT_EXTBUF14B_REG_CPGC_STRUCT;
#endif // ASM_INC

#define CPGC_DPAT_EXTBUF15B_REG_CPGC_REG                   0x0000027C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Ext Buffer General Register
    // 
    // Bits[31:0], AA, default = 0x0
    //
    UINTX data : 32;
  } Bits;
  UINTX Data;
} CPGC_DPAT_EXTBUF15B_REG_CPGC_STRUCT;
#endif // ASM_INC

#define CPGC_SUBSEQ0_VAR_REG_CPGC_REG                      0x00000088
#ifndef ASM_INC
typedef union {
  struct {
    //
    // If the subsequence is running in the Infinite Burst Addressing mode, this field
    // defines the starting address for the subsequence.  This address is used along
    // with the WRAP_ADDR to control the test execution.  Note:  The  
    // 
    // Bits[31:0], RW, default = 0x0
    //
    UINTX start_addr : 32;
  } Bits;
  UINTX Data;
} CPGC_SUBSEQ0_VAR_REG_CPGC_STRUCT;
#endif // ASM_INC

#define CPGC_SUBSEQ0_FIX_REG_CPGC_REG                      0x0000008C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // If the subsequence is running in the Infinite Burst Addressing mode, WRAP_ADDR
    // - 1 defines the top value for the channel address.  Once hit, a wrap trigger is
    // issued and used with COMP_ON_WRAP and/or  
    // 
    // Bits[31:0], RW, default = 0x0
    //
    UINTX wrap_addr : 32;
  } Bits;
  UINTX Data;
} CPGC_SUBSEQ0_FIX_REG_CPGC_STRUCT;
#endif // ASM_INC

#define CPGC_SUBSEQ1_VAR_REG_CPGC_REG                      0x00000098
#ifndef ASM_INC
typedef union {
  struct {
    //
    // If the subsequence is running in the Infinite Burst Addressing mode, this field
    // defines the starting address for the subsequence.  This address is used along
    // with the WRAP_ADDR to control the test execution.  Note:  The  
    // 
    // Bits[31:0], RW, default = 0x0
    //
    UINTX start_addr : 32;
  } Bits;
  UINTX Data;
} CPGC_SUBSEQ1_VAR_REG_CPGC_STRUCT;
#endif // ASM_INC

#define CPGC_SUBSEQ1_FIX_REG_CPGC_REG                      0x0000009C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // If the subsequence is running in the Infinite Burst Addressing mode, WRAP_ADDR
    // - 1 defines the top value for the channel address.  Once hit, a wrap trigger is
    // issued and used with COMP_ON_WRAP and/or  
    // 
    // Bits[31:0], RW, default = 0x0
    //
    UINTX wrap_addr : 32;
  } Bits;
  UINTX Data;
} CPGC_SUBSEQ1_FIX_REG_CPGC_STRUCT;
#endif // ASM_INC

#define CPGC_ERR_STAT_LO_MISC_CPGC_REG                     0x00000298
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Lane 31_0
    // 
    // Bits[31:0], RW, default = 0x0
    //
    UINTX lane_err_status_lo : 32;
  } Bits;
  UINTX Data;
} CPGC_ERR_STAT_LO_MISC_CPGC_STRUCT;
#endif // ASM_INC

#define CPGC_ERR_STAT_HI_MISC_CPGC_REG                     0x0000029C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Lane 63_32
    // 
    // Bits[31:0], RW, default = 0x0
    //
    UINTX lane_err_status_hi : 32;
  } Bits;
  UINTX Data;
} CPGC_ERR_STAT_HI_MISC_CPGC_STRUCT;
#endif // ASM_INC

#define CPGC_SEQ_CAP_CPGC_REG                              0x00000040
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[3:0], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 4;
    //
    // Set if functional command/address pattern generation mode (also known as normal
    // mode) is supported. 
    // 
    // Bits[4:4], RO, default = 0x1
    //
    UINTX norm_mode_cap : 1;
    //
    // Set if direct data mode for compliance master, compliance slave, and loopback,
    // data functionality is supported. 
    // 
    // Bits[5:5], RO, default = 0x1
    //
    UINTX dir_mode_cap : 1;
    //
    // Set if MRS mode functionality is supported.
    // 
    // Bits[6:6], RO, default = 0x0
    //
    UINTX mrs_mode_cap : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:7], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 1;
    //
    // This field indicates the width of the fixed address generation segment (and hence
    // the channel address width).   
    // 
    // Bits[13:8], RO, default = 0x20
    //
    UINTX fix_addr_width_cap : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[15:14], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 2;
    //
    // Set if DRAM refresh blocking is supported.
    // 
    // Bits[16:16], RO, default = 0x1
    //
    UINTX ref_blk_cap : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[17:17], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_3 : 1;
    //
    // This bit indicates if phase synchronization for a multi-channel/multi-engine implementation
    // is supported through the START_DELAY, GLOBAL_START_BIND, and GBL_STOP_BIND capabilities.
    //    
    // 
    // Bits[18:18], RO, default = 0x1
    //
    UINTX mult_eng_syn_cap : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:19], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_4 : 13;
  } Bits;
  UINTX Data;
} CPGC_SEQ_CAP_CPGC_STRUCT;
#endif // ASM_INC

#define CPGC_SEQ_CTL_CPGC_REG                              0x00000044
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Used to initiate a transition to active mode on this engine/channel (note that
    // INITIALIZATION_MODE has to be programmed first).  This bit will always return
    // '0' if read by software. Note that this will also cause a test start for all engines
    // with GLOBAL_START_BIND set. 
    // 
    // Bits[0:0], WO, default = 0x0
    //
    UINTX start_test : 1;
    //
    // Forces an exit from the tests running on this engine/channel.  This bit will always
    // return '0' if read by software. Note that this will also cause a test stop for
    // all engines with GLOBAL_STOP_BIND set. 
    // 
    // Bits[1:1], WO, default = 0x0
    //
    UINTX stop_test : 1;
    //
    // Setting this bit will immediately clear all error registers and error status.
    // 
    // Bits[2:2], WO, default = 0x0
    //
    UINTX clear_err : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:3], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 29;
  } Bits;
  UINTX Data;
} CPGC_SEQ_CTL_CPGC_STRUCT;
#endif // ASM_INC

#define CPGC_SEQ_CFG_A_CPGC_REG                            0x00000048
#ifndef ASM_INC
typedef union {
  struct {
    //
    // If this bit is set then the VAR/FIX CPGC-S addressing approach is used.  If this
    // bit is zero then CPGC Mainstream addressing scheme is used. 
    // 
    // Bits[0:0], RO, default = 0x1
    //
    UINTX addr_bkw_comp : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[2:1], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
    //
    // If any wrap trigger occurs and this bit is set, then a stop condition will be
    // generated immediately forcing the test to stop. 
    // 
    // Bits[3:3], RW/P, default = 0x0
    //
    UINTX stop_on_wrap : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[9:4], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 6;
    //
    // Setting this bit will Bind this channel engine to all other channel engines with
    // this bit set. A test start for any channel with GLOBAL_START_BIND set will cause
    // the same action to occur on all engines with GLOBAL_START_BIND set. This feature
    // is usually used when synchronization between multiple engines/channels necessitates
    // a global control of all supported engines.[br] Note: this field is only available
    // if multiple channels/engines are supported for the current implementation, otherwise
    // it is reserved. 
    // 
    // Bits[10:10], RW, default = 0x0
    //
    UINTX global_start_bind : 1;
    //
    // Setting this bit will bind this channel engine to all other channel engines with
    // this bit set.  A test stop (both forced and due to a stop condition) for any channel
    // engine with GLOBAL_STOP_BIND set will cause the same action to occur on all engines
    // with GLOBAL_STOP_BIND set.  This feature is usually used when synchronization
    // between multiple engines/channels necessitates a global control of all supported
    // engines.[br] Note: this field is only available if multiple channels/engines are
    // supported for the current implementation, otherwise it is reserved.  
    // 
    // Bits[11:11], RW, default = 0x0
    //
    UINTX global_stop_bind : 1;
    //
    // 000 - IDLE MODE[br]
    // 001 - ACTIVE MODE[br]
    // 010 - NORMAL MODE[br]
    // 011 - DIRECT MODE[br]
    // 100 - MRS MODE[br]
    // 101 - ERR DUMP MODE[br]
    // 110 - WDB FILL MODE[br]
    // 111 - REWIND MODE
    // 
    // Bits[14:12], RW, default = 0x0
    //
    UINTX initialization_mode : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[15:15], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 1;
    //
    // Sets the number of the command sequence loops to issue to 2^(LOOP_CNT- 1) before
    // a test exits normally (if no other stop condition has been detected).  A sequence
    // loop is defined as the completion of all subsequences between SUBSEQ_START_POINTER
    // to SUBSEQ_END_POINTER.  A value of 0 will force an infinite loop mode.  In this
    // case, only some stop condition can end the test or by the user directly asserting
    // the STOP_TEST bit. 
    // 
    // Bits[20:16], RW/P, default = 0x6
    //
    UINTX loopcount : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:21], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_3 : 3;
    //
    // Pointer to first subsequence in a command sequence loop.  A full command sequence
    // loop will start with the sequence pointed to by SUBSEQ_START_POINTER and end at
    // the sequence pointed to by SUBSEQ_END_POINTER before wrapping back to the Subseq_START_POINTER.
    // 
    // Bits[26:24], RW/P, default = 0x0
    //
    UINTX subsequence_start_pointer : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[27:27], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_4 : 1;
    //
    // Pointer to last subsequence in a command sequence loop.  A full command sequence
    // loop will start with the subsequence pointed to by SUBSEQUENCE_START_POINTER and
    // end at the subsequence pointed to by SUBSEQUENCE_END_POINTER before wrapping back
    // to the Subseq_START_POINTER. 
    // 
    // Bits[30:28], RW/P, default = 0x0
    //
    UINTX subsequence_end_pointer : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:31], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_5 : 1;
  } Bits;
  UINTX Data;
} CPGC_SEQ_CFG_A_CPGC_STRUCT;
#endif // ASM_INC

#define CPGC_SEQ_CFG_B_CPGC_REG                            0x0000004C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Number of clock cycles (in CPGC-S clock domain) the start of the test is delayed
    // by after START_TEST has been asserted by the user. This is usually used to synchronize
    // multiple SoC CPGC engines on multiple channels according to a defined phase relationship.
    // 
    // Bits[9:0], RW/P, default = 0x0
    //
    UINTX start_delay : 10;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:10], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 22;
  } Bits;
  UINTX Data;
} CPGC_SEQ_CFG_B_CPGC_STRUCT;
#endif // ASM_INC

#define CPGC_SEQ_STATUS_CPGC_REG                           0x00000050
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Indicates the current subsequence being executed within the CPGC sequence.
    // 
    // Bits[2:0], RO/V, default = 0x0
    //
    UINTX current_subsequence_pointer : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[29:3], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 27;
    //
    // This bit will be set when once a test has started.  Bit is cleared on a reset
    // or once test is done (or has been forced to exit due a stop condition). 
    // 
    // Bits[30:30], RO/V, default = 0x0
    //
    UINTX test_busy : 1;
    //
    // This bit will be set when the test is complete (or has been forced to exit due
    // to a stop condition). But is cleared on a reset or when user starts another test.
    // 
    // Bits[31:31], RO/V, default = 0x0
    //
    UINTX test_done : 1;
  } Bits;
  UINTX Data;
} CPGC_SEQ_STATUS_CPGC_STRUCT;
#endif // ASM_INC

#define CPGC_SEQ_LOOPCOUNT_STATUS_CPGC_REG                 0x00000054
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Current number of command sequence loops that have been executed.
    // 
    // Bits[15:0], RO/V, default = 0x0
    //
    UINTX current_loopcount : 16;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:16], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 16;
  } Bits;
  UINTX Data;
} CPGC_SEQ_LOOPCOUNT_STATUS_CPGC_STRUCT;
#endif // ASM_INC

#define CPGC_SEQ_BURSTCOUNT_STATUS_CPGC_REG                0x00000058
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Number of bursts (CAS commands) that have been executed completely for the current
    // subsequence pointed to by CURRENT_SUBSEQUENCE_POINTER. [br] Note: This register
    // resets each time a new SubSequence is being executed. 
    // 
    // Bits[31:0], RO/V, default = 0x0
    //
    UINTX current_burst_count : 32;
  } Bits;
  UINTX Data;
} CPGC_SEQ_BURSTCOUNT_STATUS_CPGC_STRUCT;
#endif // ASM_INC

#define CPGC_SUBSEQ0_CTL_A_CPGC_REG                        0x00000080
#ifndef ASM_INC
typedef union {
  struct {
    //
    // If NUMBER_OF_BURSTS_SCALE == 0[br] Number of bursts (CAS commands) composing the
    // subsequence is equal to 2^(NUMBER_OF_BURSTS). Only bits [3:0] are supported if
    // set as an exponential counter.[br][br] If NUMBER_OF_BURSTS_SCALE == 1[br] Number
    // of bursts (CAS commands) composing the subsequence is equal to NUMBER_OF_BURSTS.
    // All bits are supported. Setting NUMBER_OF_BURSTS_SCALE to 1 and NUMBER_OF_BURSTS
    // to 0 will result in an infinite number of bursts being issued.[br][br] If CPGC_SEQ_CFG.ADDR_BKWRD_COMP
    // is set 1 then:[br] A value of 0 stands for infinite number of bursts and enables
    // the Infinite Burst Addressing mode[br] Note: Only bits [3:0] are supported if
    // set as an exponential counter. If set as a linear counter and NUMBER_OF_BURSTS
    // == 0, then the SubSequence will issue an infinite number of transactions. 
    // 
    // Bits[6:0], RW/P, default = 0x0
    //
    UINTX number_of_bursts : 7;
    //
    // If set to 0 then NUMBER_OF_BURSTS operates as an exponential counter.[br] If set
    // to 1 then NUMBER_OF_BURSTS operates as a linear counter.. 
    // 
    // Bits[7:7], RW/P, default = 0x0
    //
    UINTX number_of_bursts_scale : 1;
    //
    // Number of clock cycles (in CPGC-S clock domain) between finishing a SubSequence
    // and the beginning of the next Subsequence is defined by SUBSEQUENCE_WAIT.  The
    // wait period is considered independent from the Subsequence itself and hence refresh
    // commands can be Enabled/Disabled for the wait period independent of the preceding
    // Subsequence. 
    // 
    // Bits[21:8], RW/P, default = 0x0
    //
    UINTX subsequence_wait : 14;
    //
    // This field defines the type of commands this sequence will issue:[br]
    // 0000 - Read Commands[br]
    // 0001 - Write Commands[br]
    // 0010 - Read Commands -> Write Commands[br]
    // 0011 - Write Commands -> Read Commands[br]
    // 0100 - Offset Read[br]
    // 0101 - Offset Write[br]
    // 1000 - Read Commands (Self Refresh Exit)[br]
    // 1001 - Write Commands (Self Refresh Exit)[br]
    // 1010 - Read Commands -> Write Commands (Self Refresh Exit)[br]
    // 1011 - Write Commands -> Read Commands (Self Refresh Exit)[br]
    // All other values are reserved for future use.[br]
    // [br]
    // The address that is going to be used at any new command request is the address
    // in CPGC_SEQ_BASE_ADDR_CURRENT. 
    // 
    // Bits[25:22], RW/P, default = 0x0
    //
    UINTX subsequence_type : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[26:26], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 1;
    //
    // If CPGC_SEQ_CFG.ADDR_BKWRD_COMP is set then:[br] This bit will force the subsequence
    // to reload its initial address from each time before it starts. This bit is not
    // applicable to Infinite Burst Addressing mode.[br][br] If CPGC_SEQ_CFG.ADDR_BKWRD_COMP
    // is set to 0 then:[br] Upon entry to a subsequence where RESET_CURRENT_BASE_ADDRESS_TO_START
    // is set:[br] 
    // 1) Base Current Address (CPGC_SEQ_BASE_ADDR_CURRENT) gets immediately re initialized
    // to the Base Starting Address (CPGC_SEQ_BASE_ADDR_START).[br] 
    // 2) Reset the:[br]
    // Rank_Base_Address_Update_Rate,[br]
    // Bank_Base_Address_Update_Rate,[br]
    // Row_Base_Address_Update_Rate, and[br]
    // Column_Base_Address_Update_Rate(CPGC_SEQ_BASE_ADDR_INC_CTL)[br][br]
    // 3) Reset the Base_Address_Invert_Rate(CPGC_SEQ_BASE_ADDR_ORDER_CARRY_INVERT_CTL)[br][br]
    // In the case where both SAVE_ADDR = 1 and RESET_CURRENT_BASE_ADDRESS_TO_START =
    // 1 then only SAVE_ADDR = 1 will take effect and RESET_CURRENT_BASE_ADDRESS_TO_START
    // =1 will be ignored.[br][br] 
    // Use case: long WR subseq and then long RD subseq: RD should set this field on,
    // WR should set the next one (Save_Current_Base_Address_To_Start) on. 
    // 
    // Bits[27:27], RW/P, default = 0x0
    //
    UINTX reset_current_base_address_to_start : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[30:28], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 3;
    //
    // If the Subsequence is running in the infinite burst mode, setting this bit will
    // cause a transition from this SubSequence to the next SubSequence (after the wait
    // period) once the channel address hits the wrap address defined by WRAP_ADDR -
    // 1. This bit is not used for finite burst addressing mode. 
    // 
    // Bits[31:31], RW/P, default = 0x0
    //
    UINTX stop_subsequence_on_base_wrap_trigger : 1;
  } Bits;
  UINTX Data;
} CPGC_SUBSEQ0_CTL_A_CPGC_STRUCT;
#endif // ASM_INC

#define CPGC_SUBSEQ0_CTL_B_CPGC_REG                        0x00000084
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Size of requests CPGC is issuing, 64B and 32B transactions and is encoded as follows:[br]
    // 0 - 32 Byte Transactions[br]
    // 1 - 64 Byte Transactions
    // 
    // Bits[0:0], RW/P, default = 0x1
    //
    UINTX request_data_size : 1;
    //
    // If set, refresh commands will be blocked for the duration of the wait period specified
    // by SUBSEQUENCE_WAIT.  Otherwise refreshes will be enabled for that period of time.
    // 
    // Bits[1:1], RW/P, default = 0x0
    //
    UINTX subsequence_wait_refresh_block : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:2], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 6;
    //
    // Four bit exponential timer according to 2^(TIMER). This is used to dynamically
    // replace SUBSEQUENCE_WAIT counter if POWER_MODE_ON is asserted for the particular
    // Subsequence 
    // 
    // Bits[11:8], RW/P, default = 0x0
    //
    UINTX timer : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[14:12], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 3;
    //
    // Allows the Subsequence wait counter to be replaced by the value set in TIMER field
    // when the D-unit enters Self-Refresh or Power-Down. This is used for power state
    // stress testing 
    // 
    // Bits[15:15], RW/P, default = 0x0
    //
    UINTX power_mode_on : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[20:16], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 5;
    //
    // If set, the CADB will be able to issue harassment patterns into the command and
    // address bus. 
    // 
    // Bits[21:21], RW/P, default = 0x0
    //
    UINTX subsequence_cadb_deselect_on : 1;
    //
    // SUBSEQUENCE_CADB_SELECT_ON is an ON/OFF signal in the subsequence logic that determines
    // whether a particular subsequence allows the CADB contents to be driven during
    // Select cycles. 
    // 
    // Bits[22:22], RW/P, default = 0x0
    //
    UINTX subsequence_cadb_select_on : 1;
    //
    // SUBSEQUENCE_CADB_SEEDS_SAVE_EN is an ON/OFF signal in the subsequence logic that
    // determines whether a particular subsequence allows the CADB PB/ LFSRs to saved.
    // 
    // Bits[23:23], RW/P, default = 0x0
    //
    UINTX subsequence_cadb_seeds_save_en : 1;
    //
    // SUBSEQUENCE_CADB_SEEDS_RELOAD_EN is an ON/OFF signal in the subsequence logic
    // that determines whether a particular subsequence allows the CADB PB/ LFSRs to
    // reload. 
    // 
    // Bits[24:24], RW/P, default = 0x0
    //
    UINTX subsequence_cadb_seeds_reload_en : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:25], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_3 : 7;
  } Bits;
  UINTX Data;
} CPGC_SUBSEQ0_CTL_B_CPGC_STRUCT;
#endif // ASM_INC

#define CPGC_SUBSEQ0_VAR_CPGC_REG                          0x00000088
#ifndef ASM_INC
typedef union {
  struct {
    //
    // 0 - Linear Variable Address Segment[br]       1 - Scrambled Variable Address Segment
    // 
    // Bits[0:0], RW/P, default = 0x0
    //
    UINTX var_scramble : 1;
    //
    // This field is used to program the VAR address segment for the command sequence
    // 
    // Bits[15:1], RW/P, default = 0x0
    //
    UINTX var_segment : 15;
    //
    // The Width of the VAR address segment for the sequence will be set to the following
    // number of bits[br] 
    //                         0000 -  5 bits[br]
    //                         0001 -  6 bits[br]
    //                         0010 -  7 bits[br]
    //                         0011 -  8 bits[br]
    //                         0100 -  9 bits[br]
    //                         0101 - 10 bits[br]
    //                         0110 - 11 bits[br]
    //                         0111 - 12 bits[br]
    //                         1000 - 13 bits[br]
    //                         1001 - 14 bits[br]
    //                         1010 - 15 bits[br]
    //                         All other values are reserved 
    // 
    // Bits[19:16], RW/P, default = 0x0
    //
    UINTX var_width : 4;
    //
    // The lower 3-bits of the VAR address segment will be shifted to the left by VAR_LO_SHIFT
    // bits 
    // 
    // Bits[24:20], RW/P, default = 0x0
    //
    UINTX var_lo_shift : 5;
    //
    // The upper (VAR_WIDTH - 3)-bits of the VAR address segment will be shifted to the
    // left by VAR_HI_SHIFT bits 
    // 
    // Bits[29:25], RW/P, default = 0x0
    //
    UINTX var_hi_shift : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:30], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
  } Bits;
  UINTX Data;
} CPGC_SUBSEQ0_VAR_CPGC_STRUCT;
#endif // ASM_INC

#define CPGC_SUBSEQ0_FIX_CPGC_REG                          0x0000008C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // This field is used to program the FIX address segment for this Subsequence. Note:
    //  The width of this field is dependent on the channel address width and maybe different
    // for different implementations. 
    // 
    // Bits[30:0], RW/P, default = 0x0
    //
    UINTX fix_segment : 31;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:31], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 1;
  } Bits;
  UINTX Data;
} CPGC_SUBSEQ0_FIX_CPGC_STRUCT;
#endif // ASM_INC

#define CPGC_SUBSEQ1_CTL_A_CPGC_REG                        0x00000090
#ifndef ASM_INC
typedef union {
  struct {
    //
    // If NUMBER_OF_BURSTS_SCALE == 0[br] Number of bursts (CAS commands) composing the
    // subsequence is equal to 2^(NUMBER_OF_BURSTS). Only bits [3:0] are supported if
    // set as an exponential counter.[br][br] If NUMBER_OF_BURSTS_SCALE == 1[br] Number
    // of bursts (CAS commands) composing the subsequence is equal to NUMBER_OF_BURSTS.
    // All bits are supported. Setting NUMBER_OF_BURSTS_SCALE to 1 and NUMBER_OF_BURSTS
    // to 0 will result in an infinite number of bursts being issued.[br][br] If CPGC_SEQ_CFG.ADDR_BKWRD_COMP
    // is set 1 then:[br] A value of 0 stands for infinite number of bursts and enables
    // the Infinite Burst Addressing mode[br] Note: Only bits [3:0] are supported if
    // set as an exponential counter. If set as a linear counter and NUMBER_OF_BURSTS
    // == 0, then the SubSequence will issue an infinite number of transactions. 
    // 
    // Bits[6:0], RW/P, default = 0x0
    //
    UINTX number_of_bursts : 7;
    //
    // If set to 0 then NUMBER_OF_BURSTS operates as an exponential counter.[br] If set
    // to 1 then NUMBER_OF_BURSTS operates as a linear counter.. 
    // 
    // Bits[7:7], RW/P, default = 0x0
    //
    UINTX number_of_bursts_scale : 1;
    //
    // Number of clock cycles (in CPGC-S clock domain) between finishing a Subsequence
    // and the beginning of the next Subsequence is defined by SUBSEQUENCE_WAIT.  The
    // wait period is considered independent from the Subsequence itself and hence refresh
    // commands can be Enabled/Disabled for the wait period independent of the preceding
    // Subsequence. 
    // 
    // Bits[21:8], RW/P, default = 0x0
    //
    UINTX subsequence_wait : 14;
    //
    // This field defines the type of commands this sequence will issue:[br]
    // 0000 - Read Commands[br]
    // 0001 - Write Commands[br]
    // 0010 - Read Commands -> Write Commands[br]
    // 0011 - Write Commands -> Read Commands[br]
    // 0100 - Offset Read[br]
    // 0101 - Offset Write[br]
    // 1000 - Read Commands (Self Refresh Exit)[br]
    // 1001 - Write Commands (Self Refresh Exit)[br]
    // 1010 - Read Commands -> Write Commands (Self Refresh Exit)[br]
    // 1011 - Write Commands -> Read Commands (Self Refresh Exit)[br]
    // All other values are reserved for future use.
    // 
    // Bits[25:22], RW/P, default = 0x0
    //
    UINTX subsequence_type : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[26:26], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 1;
    //
    // If CPGC_SEQ_CFG.ADDR_BKWRD_COMP is set then:[br] This bit will force the subsequence
    // to reload its initial address from each time before it starts. This bit is not
    // applicable to Infinite Burst Addressing mode.[br][br] If CPGC_SEQ_CFG.ADDR_BKWRD_COMP
    // is set to 0 then:[br] Upon entry to a subsequence where RESET_CURRENT_BASE_ADDRESS_TO_START
    // is set:[br] 
    // 1) Base Current Address (CPGC_SEQ_BASE_ADDR_CURRENT) gets immediately re initialized
    // to the Base Starting Address (CPGC_SEQ_BASE_ADDR_START).[br] 
    // 2) Reset the:[br]
    // Rank_Base_Address_Update_Rate,[br]
    // Bank_Base_Address_Update_Rate,[br]
    // Row_Base_Address_Update_Rate, and[br]
    // Column_Base_Address_Update_Rate(CPGC_SEQ_BASE_ADDR_INC_CTL)[br][br]
    // 3) Reset the Base_Address_Invert_Rate(CPGC_SEQ_BASE_ADDR_ORDER_CARRY_INVERT_CTL)[br][br]
    // In the case where both SAVE_ADDR = 1 and RESET_CURRENT_BASE_ADDRESS_TO_START =
    // 1 then only SAVE_ADDR = 1 will take effect and RESET_CURRENT_BASE_ADDRESS_TO_START
    // =1 will be ignored.[br][br] 
    // Use case: long WR subseq and then long RD subseq: RD should set this field on,
    // WR should set the next one (Save_Current_Base_Address_To_Start) on. 
    // 
    // Bits[27:27], RW/P, default = 0x0
    //
    UINTX reset_current_base_address_to_start : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[30:28], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 3;
    //
    // If the Subsequence is running in the infinite burst mode, setting this bit will
    // cause a transition from this Subsequence to the next Subsequence (after the wait
    // period) once the channel address hits the wrap address defined by WRAP_ADDR -
    // 1. This bit is not used for finite burst addressing mode. 
    // 
    // Bits[31:31], RW/P, default = 0x0
    //
    UINTX stop_subsequence_on_base_wrap_trigger : 1;
  } Bits;
  UINTX Data;
} CPGC_SUBSEQ1_CTL_A_CPGC_STRUCT;
#endif // ASM_INC

#define CPGC_SUBSEQ1_CTL_B_CPGC_REG                        0x00000094
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Size of requests CPGC is issuing, 64B and 32B transactions and is encoded as follows:[br]
    // 0 - 32 Byte Transactions[br]
    // 1 - 64 Byte Transactions
    // 
    // Bits[0:0], RW/P, default = 0x1
    //
    UINTX request_data_size : 1;
    //
    // If set, refresh commands will be blocked for the duration of the wait period specified
    // by SUBSEQUENCE_WAIT.  Otherwise refreshes will be enabled for that period of time.
    // 
    // Bits[1:1], RW/P, default = 0x0
    //
    UINTX subsequence_wait_refresh_block : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:2], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 6;
    //
    // Four bit exponential timer according to 2^(TIMER). This is used to dynamically
    // replace SUBSEQUENCE_WAIT counter if POWER_MODE_ON is asserted for the particular
    // Subsequence 
    // 
    // Bits[11:8], RW/P, default = 0x0
    //
    UINTX timer : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[14:12], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 3;
    //
    // Allows the Subsequence wait counter to be replaced by the value set in TIMER field
    // when the D-unit enters Self-Refresh or Power-Down. This is used for power state
    // stress testing 
    // 
    // Bits[15:15], RW/P, default = 0x0
    //
    UINTX power_mode_on : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[20:16], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 5;
    //
    // If set, the CADB will be able to issue harassment patterns into the command and
    // address bus. 
    // 
    // Bits[21:21], RW/P, default = 0x0
    //
    UINTX subsequence_cadb_deselect_on : 1;
    //
    // SUBSEQUENCE_CADB_SELECT_ON is an ON/OFF signal in the subsequence logic that determines
    // whether a particular subsequence allows the CADB contents to be driven during
    // Select cycles. 
    // 
    // Bits[22:22], RW/P, default = 0x0
    //
    UINTX subsequence_cadb_select_on : 1;
    //
    // SUBSEQUENCE_CADB_SEEDS_SAVE_EN is an ON/OFF signal in the subsequence logic that
    // determines whether a particular subsequence allows the CADB PB/ LFSRs to saved.
    // 
    // Bits[23:23], RW/P, default = 0x0
    //
    UINTX subsequence_cadb_seeds_save_en : 1;
    //
    // SUBSEQUENCE_CADB_SEEDS_RELOAD_EN is an ON/OFF signal in the subsequence logic
    // that determines whether a particular subsequence allows the CADB PB/ LFSRs to
    // reload. 
    // 
    // Bits[24:24], RW/P, default = 0x0
    //
    UINTX subsequence_cadb_seeds_reload_en : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:25], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_3 : 7;
  } Bits;
  UINTX Data;
} CPGC_SUBSEQ1_CTL_B_CPGC_STRUCT;
#endif // ASM_INC

#define CPGC_SUBSEQ1_VAR_CPGC_REG                          0x00000098
#ifndef ASM_INC
typedef union {
  struct {
    //
    // 0 - Linear Variable Address Segment[br]       1 - Scrambled Variable Address Segment
    // 
    // Bits[0:0], RW/P, default = 0x0
    //
    UINTX var_scramble : 1;
    //
    // This field is used to program the VAR address segment for the command sequence
    // 
    // Bits[15:1], RW/P, default = 0x0
    //
    UINTX var_segment : 15;
    //
    // The Width of the VAR address segment for the sequence will be set to the following
    // number of bits[br] 
    //                         0000 -  5 bits[br]
    //                         0001 -  6 bits[br]
    //                         0010 -  7 bits[br]
    //                         0011 -  8 bits[br]
    //                         0100 -  9 bits[br]
    //                         0101 - 10 bits[br]
    //                         0110 - 11 bits[br]
    //                         0111 - 12 bits[br]
    //                         1000 - 13 bits[br]
    //                         1001 - 14 bits[br]
    //                         1010 - 15 bits[br]
    //                         All other values are reserved 
    // 
    // Bits[19:16], RW/P, default = 0x0
    //
    UINTX var_width : 4;
    //
    // The lower 3-bits of the VAR address segment will be shifted to the left by VAR_LO_SHIFT
    // bits 
    // 
    // Bits[24:20], RW/P, default = 0x0
    //
    UINTX var_lo_shift : 5;
    //
    // The upper (VAR_WIDTH - 3)-bits of the VAR address segment will be shifted to the
    // left by VAR_HI_SHIFT bits 
    // 
    // Bits[29:25], RW/P, default = 0x0
    //
    UINTX var_hi_shift : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:30], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
  } Bits;
  UINTX Data;
} CPGC_SUBSEQ1_VAR_CPGC_STRUCT;
#endif // ASM_INC

#define CPGC_SUBSEQ1_FIX_CPGC_REG                          0x0000009C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // This field is used to program the FIX address segment for this Subsequence. Note:
    //  The width of this field is dependent on the channel address width and maybe different
    // for different implementations. 
    // 
    // Bits[30:0], RW/P, default = 0x0
    //
    UINTX fix_segment : 31;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:31], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 1;
  } Bits;
  UINTX Data;
} CPGC_SUBSEQ1_FIX_CPGC_STRUCT;
#endif // ASM_INC

#define CPGC_SUBSEQ2_CTL_A_CPGC_REG                        0x000000A0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // If NUMBER_OF_BURSTS_SCALE == 0[br] Number of bursts (CAS commands) composing the
    // subsequence is equal to 2^(NUMBER_OF_BURSTS). Only bits [3:0] are supported if
    // set as an exponential counter.[br][br] If NUMBER_OF_BURSTS_SCALE == 1[br] Number
    // of bursts (CAS commands) composing the subsequence is equal to NUMBER_OF_BURSTS.
    // All bits are supported. Setting NUMBER_OF_BURSTS_SCALE to 1 and NUMBER_OF_BURSTS
    // to 0 will result in an infinite number of bursts being issued.[br][br] If CPGC_SEQ_CFG.ADDR_BKWRD_COMP
    // is set 1 then:[br] A value of 0 stands for infinite number of bursts and enables
    // the Infinite Burst Addressing mode[br] Note: Only bits [3:0] are supported if
    // set as an exponential counter. If set as a linear counter and NUMBER_OF_BURSTS
    // == 0, then the SubSequence will issue an infinite number of transactions. 
    // 
    // Bits[6:0], RW/P, default = 0x0
    //
    UINTX number_of_bursts : 7;
    //
    // If set to 0 then NUMBER_OF_BURSTS operates as an exponential counter.[br] If set
    // to 1 then NUMBER_OF_BURSTS operates as a linear counter.. 
    // 
    // Bits[7:7], RW/P, default = 0x0
    //
    UINTX number_of_bursts_scale : 1;
    //
    // Number of clock cycles (in CPGC-S clock domain) between finishing a Subsequence
    // and the beginning of the next Subsequence is defined by SUBSEQUENCE_WAIT.  The
    // wait period is considered independent from the Subsequence itself and hence refresh
    // commands can be Enabled/Disabled for the wait period independent of the preceding
    // Subsequence. 
    // 
    // Bits[21:8], RW/P, default = 0x0
    //
    UINTX subsequence_wait : 14;
    //
    // This field defines the type of commands this sequence will issue:[br]
    // 0000 - Read Commands[br]
    // 0001 - Write Commands[br]
    // 0010 - Read Commands -> Write Commands[br]
    // 0011 - Write Commands -> Read Commands[br]
    // 0100 - Offset Read[br]
    // 0101 - Offset Write[br]
    // 1000 - Read Commands (Self Refresh Exit)[br]
    // 1001 - Write Commands (Self Refresh Exit)[br]
    // 1010 - Read Commands -> Write Commands (Self Refresh Exit)[br]
    // 1011 - Write Commands -> Read Commands (Self Refresh Exit)[br]
    // All other values are reserved for future use.
    // 
    // Bits[25:22], RW/P, default = 0x0
    //
    UINTX subsequence_type : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[26:26], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 1;
    //
    // If CPGC_SEQ_CFG.ADDR_BKWRD_COMP is set then:[br] This bit will force the subsequence
    // to reload its initial address from each time before it starts. This bit is not
    // applicable to Infinite Burst Addressing mode.[br][br] If CPGC_SEQ_CFG.ADDR_BKWRD_COMP
    // is set to 0 then:[br] Upon entry to a subsequence where RESET_CURRENT_BASE_ADDRESS_TO_START
    // is set:[br] 
    // 1) Base Current Address (CPGC_SEQ_BASE_ADDR_CURRENT) gets immediately re initialized
    // to the Base Starting Address (CPGC_SEQ_BASE_ADDR_START).[br] 
    // 2) Reset the:[br]
    // Rank_Base_Address_Update_Rate,[br]
    // Bank_Base_Address_Update_Rate,[br]
    // Row_Base_Address_Update_Rate, and[br]
    // Column_Base_Address_Update_Rate(CPGC_SEQ_BASE_ADDR_INC_CTL)[br][br]
    // 3) Reset the Base_Address_Invert_Rate(CPGC_SEQ_BASE_ADDR_ORDER_CARRY_INVERT_CTL)[br][br]
    // In the case where both SAVE_ADDR = 1 and RESET_CURRENT_BASE_ADDRESS_TO_START =
    // 1 then only SAVE_ADDR = 1 will take effect and RESET_CURRENT_BASE_ADDRESS_TO_START
    // =1 will be ignored.[br][br] 
    // Use case: long WR subseq and then long RD subseq: RD should set this field on,
    // WR should set the next one (Save_Current_Base_Address_To_Start) on. 
    // 
    // Bits[27:27], RW/P, default = 0x0
    //
    UINTX reset_current_base_address_to_start : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[30:28], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 3;
    //
    // If the Subsequence is running in the infinite burst mode, setting this bit will
    // cause a transition from this Subsequence to the next Subsequence (after the wait
    // period) once the channel address hits the wrap address defined by WRAP_ADDR -
    // 1. This bit is not used for finite burst addressing mode. 
    // 
    // Bits[31:31], RW/P, default = 0x0
    //
    UINTX stop_subsequence_on_base_wrap_trigger : 1;
  } Bits;
  UINTX Data;
} CPGC_SUBSEQ2_CTL_A_CPGC_STRUCT;
#endif // ASM_INC

#define CPGC_SUBSEQ2_CTL_B_CPGC_REG                        0x000000A4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Size of requests CPGC is issuing, 64B and 32B transactions and is encoded as follows:[br]
    // 0 - 32 Byte Transactions[br]
    // 1 - 64 Byte Transactions
    // 
    // Bits[0:0], RW/P, default = 0x1
    //
    UINTX request_data_size : 1;
    //
    // If set, refresh commands will be blocked for the duration of the wait period specified
    // by SUBSEQUENCE_WAIT.  Otherwise refreshes will be enabled for that period of time.
    // 
    // Bits[1:1], RW/P, default = 0x0
    //
    UINTX subsequence_wait_refresh_block : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:2], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 6;
    //
    // Four bit exponential timer according to 2^(TIMER). This is used to dynamically
    // replace SUBSEQUENCE_WAIT counter if POWER_MODE_ON is asserted for the particular
    // Subsequence 
    // 
    // Bits[11:8], RW/P, default = 0x0
    //
    UINTX timer : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[14:12], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 3;
    //
    // Allows the Subsequence wait counter to be replaced by the value set in TIMER field
    // when the D-unit enters Self-Refresh or Power-Down. This is used for power state
    // stress testing 
    // 
    // Bits[15:15], RW/P, default = 0x0
    //
    UINTX power_mode_on : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[20:16], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 5;
    //
    // If set, the CADB will be able to issue harassment patterns into the command and
    // address bus. 
    // 
    // Bits[21:21], RW/P, default = 0x0
    //
    UINTX subsequence_cadb_deselect_on : 1;
    //
    // SUBSEQUENCE_CADB_SELECT_ON is an ON/OFF signal in the subsequence logic that determines
    // whether a particular subsequence allows the CADB contents to be driven during
    // Select cycles. 
    // 
    // Bits[22:22], RW/P, default = 0x0
    //
    UINTX subsequence_cadb_select_on : 1;
    //
    // SUBSEQUENCE_CADB_SEEDS_SAVE_EN is an ON/OFF signal in the subsequence logic that
    // determines whether a particular subsequence allows the CADB PB/ LFSRs to saved.
    // 
    // Bits[23:23], RW/P, default = 0x0
    //
    UINTX subsequence_cadb_seeds_save_en : 1;
    //
    // SUBSEQUENCE_CADB_SEEDS_RELOAD_EN is an ON/OFF signal in the subsequence logic
    // that determines whether a particular subsequence allows the CADB PB/ LFSRs to
    // reload. 
    // 
    // Bits[24:24], RW/P, default = 0x0
    //
    UINTX subsequence_cadb_seeds_reload_en : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:25], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_3 : 7;
  } Bits;
  UINTX Data;
} CPGC_SUBSEQ2_CTL_B_CPGC_STRUCT;
#endif // ASM_INC

#define CPGC_SUBSEQ2_VAR_CPGC_REG                          0x000000A8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // 0 - Linear Variable Address Segment[br]       1 - Scrambled Variable Address Segment
    // 
    // Bits[0:0], RW/P, default = 0x0
    //
    UINTX var_scramble : 1;
    //
    // This field is used to program the VAR address segment for the command sequence
    // 
    // Bits[15:1], RW/P, default = 0x0
    //
    UINTX var_segment : 15;
    //
    // The Width of the VAR address segment for the sequence will be set to the following
    // number of bits[br] 
    //                         0000 -  5 bits[br]
    //                         0001 -  6 bits[br]
    //                         0010 -  7 bits[br]
    //                         0011 -  8 bits[br]
    //                         0100 -  9 bits[br]
    //                         0101 - 10 bits[br]
    //                         0110 - 11 bits[br]
    //                         0111 - 12 bits[br]
    //                         1000 - 13 bits[br]
    //                         1001 - 14 bits[br]
    //                         1010 - 15 bits[br]
    //                         All other values are reserved 
    // 
    // Bits[19:16], RW/P, default = 0x0
    //
    UINTX var_width : 4;
    //
    // The lower 3-bits of the VAR address segment will be shifted to the left by VAR_LO_SHIFT
    // bits 
    // 
    // Bits[24:20], RW/P, default = 0x0
    //
    UINTX var_lo_shift : 5;
    //
    // The upper (VAR_WIDTH - 3)-bits of the VAR address segment will be shifted to the
    // left by VAR_HI_SHIFT bits 
    // 
    // Bits[29:25], RW/P, default = 0x0
    //
    UINTX var_hi_shift : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:30], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
  } Bits;
  UINTX Data;
} CPGC_SUBSEQ2_VAR_CPGC_STRUCT;
#endif // ASM_INC

#define CPGC_SUBSEQ2_FIX_CPGC_REG                          0x000000AC
#ifndef ASM_INC
typedef union {
  struct {
    //
    // This field is used to program the FIX address segment for this Subsequence. Note:
    //  The width of this field is dependent on the channel address width and maybe different
    // for different implementations. 
    // 
    // Bits[30:0], RW/P, default = 0x0
    //
    UINTX fix_segment : 31;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:31], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 1;
  } Bits;
  UINTX Data;
} CPGC_SUBSEQ2_FIX_CPGC_STRUCT;
#endif // ASM_INC

#define CPGC_SUBSEQ3_CTL_A_CPGC_REG                        0x000000B0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // If NUMBER_OF_BURSTS_SCALE == 0[br] Number of bursts (CAS commands) composing the
    // subsequence is equal to 2^(NUMBER_OF_BURSTS). Only bits [3:0] are supported if
    // set as an exponential counter.[br][br] If NUMBER_OF_BURSTS_SCALE == 1[br] Number
    // of bursts (CAS commands) composing the subsequence is equal to NUMBER_OF_BURSTS.
    // All bits are supported. Setting NUMBER_OF_BURSTS_SCALE to 1 and NUMBER_OF_BURSTS
    // to 0 will result in an infinite number of bursts being issued.[br][br] If CPGC_SEQ_CFG.ADDR_BKWRD_COMP
    // is set 1 then:[br] A value of 0 stands for infinite number of bursts and enables
    // the Infinite Burst Addressing mode[br] Note: Only bits [3:0] are supported if
    // set as an exponential counter. If set as a linear counter and NUMBER_OF_BURSTS
    // == 0, then the SubSequence will issue an infinite number of transactions. 
    // 
    // Bits[6:0], RW/P, default = 0x0
    //
    UINTX number_of_bursts : 7;
    //
    // If set to 0 then NUMBER_OF_BURSTS operates as an exponential counter.[br] If set
    // to 1 then NUMBER_OF_BURSTS operates as a linear counter.. 
    // 
    // Bits[7:7], RW/P, default = 0x0
    //
    UINTX number_of_bursts_scale : 1;
    //
    // Number of clock cycles (in CPGC-S clock domain) between finishing a Subsequence
    // and the beginning of the next Subsequence is defined by SUBSEQUENCE_WAIT.  The
    // wait period is considered independent from the Subsequence itself and hence refresh
    // commands can be Enabled/Disabled for the wait period independent of the preceding
    // Subsequence. 
    // 
    // Bits[21:8], RW/P, default = 0x0
    //
    UINTX subsequence_wait : 14;
    //
    // This field defines the type of commands this sequence will issue:[br]
    // 0000 - Read Commands[br]
    // 0001 - Write Commands[br]
    // 0010 - Read Commands -> Write Commands[br]
    // 0011 - Write Commands -> Read Commands[br]
    // 0100 - Offset Read[br]
    // 0101 - Offset Write[br]
    // 1000 - Read Commands (Self Refresh Exit)[br]
    // 1001 - Write Commands (Self Refresh Exit)[br]
    // 1010 - Read Commands -> Write Commands (Self Refresh Exit)[br]
    // 1011 - Write Commands -> Read Commands (Self Refresh Exit)[br]
    // All other values are reserved for future use.
    // 
    // Bits[25:22], RW/P, default = 0x0
    //
    UINTX subsequence_type : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[26:26], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 1;
    //
    // If CPGC_SEQ_CFG.ADDR_BKWRD_COMP is set then:[br] This bit will force the subsequence
    // to reload its initial address from each time before it starts. This bit is not
    // applicable to Infinite Burst Addressing mode.[br][br] If CPGC_SEQ_CFG.ADDR_BKWRD_COMP
    // is set to 0 then:[br] Upon entry to a subsequence where RESET_CURRENT_BASE_ADDRESS_TO_START
    // is set:[br] 
    // 1) Base Current Address (CPGC_SEQ_BASE_ADDR_CURRENT) gets immediately re initialized
    // to the Base Starting Address (CPGC_SEQ_BASE_ADDR_START).[br] 
    // 2) Reset the:[br]
    // Rank_Base_Address_Update_Rate,[br]
    // Bank_Base_Address_Update_Rate,[br]
    // Row_Base_Address_Update_Rate, and[br]
    // Column_Base_Address_Update_Rate(CPGC_SEQ_BASE_ADDR_INC_CTL)[br][br]
    // 3) Reset the Base_Address_Invert_Rate(CPGC_SEQ_BASE_ADDR_ORDER_CARRY_INVERT_CTL)[br][br]
    // In the case where both SAVE_ADDR = 1 and RESET_CURRENT_BASE_ADDRESS_TO_START =
    // 1 then only SAVE_ADDR = 1 will take effect and RESET_CURRENT_BASE_ADDRESS_TO_START
    // =1 will be ignored.[br][br] 
    // Use case: long WR subseq and then long RD subseq: RD should set this field on,
    // WR should set the next one (Save_Current_Base_Address_To_Start) on. 
    // 
    // Bits[27:27], RW/P, default = 0x0
    //
    UINTX reset_current_base_address_to_start : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[30:28], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 3;
    //
    // If the Subsequence is running in the infinite burst mode, setting this bit will
    // cause a transition from this Subsequence to the next Subsequence (after the wait
    // period) once the channel address hits the wrap address defined by WRAP_ADDR -
    // 1. This bit is not used for finite burst addressing mode. 
    // 
    // Bits[31:31], RW/P, default = 0x0
    //
    UINTX stop_subsequence_on_base_wrap_trigger : 1;
  } Bits;
  UINTX Data;
} CPGC_SUBSEQ3_CTL_A_CPGC_STRUCT;
#endif // ASM_INC

#define CPGC_SUBSEQ3_CTL_B_CPGC_REG                        0x000000B4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Size of requests CPGC is issuing, 64B and 32B transactions and is encoded as follows:[br]
    // 0 - 32 Byte Transactions[br]
    // 1 - 64 Byte Transactions
    // 
    // Bits[0:0], RW/P, default = 0x1
    //
    UINTX request_data_size : 1;
    //
    // If set, refresh commands will be blocked for the duration of the wait period specified
    // by SUBSEQUENCE_WAIT.  Otherwise refreshes will be enabled for that period of time.
    // 
    // Bits[1:1], RW/P, default = 0x0
    //
    UINTX subsequence_wait_refresh_block : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:2], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 6;
    //
    // Four bit exponential timer according to 2^(TIMER). This is used to dynamically
    // replace SUBSEQUENCE_WAIT counter if POWER_MODE_ON is asserted for the particular
    // Subsequence 
    // 
    // Bits[11:8], RW/P, default = 0x0
    //
    UINTX timer : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[14:12], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 3;
    //
    // Allows the Subsequence wait counter to be replaced by the value set in TIMER field
    // when the D-unit enters Self-Refresh or Power-Down. This is used for power state
    // stress testing 
    // 
    // Bits[15:15], RW/P, default = 0x0
    //
    UINTX power_mode_on : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[20:16], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 5;
    //
    // If set, the CADB will be able to issue harassment patterns into the command and
    // address bus. 
    // 
    // Bits[21:21], RW/P, default = 0x0
    //
    UINTX subsequence_cadb_deselect_on : 1;
    //
    // SUBSEQUENCE_CADB_SELECT_ON is an ON/OFF signal in the subsequence logic that determines
    // whether a particular subsequence allows the CADB contents to be driven during
    // Select cycles. 
    // 
    // Bits[22:22], RW/P, default = 0x0
    //
    UINTX subsequence_cadb_select_on : 1;
    //
    // SUBSEQUENCE_CADB_SEEDS_SAVE_EN is an ON/OFF signal in the subsequence logic that
    // determines whether a particular subsequence allows the CADB PB/ LFSRs to saved.
    // 
    // Bits[23:23], RW/P, default = 0x0
    //
    UINTX subsequence_cadb_seeds_save_en : 1;
    //
    // SUBSEQUENCE_CADB_SEEDS_RELOAD_EN is an ON/OFF signal in the subsequence logic
    // that determines whether a particular subsequence allows the CADB PB/ LFSRs to
    // reload. 
    // 
    // Bits[24:24], RW/P, default = 0x0
    //
    UINTX subsequence_cadb_seeds_reload_en : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:25], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_3 : 7;
  } Bits;
  UINTX Data;
} CPGC_SUBSEQ3_CTL_B_CPGC_STRUCT;
#endif // ASM_INC

#define CPGC_SUBSEQ3_VAR_CPGC_REG                          0x000000B8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // 0 - Linear Variable Address Segment[br]       1 - Scrambled Variable Address Segment
    // 
    // Bits[0:0], RW/P, default = 0x0
    //
    UINTX var_scramble : 1;
    //
    // This field is used to program the VAR address segment for the command sequence
    // 
    // Bits[15:1], RW/P, default = 0x0
    //
    UINTX var_segment : 15;
    //
    // The Width of the VAR address segment for the sequence will be set to the following
    // number of bits[br] 
    //                         0000 -  5 bits[br]
    //                         0001 -  6 bits[br]
    //                         0010 -  7 bits[br]
    //                         0011 -  8 bits[br]
    //                         0100 -  9 bits[br]
    //                         0101 - 10 bits[br]
    //                         0110 - 11 bits[br]
    //                         0111 - 12 bits[br]
    //                         1000 - 13 bits[br]
    //                         1001 - 14 bits[br]
    //                         1010 - 15 bits[br]
    //                         All other values are reserved 
    // 
    // Bits[19:16], RW/P, default = 0x0
    //
    UINTX var_width : 4;
    //
    // The lower 3-bits of the VAR address segment will be shifted to the left by VAR_LO_SHIFT
    // bits 
    // 
    // Bits[24:20], RW/P, default = 0x0
    //
    UINTX var_lo_shift : 5;
    //
    // The upper (VAR_WIDTH - 3)-bits of the VAR address segment will be shifted to the
    // left by VAR_HI_SHIFT bits 
    // 
    // Bits[29:25], RW/P, default = 0x0
    //
    UINTX var_hi_shift : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:30], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
  } Bits;
  UINTX Data;
} CPGC_SUBSEQ3_VAR_CPGC_STRUCT;
#endif // ASM_INC

#define CPGC_SUBSEQ3_FIX_CPGC_REG                          0x000000BC
#ifndef ASM_INC
typedef union {
  struct {
    //
    // This field is used to program the FIX address segment for this Subsequence. Note:
    //  The width of this field is dependent on the channel address width and maybe different
    // for different implementations. 
    // 
    // Bits[30:0], RW/P, default = 0x0
    //
    UINTX fix_segment : 31;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:31], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 1;
  } Bits;
  UINTX Data;
} CPGC_SUBSEQ3_FIX_CPGC_STRUCT;
#endif // ASM_INC

#define CPGC_SUBSEQ4_CTL_A_CPGC_REG                        0x000000C0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // If NUMBER_OF_BURSTS_SCALE == 0[br] Number of bursts (CAS commands) composing the
    // subsequence is equal to 2^(NUMBER_OF_BURSTS). Only bits [3:0] are supported if
    // set as an exponential counter.[br][br] If NUMBER_OF_BURSTS_SCALE == 1[br] Number
    // of bursts (CAS commands) composing the subsequence is equal to NUMBER_OF_BURSTS.
    // All bits are supported. Setting NUMBER_OF_BURSTS_SCALE to 1 and NUMBER_OF_BURSTS
    // to 0 will result in an infinite number of bursts being issued.[br][br] If CPGC_SEQ_CFG.ADDR_BKWRD_COMP
    // is set 1 then:[br] A value of 0 stands for infinite number of bursts and enables
    // the Infinite Burst Addressing mode[br] Note: Only bits [3:0] are supported if
    // set as an exponential counter. If set as a linear counter and NUMBER_OF_BURSTS
    // == 0, then the SubSequence will issue an infinite number of transactions. 
    // 
    // Bits[6:0], RW/P, default = 0x0
    //
    UINTX number_of_bursts : 7;
    //
    // If set to 0 then NUMBER_OF_BURSTS operates as an exponential counter.[br] If set
    // to 1 then NUMBER_OF_BURSTS operates as a linear counter.. 
    // 
    // Bits[7:7], RW/P, default = 0x0
    //
    UINTX number_of_bursts_scale : 1;
    //
    // Number of clock cycles (in CPGC-S clock domain) between finishing a Subsequence
    // and the beginning of the next Subsequence is defined by SUBSEQUENCE_WAIT.  The
    // wait period is considered independent from the Subsequence itself and hence refresh
    // commands can be Enabled/Disabled for the wait period independent of the preceding
    // Subsequence. 
    // 
    // Bits[21:8], RW/P, default = 0x0
    //
    UINTX subsequence_wait : 14;
    //
    // This field defines the type of commands this sequence will issue:[br]
    // 0000 - Read Commands[br]
    // 0001 - Write Commands[br]
    // 0010 - Read Commands -> Write Commands[br]
    // 0011 - Write Commands -> Read Commands[br]
    // 0100 - Offset Read[br]
    // 0101 - Offset Write[br]
    // 1000 - Read Commands (Self Refresh Exit)[br]
    // 1001 - Write Commands (Self Refresh Exit)[br]
    // 1010 - Read Commands -> Write Commands (Self Refresh Exit)[br]
    // 1011 - Write Commands -> Read Commands (Self Refresh Exit)[br]
    // All other values are reserved for future use.
    // 
    // Bits[25:22], RW/P, default = 0x0
    //
    UINTX subsequence_type : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[26:26], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 1;
    //
    // If CPGC_SEQ_CFG.ADDR_BKWRD_COMP is set then:[br] This bit will force the subsequence
    // to reload its initial address from each time before it starts. This bit is not
    // applicable to Infinite Burst Addressing mode.[br][br] If CPGC_SEQ_CFG.ADDR_BKWRD_COMP
    // is set to 0 then:[br] Upon entry to a subsequence where RESET_CURRENT_BASE_ADDRESS_TO_START
    // is set:[br] 
    // 1) Base Current Address (CPGC_SEQ_BASE_ADDR_CURRENT) gets immediately re initialized
    // to the Base Starting Address (CPGC_SEQ_BASE_ADDR_START).[br] 
    // 2) Reset the:[br]
    // Rank_Base_Address_Update_Rate,[br]
    // Bank_Base_Address_Update_Rate,[br]
    // Row_Base_Address_Update_Rate, and[br]
    // Column_Base_Address_Update_Rate(CPGC_SEQ_BASE_ADDR_INC_CTL)[br][br]
    // 3) Reset the Base_Address_Invert_Rate(CPGC_SEQ_BASE_ADDR_ORDER_CARRY_INVERT_CTL)[br][br]
    // In the case where both SAVE_ADDR = 1 and RESET_CURRENT_BASE_ADDRESS_TO_START =
    // 1 then only SAVE_ADDR = 1 will take effect and RESET_CURRENT_BASE_ADDRESS_TO_START
    // =1 will be ignored.[br][br] 
    // Use case: long WR subseq and then long RD subseq: RD should set this field on,
    // WR should set the next one (Save_Current_Base_Address_To_Start) on. 
    // 
    // Bits[27:27], RW/P, default = 0x0
    //
    UINTX reset_current_base_address_to_start : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[30:28], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 3;
    //
    // If the Subsequence is running in the infinite burst mode, setting this bit will
    // cause a transition from this Subsequence to the next Subsequence (after the wait
    // period) once the channel address hits the wrap address defined by WRAP_ADDR -
    // 1. This bit is not used for finite burst addressing mode. 
    // 
    // Bits[31:31], RW/P, default = 0x0
    //
    UINTX stop_subsequence_on_base_wrap_trigger : 1;
  } Bits;
  UINTX Data;
} CPGC_SUBSEQ4_CTL_A_CPGC_STRUCT;
#endif // ASM_INC

#define CPGC_SUBSEQ4_CTL_B_CPGC_REG                        0x000000C4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Size of requests CPGC is issuing, 64B and 32B transactions and is encoded as follows:[br]
    // 0 - 32 Byte Transactions[br]
    // 1 - 64 Byte Transactions
    // 
    // Bits[0:0], RW/P, default = 0x1
    //
    UINTX request_data_size : 1;
    //
    // If set, refresh commands will be blocked for the duration of the wait period specified
    // by SUBSEQUENCE_WAIT.  Otherwise refreshes will be enabled for that period of time.
    // 
    // Bits[1:1], RW/P, default = 0x0
    //
    UINTX subsequence_wait_refresh_block : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:2], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 6;
    //
    // Four bit exponential timer according to 2^(TIMER). This is used to dynamically
    // replace SUBSEQUENCE_WAIT counter if POWER_MODE_ON is asserted for the particular
    // Subsequence 
    // 
    // Bits[11:8], RW/P, default = 0x0
    //
    UINTX timer : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[14:12], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 3;
    //
    // Allows the Subsequence wait counter to be replaced by the value set in TIMER field
    // when the D-unit enters Self-Refresh or Power-Down. This is used for power state
    // stress testing 
    // 
    // Bits[15:15], RW/P, default = 0x0
    //
    UINTX power_mode_on : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[20:16], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 5;
    //
    // If set, the CADB will be able to issue harassment patterns into the command and
    // address bus. 
    // 
    // Bits[21:21], RW/P, default = 0x0
    //
    UINTX subsequence_cadb_deselect_on : 1;
    //
    // SUBSEQUENCE_CADB_SELECT_ON is an ON/OFF signal in the subsequence logic that determines
    // whether a particular subsequence allows the CADB contents to be driven during
    // Select cycles. 
    // 
    // Bits[22:22], RW/P, default = 0x0
    //
    UINTX subsequence_cadb_select_on : 1;
    //
    // SUBSEQUENCE_CADB_SEEDS_SAVE_EN is an ON/OFF signal in the subsequence logic that
    // determines whether a particular subsequence allows the CADB PB/ LFSRs to saved.
    // 
    // Bits[23:23], RW/P, default = 0x0
    //
    UINTX subsequence_cadb_seeds_save_en : 1;
    //
    // SUBSEQUENCE_CADB_SEEDS_RELOAD_EN is an ON/OFF signal in the subsequence logic
    // that determines whether a particular subsequence allows the CADB PB/ LFSRs to
    // reload. 
    // 
    // Bits[24:24], RW/P, default = 0x0
    //
    UINTX subsequence_cadb_seeds_reload_en : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:25], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_3 : 7;
  } Bits;
  UINTX Data;
} CPGC_SUBSEQ4_CTL_B_CPGC_STRUCT;
#endif // ASM_INC

#define CPGC_SUBSEQ4_VAR_CPGC_REG                          0x000000C8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // 0 - Linear Variable Address Segment[br]       1 - Scrambled Variable Address Segment
    // 
    // Bits[0:0], RW/P, default = 0x0
    //
    UINTX var_scramble : 1;
    //
    // This field is used to program the VAR address segment for the command sequence
    // 
    // Bits[15:1], RW/P, default = 0x0
    //
    UINTX var_segment : 15;
    //
    // The Width of the VAR address segment for the sequence will be set to the following
    // number of bits[br] 
    //                         0000 -  5 bits[br]
    //                         0001 -  6 bits[br]
    //                         0010 -  7 bits[br]
    //                         0011 -  8 bits[br]
    //                         0100 -  9 bits[br]
    //                         0101 - 10 bits[br]
    //                         0110 - 11 bits[br]
    //                         0111 - 12 bits[br]
    //                         1000 - 13 bits[br]
    //                         1001 - 14 bits[br]
    //                         1010 - 15 bits[br]
    //                         All other values are reserved 
    // 
    // Bits[19:16], RW/P, default = 0x0
    //
    UINTX var_width : 4;
    //
    // The lower 3-bits of the VAR address segment will be shifted to the left by VAR_LO_SHIFT
    // bits 
    // 
    // Bits[24:20], RW/P, default = 0x0
    //
    UINTX var_lo_shift : 5;
    //
    // The upper (VAR_WIDTH - 3)-bits of the VAR address segment will be shifted to the
    // left by VAR_HI_SHIFT bits 
    // 
    // Bits[29:25], RW/P, default = 0x0
    //
    UINTX var_hi_shift : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:30], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
  } Bits;
  UINTX Data;
} CPGC_SUBSEQ4_VAR_CPGC_STRUCT;
#endif // ASM_INC

#define CPGC_SUBSEQ4_FIX_CPGC_REG                          0x000000CC
#ifndef ASM_INC
typedef union {
  struct {
    //
    // This field is used to program the FIX address segment for this Subsequence. Note:
    //  The width of this field is dependent on the channel address width and maybe different
    // for different implementations. 
    // 
    // Bits[30:0], RW/P, default = 0x0
    //
    UINTX fix_segment : 31;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:31], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 1;
  } Bits;
  UINTX Data;
} CPGC_SUBSEQ4_FIX_CPGC_STRUCT;
#endif // ASM_INC

#define CPGC_SUBSEQ5_CTL_A_CPGC_REG                        0x000000D0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // If NUMBER_OF_BURSTS_SCALE == 0[br] Number of bursts (CAS commands) composing the
    // subsequence is equal to 2^(NUMBER_OF_BURSTS). Only bits [3:0] are supported if
    // set as an exponential counter.[br][br] If NUMBER_OF_BURSTS_SCALE == 1[br] Number
    // of bursts (CAS commands) composing the subsequence is equal to NUMBER_OF_BURSTS.
    // All bits are supported. Setting NUMBER_OF_BURSTS_SCALE to 1 and NUMBER_OF_BURSTS
    // to 0 will result in an infinite number of bursts being issued.[br][br] If CPGC_SEQ_CFG.ADDR_BKWRD_COMP
    // is set 1 then:[br] A value of 0 stands for infinite number of bursts and enables
    // the Infinite Burst Addressing mode[br] Note: Only bits [3:0] are supported if
    // set as an exponential counter. If set as a linear counter and NUMBER_OF_BURSTS
    // == 0, then the SubSequence will issue an infinite number of transactions. 
    // 
    // Bits[6:0], RW/P, default = 0x0
    //
    UINTX number_of_bursts : 7;
    //
    // If set to 0 then NUMBER_OF_BURSTS operates as an exponential counter.[br] If set
    // to 1 then NUMBER_OF_BURSTS operates as a linear counter.. 
    // 
    // Bits[7:7], RW/P, default = 0x0
    //
    UINTX number_of_bursts_scale : 1;
    //
    // Number of clock cycles (in CPGC-S clock domain) between finishing a Subsequence
    // and the beginning of the next Subsequence is defined by SUBSEQUENCE_WAIT.  The
    // wait period is considered independent from the Subsequence itself and hence refresh
    // commands can be Enabled/Disabled for the wait period independent of the preceding
    // Subsequence. 
    // 
    // Bits[21:8], RW/P, default = 0x0
    //
    UINTX subsequence_wait : 14;
    //
    // This field defines the type of commands this sequence will issue:[br]
    // 0000 - Read Commands[br]
    // 0001 - Write Commands[br]
    // 0010 - Read Commands -> Write Commands[br]
    // 0011 - Write Commands -> Read Commands[br]
    // 0100 - Offset Read[br]
    // 0101 - Offset Write[br]
    // 1000 - Read Commands (Self Refresh Exit)[br]
    // 1001 - Write Commands (Self Refresh Exit)[br]
    // 1010 - Read Commands -> Write Commands (Self Refresh Exit)[br]
    // 1011 - Write Commands -> Read Commands (Self Refresh Exit)[br]
    // All other values are reserved for future use.
    // 
    // Bits[25:22], RW/P, default = 0x0
    //
    UINTX subsequence_type : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[26:26], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 1;
    //
    // If CPGC_SEQ_CFG.ADDR_BKWRD_COMP is set then:[br] This bit will force the subsequence
    // to reload its initial address from each time before it starts. This bit is not
    // applicable to Infinite Burst Addressing mode.[br][br] If CPGC_SEQ_CFG.ADDR_BKWRD_COMP
    // is set to 0 then:[br] Upon entry to a subsequence where RESET_CURRENT_BASE_ADDRESS_TO_START
    // is set:[br] 
    // 1) Base Current Address (CPGC_SEQ_BASE_ADDR_CURRENT) gets immediately re initialized
    // to the Base Starting Address (CPGC_SEQ_BASE_ADDR_START).[br] 
    // 2) Reset the:[br]
    // Rank_Base_Address_Update_Rate,[br]
    // Bank_Base_Address_Update_Rate,[br]
    // Row_Base_Address_Update_Rate, and[br]
    // Column_Base_Address_Update_Rate(CPGC_SEQ_BASE_ADDR_INC_CTL)[br][br]
    // 3) Reset the Base_Address_Invert_Rate(CPGC_SEQ_BASE_ADDR_ORDER_CARRY_INVERT_CTL)[br][br]
    // In the case where both SAVE_ADDR = 1 and RESET_CURRENT_BASE_ADDRESS_TO_START =
    // 1 then only SAVE_ADDR = 1 will take effect and RESET_CURRENT_BASE_ADDRESS_TO_START
    // =1 will be ignored.[br][br] 
    // Use case: long WR subseq and then long RD subseq: RD should set this field on,
    // WR should set the next one (Save_Current_Base_Address_To_Start) on. 
    // 
    // Bits[27:27], RW/P, default = 0x0
    //
    UINTX reset_current_base_address_to_start : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[30:28], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 3;
    //
    // If the Subsequence is running in the infinite burst mode, setting this bit will
    // cause a transition from this Subsequence to the next Subsequence (after the wait
    // period) once the channel address hits the wrap address defined by WRAP_ADDR -
    // 1. This bit is not used for finite burst addressing mode. 
    // 
    // Bits[31:31], RW/P, default = 0x0
    //
    UINTX stop_subsequence_on_base_wrap_trigger : 1;
  } Bits;
  UINTX Data;
} CPGC_SUBSEQ5_CTL_A_CPGC_STRUCT;
#endif // ASM_INC

#define CPGC_SUBSEQ5_CTL_B_CPGC_REG                        0x000000D4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Size of requests CPGC is issuing, 64B and 32B transactions and is encoded as follows:[br]
    // 0 - 32 Byte Transactions[br]
    // 1 - 64 Byte Transactions
    // 
    // Bits[0:0], RW/P, default = 0x1
    //
    UINTX request_data_size : 1;
    //
    // If set, refresh commands will be blocked for the duration of the wait period specified
    // by SUBSEQUENCE_WAIT.  Otherwise refreshes will be enabled for that period of time.
    // 
    // Bits[1:1], RW/P, default = 0x0
    //
    UINTX subsequence_wait_refresh_block : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:2], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 6;
    //
    // Four bit exponential timer according to 2^(TIMER). This is used to dynamically
    // replace SUBSEQUENCE_WAIT counter if POWER_MODE_ON is asserted for the particular
    // Subsequence 
    // 
    // Bits[11:8], RW/P, default = 0x0
    //
    UINTX timer : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[14:12], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 3;
    //
    // Allows the Subsequence wait counter to be replaced by the value set in TIMER field
    // when the D-unit enters Self-Refresh or Power-Down. This is used for power state
    // stress testing 
    // 
    // Bits[15:15], RW/P, default = 0x0
    //
    UINTX power_mode_on : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[20:16], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 5;
    //
    // If set, the CADB will be able to issue harassment patterns into the command and
    // address bus. 
    // 
    // Bits[21:21], RW/P, default = 0x0
    //
    UINTX subsequence_cadb_deselect_on : 1;
    //
    // SUBSEQUENCE_CADB_SELECT_ON is an ON/OFF signal in the subsequence logic that determines
    // whether a particular subsequence allows the CADB contents to be driven during
    // Select cycles. 
    // 
    // Bits[22:22], RW/P, default = 0x0
    //
    UINTX subsequence_cadb_select_on : 1;
    //
    // SUBSEQUENCE_CADB_SEEDS_SAVE_EN is an ON/OFF signal in the subsequence logic that
    // determines whether a particular subsequence allows the CADB PB/ LFSRs to saved.
    // 
    // Bits[23:23], RW/P, default = 0x0
    //
    UINTX subsequence_cadb_seeds_save_en : 1;
    //
    // SUBSEQUENCE_CADB_SEEDS_RELOAD_EN is an ON/OFF signal in the subsequence logic
    // that determines whether a particular subsequence allows the CADB PB/ LFSRs to
    // reload. 
    // 
    // Bits[24:24], RW/P, default = 0x0
    //
    UINTX subsequence_cadb_seeds_reload_en : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:25], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_3 : 7;
  } Bits;
  UINTX Data;
} CPGC_SUBSEQ5_CTL_B_CPGC_STRUCT;
#endif // ASM_INC

#define CPGC_SUBSEQ5_VAR_CPGC_REG                          0x000000D8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // 0 - Linear Variable Address Segment[br]       1 - Scrambled Variable Address Segment
    // 
    // Bits[0:0], RW/P, default = 0x0
    //
    UINTX var_scramble : 1;
    //
    // This field is used to program the VAR address segment for the command sequence
    // 
    // Bits[15:1], RW/P, default = 0x0
    //
    UINTX var_segment : 15;
    //
    // The Width of the VAR address segment for the sequence will be set to the following
    // number of bits[br] 
    //                         0000 -  5 bits[br]
    //                         0001 -  6 bits[br]
    //                         0010 -  7 bits[br]
    //                         0011 -  8 bits[br]
    //                         0100 -  9 bits[br]
    //                         0101 - 10 bits[br]
    //                         0110 - 11 bits[br]
    //                         0111 - 12 bits[br]
    //                         1000 - 13 bits[br]
    //                         1001 - 14 bits[br]
    //                         1010 - 15 bits[br]
    //                         All other values are reserved 
    // 
    // Bits[19:16], RW/P, default = 0x0
    //
    UINTX var_width : 4;
    //
    // The lower 3-bits of the VAR address segment will be shifted to the left by VAR_LO_SHIFT
    // bits 
    // 
    // Bits[24:20], RW/P, default = 0x0
    //
    UINTX var_lo_shift : 5;
    //
    // The upper (VAR_WIDTH - 3)-bits of the VAR address segment will be shifted to the
    // left by VAR_HI_SHIFT bits 
    // 
    // Bits[29:25], RW/P, default = 0x0
    //
    UINTX var_hi_shift : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:30], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
  } Bits;
  UINTX Data;
} CPGC_SUBSEQ5_VAR_CPGC_STRUCT;
#endif // ASM_INC

#define CPGC_SUBSEQ5_FIX_CPGC_REG                          0x000000DC
#ifndef ASM_INC
typedef union {
  struct {
    //
    // This field is used to program the FIX address segment for this Subsequence. Note:
    //  The width of this field is dependent on the channel address width and maybe different
    // for different implementations. 
    // 
    // Bits[30:0], RW/P, default = 0x0
    //
    UINTX fix_segment : 31;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:31], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 1;
  } Bits;
  UINTX Data;
} CPGC_SUBSEQ5_FIX_CPGC_STRUCT;
#endif // ASM_INC

#define CPGC_SUBSEQ6_CTL_A_CPGC_REG                        0x000000E0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // If NUMBER_OF_BURSTS_SCALE == 0[br] Number of bursts (CAS commands) composing the
    // subsequence is equal to 2^(NUMBER_OF_BURSTS). Only bits [3:0] are supported if
    // set as an exponential counter.[br][br] If NUMBER_OF_BURSTS_SCALE == 1[br] Number
    // of bursts (CAS commands) composing the subsequence is equal to NUMBER_OF_BURSTS.
    // All bits are supported. Setting NUMBER_OF_BURSTS_SCALE to 1 and NUMBER_OF_BURSTS
    // to 0 will result in an infinite number of bursts being issued.[br][br] If CPGC_SEQ_CFG.ADDR_BKWRD_COMP
    // is set 1 then:[br] A value of 0 stands for infinite number of bursts and enables
    // the Infinite Burst Addressing mode[br] Note: Only bits [3:0] are supported if
    // set as an exponential counter. If set as a linear counter and NUMBER_OF_BURSTS
    // == 0, then the SubSequence will issue an infinite number of transactions. 
    // 
    // Bits[6:0], RW/P, default = 0x0
    //
    UINTX number_of_bursts : 7;
    //
    // If set to 0 then NUMBER_OF_BURSTS operates as an exponential counter.[br] If set
    // to 1 then NUMBER_OF_BURSTS operates as a linear counter.. 
    // 
    // Bits[7:7], RW/P, default = 0x0
    //
    UINTX number_of_bursts_scale : 1;
    //
    // Number of clock cycles (in CPGC-S clock domain) between finishing a Subsequence
    // and the beginning of the next Subsequence is defined by SUBSEQUENCE_WAIT.  The
    // wait period is considered independent from the Subsequence itself and hence refresh
    // commands can be Enabled/Disabled for the wait period independent of the preceding
    // Subsequence. 
    // 
    // Bits[21:8], RW/P, default = 0x0
    //
    UINTX subsequence_wait : 14;
    //
    // This field defines the type of commands this sequence will issue:[br]
    // 0000 - Read Commands[br]
    // 0001 - Write Commands[br]
    // 0010 - Read Commands -> Write Commands[br]
    // 0011 - Write Commands -> Read Commands[br]
    // 0100 - Offset Read[br]
    // 0101 - Offset Write[br]
    // 1000 - Read Commands (Self Refresh Exit)[br]
    // 1001 - Write Commands (Self Refresh Exit)[br]
    // 1010 - Read Commands -> Write Commands (Self Refresh Exit)[br]
    // 1011 - Write Commands -> Read Commands (Self Refresh Exit)[br]
    // All other values are reserved for future use.
    // 
    // Bits[25:22], RW/P, default = 0x0
    //
    UINTX subsequence_type : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[26:26], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 1;
    //
    // If CPGC_SEQ_CFG.ADDR_BKWRD_COMP is set then:[br] This bit will force the subsequence
    // to reload its initial address from each time before it starts. This bit is not
    // applicable to Infinite Burst Addressing mode.[br][br] If CPGC_SEQ_CFG.ADDR_BKWRD_COMP
    // is set to 0 then:[br] Upon entry to a subsequence where RESET_CURRENT_BASE_ADDRESS_TO_START
    // is set:[br] 
    // 1) Base Current Address (CPGC_SEQ_BASE_ADDR_CURRENT) gets immediately re initialized
    // to the Base Starting Address (CPGC_SEQ_BASE_ADDR_START).[br] 
    // 2) Reset the:[br]
    // Rank_Base_Address_Update_Rate,[br]
    // Bank_Base_Address_Update_Rate,[br]
    // Row_Base_Address_Update_Rate, and[br]
    // Column_Base_Address_Update_Rate(CPGC_SEQ_BASE_ADDR_INC_CTL)[br][br]
    // 3) Reset the Base_Address_Invert_Rate(CPGC_SEQ_BASE_ADDR_ORDER_CARRY_INVERT_CTL)[br][br]
    // In the case where both SAVE_ADDR = 1 and RESET_CURRENT_BASE_ADDRESS_TO_START =
    // 1 then only SAVE_ADDR = 1 will take effect and RESET_CURRENT_BASE_ADDRESS_TO_START
    // =1 will be ignored.[br][br] 
    // Use case: long WR subseq and then long RD subseq: RD should set this field on,
    // WR should set the next one (Save_Current_Base_Address_To_Start) on. 
    // 
    // Bits[27:27], RW/P, default = 0x0
    //
    UINTX reset_current_base_address_to_start : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[30:28], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 3;
    //
    // If the Subsequence is running in the infinite burst mode, setting this bit will
    // cause a transition from this Subsequence to the next Subsequence (after the wait
    // period) once the channel address hits the wrap address defined by WRAP_ADDR -
    // 1. This bit is not used for finite burst addressing mode. 
    // 
    // Bits[31:31], RW/P, default = 0x0
    //
    UINTX stop_subsequence_on_base_wrap_trigger : 1;
  } Bits;
  UINTX Data;
} CPGC_SUBSEQ6_CTL_A_CPGC_STRUCT;
#endif // ASM_INC

#define CPGC_SUBSEQ6_CTL_B_CPGC_REG                        0x000000E4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Size of requests CPGC is issuing, 64B and 32B transactions and is encoded as follows:[br]
    // 0 - 32 Byte Transactions[br]
    // 1 - 64 Byte Transactions
    // 
    // Bits[0:0], RW/P, default = 0x1
    //
    UINTX request_data_size : 1;
    //
    // If set, refresh commands will be blocked for the duration of the wait period specified
    // by SUBSEQUENCE_WAIT.  Otherwise refreshes will be enabled for that period of time.
    // 
    // Bits[1:1], RW/P, default = 0x0
    //
    UINTX subsequence_wait_refresh_block : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:2], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 6;
    //
    // Four bit exponential timer according to 2^(TIMER). This is used to dynamically
    // replace SUBSEQUENCE_WAIT counter if POWER_MODE_ON is asserted for the particular
    // Subsequence 
    // 
    // Bits[11:8], RW/P, default = 0x0
    //
    UINTX timer : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[14:12], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 3;
    //
    // Allows the Subsequence wait counter to be replaced by the value set in TIMER field
    // when the D-unit enters Self-Refresh or Power-Down. This is used for power state
    // stress testing 
    // 
    // Bits[15:15], RW/P, default = 0x0
    //
    UINTX power_mode_on : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[20:16], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 5;
    //
    // If set, the CADB will be able to issue harassment patterns into the command and
    // address bus. 
    // 
    // Bits[21:21], RW/P, default = 0x0
    //
    UINTX subsequence_cadb_deselect_on : 1;
    //
    // SUBSEQUENCE_CADB_SELECT_ON is an ON/OFF signal in the subsequence logic that determines
    // whether a particular subsequence allows the CADB contents to be driven during
    // Select cycles. 
    // 
    // Bits[22:22], RW/P, default = 0x0
    //
    UINTX subsequence_cadb_select_on : 1;
    //
    // SUBSEQUENCE_CADB_SEEDS_SAVE_EN is an ON/OFF signal in the subsequence logic that
    // determines whether a particular subsequence allows the CADB PB/ LFSRs to saved.
    // 
    // Bits[23:23], RW/P, default = 0x0
    //
    UINTX subsequence_cadb_seeds_save_en : 1;
    //
    // SUBSEQUENCE_CADB_SEEDS_RELOAD_EN is an ON/OFF signal in the subsequence logic
    // that determines whether a particular subsequence allows the CADB PB/ LFSRs to
    // reload. 
    // 
    // Bits[24:24], RW/P, default = 0x0
    //
    UINTX subsequence_cadb_seeds_reload_en : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:25], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_3 : 7;
  } Bits;
  UINTX Data;
} CPGC_SUBSEQ6_CTL_B_CPGC_STRUCT;
#endif // ASM_INC

#define CPGC_SUBSEQ6_VAR_CPGC_REG                          0x000000E8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // 0 - Linear Variable Address Segment[br]       1 - Scrambled Variable Address Segment
    // 
    // Bits[0:0], RW/P, default = 0x0
    //
    UINTX var_scramble : 1;
    //
    // This field is used to program the VAR address segment for the command sequence
    // 
    // Bits[15:1], RW/P, default = 0x0
    //
    UINTX var_segment : 15;
    //
    // The Width of the VAR address segment for the sequence will be set to the following
    // number of bits[br] 
    //                         0000 -  5 bits[br]
    //                         0001 -  6 bits[br]
    //                         0010 -  7 bits[br]
    //                         0011 -  8 bits[br]
    //                         0100 -  9 bits[br]
    //                         0101 - 10 bits[br]
    //                         0110 - 11 bits[br]
    //                         0111 - 12 bits[br]
    //                         1000 - 13 bits[br]
    //                         1001 - 14 bits[br]
    //                         1010 - 15 bits[br]
    //                         All other values are reserved 
    // 
    // Bits[19:16], RW/P, default = 0x0
    //
    UINTX var_width : 4;
    //
    // The lower 3-bits of the VAR address segment will be shifted to the left by VAR_LO_SHIFT
    // bits 
    // 
    // Bits[24:20], RW/P, default = 0x0
    //
    UINTX var_lo_shift : 5;
    //
    // The upper (VAR_WIDTH - 3)-bits of the VAR address segment will be shifted to the
    // left by VAR_HI_SHIFT bits 
    // 
    // Bits[29:25], RW/P, default = 0x0
    //
    UINTX var_hi_shift : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:30], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
  } Bits;
  UINTX Data;
} CPGC_SUBSEQ6_VAR_CPGC_STRUCT;
#endif // ASM_INC

#define CPGC_SUBSEQ6_FIX_CPGC_REG                          0x000000EC
#ifndef ASM_INC
typedef union {
  struct {
    //
    // This field is used to program the FIX address segment for this Subsequence. Note:
    //  The width of this field is dependent on the channel address width and maybe different
    // for different implementations. 
    // 
    // Bits[30:0], RW/P, default = 0x0
    //
    UINTX fix_segment : 31;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:31], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 1;
  } Bits;
  UINTX Data;
} CPGC_SUBSEQ6_FIX_CPGC_STRUCT;
#endif // ASM_INC

#define CPGC_SUBSEQ7_CTL_A_CPGC_REG                        0x000000F0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // If NUMBER_OF_BURSTS_SCALE == 0[br] Number of bursts (CAS commands) composing the
    // subsequence is equal to 2^(NUMBER_OF_BURSTS). Only bits [3:0] are supported if
    // set as an exponential counter.[br][br] If NUMBER_OF_BURSTS_SCALE == 1[br] Number
    // of bursts (CAS commands) composing the subsequence is equal to NUMBER_OF_BURSTS.
    // All bits are supported. Setting NUMBER_OF_BURSTS_SCALE to 1 and NUMBER_OF_BURSTS
    // to 0 will result in an infinite number of bursts being issued.[br][br] If CPGC_SEQ_CFG.ADDR_BKWRD_COMP
    // is set 1 then:[br] A value of 0 stands for infinite number of bursts and enables
    // the Infinite Burst Addressing mode[br] Note: Only bits [3:0] are supported if
    // set as an exponential counter. If set as a linear counter and NUMBER_OF_BURSTS
    // == 0, then the SubSequence will issue an infinite number of transactions. 
    // 
    // Bits[6:0], RW/P, default = 0x0
    //
    UINTX number_of_bursts : 7;
    //
    // If set to 0 then NUMBER_OF_BURSTS operates as an exponential counter.[br] If set
    // to 1 then NUMBER_OF_BURSTS operates as a linear counter.. 
    // 
    // Bits[7:7], RW/P, default = 0x0
    //
    UINTX number_of_bursts_scale : 1;
    //
    // Number of clock cycles (in CPGC-S clock domain) between finishing a Subsequence
    // and the beginning of the next Subsequence is defined by SUBSEQUENCE_WAIT.  The
    // wait period is considered independent from the Subsequence itself and hence refresh
    // commands can be Enabled/Disabled for the wait period independent of the preceding
    // Subsequence. 
    // 
    // Bits[21:8], RW/P, default = 0x0
    //
    UINTX subsequence_wait : 14;
    //
    // This field defines the type of commands this sequence will issue:[br]
    // 0000 - Read Commands[br]
    // 0001 - Write Commands[br]
    // 0010 - Read Commands -> Write Commands[br]
    // 0011 - Write Commands -> Read Commands[br]
    // 0100 - Offset Read[br]
    // 0101 - Offset Write[br]
    // 1000 - Read Commands (Self Refresh Exit)[br]
    // 1001 - Write Commands (Self Refresh Exit)[br]
    // 1010 - Read Commands -> Write Commands (Self Refresh Exit)[br]
    // 1011 - Write Commands -> Read Commands (Self Refresh Exit)[br]
    // All other values are reserved for future use.
    // 
    // Bits[25:22], RW/P, default = 0x0
    //
    UINTX subsequence_type : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[26:26], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 1;
    //
    // If CPGC_SEQ_CFG.ADDR_BKWRD_COMP is set then:[br] This bit will force the subsequence
    // to reload its initial address from each time before it starts. This bit is not
    // applicable to Infinite Burst Addressing mode.[br][br] If CPGC_SEQ_CFG.ADDR_BKWRD_COMP
    // is set to 0 then:[br] Upon entry to a subsequence where RESET_CURRENT_BASE_ADDRESS_TO_START
    // is set:[br] 
    // 1) Base Current Address (CPGC_SEQ_BASE_ADDR_CURRENT) gets immediately re initialized
    // to the Base Starting Address (CPGC_SEQ_BASE_ADDR_START).[br] 
    // 2) Reset the:[br]
    // Rank_Base_Address_Update_Rate,[br]
    // Bank_Base_Address_Update_Rate,[br]
    // Row_Base_Address_Update_Rate, and[br]
    // Column_Base_Address_Update_Rate(CPGC_SEQ_BASE_ADDR_INC_CTL)[br][br]
    // 3) Reset the Base_Address_Invert_Rate(CPGC_SEQ_BASE_ADDR_ORDER_CARRY_INVERT_CTL)[br][br]
    // In the case where both SAVE_ADDR = 1 and RESET_CURRENT_BASE_ADDRESS_TO_START =
    // 1 then only SAVE_ADDR = 1 will take effect and RESET_CURRENT_BASE_ADDRESS_TO_START
    // =1 will be ignored.[br][br] 
    // Use case: long WR subseq and then long RD subseq: RD should set this field on,
    // WR should set the next one (Save_Current_Base_Address_To_Start) on. 
    // 
    // Bits[27:27], RW/P, default = 0x0
    //
    UINTX reset_current_base_address_to_start : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[30:28], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 3;
    //
    // If the Subsequence is running in the infinite burst mode, setting this bit will
    // cause a transition from this Subsequence to the next Subsequence (after the wait
    // period) once the channel address hits the wrap address defined by WRAP_ADDR -
    // 1. This bit is not used for finite burst addressing mode. 
    // 
    // Bits[31:31], RW/P, default = 0x0
    //
    UINTX stop_subsequence_on_base_wrap_trigger : 1;
  } Bits;
  UINTX Data;
} CPGC_SUBSEQ7_CTL_A_CPGC_STRUCT;
#endif // ASM_INC

#define CPGC_SUBSEQ7_CTL_B_CPGC_REG                        0x000000F4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Size of requests CPGC is issuing, 64B and 32B transactions and is encoded as follows:[br]
    // 0 - 32 Byte Transactions[br]
    // 1 - 64 Byte Transactions
    // 
    // Bits[0:0], RW/P, default = 0x1
    //
    UINTX request_data_size : 1;
    //
    // If set, refresh commands will be blocked for the duration of the wait period specified
    // by SUBSEQUENCE_WAIT.  Otherwise refreshes will be enabled for that period of time.
    // 
    // Bits[1:1], RW/P, default = 0x0
    //
    UINTX subsequence_wait_refresh_block : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:2], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 6;
    //
    // Four bit exponential timer according to 2^(TIMER). This is used to dynamically
    // replace SUBSEQUENCE_WAIT counter if POWER_MODE_ON is asserted for the particular
    // Subsequence 
    // 
    // Bits[11:8], RW/P, default = 0x0
    //
    UINTX timer : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[14:12], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 3;
    //
    // Allows the Subsequence wait counter to be replaced by the value set in TIMER field
    // when the D-unit enters Self-Refresh or Power-Down. This is used for power state
    // stress testing 
    // 
    // Bits[15:15], RW/P, default = 0x0
    //
    UINTX power_mode_on : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[20:16], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 5;
    //
    // If set, the CADB will be able to issue harassment patterns into the command and
    // address bus. 
    // 
    // Bits[21:21], RW/P, default = 0x0
    //
    UINTX subsequence_cadb_deselect_on : 1;
    //
    // SUBSEQUENCE_CADB_SELECT_ON is an ON/OFF signal in the subsequence logic that determines
    // whether a particular subsequence allows the CADB contents to be driven during
    // Select cycles. 
    // 
    // Bits[22:22], RW/P, default = 0x0
    //
    UINTX subsequence_cadb_select_on : 1;
    //
    // SUBSEQUENCE_CADB_SEEDS_SAVE_EN is an ON/OFF signal in the subsequence logic that
    // determines whether a particular subsequence allows the CADB PB/ LFSRs to saved.
    // 
    // Bits[23:23], RW/P, default = 0x0
    //
    UINTX subsequence_cadb_seeds_save_en : 1;
    //
    // SUBSEQUENCE_CADB_SEEDS_RELOAD_EN is an ON/OFF signal in the subsequence logic
    // that determines whether a particular subsequence allows the CADB PB/ LFSRs to
    // reload. 
    // 
    // Bits[24:24], RW/P, default = 0x0
    //
    UINTX subsequence_cadb_seeds_reload_en : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:25], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_3 : 7;
  } Bits;
  UINTX Data;
} CPGC_SUBSEQ7_CTL_B_CPGC_STRUCT;
#endif // ASM_INC

#define CPGC_SUBSEQ7_VAR_CPGC_REG                          0x000000F8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // 0 - Linear Variable Address Segment[br]       1 - Scrambled Variable Address Segment
    // 
    // Bits[0:0], RW/P, default = 0x0
    //
    UINTX var_scramble : 1;
    //
    // This field is used to program the VAR address segment for the command sequence
    // 
    // Bits[15:1], RW/P, default = 0x0
    //
    UINTX var_segment : 15;
    //
    // The Width of the VAR address segment for the sequence will be set to the following
    // number of bits[br] 
    //                         0000 -  5 bits[br]
    //                         0001 -  6 bits[br]
    //                         0010 -  7 bits[br]
    //                         0011 -  8 bits[br]
    //                         0100 -  9 bits[br]
    //                         0101 - 10 bits[br]
    //                         0110 - 11 bits[br]
    //                         0111 - 12 bits[br]
    //                         1000 - 13 bits[br]
    //                         1001 - 14 bits[br]
    //                         1010 - 15 bits[br]
    //                         All other values are reserved 
    // 
    // Bits[19:16], RW/P, default = 0x0
    //
    UINTX var_width : 4;
    //
    // The lower 3-bits of the VAR address segment will be shifted to the left by VAR_LO_SHIFT
    // bits 
    // 
    // Bits[24:20], RW/P, default = 0x0
    //
    UINTX var_lo_shift : 5;
    //
    // The upper (VAR_WIDTH - 3)-bits of the VAR address segment will be shifted to the
    // left by VAR_HI_SHIFT bits 
    // 
    // Bits[29:25], RW/P, default = 0x0
    //
    UINTX var_hi_shift : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:30], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
  } Bits;
  UINTX Data;
} CPGC_SUBSEQ7_VAR_CPGC_STRUCT;
#endif // ASM_INC

#define CPGC_SUBSEQ7_FIX_CPGC_REG                          0x000000FC
#ifndef ASM_INC
typedef union {
  struct {
    //
    // This field is used to program the FIX address segment for this Subsequence. Note:
    //  The width of this field is dependent on the channel address width and maybe different
    // for different implementations. 
    // 
    // Bits[30:0], RW/P, default = 0x0
    //
    UINTX fix_segment : 31;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:31], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 1;
  } Bits;
  UINTX Data;
} CPGC_SUBSEQ7_FIX_CPGC_STRUCT;
#endif // ASM_INC

#define CPGC_CADB_CAP_CPGC_REG                             0x00000100
#ifndef ASM_INC
typedef union {
  struct {
    //
    // The number of unified sequencers supported for command/address pattern generation
    // is encoded as follows:[br] 
    // 01 - 2 Unified Sequencers[br]
    // 10 - 3 Unified Sequencers[br]
    // 11 - 4 Unified Sequencers[br]
    // All other values are reserved for future use.
    // 
    // Bits[1:0], RO, default = 0x2
    //
    UINTX num_uniseq_cap : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[2:2], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 1;
    //
    // The Unified Sequencer Width supported for command/address pattern generation is
    // encoded as follows:[br] 
    // 0 - 16-bit[br]
    // 1 - 32-bit.
    // 
    // Bits[3:3], RO, default = 0x0
    //
    UINTX uniseq_width_cap : 1;
    //
    // The CADB block supports linear walking of the Buffer with a fixed delay in between
    // selecting new buffer entries. 
    // 
    // Bits[4:4], RO, default = 0x1
    //
    UINTX mrs_linear_sequencing : 1;
    //
    // If set, the CADB implementation supports means to trigger deselect packets after
    // (or in between) certain user defined DDR/LPDDRcommands. 
    // 
    // Bits[5:5], RO, default = 0x1
    //
    UINTX deselect_trigger_on_cmd : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:6], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 26;
  } Bits;
  UINTX Data;
} CPGC_CADB_CAP_CPGC_STRUCT;
#endif // ASM_INC

#define CPGC_CADB_CTL_CPGC_REG                             0x00000104
#ifndef ASM_INC
typedef union {
  struct {
    //
    // The operation mode of the command/address pattern generator is encoded as follows:[br]
    // 00 - Sequencer and CAS command Driven: Same as Global Deselect though in this
    // mode determinism is enforced as now CADB valid deselect patterns will depend on
    // the values programmed on Lane_Deselect_Enable and CMD_Deselect_Enable thus allowing
    // Deselect to synchronize with various CMD events and Subsequence control bits.[br]
    // 01 - Global Deselect: Pattern stored in the command/address buffers will be driven
    // on the bus during deselect cycles only whenever SoC CPGC is in ACTIVE or NORMAL
    // modes.  SoC CPGC will drive out the pattern stored in the command/address buffers
    // on all command and address signals (except CKE, and ODT). User can chose which
    // ADDRESS/CMD lanes to be enabled in this mode. CS is special refert to it in LANE_DESELECT_EN
    // .[br] 
    // 10 - Always On: Pattern stored in the command/address buffers will be driven on
    // all command and address signals on every DCLK cycle only if SoC CPGC is in ACTIVE
    // mode.  This is not a functional mode and should only be used for BDV purposes.[br]
    // 11 - RESERVED: 
    // 
    // Bits[1:0], RW/P, default = 0x0
    //
    UINTX cadb_mode : 2;
    //
    // Setting Bit 5 - Start Driving Deselects on the following cycle after a PRE CMD
    // if CADB_Deselect_Enable is high[br] 
    // Setting Bit 4 - Start Driving Deselects on the following cycle after an ACT CMD
    // if CADB_Deselect_Enable is high[br] 
    // Setting Bit 3 - Start Driving Deselects on the following cycle after a RD CMD
    // if CADB_Deselect_Enable is high[br] 
    // Setting Bit 2 - Start Driving Deselects on the following cycle after a WR CMD
    // if CADB_Deselect_Enable is high[br] 
    // 
    // Bits[5:2], RW/P, default = 0x0
    //
    UINTX cmd_deselect_start : 4;
    //
    // Setting Bit 9 - Stop Driving Deselects on the following cycle after a PRE CMD
    // if Deselects where transmitting beforehand[br] 
    // Setting Bit 8 - Stop Driving Deselects on the following cycle after a ACT CMD
    // if Deselects where transmitting beforehand[br] 
    // Setting Bit 7 - Stop Driving Deselects on the following cycle after a RD CMD if
    // Deselects where transmitting beforehand[br] 
    // Setting Bit 6 - Stop Driving Deselects on the following cycle after a WR CMD if
    // Deselects where transmitting beforehand[br] 
    // Note: If Deselect was off before the command that is supposed to stop it, it will
    // remain in the off state. 
    // 
    // Bits[9:6], RW/P, default = 0x0
    //
    UINTX cmd_deselect_stop : 4;
    //
    // Setting Bit 13 - Drive CADB on Deselects on CS[br]
    // Setting Bit 12 - Drive CADB on Deselects on CMD[br]
    // Setting Bit 11 - Drive CADB on Deselects on BA[br]
    // Setting Bit 10 - Drive CADB on Deselects on MA[br]
    // Note: If CS is set than and CADB entry that also has CS set to one, the logic
    // overrides CMD signals w/NOP encoding, thus making CMD and CS mutually exclusive
    // to ensure no DDR functional violations occur. 
    // 
    // Bits[13:10], RW/P, default = 0x0
    //
    UINTX lane_deselect_enable : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[27:14], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 14;
    //
    // CADB will be able to generate single or double phase patterns.[br] 0: Patterns
    // will be generated in one phase.[br] 1: Patterns will be generated in two phases.
    // 
    // Bits[28:28], RW/P, default = 0x0
    //
    UINTX double_pump : 1;
    //
    // If set, the CADB pattern will reload each time the chosen CMD_DESELECT_START condition
    // is met 
    // 
    // Bits[29:29], RW/P, default = 0x0
    //
    UINTX cmd_deselect_restart : 1;
    //
    // If stall is activated, when a command comes during a stall cycle, the corresponding
    // pattern will be delayed for a clock cycle 
    // 
    // Bits[30:30], RW/P, default = 0x0
    //
    UINTX cmd_deselect_stall : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:31], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 1;
  } Bits;
  UINTX Data;
} CPGC_CADB_CTL_CPGC_STRUCT;
#endif // ASM_INC

#define CPGC_CADB_CFG_CPGC_REG                             0x00000108
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Defines the operational mode for unified sequence 0 as follows:[br]
    // 00 - LMN Mode[br]
    // 01 - Pattern Buffer Mode[br]
    // 10 - LFSR Mode[br]
    // 11 - Reserved for future use
    // 
    // Bits[1:0], WO, default = 0x1
    //
    UINTX uniseq0_mode : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[3:2], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
    //
    // Defines the operational mode for unified sequence 1 as follows:[br]
    // 00 - LMN Mode[br]
    // 01 - Pattern Buffer Mode[br]
    // 10 - LFSR Mode[br]
    // 11 - Reserved for future use
    // 
    // Bits[5:4], WO, default = 0x1
    //
    UINTX uniseq1_mode : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:6], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 2;
    //
    // Defines the operational mode for unified sequence 2 as follows:[br]
    // 00 - LMN Mode[br]
    // 01 - Pattern Buffer Mode[br]
    // 10 - LFSR Mode[br]
    // 11 - Reserved for future use
    // 
    // Bits[9:8], WO, default = 0x1
    //
    UINTX uniseq2_mode : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[15:10], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 6;
    //
    // Defines the operational mode for select unified sequence 0 as follows:[br]
    // 00 - Reserved for future use[br]
    // 01 - Pattern Buffer Mode[br]
    // 10 - LFSR Mode[br]
    // 11 - Reserved for future use
    // 
    // Bits[17:16], RW/P, default = 0x1
    //
    UINTX sel_uniseq0_mode : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[19:18], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_3 : 2;
    //
    // Defines the operational mode for select unified sequence 1 as follows:[br]
    // 00 - Reserved for future use[br]
    // 01 - Pattern Buffer Mode[br]
    // 10 - LFSR Mode[br]
    // 11 - Reserved for future use
    // 
    // Bits[21:20], RW/P, default = 0x1
    //
    UINTX sel_uniseq1_mode : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:22], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_4 : 2;
    //
    // Defines the operational mode for select unified sequence 2 as follows:[br]
    // 00 - Reserved for future use[br]
    // 01 - Pattern Buffer Mode[br]
    // 10 - LFSR Mode[br]
    // 11 - Reserved for future use
    // 
    // Bits[25:24], RW/P, default = 0x1
    //
    UINTX sel_uniseq2_mode : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:26], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_5 : 6;
  } Bits;
  UINTX Data;
} CPGC_CADB_CFG_CPGC_STRUCT;
#endif // ASM_INC

#define CPGC_CADB_MRS_CPGC_REG                             0x0000010C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // 2^(CADB_GAP +1) clock cycles between changing to the next MRS CADB entry[br] Note:
    // This GAP is applicable to both, MRS mode or normal CADB pattern gen. When used
    // for non MRS CADB pattern generation the formula changes to 2^(CADB_GAP) 
    // 
    // Bits[3:0], WO, default = 0x0
    //
    UINTX mrs_gap : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:4], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 4;
    //
    // Pointer to the first CADB entry to be used if on MRS mode[br] Note: This indexing
    // mode of the CADB buffer is only available if in CPGC_SEQ_CFG_0.INITIALIZATION_MODE
    // = MRS_MODE 
    // 
    // Bits[10:8], WO, default = 0x0
    //
    UINTX cadb_mrs_start_pointer : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[15:11], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 5;
    //
    // Pointer to the last CADB entry to be used if on MRS mode[br] Note: This indexing
    // mode of the CADB buffer is only available if in CPGC_SEQ_CFG_0.INITIALIZATION_MODE
    // = MRS_MODE 
    // 
    // Bits[18:16], WO, default = 0x7
    //
    UINTX cadb_mrs_end_pointer : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:19], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 5;
    //
    // N/A
    // 
    // Bits[26:24], RO/V, default = 0x0
    //
    UINTX mrs_curr_ptr : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[27:27], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_3 : 1;
    //
    // Only if it is set to 0 it will be deaserted at (1 or 2 cycles) number of cycles
    // at the middle of Gap CS is selected per entry and per rank[br] 
    // 00 - No Override[br]
    // 01 - No Override[br]
    // 10 - One Cycle CS[br]
    // 11 - Two Cycles CS
    // 
    // Bits[29:28], RW/P, default = 0x0
    //
    UINTX cadb_mrs_cs_ov_ext : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:30], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_4 : 2;
  } Bits;
  UINTX Data;
} CPGC_CADB_MRS_CPGC_STRUCT;
#endif // ASM_INC

#define CPGC_CADB_UNISEQ0_CPGC_REG                         0x00000110
#ifndef ASM_INC
typedef union {
  struct {
    //
    // The initial content of the rotating pattern buffer for the unified sequencer.[br]
    // Note: This is a shared register, it has a meaning according to the UniSeq# mode.
    // 
    // Bits[15:0], RW/P, default = 0xAA55
    //
    UINTX pattern_buffer : 16;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:16], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 16;
  } Bits;
  UINTX Data;
} CPGC_CADB_UNISEQ0_CPGC_STRUCT;
#endif // ASM_INC

#define CPGC_CADB_UNISEQ0_LMN_CPGC_REG                     0x00000114
#ifndef ASM_INC
typedef union {
  struct {
    //
    // The initial logic output of the sequencer is defined as follows:[br]
    //                         0 - Output Logic '0' for L_CNT UIs[br]
    //                         1 - Output Logic '1' for L_CNT UIs
    // 
    // Bits[0:0], RW/P, default = 0x1
    //
    UINTX l_sel : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[3:1], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 3;
    //
    // Values for L_CNT, M_CNT, and N_CNT are scaled by a factor of 2^COUNT_SCALE.
    // 
    // Bits[6:4], RW/P, default = 0x0
    //
    UINTX count_scale : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:7], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 1;
    //
    // Number of UIs that the unisequencer will drive the logic value selected through
    // L_SEL before entering the steady state periodic phase. 
    // 
    // Bits[10:8], RW/P, default = 0x1
    //
    UINTX l_cnt : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[15:11], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 5;
    //
    // Number of UIs that the unisequencer will drive logic '0'.
    // 
    // Bits[18:16], RW/P, default = 0x1
    //
    UINTX m_cnt : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:19], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_3 : 5;
    //
    // Number of UIs that the unisequencer will drive logic '1'.
    // 
    // Bits[26:24], RW/P, default = 0x1
    //
    UINTX n_cnt : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:27], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_4 : 5;
  } Bits;
  UINTX Data;
} CPGC_CADB_UNISEQ0_LMN_CPGC_STRUCT;
#endif // ASM_INC

#define CPGC_CADB_UNISEQ1_CPGC_REG                         0x00000118
#ifndef ASM_INC
typedef union {
  struct {
    //
    // The initial content of the rotating pattern buffer for the unified sequencer.
    // 
    // Bits[15:0], RW/P, default = 0xAA55
    //
    UINTX pattern_buffer : 16;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:16], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 16;
  } Bits;
  UINTX Data;
} CPGC_CADB_UNISEQ1_CPGC_STRUCT;
#endif // ASM_INC

#define CPGC_CADB_UNISEQ1_LMN_CPGC_REG                     0x0000011C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // The initial logic output of the sequencer is defined as follows:[br]
    //                         0 - Output Logic '0' for L_CNT UIs[br]
    //                         1 - Output Logic '1' for L_CNT UIs
    // 
    // Bits[0:0], RW/P, default = 0x1
    //
    UINTX l_sel : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[3:1], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 3;
    //
    // Values for L_CNT, M_CNT, and N_CNT are scaled by a factor of 2^COUNT_SCALE.
    // 
    // Bits[6:4], RW/P, default = 0x0
    //
    UINTX count_scale : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:7], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 1;
    //
    // Number of UIs that the unisequencer will drive the logic value selected through
    // L_SEL before entering the steady state periodic phase. 
    // 
    // Bits[10:8], RW/P, default = 0x1
    //
    UINTX l_cnt : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[15:11], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 5;
    //
    // Number of UIs that the unisequencer will drive logic '0'.
    // 
    // Bits[18:16], RW/P, default = 0x1
    //
    UINTX m_cnt : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:19], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_3 : 5;
    //
    // Number of UIs that the unisequencer will drive logic '1'.
    // 
    // Bits[26:24], RW/P, default = 0x1
    //
    UINTX n_cnt : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:27], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_4 : 5;
  } Bits;
  UINTX Data;
} CPGC_CADB_UNISEQ1_LMN_CPGC_STRUCT;
#endif // ASM_INC

#define CPGC_CADB_UNISEQ2_CPGC_REG                         0x00000120
#ifndef ASM_INC
typedef union {
  struct {
    //
    // The initial content of the rotating pattern buffer for the unified sequencer.
    // 
    // Bits[15:0], RW/P, default = 0xAA55
    //
    UINTX pattern_buffer : 16;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:16], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 16;
  } Bits;
  UINTX Data;
} CPGC_CADB_UNISEQ2_CPGC_STRUCT;
#endif // ASM_INC

#define CPGC_CADB_UNISEQ2_LMN_CPGC_REG                     0x00000124
#ifndef ASM_INC
typedef union {
  struct {
    //
    // The initial logic output of the sequencer is defined as follows:[br]
    //                         0 - Output Logic '0' for L_CNT UIs[br]
    //                         1 - Output Logic '1' for L_CNT UIs
    // 
    // Bits[0:0], RW/P, default = 0x1
    //
    UINTX l_sel : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[3:1], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 3;
    //
    // Values for L_CNT, M_CNT, and N_CNT are scaled by a factor of 2^COUNT_SCALE.
    // 
    // Bits[6:4], RW/P, default = 0x0
    //
    UINTX count_scale : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:7], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 1;
    //
    // Number of UIs that the unisequencer will drive the logic value selected through
    // L_SEL before entering the steady state periodic phase. 
    // 
    // Bits[10:8], RW/P, default = 0x1
    //
    UINTX l_cnt : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[15:11], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 5;
    //
    // Number of UIs that the unisequencer will drive logic '0'.
    // 
    // Bits[18:16], RW/P, default = 0x1
    //
    UINTX m_cnt : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:19], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_3 : 5;
    //
    // Number of UIs that the unisequencer will drive logic '1'.
    // 
    // Bits[26:24], RW/P, default = 0x1
    //
    UINTX n_cnt : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:27], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_4 : 5;
  } Bits;
  UINTX Data;
} CPGC_CADB_UNISEQ2_LMN_CPGC_STRUCT;
#endif // ASM_INC

#define CPGC_CADB_SEL_UNISEQ0_CPGC_REG                     0x00000128
#ifndef ASM_INC
typedef union {
  struct {
    //
    // The initial content of the rotating pattern buffer for the select unified sequencer.
    // 
    // Bits[15:0], RW/P, default = 0xAA55
    //
    UINTX pattern_buffer : 16;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:16], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 16;
  } Bits;
  UINTX Data;
} CPGC_CADB_SEL_UNISEQ0_CPGC_STRUCT;
#endif // ASM_INC

#define CPGC_CADB_SEL_UNISEQ1_CPGC_REG                     0x0000012C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // The initial content of the rotating pattern buffer for the select unified sequencer.
    // 
    // Bits[15:0], RW/P, default = 0xAA55
    //
    UINTX pattern_buffer : 16;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:16], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 16;
  } Bits;
  UINTX Data;
} CPGC_CADB_SEL_UNISEQ1_CPGC_STRUCT;
#endif // ASM_INC

#define CPGC_CADB_SEL_UNISEQ2_CPGC_REG                     0x00000130
#ifndef ASM_INC
typedef union {
  struct {
    //
    // The initial content of the rotating pattern buffer for the select unified sequencer.
    // 
    // Bits[15:0], RW/P, default = 0xAA55
    //
    UINTX pattern_buffer : 16;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:16], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 16;
  } Bits;
  UINTX Data;
} CPGC_CADB_SEL_UNISEQ2_CPGC_STRUCT;
#endif // ASM_INC

#define CPGC_CADB_UNISEQ0STAT_CPGC_REG                     0x00000134
#ifndef ASM_INC
typedef union {
  struct {
    //
    // The current contents of the command/address pattern unified sequencer buffer.
    //  In case a stop condition occurs, this register will contain the last value that
    // was used to generate the command/address pattern.  Bit 0 represents the value
    // used for the current chunk. 
    // 
    // Bits[15:0], RO/V, default = 0x0
    //
    UINTX uniseq_stat : 16;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:16], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 16;
  } Bits;
  UINTX Data;
} CPGC_CADB_UNISEQ0STAT_CPGC_STRUCT;
#endif // ASM_INC

#define CPGC_CADB_UNISEQ1STAT_CPGC_REG                     0x00000138
#ifndef ASM_INC
typedef union {
  struct {
    //
    // The current contents of the command/address pattern unified sequencer buffer.
    //  In case a stop condition occurs, this register will contain the last value that
    // was used to generate the command/address pattern.  Bit 0 represents the value
    // used for the current chunk. 
    // 
    // Bits[15:0], RO/V, default = 0x0
    //
    UINTX uniseq_stat : 16;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:16], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 16;
  } Bits;
  UINTX Data;
} CPGC_CADB_UNISEQ1STAT_CPGC_STRUCT;
#endif // ASM_INC

#define CPGC_CADB_UNISEQ2STAT_CPGC_REG                     0x0000013C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // The current contents of the command/address pattern unified sequencer buffer.
    //  In case a stop condition occurs, this register will contain the last value that
    // was used to generate the command/address pattern.  Bit 0 represents the value
    // used for the current chunk. 
    // 
    // Bits[15:0], RO/V, default = 0x0
    //
    UINTX uniseq_stat : 16;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:16], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 16;
  } Bits;
  UINTX Data;
} CPGC_CADB_UNISEQ2STAT_CPGC_STRUCT;
#endif // ASM_INC

#define CPGC_CADB_BUFA0_CPGC_REG                           0x00000140
#ifndef ASM_INC
typedef union {
  struct {
    //
    // The DRAM row/column address.[br]
    // LPDDR2/3 Maps the following:[br]
    // CA[9:0] rise = CADB_DATA_ADDRESS[9:0][br]
    // CA[9:0] fall = CADB_DATA_ADDRESS[19:10][br]
    // Note: Shared for DDR3 and LPDDR2/3. See ANN/CHV Dunit HAS for further information
    // on the mapping. 
    // 
    // Bits[17:0], RW/P, default = 0x0
    //
    UINTX cadb_data_address : 18;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:18], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 6;
    //
    // The DRAM bank address.[br] Note: Not used in LPDDR2/3
    // 
    // Bits[27:24], RW/P, default = 0x0
    //
    UINTX cadb_data_bank : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:28], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 4;
  } Bits;
  UINTX Data;
} CPGC_CADB_BUFA0_CPGC_STRUCT;
#endif // ASM_INC

#define CPGC_CADB_BUFB0_CPGC_REG                           0x00000144
#ifndef ASM_INC
typedef union {
  struct {
    //
    // The DRAM Chip Select signals.
    // 
    // Bits[3:0], RW/P, default = 0xF
    //
    UINTX cadb_data_cs : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:4], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 4;
    //
    // The DRAM command signals, [RAS#,CAS#,WE#]. All Three signals are active low and
    // hence default to '1's on reset.[br] Note: Not used in LPDDR2/3 
    // 
    // Bits[10:8], RW/P, default = 0x7
    //
    UINTX cadb_data_cmd : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[15:11], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 5;
    //
    // The DRAM On-Die Termination Signals.[br] Note: Not used in LPDDR2/3.
    // 
    // Bits[19:16], RW/P, default = 0x0
    //
    UINTX cadb_data_odt : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:20], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 4;
    //
    // The DRAM Clock Enable signals.
    // 
    // Bits[27:24], RW/P, default = 0x0
    //
    UINTX cadb_data_cke : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:28], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_3 : 4;
  } Bits;
  UINTX Data;
} CPGC_CADB_BUFB0_CPGC_STRUCT;
#endif // ASM_INC

#define CPGC_CADB_BUFA1_CPGC_REG                           0x00000148
#ifndef ASM_INC
typedef union {
  struct {
    //
    // The DRAM row/column address.[br]
    // LPDDR2/3 Maps the following:[br]
    // CA[9:0] rise = CADB_DATA_ADDRESS[9:0][br]
    // CA[9:0] fall = CADB_DATA_ADDRESS[19:10][br]
    // Note: Shared for DDR3 and LPDDR2/3. See ANN/CHV Dunit HAS for further information
    // on the mapping. 
    // 
    // Bits[17:0], RW/P, default = 0x0
    //
    UINTX cadb_data_address : 18;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:18], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 6;
    //
    // The DRAM bank address.[br] Note: Not used in LPDDR2/3
    // 
    // Bits[27:24], RW/P, default = 0x0
    //
    UINTX cadb_data_bank : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:28], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 4;
  } Bits;
  UINTX Data;
} CPGC_CADB_BUFA1_CPGC_STRUCT;
#endif // ASM_INC

#define CPGC_CADB_BUFB1_CPGC_REG                           0x0000014C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // The DRAM Chip Select signals.
    // 
    // Bits[3:0], RW/P, default = 0xF
    //
    UINTX cadb_data_cs : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:4], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 4;
    //
    // The DRAM command signals, [RAS#,CAS#,WE#]. All Three signals are active low and
    // hence default to '1's on reset.[br] Note: Not used in LPDDR2/3 
    // 
    // Bits[10:8], RW/P, default = 0x7
    //
    UINTX cadb_data_cmd : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[15:11], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 5;
    //
    // The DRAM On-Die Termination Signals.[br] Note: Not used in LPDDR2/3.
    // 
    // Bits[19:16], RW/P, default = 0x0
    //
    UINTX cadb_data_odt : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:20], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 4;
    //
    // The DRAM Clock Enable signals.
    // 
    // Bits[27:24], RW/P, default = 0x0
    //
    UINTX cadb_data_cke : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:28], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_3 : 4;
  } Bits;
  UINTX Data;
} CPGC_CADB_BUFB1_CPGC_STRUCT;
#endif // ASM_INC

#define CPGC_CADB_BUFA2_CPGC_REG                           0x00000150
#ifndef ASM_INC
typedef union {
  struct {
    //
    // The DRAM row/column address.[br]
    // LPDDR2/3 Maps the following:[br]
    // CA[9:0] rise = CADB_DATA_ADDRESS[9:0][br]
    // CA[9:0] fall = CADB_DATA_ADDRESS[19:10][br]
    // Note: Shared for DDR3 and LPDDR2/3. See ANN/CHV Dunit HAS for further information
    // on the mapping. 
    // 
    // Bits[17:0], RW/P, default = 0x0
    //
    UINTX cadb_data_address : 18;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:18], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 6;
    //
    // The DRAM bank address.[br] Note: Not used in LPDDR2/3
    // 
    // Bits[27:24], RW/P, default = 0x0
    //
    UINTX cadb_data_bank : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:28], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 4;
  } Bits;
  UINTX Data;
} CPGC_CADB_BUFA2_CPGC_STRUCT;
#endif // ASM_INC

#define CPGC_CADB_BUFB2_CPGC_REG                           0x00000154
#ifndef ASM_INC
typedef union {
  struct {
    //
    // The DRAM Chip Select signals.
    // 
    // Bits[3:0], RW/P, default = 0xF
    //
    UINTX cadb_data_cs : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:4], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 4;
    //
    // The DRAM command signals, [RAS#,CAS#,WE#]. All Three signals are active low and
    // hence default to '1's on reset.[br] Note: Not used in LPDDR2/3 
    // 
    // Bits[10:8], RW/P, default = 0x7
    //
    UINTX cadb_data_cmd : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[15:11], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 5;
    //
    // The DRAM On-Die Termination Signals.[br] Note: Not used in LPDDR2/3.
    // 
    // Bits[19:16], RW/P, default = 0x0
    //
    UINTX cadb_data_odt : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:20], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 4;
    //
    // The DRAM Clock Enable signals.
    // 
    // Bits[27:24], RW/P, default = 0x0
    //
    UINTX cadb_data_cke : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:28], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_3 : 4;
  } Bits;
  UINTX Data;
} CPGC_CADB_BUFB2_CPGC_STRUCT;
#endif // ASM_INC

#define CPGC_CADB_BUFA3_CPGC_REG                           0x00000158
#ifndef ASM_INC
typedef union {
  struct {
    //
    // The DRAM row/column address.[br]
    // LPDDR2/3 Maps the following:[br]
    // CA[9:0] rise = CADB_DATA_ADDRESS[9:0][br]
    // CA[9:0] fall = CADB_DATA_ADDRESS[19:10][br]
    // Note: Shared for DDR3 and LPDDR2/3. See ANN/CHV Dunit HAS for further information
    // on the mapping. 
    // 
    // Bits[17:0], RW/P, default = 0x0
    //
    UINTX cadb_data_address : 18;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:18], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 6;
    //
    // The DRAM bank address.[br] Note: Not used in LPDDR2/3
    // 
    // Bits[27:24], RW/P, default = 0x0
    //
    UINTX cadb_data_bank : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:28], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 4;
  } Bits;
  UINTX Data;
} CPGC_CADB_BUFA3_CPGC_STRUCT;
#endif // ASM_INC

#define CPGC_CADB_BUFB3_CPGC_REG                           0x0000015C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // The DRAM Chip Select signals.
    // 
    // Bits[3:0], RW/P, default = 0xF
    //
    UINTX cadb_data_cs : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:4], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 4;
    //
    // The DRAM command signals, [RAS#,CAS#,WE#]. All Three signals are active low and
    // hence default to '1's on reset.[br] Note: Not used in LPDDR2/3 
    // 
    // Bits[10:8], RW/P, default = 0x7
    //
    UINTX cadb_data_cmd : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[15:11], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 5;
    //
    // The DRAM On-Die Termination Signals.[br] Note: Not used in LPDDR2/3.
    // 
    // Bits[19:16], RW/P, default = 0x0
    //
    UINTX cadb_data_odt : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:20], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 4;
    //
    // The DRAM Clock Enable signals.
    // 
    // Bits[27:24], RW/P, default = 0x0
    //
    UINTX cadb_data_cke : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:28], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_3 : 4;
  } Bits;
  UINTX Data;
} CPGC_CADB_BUFB3_CPGC_STRUCT;
#endif // ASM_INC

#define CPGC_CADB_BUFA4_CPGC_REG                           0x00000160
#ifndef ASM_INC
typedef union {
  struct {
    //
    // The DRAM row/column address.[br]
    // LPDDR2/3 Maps the following:[br]
    // CA[9:0] rise = CADB_DATA_ADDRESS[9:0][br]
    // CA[9:0] fall = CADB_DATA_ADDRESS[19:10][br]
    // Note: Shared for DDR3 and LPDDR2/3. See ANN/CHV Dunit HAS for further information
    // on the mapping. 
    // 
    // Bits[17:0], RW/P, default = 0x0
    //
    UINTX cadb_data_address : 18;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:18], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 6;
    //
    // The DRAM bank address.[br] Note: Not used in LPDDR2/3
    // 
    // Bits[27:24], RW/P, default = 0x0
    //
    UINTX cadb_data_bank : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:28], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 4;
  } Bits;
  UINTX Data;
} CPGC_CADB_BUFA4_CPGC_STRUCT;
#endif // ASM_INC

#define CPGC_CADB_BUFB4_CPGC_REG                           0x00000164
#ifndef ASM_INC
typedef union {
  struct {
    //
    // The DRAM Chip Select signals.
    // 
    // Bits[3:0], RW/P, default = 0xF
    //
    UINTX cadb_data_cs : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:4], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 4;
    //
    // The DRAM command signals, [RAS#,CAS#,WE#]. All Three signals are active low and
    // hence default to '1's on reset.[br] Note: Not used in LPDDR2/3 
    // 
    // Bits[10:8], RW/P, default = 0x7
    //
    UINTX cadb_data_cmd : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[15:11], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 5;
    //
    // The DRAM On-Die Termination Signals.[br] Note: Not used in LPDDR2/3.
    // 
    // Bits[19:16], RW/P, default = 0x0
    //
    UINTX cadb_data_odt : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:20], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 4;
    //
    // The DRAM Clock Enable signals.
    // 
    // Bits[27:24], RW/P, default = 0x0
    //
    UINTX cadb_data_cke : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:28], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_3 : 4;
  } Bits;
  UINTX Data;
} CPGC_CADB_BUFB4_CPGC_STRUCT;
#endif // ASM_INC

#define CPGC_CADB_BUFA5_CPGC_REG                           0x00000168
#ifndef ASM_INC
typedef union {
  struct {
    //
    // The DRAM row/column address.[br]
    // LPDDR2/3 Maps the following:[br]
    // CA[9:0] rise = CADB_DATA_ADDRESS[9:0][br]
    // CA[9:0] fall = CADB_DATA_ADDRESS[19:10][br]
    // Note: Shared for DDR3 and LPDDR2/3. See ANN/CHV Dunit HAS for further information
    // on the mapping. 
    // 
    // Bits[17:0], RW/P, default = 0x0
    //
    UINTX cadb_data_address : 18;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:18], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 6;
    //
    // The DRAM bank address.[br] Note: Not used in LPDDR2/3
    // 
    // Bits[27:24], RW/P, default = 0x0
    //
    UINTX cadb_data_bank : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:28], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 4;
  } Bits;
  UINTX Data;
} CPGC_CADB_BUFA5_CPGC_STRUCT;
#endif // ASM_INC

#define CPGC_CADB_BUFB5_CPGC_REG                           0x0000016C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // The DRAM Chip Select signals.
    // 
    // Bits[3:0], RW/P, default = 0xF
    //
    UINTX cadb_data_cs : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:4], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 4;
    //
    // The DRAM command signals, [RAS#,CAS#,WE#]. All Three signals are active low and
    // hence default to '1's on reset.[br] Note: Not used in LPDDR2/3 
    // 
    // Bits[10:8], RW/P, default = 0x7
    //
    UINTX cadb_data_cmd : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[15:11], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 5;
    //
    // The DRAM On-Die Termination Signals.[br] Note: Not used in LPDDR2/3.
    // 
    // Bits[19:16], RW/P, default = 0x0
    //
    UINTX cadb_data_odt : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:20], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 4;
    //
    // The DRAM Clock Enable signals.
    // 
    // Bits[27:24], RW/P, default = 0x0
    //
    UINTX cadb_data_cke : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:28], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_3 : 4;
  } Bits;
  UINTX Data;
} CPGC_CADB_BUFB5_CPGC_STRUCT;
#endif // ASM_INC

#define CPGC_CADB_BUFA6_CPGC_REG                           0x00000170
#ifndef ASM_INC
typedef union {
  struct {
    //
    // The DRAM row/column address.[br]
    // LPDDR2/3 Maps the following:[br]
    // CA[9:0] rise = CADB_DATA_ADDRESS[9:0][br]
    // CA[9:0] fall = CADB_DATA_ADDRESS[19:10][br]
    // Note: Shared for DDR3 and LPDDR2/3. See ANN/CHV Dunit HAS for further information
    // on the mapping. 
    // 
    // Bits[17:0], RW/P, default = 0x0
    //
    UINTX cadb_data_address : 18;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:18], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 6;
    //
    // The DRAM bank address.[br] Note: Not used in LPDDR2/3
    // 
    // Bits[27:24], RW/P, default = 0x0
    //
    UINTX cadb_data_bank : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:28], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 4;
  } Bits;
  UINTX Data;
} CPGC_CADB_BUFA6_CPGC_STRUCT;
#endif // ASM_INC

#define CPGC_CADB_BUFB6_CPGC_REG                           0x00000174
#ifndef ASM_INC
typedef union {
  struct {
    //
    // The DRAM Chip Select signals.
    // 
    // Bits[3:0], RW/P, default = 0xF
    //
    UINTX cadb_data_cs : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:4], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 4;
    //
    // The DRAM command signals, [RAS#,CAS#,WE#]. All Three signals are active low and
    // hence default to '1's on reset.[br] Note: Not used in LPDDR2/3 
    // 
    // Bits[10:8], RW/P, default = 0x7
    //
    UINTX cadb_data_cmd : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[15:11], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 5;
    //
    // The DRAM On-Die Termination Signals.[br] Note: Not used in LPDDR2/3.
    // 
    // Bits[19:16], RW/P, default = 0x0
    //
    UINTX cadb_data_odt : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:20], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 4;
    //
    // The DRAM Clock Enable signals.
    // 
    // Bits[27:24], RW/P, default = 0x0
    //
    UINTX cadb_data_cke : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:28], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_3 : 4;
  } Bits;
  UINTX Data;
} CPGC_CADB_BUFB6_CPGC_STRUCT;
#endif // ASM_INC

#define CPGC_CADB_BUFA7_CPGC_REG                           0x00000178
#ifndef ASM_INC
typedef union {
  struct {
    //
    // The DRAM row/column address.[br]
    // LPDDR2/3 Maps the following:[br]
    // CA[9:0] rise = CADB_DATA_ADDRESS[9:0][br]
    // CA[9:0] fall = CADB_DATA_ADDRESS[19:10][br]
    // Note: Shared for DDR3 and LPDDR2/3. See ANN/CHV Dunit HAS for further information
    // on the mapping. 
    // 
    // Bits[17:0], RW/P, default = 0x0
    //
    UINTX cadb_data_address : 18;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:18], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 6;
    //
    // The DRAM bank address.[br] Note: Not used in LPDDR2/3
    // 
    // Bits[27:24], RW/P, default = 0x0
    //
    UINTX cadb_data_bank : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:28], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 4;
  } Bits;
  UINTX Data;
} CPGC_CADB_BUFA7_CPGC_STRUCT;
#endif // ASM_INC

#define CPGC_CADB_BUFB7_CPGC_REG                           0x0000017C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // The DRAM Chip Select signals.
    // 
    // Bits[3:0], RW/P, default = 0xF
    //
    UINTX cadb_data_cs : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:4], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 4;
    //
    // The DRAM command signals, [RAS#,CAS#,WE#]. All Three signals are active low and
    // hence default to '1's on reset.[br] Note: Not used in LPDDR2/3 
    // 
    // Bits[10:8], RW/P, default = 0x7
    //
    UINTX cadb_data_cmd : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[15:11], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 5;
    //
    // The DRAM On-Die Termination Signals.[br] Note: Not used in LPDDR2/3.
    // 
    // Bits[19:16], RW/P, default = 0x0
    //
    UINTX cadb_data_odt : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:20], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 4;
    //
    // The DRAM Clock Enable signals.
    // 
    // Bits[27:24], RW/P, default = 0x0
    //
    UINTX cadb_data_cke : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:28], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_3 : 4;
  } Bits;
  UINTX Data;
} CPGC_CADB_BUFB7_CPGC_STRUCT;
#endif // ASM_INC

#define CPGC_DPAT_CAP_CPGC_REG                             0x00000180
#ifndef ASM_INC
typedef union {
  struct {
    //
    // The number of data bus lanes (excluding any ECC lanes if supported) this implementation
    // supports is encoded as follows:[br] 
    // 01 - 32 Data Lanes[br]
    // 10 - 64 Data Lanes[br]
    // 11 - 32 Data Lanes and 64 Data Lanes[br]
    // All other values are reserved.
    // 
    // Bits[1:0], RO, default = 0x2
    //
    UINTX data_bus_width_cap : 2;
    //
    // The number of ECC lanes this implementation supports is encoded as follows:[br]
    // 00 - 0 ECC Lanes (ECC Not Supported)[br]
    // 01 - 4 ECC Lanes[br]
    // 10 - 8 ECC Lanes [br]
    // 11 - 4 ECC Lanes and 8 ECC Lanes
    // 
    // Bits[3:2], RO, default = 0x2
    //
    UINTX ecc_width_cap : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:4], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 4;
    //
    // The width of the pattern that can be generated by this implementation before any
    // replication is encoded in this field. 
    // This number is also equivalent to the memory array width, if supported, or to
    // the number of extended pattern buffers, otherwise, and is encoded as follows:[br]
    // 00 - 8-bit Wide Pattern (8 Independent Lanes)[br]
    // 01 - 16-bit Wide Pattern (16 Independent Lanes)[br]
    // 10 - 32-bit Wide Pattern (32 Independent Lanes)[br]
    // 11 - 64-bit Wide Pattern (64 Independent Lanes)[br]
    // It should be clear that this value has to be less than or equal to the value in
    // the DATA_BUS_WIDTH_CAP field. 
    // 
    // Bits[9:8], RO, default = 0x1
    //
    UINTX data_pat_width_cap : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[11:10], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 2;
    //
    //  The depth of the pattern that can be generated by this implementation is encoded
    // in this field. 
    // This number is also equivalent to the number of entries in the memory array, if
    // supported, or to the number lines supported per extended buffer, otherwise, and
    // is encoded as follows:[br] 
    // 000 - 8-bit Deep Pattern (1 Line)[br]
    // 001 - 16-bit Deep Pattern (2 Lines)[br]
    // 010 - 32-bit Deep Pattern (4 Lines)[br]
    // 011 - 64-bit Deep Pattern (8 Lines)[br]
    // 100 - 128-bit Deep Pattern (16 Lines)[br]
    // All other values are reserved.
    // 
    // Bits[14:12], RO, default = 0x3
    //
    UINTX data_pat_depth_cap : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[15:15], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 1;
    //
    // This bit will be set if the data pattern buffers are implemented using a memory
    // array (i.e. register file).  Otherwise extended buffers are used in a CBD implementation.
    // 
    // Bits[16:16], RO, default = 0x0
    //
    UINTX mem_array_cap : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[19:17], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_3 : 3;
    //
    // The width of the Data Inversion/DC mask supported by this implementation is encoded
    // as follows:[br] 
    // 00 - 8-bit Mask[br]
    // 01 - 16-bit Mask[br]
    // 10 - 32-bit Mask[br]
    // 11 - 64-bit Mask[br]
    // It should be clear that this value has to be less than or equal to the value in
    // the DATA_BUS_WIDTH_CAP field. 
    // 
    // Bits[21:20], RO, default = 0x3
    //
    UINTX data_idc_mask_width_cap : 2;
    //
    // The width of the ECC Inversion/DC mask (if supported by this implementation) is
    // encoded as follows:[br] 
    // 00 - No ECC Inv/DC Mask Supported[br]
    // 01 - 4-bit Mask[br]
    // 10 - 8-bit Mask[br]
    // All other values are reserved.
    // 
    // Bits[23:22], RO, default = 0x2
    //
    UINTX ecc_idc_mask_width_cap : 2;
    //
    // This bit is set if implementation supports DRAM Data Mask programming for data
    // lanes. 
    // 
    // Bits[24:24], RO, default = 0x1
    //
    UINTX dram_data_mask_cap : 1;
    //
    // This bit is set if implementation supports DRAM Data Mask programming for ECC
    // lanes. 
    // 
    // Bits[25:25], RO, default = 0x1
    //
    UINTX dram_ecc_mask_cap : 1;
    //
    // This bit is set if implementation supports the Auto Rotate feature.
    // 
    // Bits[26:26], RO, default = 0x1
    //
    UINTX ext_buf_rotate_cap : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:27], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_4 : 5;
  } Bits;
  UINTX Data;
} CPGC_DPAT_CAP_CPGC_STRUCT;
#endif // ASM_INC

#define CPGC_DPAT_BUF_CTL_CPGC_REG                         0x00000184
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Each buffer entry will be used 2^BUF_POINTER_INC_RATE or BUF_POINTER_INC_RATE
    // + 1 number of bursts (CAS commands) before incrementing the buffer pointer by
    // 1.[br] 
    // Note:[br]
    // #1 - To disable Buffer Pointer increments, set BUF_END_POINTER == BUF_START_POINTER.[br]
    // #2 - When Exponential Rate is chosen on BUF_POINTER_INC_SCALE this field is limited
    // to values [2:0],  ie Max is 2^7 = 128 
    // 
    // Bits[5:0], RW/P, default = 0x3
    //
    UINTX buf_pointer_inc_rate : 6;
    //
    // If set, the buffer pointer will be incremented at a linear rate given by BUF_POINTER_INC_RATE,
    // otherwise the buffer pointer will be incremented at an exponential rate given
    // by BUF_POINTER_INC_RATE.[br] 
    // 1 = Buffer Pointer Increment Rate field is treated as a linear number.[br]
    // 0 = Buffer Pointer Increment Rate field is treated is an exponential number.
    // 
    // Bits[6:6], RW/P, default = 0x0
    //
    UINTX buf_pointer_inc_scale : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:7], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 1;
    //
    // Pointer to first buffer entry.  Also used as the only entry if BUF_INC_EN is not
    // enabled.[br] Note: The actual size of this field depends on the # of lines supported
    // for data generation (DATA_PAT_DEPTH_CAP). i.e If 1 or 2 lines are supported then
    // it is a 1 bit field, if 16 lines are supported then the whole 4 bits are available.
    // 
    // Bits[10:8], RW/P, default = 0x0
    //
    UINTX buf_start_pointer : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[15:11], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 5;
    //
    // Pointer to last data pattern buffer entry before wrapping back to BUF_START_POINTER
    // if incrementing is enabled through BUF_INC_EN.[br] Note: The actual size of this
    // field depends on the # of lines supported for data generation (DATA_PAT_DEPTH_CAP).
    // i.e If 1 or 2 lines are supported then it is a 1 bit field, if 16 lines are supported
    // then the whole 4 bits are available. 
    // 
    // Bits[18:16], RW/P, default = 0x0
    //
    UINTX buf_end_pointer : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:19], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 13;
  } Bits;
  UINTX Data;
} CPGC_DPAT_BUF_CTL_CPGC_STRUCT;
#endif // ASM_INC

#define CPGC_DPAT_CFG_CPGC_REG                             0x00000188
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Defines the operational mode for unified sequence 0 as follows:[br]
    // 00 - LMN Mode[br]
    // 01 - Pattern Buffer Mode[br]
    // 10 - LFSR Mode[br]
    // 11 - Reserved for future use
    // 
    // Bits[1:0], RW/P, default = 0x1
    //
    UINTX uniseq0_mode : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[2:2], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 1;
    //
    // Defines the operational mode for unified sequence 1 as follows:[br]
    // 00 - LMN Mode[br]
    // 01 - Pattern Buffer Mode[br]
    // 10 - LFSR Mode[br]
    // 11 - Reserved for future use
    // 
    // Bits[4:3], RW/P, default = 0x1
    //
    UINTX uniseq1_mode : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[5:5], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 1;
    //
    // Defines the operational mode for unified sequence 2 as follows:[br]
    // 00 - LMN Mode[br]
    // 01 - Pattern Buffer Mode[br]
    // 10 - LFSR Mode[br]
    // 11 - Reserved for future use
    // 
    // Bits[7:6], RW/P, default = 0x1
    //
    UINTX uniseq2_mode : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[12:8], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 5;
    //
    // Setting this bit will internally disable all related ECC features in CPGC-S having
    // the effect of generating all '0 in the ECC CPGC-S interface outputs, and of Binding
    // to '0 all the ECC interface CPGC-S inputs. ECC masks and error comparisons will
    // be disabled as well.[br] Note: If ECC is not supported at compile time, this bit
    // will be reserved.  
    // 
    // Bits[13:13], RW/P, default = 0x0
    //
    UINTX ecc_disable : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[15:14], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_3 : 2;
    //
    // Save_LFSR_Seed_Rate only exists if the LFSR_Save_Restore capability is set to
    // 1.[br] 
    // See Reload_LFSR_Seed_Rate for use model.[br]
    // UNISEQ#_RDSAVE.Pattern_Buffer is initially loaded at the start of a test with
    // UNISEQ#_RDSTAT.Uniseq_RdStat (the Seed). [br] 
    // 2^(Reload_LFSR_Seed_Rate-1) * (Save_LFSR_Seed_Rate) defines the periodic Loopcount
    // interval that the current LFSR Seed is saved into UNISEQ#_RDSAVE.Pattern_Buffer[br]
    // When the Save_LFSR_Seed_Rate and Reload_LFSR_Seed_Rate is reached in the same
    // Loopcount only the saving of the LFSR seed takes place.[br] 
    // Examples:[br]
    // 0 = Disable - The current LFSR seed (UNISEQ#_RDSTAT.Uniseq_RdStat) is saved only
    // at the start of test into UNISEQ#_RDSAVE.Pattern_Buffer[br] 
    // 1 = Illegal (Would save every Reload and effectively disable both Save and Reload).[br]
    // 2 = The current LFSR seed is saved every other 2^(Reload_LFSR_Seed_Rate-1) Loopcounts.[br]
    // 3 = The current LFSR seed is saved every third Reload (and Reload does not happen).
    // 
    // Bits[23:16], RW/P, default = 0x0
    //
    UINTX save_lfsr_seed_rate : 8;
    //
    // Reload_LFSR_Seed_Rate only exists if the LFSR_Save_Restore capability is set to
    // 1.[br] 
    // Reload_LFSR_Seed_Rate and Save_LFSR_Seed_Rate is most often used in conjunction
    // with Lane_Rotate_Rate where the user desires to replay the same deterministic
    // LFSR stress as the victim aggressor patterns shifts Lanes left.  When the victim
    // aggressor pattern returns to the starting position the current LFSR stress is
    // saved using Save_LFSR_Seed_Rate to allow the LFSR stress to advance for the new
    // period.[br] 
    // 2^(Reload_LFSR_Seed_Rate-1) defines the periodic Loopcount interval that the current
    // LFSR Seed UNISEQ#_RDSTAT.Uniseq_RdStat is reloaded from CPGC_UNISEQ#_RDSAVE.Pattern_Buffer[br]
    // When the Save_LFSR_Seed_Rate and Reload_LFSR_Seed_Rate is reached in the same
    // Bit only the saving of the LFSR seed takes place.[br] 
    // Examples:[br]
    // 0 = Disable - The current LFSR seed is never reloaded.[br]
    // 1 = The current LFSR seed  is reloaded every Loopcount.[br]
    // 2 = The current LFSR seed  is reloaded every other Loopcount.[br]
    // 3 = The current LFSR seed  is reloaded every fourth Loopcount.[br]
    // Note: If UNISEQ_RELOAD_LFSR_SEED_RATE is set to 0 then this is effectively disabled.
    // 
    // Bits[28:24], RW/P, default = 0x0
    //
    UINTX reload_lfsr_seed_rate : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:29], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_4 : 3;
  } Bits;
  UINTX Data;
} CPGC_DPAT_CFG_CPGC_STRUCT;
#endif // ASM_INC

#define CPGC_DPAT_XTRA_LFSR_CFG_CPGC_REG                   0x0000018C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[1:0], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
    //
    // Possible Polynomial Sizes:[br]
    // 0x0 = Use 8 bit LFSR (x8 + x6 + x5 + x4)[br]
    // 0x1 = Use 15 bit LFSR (x15 + x14)[br]
    // 0x2 = Use 31 bit LFSR (x31 + x28)[br]
    // 0x3 = Use 23 bit LFSR (x23 + x18)[br]
    // 0x4 = Use 7 bit LFSR (x7 + x6)[br]
    // 0x5 = Use 16 bit LFSR (x16+x5+x4+x3)[br]
    // 0x6 = Use 23 bit LFSR (x23+x21+x18+x15+x7+x2)[br]
    // 0x7 = Use 32 bit LFSR (x32+x31+x30+x10)
    // 
    // Bits[4:2], RW/P, default = 0x0
    //
    UINTX uniseq0_lfsr_polynomial_size : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[9:5], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 5;
    //
    // Possible Polynomial Sizes:[br]
    // 0x0 = Use 8 bit LFSR (x8 + x6 + x5 + x4)[br]
    // 0x1 = Use 15 bit LFSR (x15 + x14)[br]
    // 0x2 = Use 31 bit LFSR (x31 + x28)[br]
    // 0x3 = Use 23 bit LFSR (x23 + x18)[br]
    // 0x4 = Use 7 bit LFSR (x7 + x6)[br]
    // 0x5 = Use 16 bit LFSR (x16+x5+x4+x3)[br]
    // 0x6 = Use 23 bit LFSR (x23+x21+x18+x15+x7+x2)[br]
    // 0x7 = Use 32 bit LFSR (x32+x31+x30+x10)
    // 
    // Bits[12:10], RW/P, default = 0x0
    //
    UINTX uniseq1_lfsr_polynomial_size : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[17:13], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 5;
    //
    // Possible Polynomial Sizes:[br]
    // 0x0 = Use 8 bit LFSR (x8 + x6 + x5 + x4)[br]
    // 0x1 = Use 15 bit LFSR (x15 + x14)[br]
    // 0x2 = Use 31 bit LFSR (x31 + x28)[br]
    // 0x3 = Use 23 bit LFSR (x23 + x18)[br]
    // 0x4 = Use 7 bit LFSR (x7 + x6)[br]
    // 0x5 = Use 16 bit LFSR (x16+x5+x4+x3)[br]
    // 0x6 = Use 23 bit LFSR (x23+x21+x18+x15+x7+x2)[br]
    // 0x7 = Use 32 bit LFSR (x32+x31+x30+x10)
    // 
    // Bits[20:18], RW/P, default = 0x0
    //
    UINTX uniseq2_lfsr_polynomial_size : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:21], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_3 : 3;
    //
    // Lane_Rotate_Rate only exists if the Lane_Rotation_Support capability exists.[br]
    // 2^(Lane_Rotate_Rate-1) indicates the periodic Loopcount rate when the EXTBUF_#
    // registers are rotated up by one bit.[br] 
    // Lane_Rotate_Rate = 0 disables all rotation.[br]
    // Lane_Rotate_Rate = 1 causes the EXTBUF_# registers to be rotated every one Loopcount.[br]
    // Lane_Rotate_Rate =2  causes the EXTBUF_# registers to be rotated every other Loopcount.[br]
    // Etc..[br]
    // When the EXTBUF_# registers are rotated Bit 0 shifts to Bit 1 all the way up to
    // the Max-1 Bit and the Max bit shifts to Bit0. 
    // 
    // Bits[28:24], RW/P, default = 0x0
    //
    UINTX lane_rotate_rate : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[29:29], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_4 : 1;
    //
    // N/A
    // 
    // Bits[30:30], RW/P, default = 0x0
    //
    UINTX ext_dpat_buf_rotate_en : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:31], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_5 : 1;
  } Bits;
  UINTX Data;
} CPGC_DPAT_XTRA_LFSR_CFG_CPGC_STRUCT;
#endif // ASM_INC

#define CPGC_DPAT_UNISEQ0_CPGC_REG                         0x00000190
#ifndef ASM_INC
typedef union {
  struct {
    //
    // If UniSeq0_Mode is set to Pattern Buffer mode, then this field represents the
    // initial content of the rotating pattern buffer for the unified sequencer. If UniSeq#_Mode
    // is set to LFSR mode, then this field represents the 32-bit LFSR seed for the unified
    // sequencer. Note: This is a shared register, it has a meaning according to the
    // UniSeq0 mode. 
    // 
    // Bits[31:0], RW/V, default = 0xAAAAAAAA
    //
    UINTX pattern_buffer : 32;
  } Bits;
  UINTX Data;
} CPGC_DPAT_UNISEQ0_CPGC_STRUCT;
#endif // ASM_INC

#define CPGC_DPAT_UNISEQ0_LMN_CPGC_REG                     0x00000194
#ifndef ASM_INC
typedef union {
  struct {
    //
    // The initial logic output of the sequencer is defined as follows:[br]
    //                         0 - Output Logic '0' for L_CNT UIs[br]
    //                         1 - Output Logic '1' for L_CNT UIs
    // 
    // Bits[0:0], RW/P, default = 0x0
    //
    UINTX l_sel : 1;
    //
    // If set, Frequency Sweep is Enabled.[br] M_CNT & N_CNT will act now respectively
    // as MIN_PERIOD & MAX_PERIOD respectively.[br] 
    // The frequency sweep feature works as follows:[br]
    // i) It will drive N_CNT # of UI's Low & # of UI's High a # of repeat times.[br]
    // ii) It will increment the cycle count by the user defined  Freq_Sweep_Count_Increment.[br]
    // iii) Drive the new increased # of UI's Low & # of UI's High a # of repeat times.[br]
    // iv) Increment again and loop until M_CNT is reached.[br]
    // v) Once M_CNT is reached, the Frequency Sweep repeats again.[br]
    // Note: L Select is not used in this mode and the first UI's driven will be the
    // Low value (zero). 
    // 
    // Bits[1:1], RW/P, default = 0x0
    //
    UINTX freq_sweep_en : 1;
    //
    // N/A
    // 
    // Bits[2:2], RW/P, default = 0x0
    //
    UINTX l_count_en : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:3], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 5;
    //
    // If LMN_Support capability is set to 0 then:[br]A periodic square wave is generated
    // that has the following behavior.[br] 
    // 1) Drive L_Polarity for L_Count Bits.[br]
    // 2) Drive inverse of L_Polarity for L_Count Bits.[br]
    // 3) Go to step 1.[br]
    // Else if LMN_Support is set to 1 then:[br]
    // After L_Count bits are driven at the beginning of a test then periodic pattern
    // is continuously repeated depending on the value of Enable_Sweep_Frequency is set
    // to 1.[br] 
    // If Enable_Sweep_Frequency = 0 then a steady state frequency is driven (see Enable_Sweep_Frequency
    // for exact behavior)[br] 
    // If Enable_Sweep_Frequency = 1 then a frequency sweep is continuously generated
    // ranging from 2*(M) to 2*(N) driven (see Enable_Sweep_Frequency for exact behavior).
    // 
    // Bits[15:8], RW/P, default = 0x1
    //
    UINTX l_cnt : 8;
    //
    // M_Count only exists if  LMN_Support capability is set to 1.[br] After L_Count
    // bits are driven at the beginning of a test then periodic pattern is continuously
    // repeated depending on the value of Enable_Sweep_Frequency.[br] If Enable_Sweep_Frequency
    // = 0 then a steady state frequency is driven (see Enable_Sweep_Frequency for exact
    // behavior).[br]If Enable_Sweep_Frequency = 1 then a frequency sweep is continuously
    // generated ranging from 2*(M) to 2*(N) driven (see Enable_Sweep_Frequency for exact
    // behavior) 
    // 
    // Bits[23:16], RW/P, default = 0x1
    //
    UINTX m_cnt : 8;
    //
    // N_Count only exists if  LMN_Support capability is set to 1.[br] After L_Count
    // bits are driven at the beginning of a test then periodic pattern is continuously
    // repeated depending on the value of Enable_Sweep_Frequency.[br] If Enable_Sweep_Frequency
    // = 0 then a steady state frequency is driven (see Enable_Sweep_Frequency for exact
    // behavior).[br] If Enable_Sweep_Frequency = 1 then a frequency sweep is continuously
    // generated ranging from 2*(M) to 2*(N) driven (see Enable_Sweep_Frequency for exact
    // behavior) 
    // 
    // Bits[31:24], RW/P, default = 0x1
    //
    UINTX n_cnt : 8;
  } Bits;
  UINTX Data;
} CPGC_DPAT_UNISEQ0_LMN_CPGC_STRUCT;
#endif // ASM_INC

#define CPGC_DPAT_UNISEQ1_CPGC_REG                         0x00000198
#ifndef ASM_INC
typedef union {
  struct {
    //
    // If UniSeq1_Mode is set to Pattern Buffer mode, then this field represents the
    // initial content of the rotating pattern buffer for the unified sequencer. If UniSeq#_Mode
    // is set to LFSR mode, then this field represents the 32-bit LFSR seed for the unified
    // sequencer. Note: This is a shared register, it has a meaning according to the
    // UniSeq1 mode. 
    // 
    // Bits[31:0], RW/P, default = 0xCCCCCCCC
    //
    UINTX pattern_buffer : 32;
  } Bits;
  UINTX Data;
} CPGC_DPAT_UNISEQ1_CPGC_STRUCT;
#endif // ASM_INC

#define CPGC_DPAT_UNISEQ1_LMN_CPGC_REG                     0x0000019C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // The initial logic output of the sequencer is defined as follows:[br]
    //                         0 - Output Logic '0' for L_CNT UIs[br]
    //                         1 - Output Logic '1' for L_CNT UIs
    // 
    // Bits[0:0], RW/P, default = 0x0
    //
    UINTX l_sel : 1;
    //
    // If set, Frequency Sweep is Enabled.[br] M_CNT & N_CNT will act now respectively
    // as MIN_PERIOD & MAX_PERIOD respectively.[br] 
    // The frequency sweep feature works as follows:[br]
    // i) It will drive N_CNT # of UI's Low & # of UI's High a # of repeat times.[br]
    // ii) It will increment the cycle count by the user defined  Freq_Sweep_Count_Increment.[br]
    // iii) Drive the new increased # of UI's Low & # of UI's High a # of repeat times.[br]
    // iv) Increment again and loop until M_CNT is reached.[br]
    // v) Once M_CNT is reached, the Frequency Sweep repeats again.[br]
    // Note: L Select is not used in this mode and the first UI's driven will be the
    // Low value (zero). 
    // 
    // Bits[1:1], RW/P, default = 0x0
    //
    UINTX freq_sweep_en : 1;
    //
    // N/A
    // 
    // Bits[2:2], RW/P, default = 0x0
    //
    UINTX l_count_en : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:3], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 5;
    //
    // If LMN_Support capability is set to 0 then:[br]A periodic square wave is generated
    // that has the following behavior.[br] 
    // 1) Drive L_Polarity for L_Count Bits.[br]
    // 2) Drive inverse of L_Polarity for L_Count Bits.[br]
    // 3) Go to step 1.[br]
    // Else if LMN_Support is set to 1 then:[br]
    // After L_Count bits are driven at the beginning of a test then periodic pattern
    // is continuously repeated depending on the value of Enable_Sweep_Frequency is set
    // to 1.[br] 
    // If Enable_Sweep_Frequency = 0 then a steady state frequency is driven (see Enable_Sweep_Frequency
    // for exact behavior)[br] 
    // If Enable_Sweep_Frequency = 1 then a frequency sweep is continuously generated
    // ranging from 2*(M) to 2*(N) driven (see Enable_Sweep_Frequency for exact behavior).
    // 
    // Bits[15:8], RW/P, default = 0x1
    //
    UINTX l_cnt : 8;
    //
    // M_Count only exists if  LMN_Support capability is set to 1.[br] After L_Count
    // bits are driven at the beginning of a test then periodic pattern is continuously
    // repeated depending on the value of Enable_Sweep_Frequency.[br] If Enable_Sweep_Frequency
    // = 0 then a steady state frequency is driven (see Enable_Sweep_Frequency for exact
    // behavior).[br]If Enable_Sweep_Frequency = 1 then a frequency sweep is continuously
    // generated ranging from 2*(M) to 2*(N) driven (see Enable_Sweep_Frequency for exact
    // behavior) 
    // 
    // Bits[23:16], RW/P, default = 0x1
    //
    UINTX m_cnt : 8;
    //
    // N_Count only exists if  LMN_Support capability is set to 1.[br] After L_Count
    // bits are driven at the beginning of a test then periodic pattern is continuously
    // repeated depending on the value of Enable_Sweep_Frequency.[br] If Enable_Sweep_Frequency
    // = 0 then a steady state frequency is driven (see Enable_Sweep_Frequency for exact
    // behavior).[br] If Enable_Sweep_Frequency = 1 then a frequency sweep is continuously
    // generated ranging from 2*(M) to 2*(N) driven (see Enable_Sweep_Frequency for exact
    // behavior) 
    // 
    // Bits[31:24], RW/P, default = 0x1
    //
    UINTX n_cnt : 8;
  } Bits;
  UINTX Data;
} CPGC_DPAT_UNISEQ1_LMN_CPGC_STRUCT;
#endif // ASM_INC

#define CPGC_DPAT_UNISEQ2_CPGC_REG                         0x000001A0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // If UniSeq1_Mode is set to Pattern Buffer mode, then this field represents the
    // initial content of the rotating pattern buffer for the unified sequencer. If UniSeq2_Mode
    // is set to LFSR mode, then this field represents the 32-bit LFSR seed for the unified
    // sequencer. Note: This is a shared register, it has a meaning according to the
    // UniSeq2 mode. 
    // 
    // Bits[31:0], RW/P, default = 0xF0F0F0F0
    //
    UINTX pattern_buffer : 32;
  } Bits;
  UINTX Data;
} CPGC_DPAT_UNISEQ2_CPGC_STRUCT;
#endif // ASM_INC

#define CPGC_DPAT_UNISEQ2_LMN_CPGC_REG                     0x000001A4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // The initial logic output of the sequencer is defined as follows:[br]
    //                         0 - Output Logic '0' for L_CNT UIs[br]
    //                         1 - Output Logic '1' for L_CNT UIs
    // 
    // Bits[0:0], RW/P, default = 0x0
    //
    UINTX l_sel : 1;
    //
    // If set, Frequency Sweep is Enabled.[br] M_CNT & N_CNT will act now respectively
    // as MIN_PERIOD & MAX_PERIOD respectively.[br] 
    // The frequency sweep feature works as follows:[br]
    // i) It will drive N_CNT # of UI's Low & # of UI's High a # of repeat times.[br]
    // ii) It will increment the cycle count by the user defined  Freq_Sweep_Count_Increment.[br]
    // iii) Drive the new increased # of UI's Low & # of UI's High a # of repeat times.[br]
    // iv) Increment again and loop until M_CNT is reached.[br]
    // v) Once M_CNT is reached, the Frequency Sweep repeats again.[br]
    // Note: L Select is not used in this mode and the first UI's driven will be the
    // Low value (zero). 
    // 
    // Bits[1:1], RW/P, default = 0x0
    //
    UINTX freq_sweep_en : 1;
    //
    // N/A
    // 
    // Bits[2:2], RW/P, default = 0x0
    //
    UINTX l_count_en : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:3], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 5;
    //
    // If LMN_Support capability is set to 0 then:[br]A periodic square wave is generated
    // that has the following behavior.[br] 
    // 1) Drive L_Polarity for L_Count Bits.[br]
    // 2) Drive inverse of L_Polarity for L_Count Bits.[br]
    // 3) Go to step 1.[br]
    // Else if LMN_Support is set to 1 then:[br]
    // After L_Count bits are driven at the beginning of a test then periodic pattern
    // is continuously repeated depending on the value of Enable_Sweep_Frequency is set
    // to 1.[br] 
    // If Enable_Sweep_Frequency = 0 then a steady state frequency is driven (see Enable_Sweep_Frequency
    // for exact behavior)[br] 
    // If Enable_Sweep_Frequency = 1 then a frequency sweep is continuously generated
    // ranging from 2*(M) to 2*(N) driven (see Enable_Sweep_Frequency for exact behavior).
    // 
    // Bits[15:8], RW/P, default = 0x1
    //
    UINTX l_cnt : 8;
    //
    // M_Count only exists if  LMN_Support capability is set to 1.[br] After L_Count
    // bits are driven at the beginning of a test then periodic pattern is continuously
    // repeated depending on the value of Enable_Sweep_Frequency.[br] If Enable_Sweep_Frequency
    // = 0 then a steady state frequency is driven (see Enable_Sweep_Frequency for exact
    // behavior).[br]If Enable_Sweep_Frequency = 1 then a frequency sweep is continuously
    // generated ranging from 2*(M) to 2*(N) driven (see Enable_Sweep_Frequency for exact
    // behavior) 
    // 
    // Bits[23:16], RW/P, default = 0x1
    //
    UINTX m_cnt : 8;
    //
    // N_Count only exists if  LMN_Support capability is set to 1.[br] After L_Count
    // bits are driven at the beginning of a test then periodic pattern is continuously
    // repeated depending on the value of Enable_Sweep_Frequency.[br] If Enable_Sweep_Frequency
    // = 0 then a steady state frequency is driven (see Enable_Sweep_Frequency for exact
    // behavior).[br] If Enable_Sweep_Frequency = 1 then a frequency sweep is continuously
    // generated ranging from 2*(M) to 2*(N) driven (see Enable_Sweep_Frequency for exact
    // behavior) 
    // 
    // Bits[31:24], RW/P, default = 0x1
    //
    UINTX n_cnt : 8;
  } Bits;
  UINTX Data;
} CPGC_DPAT_UNISEQ2_LMN_CPGC_STRUCT;
#endif // ASM_INC

#define CPGC_DPAT_INVDC_CTL_CPGC_REG                       0x000001AC
#ifndef ASM_INC
typedef union {
  struct {
    //
    // A value of 1 for any of the bits means the corresponding ECC lane(s) will be inverted
    // or a DC value driven on it.  Note that this field is used to load bits [71:64]
    // of the continuous shift register composed of this field along with DATA_INV_DC_MASK_HI
    // and DATA_INV_DC_MASK_LO.   Note: this field is only available if ECC is supported
    // for the current implementation, otherwise it is reserved. 
    // 
    // Bits[7:0], RW/P, default = 0x0
    //
    UINTX ecc_inv_dc_mask : 8;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[15:8], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 8;
    //
    // If inversion mask rotation is enabled through INV_ROTATE_EN, the mask will rotate
    // to the left every time 2^INV_ROTATE_RATE bursts (CAS commands) have been have
    // been issued. 
    // 
    // Bits[19:16], RW/P, default = 0x0
    //
    UINTX mask_rotate_rate : 4;
    //
    // Selects the polarity of the signal to be driven through the inversion/DC mask
    // if DC_OR_INV is set to 1:[br] 
    // 0 - Drive a logic low (zero).[br]
    // 1 - Drive a logic high (one).
    // 
    // Bits[20:20], RW/P, default = 0x0
    //
    UINTX dc_pol : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[29:21], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 9;
    //
    // Selects between using the inversion/DC mask for inversion or DC as follows:[br]
    // 0 - Mask used for inversion.[br]
    // 1 - Mask used for driving a DC signal of polarity DC_POL.
    // 
    // Bits[30:30], RW/P, default = 0x0
    //
    UINTX dc_or_inv : 1;
    //
    // If set, the inversion/DC mask will rotate to the left at a rate defined by the
    // MASK_ROTATE_RATE field. 
    // 
    // Bits[31:31], RW/P, default = 0x0
    //
    UINTX mask_rotate_en : 1;
  } Bits;
  UINTX Data;
} CPGC_DPAT_INVDC_CTL_CPGC_STRUCT;
#endif // ASM_INC

#define CPGC_DPAT_INVDC_MASK_LO_CPGC_REG                   0x000001B0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // A value of '1' for any of the bits means the corresponding data lane(s) will be
    // inverted or a DC value driven on it. Note that this field is used to load bits
    // [31:0] of the continuous shift register composed of this field along with ECC_INV_DC_MASK
    // and DATA_INV_DC_MASK_HI. 
    // 
    // Bits[31:0], RW/P, default = 0x0
    //
    UINTX data_inv_dc_mask_lo : 32;
  } Bits;
  UINTX Data;
} CPGC_DPAT_INVDC_MASK_LO_CPGC_STRUCT;
#endif // ASM_INC

#define CPGC_DPAT_INVDC_MASK_HI_CPGC_REG                   0x000001B4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // A value of '1' for any of the bits means the corresponding data lane(s) will be
    // inverted or a DC value driven on it. Note that this field is used to load bits
    // [63:32] of the continuous shift register composed of this field along with ECC_INV_DC_MASK
    // and DATA_INV_DC_MASK_LO. 
    // 
    // Bits[31:0], RW/P, default = 0x0
    //
    UINTX data_inv_dc_mask_hi : 32;
  } Bits;
  UINTX Data;
} CPGC_DPAT_INVDC_MASK_HI_CPGC_STRUCT;
#endif // ASM_INC

#define CPGC_DPAT_DRAMDM_CPGC_REG                          0x000001B8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // A one-hot field with each bit corresponding to a data byte sent during a burst
    // such that:[br] 
    // 0 - Mask the Corresponding Byte[br]
    // 1 - No Mask to the Corresponding Byte
    // The byte-to-bit mapping is given by Byte[n] -> bit[n % 32].[br]  Note: This field
    // is only available if the DRAM_DATA_MASK_CAP bit is set otherwise it's reserved.
    // 
    // Bits[31:0], RW/P, default = 0xFFFFFFFF
    //
    UINTX data_mask : 32;
  } Bits;
  UINTX Data;
} CPGC_DPAT_DRAMDM_CPGC_STRUCT;
#endif // ASM_INC

#define CPGC_DPAT_XDRAMDM_CPGC_REG                         0x000001BC
#ifndef ASM_INC
typedef union {
  struct {
    //
    // A one-hot field with each bit corresponding to an ECC byte sent during a burst
    // such that:[br] 
    // 0 - Mask the Corresponding ECC Byte[br]
    // 1 - No Mask to the Corresponding ECC Byte
    // The byte-to-bit mapping is given by Byte[n] -> bit[n % 4].[br]  Note: This field
    // is only available if the DRAM_DATA_MASK_CAP bit is set otherwise it's reserved.
    // 
    // Bits[3:0], RW/V, default = 0xF
    //
    UINTX ecc_mask : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:4], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 28;
  } Bits;
  UINTX Data;
} CPGC_DPAT_XDRAMDM_CPGC_STRUCT;
#endif // ASM_INC

#define CPGC_DPAT_BUFSTAT_CPGC_REG                         0x000001C0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Pointer to current entry in the data pattern buffers used for generating the write
    // data. 
    // 
    // Bits[3:0], RO/V, default = 0x0
    //
    UINTX wr_buf_pointer : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:4], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 4;
    //
    // Pointer to current entry in the data pattern buffers used for generating the read
    // data. 
    // 
    // Bits[11:8], RO/V, default = 0x0
    //
    UINTX rd_buf_pointer : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:12], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 20;
  } Bits;
  UINTX Data;
} CPGC_DPAT_BUFSTAT_CPGC_STRUCT;
#endif // ASM_INC

#define CPGC_DPAT_UNISEQ0_WRSTAT_CPGC_REG                  0x000001C4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // The current contents of the data pattern unified write sequencer buffer.  Bit
    // 0 represents the value used for the current chunk. 
    // 
    // Bits[31:0], RO/V, default = 0x0
    //
    UINTX uniseq_wrstat : 32;
  } Bits;
  UINTX Data;
} CPGC_DPAT_UNISEQ0_WRSTAT_CPGC_STRUCT;
#endif // ASM_INC

#define CPGC_DPAT_UNISEQ1_WRSTAT_CPGC_REG                  0x000001C8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // The current contents of the data pattern unified write sequencer buffer.  Bit
    // 0 represents the value used for the current chunk. 
    // 
    // Bits[31:0], RO/V, default = 0x0
    //
    UINTX uniseq_wrstat : 32;
  } Bits;
  UINTX Data;
} CPGC_DPAT_UNISEQ1_WRSTAT_CPGC_STRUCT;
#endif // ASM_INC

#define CPGC_DPAT_UNISEQ2_WRSTAT_CPGC_REG                  0x000001CC
#ifndef ASM_INC
typedef union {
  struct {
    //
    // The current contents of the data pattern unified write sequencer buffer.  Bit
    // 0 represents the value used for the current chunk. 
    // 
    // Bits[31:0], RO/V, default = 0x0
    //
    UINTX uniseq_wrstat : 32;
  } Bits;
  UINTX Data;
} CPGC_DPAT_UNISEQ2_WRSTAT_CPGC_STRUCT;
#endif // ASM_INC

#define CPGC_DPAT_UNISEQ0_RDSTAT_CPGC_REG                  0x000001D0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // The current contents of the data pattern unified read sequencer buffer.  Bit 0
    // represents the value used for the current chunk. 
    // 
    // Bits[31:0], RO/V, default = 0x0
    //
    UINTX uniseq_rdstat : 32;
  } Bits;
  UINTX Data;
} CPGC_DPAT_UNISEQ0_RDSTAT_CPGC_STRUCT;
#endif // ASM_INC

#define CPGC_DPAT_UNISEQ1_RDSTAT_CPGC_REG                  0x000001D4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // The current contents of the data pattern unified read sequencer buffer.  Bit 0
    // represents the value used for the current chunk. 
    // 
    // Bits[31:0], RO/V, default = 0x0
    //
    UINTX uniseq_rdstat : 32;
  } Bits;
  UINTX Data;
} CPGC_DPAT_UNISEQ1_RDSTAT_CPGC_STRUCT;
#endif // ASM_INC

#define CPGC_DPAT_UNISEQ2_RDSTAT_CPGC_REG                  0x000001D8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // The current contents of the data pattern unified read sequencer buffer.  Bit 0
    // represents the value used for the current chunk. 
    // 
    // Bits[31:0], RO/V, default = 0x0
    //
    UINTX uniseq_rdstat : 32;
  } Bits;
  UINTX Data;
} CPGC_DPAT_UNISEQ2_RDSTAT_CPGC_STRUCT;
#endif // ASM_INC

#define CPGC_DPAT_EXTBUF0_CPGC_REG                         0x00000200
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Contents of Pattern Buffer 0 Data Line 0
    // 
    // Bits[7:0], RW/P, default = 0xAA
    //
    UINTX data_line0 : 8;
    //
    // Contents of Pattern Buffer 0 Data Line 1
    // 
    // Bits[15:8], RW/P, default = 0xAA
    //
    UINTX data_line1 : 8;
    //
    // Contents of Pattern Buffer 0 Data Line 2
    // 
    // Bits[23:16], RW/P, default = 0xAA
    //
    UINTX data_line2 : 8;
    //
    // Contents of Pattern Buffer 0 Data Line 3
    // 
    // Bits[31:24], RW/P, default = 0xAA
    //
    UINTX data_line3 : 8;
  } Bits;
  UINTX Data;
} CPGC_DPAT_EXTBUF0_CPGC_STRUCT;
#endif // ASM_INC

#define CPGC_DPAT_EXTBUF1_CPGC_REG                         0x00000204
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Contents of Pattern Buffer 1 Data Line 0
    // 
    // Bits[7:0], RW/P, default = 0xAA
    //
    UINTX data_line0 : 8;
    //
    // Contents of Pattern Buffer 1 Data Line 1
    // 
    // Bits[15:8], RW/P, default = 0xAA
    //
    UINTX data_line1 : 8;
    //
    // Contents of Pattern Buffer 1 Data Line 2
    // 
    // Bits[23:16], RW/P, default = 0xAA
    //
    UINTX data_line2 : 8;
    //
    // Contents of Pattern Buffer 1 Data Line 3
    // 
    // Bits[31:24], RW/P, default = 0xAA
    //
    UINTX data_line3 : 8;
  } Bits;
  UINTX Data;
} CPGC_DPAT_EXTBUF1_CPGC_STRUCT;
#endif // ASM_INC

#define CPGC_DPAT_EXTBUF2_CPGC_REG                         0x00000208
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Contents of Pattern Buffer 2 Data Line 0
    // 
    // Bits[7:0], RW/P, default = 0xAA
    //
    UINTX data_line0 : 8;
    //
    // Contents of Pattern Buffer 2 Data Line 1
    // 
    // Bits[15:8], RW/P, default = 0xAA
    //
    UINTX data_line1 : 8;
    //
    // Contents of Pattern Buffer 2 Data Line 2
    // 
    // Bits[23:16], RW/P, default = 0xAA
    //
    UINTX data_line2 : 8;
    //
    // Contents of Pattern Buffer 2 Data Line 3
    // 
    // Bits[31:24], RW/P, default = 0xAA
    //
    UINTX data_line3 : 8;
  } Bits;
  UINTX Data;
} CPGC_DPAT_EXTBUF2_CPGC_STRUCT;
#endif // ASM_INC

#define CPGC_DPAT_EXTBUF3_CPGC_REG                         0x0000020C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Contents of Pattern Buffer 3 Data Line 0
    // 
    // Bits[7:0], RW/P, default = 0xAA
    //
    UINTX data_line0 : 8;
    //
    // Contents of Pattern Buffer 3 Data Line 1
    // 
    // Bits[15:8], RW/P, default = 0xAA
    //
    UINTX data_line1 : 8;
    //
    // Contents of Pattern Buffer 3 Data Line 2
    // 
    // Bits[23:16], RW/P, default = 0xAA
    //
    UINTX data_line2 : 8;
    //
    // Contents of Pattern Buffer 3 Data Line 3
    // 
    // Bits[31:24], RW/P, default = 0xAA
    //
    UINTX data_line3 : 8;
  } Bits;
  UINTX Data;
} CPGC_DPAT_EXTBUF3_CPGC_STRUCT;
#endif // ASM_INC

#define CPGC_DPAT_EXTBUF4_CPGC_REG                         0x00000210
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Contents of Pattern Buffer 4 Data Line 0
    // 
    // Bits[7:0], RW/P, default = 0xAA
    //
    UINTX data_line0 : 8;
    //
    // Contents of Pattern Buffer 4 Data Line 1
    // 
    // Bits[15:8], RW/P, default = 0xAA
    //
    UINTX data_line1 : 8;
    //
    // Contents of Pattern Buffer 4 Data Line 2
    // 
    // Bits[23:16], RW/P, default = 0xAA
    //
    UINTX data_line2 : 8;
    //
    // Contents of Pattern Buffer 4 Data Line 3
    // 
    // Bits[31:24], RW/P, default = 0xAA
    //
    UINTX data_line3 : 8;
  } Bits;
  UINTX Data;
} CPGC_DPAT_EXTBUF4_CPGC_STRUCT;
#endif // ASM_INC

#define CPGC_DPAT_EXTBUF5_CPGC_REG                         0x00000214
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Contents of Pattern Buffer 5 Data Line 0
    // 
    // Bits[7:0], RW/P, default = 0xAA
    //
    UINTX data_line0 : 8;
    //
    // Contents of Pattern Buffer 5 Data Line 1
    // 
    // Bits[15:8], RW/P, default = 0xAA
    //
    UINTX data_line1 : 8;
    //
    // Contents of Pattern Buffer 5 Data Line 2
    // 
    // Bits[23:16], RW/P, default = 0xAA
    //
    UINTX data_line2 : 8;
    //
    // Contents of Pattern Buffer 5 Data Line 3
    // 
    // Bits[31:24], RW/P, default = 0xAA
    //
    UINTX data_line3 : 8;
  } Bits;
  UINTX Data;
} CPGC_DPAT_EXTBUF5_CPGC_STRUCT;
#endif // ASM_INC

#define CPGC_DPAT_EXTBUF6_CPGC_REG                         0x00000218
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Contents of Pattern Buffer 6 Data Line 0
    // 
    // Bits[7:0], RW/P, default = 0xAA
    //
    UINTX data_line0 : 8;
    //
    // Contents of Pattern Buffer 6 Data Line 1
    // 
    // Bits[15:8], RW/P, default = 0xAA
    //
    UINTX data_line1 : 8;
    //
    // Contents of Pattern Buffer 6 Data Line 2
    // 
    // Bits[23:16], RW/P, default = 0xAA
    //
    UINTX data_line2 : 8;
    //
    // Contents of Pattern Buffer 6 Data Line 3
    // 
    // Bits[31:24], RW/P, default = 0xAA
    //
    UINTX data_line3 : 8;
  } Bits;
  UINTX Data;
} CPGC_DPAT_EXTBUF6_CPGC_STRUCT;
#endif // ASM_INC

#define CPGC_DPAT_EXTBUF7_CPGC_REG                         0x0000021C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Contents of Pattern Buffer 7 Data Line 0
    // 
    // Bits[7:0], RW/P, default = 0xAA
    //
    UINTX data_line0 : 8;
    //
    // Contents of Pattern Buffer 7 Data Line 1
    // 
    // Bits[15:8], RW/P, default = 0xAA
    //
    UINTX data_line1 : 8;
    //
    // Contents of Pattern Buffer 7 Data Line 2
    // 
    // Bits[23:16], RW/P, default = 0xAA
    //
    UINTX data_line2 : 8;
    //
    // Contents of Pattern Buffer 7 Data Line 3
    // 
    // Bits[31:24], RW/P, default = 0xAA
    //
    UINTX data_line3 : 8;
  } Bits;
  UINTX Data;
} CPGC_DPAT_EXTBUF7_CPGC_STRUCT;
#endif // ASM_INC

#define CPGC_DPAT_EXTBUF8_CPGC_REG                         0x00000220
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Contents of Pattern Buffer 8 Data Line 0
    // 
    // Bits[7:0], RW/P, default = 0xAA
    //
    UINTX data_line0 : 8;
    //
    // Contents of Pattern Buffer 8 Data Line 1
    // 
    // Bits[15:8], RW/P, default = 0xAA
    //
    UINTX data_line1 : 8;
    //
    // Contents of Pattern Buffer 8 Data Line 2
    // 
    // Bits[23:16], RW/P, default = 0xAA
    //
    UINTX data_line2 : 8;
    //
    // Contents of Pattern Buffer 8 Data Line 3
    // 
    // Bits[31:24], RW/P, default = 0xAA
    //
    UINTX data_line3 : 8;
  } Bits;
  UINTX Data;
} CPGC_DPAT_EXTBUF8_CPGC_STRUCT;
#endif // ASM_INC

#define CPGC_DPAT_EXTBUF9_CPGC_REG                         0x00000224
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Contents of Pattern Buffer 9 Data Line 0
    // 
    // Bits[7:0], RW/P, default = 0xAA
    //
    UINTX data_line0 : 8;
    //
    // Contents of Pattern Buffer 9 Data Line 1
    // 
    // Bits[15:8], RW/P, default = 0xAA
    //
    UINTX data_line1 : 8;
    //
    // Contents of Pattern Buffer 9 Data Line 2
    // 
    // Bits[23:16], RW/P, default = 0xAA
    //
    UINTX data_line2 : 8;
    //
    // Contents of Pattern Buffer 9 Data Line 3
    // 
    // Bits[31:24], RW/P, default = 0xAA
    //
    UINTX data_line3 : 8;
  } Bits;
  UINTX Data;
} CPGC_DPAT_EXTBUF9_CPGC_STRUCT;
#endif // ASM_INC

#define CPGC_DPAT_EXTBUF10_CPGC_REG                        0x00000228
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Contents of Pattern Buffer 10 Data Line 0
    // 
    // Bits[7:0], RW/P, default = 0xAA
    //
    UINTX data_line0 : 8;
    //
    // Contents of Pattern Buffer 10 Data Line 1
    // 
    // Bits[15:8], RW/P, default = 0xAA
    //
    UINTX data_line1 : 8;
    //
    // Contents of Pattern Buffer 10 Data Line 2
    // 
    // Bits[23:16], RW/P, default = 0xAA
    //
    UINTX data_line2 : 8;
    //
    // Contents of Pattern Buffer 10 Data Line 3
    // 
    // Bits[31:24], RW/P, default = 0xAA
    //
    UINTX data_line3 : 8;
  } Bits;
  UINTX Data;
} CPGC_DPAT_EXTBUF10_CPGC_STRUCT;
#endif // ASM_INC

#define CPGC_DPAT_EXTBUF11_CPGC_REG                        0x0000022C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Contents of Pattern Buffer 11 Data Line 0
    // 
    // Bits[7:0], RW/P, default = 0xAA
    //
    UINTX data_line0 : 8;
    //
    // Contents of Pattern Buffer 11 Data Line 1
    // 
    // Bits[15:8], RW/P, default = 0xAA
    //
    UINTX data_line1 : 8;
    //
    // Contents of Pattern Buffer 11 Data Line 2
    // 
    // Bits[23:16], RW/P, default = 0xAA
    //
    UINTX data_line2 : 8;
    //
    // Contents of Pattern Buffer 11 Data Line 3
    // 
    // Bits[31:24], RW/P, default = 0xAA
    //
    UINTX data_line3 : 8;
  } Bits;
  UINTX Data;
} CPGC_DPAT_EXTBUF11_CPGC_STRUCT;
#endif // ASM_INC

#define CPGC_DPAT_EXTBUF12_CPGC_REG                        0x00000230
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Contents of Pattern Buffer 12 Data Line 0
    // 
    // Bits[7:0], RW/P, default = 0xAA
    //
    UINTX data_line0 : 8;
    //
    // Contents of Pattern Buffer 12 Data Line 1
    // 
    // Bits[15:8], RW/P, default = 0xAA
    //
    UINTX data_line1 : 8;
    //
    // Contents of Pattern Buffer 12 Data Line 2
    // 
    // Bits[23:16], RW/P, default = 0xAA
    //
    UINTX data_line2 : 8;
    //
    // Contents of Pattern Buffer 12 Data Line 3
    // 
    // Bits[31:24], RW/P, default = 0xAA
    //
    UINTX data_line3 : 8;
  } Bits;
  UINTX Data;
} CPGC_DPAT_EXTBUF12_CPGC_STRUCT;
#endif // ASM_INC

#define CPGC_DPAT_EXTBUF13_CPGC_REG                        0x00000234
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Contents of Pattern Buffer 13 Data Line 0
    // 
    // Bits[7:0], RW/P, default = 0xAA
    //
    UINTX data_line0 : 8;
    //
    // Contents of Pattern Buffer 13 Data Line 1
    // 
    // Bits[15:8], RW/P, default = 0xAA
    //
    UINTX data_line1 : 8;
    //
    // Contents of Pattern Buffer 13 Data Line 2
    // 
    // Bits[23:16], RW/P, default = 0xAA
    //
    UINTX data_line2 : 8;
    //
    // Contents of Pattern Buffer 13 Data Line 3
    // 
    // Bits[31:24], RW/P, default = 0xAA
    //
    UINTX data_line3 : 8;
  } Bits;
  UINTX Data;
} CPGC_DPAT_EXTBUF13_CPGC_STRUCT;
#endif // ASM_INC

#define CPGC_DPAT_EXTBUF14_CPGC_REG                        0x00000238
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Contents of Pattern Buffer 14 Data Line 0
    // 
    // Bits[7:0], RW/P, default = 0xAA
    //
    UINTX data_line0 : 8;
    //
    // Contents of Pattern Buffer 14 Data Line 1
    // 
    // Bits[15:8], RW/P, default = 0xAA
    //
    UINTX data_line1 : 8;
    //
    // Contents of Pattern Buffer 14 Data Line 2
    // 
    // Bits[23:16], RW/P, default = 0xAA
    //
    UINTX data_line2 : 8;
    //
    // Contents of Pattern Buffer 14 Data Line 3
    // 
    // Bits[31:24], RW/P, default = 0xAA
    //
    UINTX data_line3 : 8;
  } Bits;
  UINTX Data;
} CPGC_DPAT_EXTBUF14_CPGC_STRUCT;
#endif // ASM_INC

#define CPGC_DPAT_EXTBUF15_CPGC_REG                        0x0000023C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Contents of Pattern Buffer 15 Data Line 0
    // 
    // Bits[7:0], RW/P, default = 0xAA
    //
    UINTX data_line0 : 8;
    //
    // Contents of Pattern Buffer 15 Data Line 1
    // 
    // Bits[15:8], RW/P, default = 0xAA
    //
    UINTX data_line1 : 8;
    //
    // Contents of Pattern Buffer 15 Data Line 2
    // 
    // Bits[23:16], RW/P, default = 0xAA
    //
    UINTX data_line2 : 8;
    //
    // Contents of Pattern Buffer 15 Data Line 3
    // 
    // Bits[31:24], RW/P, default = 0xAA
    //
    UINTX data_line3 : 8;
  } Bits;
  UINTX Data;
} CPGC_DPAT_EXTBUF15_CPGC_STRUCT;
#endif // ASM_INC

#define CPGC_DPAT_EXTBUF0B_CPGC_REG                        0x00000240
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Contents of Pattern Buffer 0 Data Line 4
    // 
    // Bits[7:0], RW/P, default = 0xAA
    //
    UINTX data_line4 : 8;
    //
    // Contents of Pattern Buffer 0 Data Line 5
    // 
    // Bits[15:8], RW/P, default = 0xAA
    //
    UINTX data_line5 : 8;
    //
    // Contents of Pattern Buffer 0 Data Line 6
    // 
    // Bits[23:16], RW/P, default = 0xAA
    //
    UINTX data_line6 : 8;
    //
    // Contents of Pattern Buffer 0 Data Line 7
    // 
    // Bits[31:24], RW/P, default = 0xAA
    //
    UINTX data_line7 : 8;
  } Bits;
  UINTX Data;
} CPGC_DPAT_EXTBUF0B_CPGC_STRUCT;
#endif // ASM_INC

#define CPGC_DPAT_EXTBUF1B_CPGC_REG                        0x00000244
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Contents of Pattern Buffer 1 Data Line 4
    // 
    // Bits[7:0], RW/P, default = 0xAA
    //
    UINTX data_line4 : 8;
    //
    // Contents of Pattern Buffer 1 Data Line 5
    // 
    // Bits[15:8], RW/P, default = 0xAA
    //
    UINTX data_line5 : 8;
    //
    // Contents of Pattern Buffer 1 Data Line 6
    // 
    // Bits[23:16], RW/P, default = 0xAA
    //
    UINTX data_line6 : 8;
    //
    // Contents of Pattern Buffer 1 Data Line 7
    // 
    // Bits[31:24], RW/P, default = 0xAA
    //
    UINTX data_line7 : 8;
  } Bits;
  UINTX Data;
} CPGC_DPAT_EXTBUF1B_CPGC_STRUCT;
#endif // ASM_INC

#define CPGC_DPAT_EXTBUF2B_CPGC_REG                        0x00000248
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Contents of Pattern Buffer 2 Data Line 4
    // 
    // Bits[7:0], RW/P, default = 0xAA
    //
    UINTX data_line4 : 8;
    //
    // Contents of Pattern Buffer 2 Data Line 5
    // 
    // Bits[15:8], RW/P, default = 0xAA
    //
    UINTX data_line5 : 8;
    //
    // Contents of Pattern Buffer 2 Data Line 6
    // 
    // Bits[23:16], RW/P, default = 0xAA
    //
    UINTX data_line6 : 8;
    //
    // Contents of Pattern Buffer 2 Data Line 7
    // 
    // Bits[31:24], RW/P, default = 0xAA
    //
    UINTX data_line7 : 8;
  } Bits;
  UINTX Data;
} CPGC_DPAT_EXTBUF2B_CPGC_STRUCT;
#endif // ASM_INC

#define CPGC_DPAT_EXTBUF3B_CPGC_REG                        0x0000024C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Contents of Pattern Buffer 3 Data Line 4
    // 
    // Bits[7:0], RW/P, default = 0xAA
    //
    UINTX data_line4 : 8;
    //
    // Contents of Pattern Buffer 3 Data Line 5
    // 
    // Bits[15:8], RW/P, default = 0xAA
    //
    UINTX data_line5 : 8;
    //
    // Contents of Pattern Buffer 3 Data Line 6
    // 
    // Bits[23:16], RW/P, default = 0xAA
    //
    UINTX data_line6 : 8;
    //
    // Contents of Pattern Buffer 3 Data Line 7
    // 
    // Bits[31:24], RW/P, default = 0xAA
    //
    UINTX data_line7 : 8;
  } Bits;
  UINTX Data;
} CPGC_DPAT_EXTBUF3B_CPGC_STRUCT;
#endif // ASM_INC

#define CPGC_DPAT_EXTBUF4B_CPGC_REG                        0x00000250
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Contents of Pattern Buffer 4 Data Line 4
    // 
    // Bits[7:0], RW/P, default = 0xAA
    //
    UINTX data_line4 : 8;
    //
    // Contents of Pattern Buffer 4 Data Line 5
    // 
    // Bits[15:8], RW/P, default = 0xAA
    //
    UINTX data_line5 : 8;
    //
    // Contents of Pattern Buffer 4 Data Line 6
    // 
    // Bits[23:16], RW/P, default = 0xAA
    //
    UINTX data_line6 : 8;
    //
    // Contents of Pattern Buffer 4 Data Line 7
    // 
    // Bits[31:24], RW/P, default = 0xAA
    //
    UINTX data_line7 : 8;
  } Bits;
  UINTX Data;
} CPGC_DPAT_EXTBUF4B_CPGC_STRUCT;
#endif // ASM_INC

#define CPGC_DPAT_EXTBUF5B_CPGC_REG                        0x00000254
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Contents of Pattern Buffer 5 Data Line 4
    // 
    // Bits[7:0], RW/P, default = 0xAA
    //
    UINTX data_line4 : 8;
    //
    // Contents of Pattern Buffer 5 Data Line 5
    // 
    // Bits[15:8], RW/P, default = 0xAA
    //
    UINTX data_line5 : 8;
    //
    // Contents of Pattern Buffer 5 Data Line 6
    // 
    // Bits[23:16], RW/P, default = 0xAA
    //
    UINTX data_line6 : 8;
    //
    // Contents of Pattern Buffer 5 Data Line 7
    // 
    // Bits[31:24], RW/P, default = 0xAA
    //
    UINTX data_line7 : 8;
  } Bits;
  UINTX Data;
} CPGC_DPAT_EXTBUF5B_CPGC_STRUCT;
#endif // ASM_INC

#define CPGC_DPAT_EXTBUF6B_CPGC_REG                        0x00000258
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Contents of Pattern Buffer 6 Data Line 4
    // 
    // Bits[7:0], RW/P, default = 0xAA
    //
    UINTX data_line4 : 8;
    //
    // Contents of Pattern Buffer 6 Data Line 5
    // 
    // Bits[15:8], RW/P, default = 0xAA
    //
    UINTX data_line5 : 8;
    //
    // Contents of Pattern Buffer 6 Data Line 6
    // 
    // Bits[23:16], RW/P, default = 0xAA
    //
    UINTX data_line6 : 8;
    //
    // Contents of Pattern Buffer 6 Data Line 7
    // 
    // Bits[31:24], RW/P, default = 0xAA
    //
    UINTX data_line7 : 8;
  } Bits;
  UINTX Data;
} CPGC_DPAT_EXTBUF6B_CPGC_STRUCT;
#endif // ASM_INC

#define CPGC_DPAT_EXTBUF7B_CPGC_REG                        0x0000025C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Contents of Pattern Buffer 7 Data Line 4
    // 
    // Bits[7:0], RW/P, default = 0xAA
    //
    UINTX data_line4 : 8;
    //
    // Contents of Pattern Buffer 7 Data Line 5
    // 
    // Bits[15:8], RW/P, default = 0xAA
    //
    UINTX data_line5 : 8;
    //
    // Contents of Pattern Buffer 7 Data Line 6
    // 
    // Bits[23:16], RW/P, default = 0xAA
    //
    UINTX data_line6 : 8;
    //
    // Contents of Pattern Buffer 7 Data Line 7
    // 
    // Bits[31:24], RW/P, default = 0xAA
    //
    UINTX data_line7 : 8;
  } Bits;
  UINTX Data;
} CPGC_DPAT_EXTBUF7B_CPGC_STRUCT;
#endif // ASM_INC

#define CPGC_DPAT_EXTBUF8B_CPGC_REG                        0x00000260
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Contents of Pattern Buffer 8 Data Line 4
    // 
    // Bits[7:0], RW/P, default = 0xAA
    //
    UINTX data_line4 : 8;
    //
    // Contents of Pattern Buffer 8 Data Line 5
    // 
    // Bits[15:8], RW/P, default = 0xAA
    //
    UINTX data_line5 : 8;
    //
    // Contents of Pattern Buffer 8 Data Line 6
    // 
    // Bits[23:16], RW/P, default = 0xAA
    //
    UINTX data_line6 : 8;
    //
    // Contents of Pattern Buffer 8 Data Line 7
    // 
    // Bits[31:24], RW/P, default = 0xAA
    //
    UINTX data_line7 : 8;
  } Bits;
  UINTX Data;
} CPGC_DPAT_EXTBUF8B_CPGC_STRUCT;
#endif // ASM_INC

#define CPGC_DPAT_EXTBUF9B_CPGC_REG                        0x00000264
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Contents of Pattern Buffer 9 Data Line 4
    // 
    // Bits[7:0], RW/P, default = 0xAA
    //
    UINTX data_line4 : 8;
    //
    // Contents of Pattern Buffer 9 Data Line 5
    // 
    // Bits[15:8], RW/P, default = 0xAA
    //
    UINTX data_line5 : 8;
    //
    // Contents of Pattern Buffer 9 Data Line 6
    // 
    // Bits[23:16], RW/P, default = 0xAA
    //
    UINTX data_line6 : 8;
    //
    // Contents of Pattern Buffer 9 Data Line 7
    // 
    // Bits[31:24], RW/P, default = 0xAA
    //
    UINTX data_line7 : 8;
  } Bits;
  UINTX Data;
} CPGC_DPAT_EXTBUF9B_CPGC_STRUCT;
#endif // ASM_INC

#define CPGC_DPAT_EXTBUF10B_CPGC_REG                       0x00000268
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Contents of Pattern Buffer 10 Data Line 4
    // 
    // Bits[7:0], RW/P, default = 0xAA
    //
    UINTX data_line4 : 8;
    //
    // Contents of Pattern Buffer 10 Data Line 5
    // 
    // Bits[15:8], RW/P, default = 0xAA
    //
    UINTX data_line5 : 8;
    //
    // Contents of Pattern Buffer 10 Data Line 6
    // 
    // Bits[23:16], RW/P, default = 0xAA
    //
    UINTX data_line6 : 8;
    //
    // Contents of Pattern Buffer 10 Data Line 7
    // 
    // Bits[31:24], RW/P, default = 0xAA
    //
    UINTX data_line7 : 8;
  } Bits;
  UINTX Data;
} CPGC_DPAT_EXTBUF10B_CPGC_STRUCT;
#endif // ASM_INC

#define CPGC_DPAT_EXTBUF11B_CPGC_REG                       0x0000026C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Contents of Pattern Buffer 11 Data Line 4
    // 
    // Bits[7:0], RW/P, default = 0xAA
    //
    UINTX data_line4 : 8;
    //
    // Contents of Pattern Buffer 11 Data Line 5
    // 
    // Bits[15:8], RW/P, default = 0xAA
    //
    UINTX data_line5 : 8;
    //
    // Contents of Pattern Buffer 11 Data Line 6
    // 
    // Bits[23:16], RW/P, default = 0xAA
    //
    UINTX data_line6 : 8;
    //
    // Contents of Pattern Buffer 11 Data Line 7
    // 
    // Bits[31:24], RW/P, default = 0xAA
    //
    UINTX data_line7 : 8;
  } Bits;
  UINTX Data;
} CPGC_DPAT_EXTBUF11B_CPGC_STRUCT;
#endif // ASM_INC

#define CPGC_DPAT_EXTBUF12B_CPGC_REG                       0x00000270
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Contents of Pattern Buffer 12 Data Line 4
    // 
    // Bits[7:0], RW/P, default = 0xAA
    //
    UINTX data_line4 : 8;
    //
    // Contents of Pattern Buffer 12 Data Line 5
    // 
    // Bits[15:8], RW/P, default = 0xAA
    //
    UINTX data_line5 : 8;
    //
    // Contents of Pattern Buffer 12 Data Line 6
    // 
    // Bits[23:16], RW/P, default = 0xAA
    //
    UINTX data_line6 : 8;
    //
    // Contents of Pattern Buffer 12 Data Line 7
    // 
    // Bits[31:24], RW/P, default = 0xAA
    //
    UINTX data_line7 : 8;
  } Bits;
  UINTX Data;
} CPGC_DPAT_EXTBUF12B_CPGC_STRUCT;
#endif // ASM_INC

#define CPGC_DPAT_EXTBUF13B_CPGC_REG                       0x00000274
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Contents of Pattern Buffer 13 Data Line 4
    // 
    // Bits[7:0], RW/P, default = 0xAA
    //
    UINTX data_line4 : 8;
    //
    // Contents of Pattern Buffer 13 Data Line 5
    // 
    // Bits[15:8], RW/P, default = 0xAA
    //
    UINTX data_line5 : 8;
    //
    // Contents of Pattern Buffer 13 Data Line 6
    // 
    // Bits[23:16], RW/P, default = 0xAA
    //
    UINTX data_line6 : 8;
    //
    // Contents of Pattern Buffer 13 Data Line 7
    // 
    // Bits[31:24], RW/P, default = 0xAA
    //
    UINTX data_line7 : 8;
  } Bits;
  UINTX Data;
} CPGC_DPAT_EXTBUF13B_CPGC_STRUCT;
#endif // ASM_INC

#define CPGC_DPAT_EXTBUF14B_CPGC_REG                       0x00000278
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Contents of Pattern Buffer 14 Data Line 4
    // 
    // Bits[7:0], RW/P, default = 0xAA
    //
    UINTX data_line4 : 8;
    //
    // Contents of Pattern Buffer 14 Data Line 5
    // 
    // Bits[15:8], RW/P, default = 0xAA
    //
    UINTX data_line5 : 8;
    //
    // Contents of Pattern Buffer 14 Data Line 6
    // 
    // Bits[23:16], RW/P, default = 0xAA
    //
    UINTX data_line6 : 8;
    //
    // Contents of Pattern Buffer 14 Data Line 7
    // 
    // Bits[31:24], RW/P, default = 0xAA
    //
    UINTX data_line7 : 8;
  } Bits;
  UINTX Data;
} CPGC_DPAT_EXTBUF14B_CPGC_STRUCT;
#endif // ASM_INC

#define CPGC_DPAT_EXTBUF15B_CPGC_REG                       0x0000027C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Contents of Pattern Buffer 15 Data Line 4
    // 
    // Bits[7:0], RW/P, default = 0xAA
    //
    UINTX data_line4 : 8;
    //
    // Contents of Pattern Buffer 15 Data Line 5
    // 
    // Bits[15:8], RW/P, default = 0xAA
    //
    UINTX data_line5 : 8;
    //
    // Contents of Pattern Buffer 15 Data Line 6
    // 
    // Bits[23:16], RW/P, default = 0xAA
    //
    UINTX data_line6 : 8;
    //
    // Contents of Pattern Buffer 15 Data Line 7
    // 
    // Bits[31:24], RW/P, default = 0xAA
    //
    UINTX data_line7 : 8;
  } Bits;
  UINTX Data;
} CPGC_DPAT_EXTBUF15B_CPGC_STRUCT;
#endif // ASM_INC

#define CPGC_ERR_CAP_CPGC_REG                              0x00000280
#ifndef ASM_INC
typedef union {
  struct {
    //
    // The width of the data lane error mask supported by this implementation is encoded
    // as follows:[br] 
    // 00 - 8-bit Mask[br]
    // 01 - 16-bit Mask[br]
    // 10 - 32-bit Mask[br]
    // 11 - 64-bit Mask
    // 
    // Bits[1:0], RO, default = 0x3
    //
    UINTX data_err_mask_width_cap : 2;
    //
    // The width of the ECC lane error mask supported by this implementation is encoded
    // as follows:[br] 
    // 00 - No ECC Lane Error Mask Supported[br]
    // 01 - 4-bit ECC Lane Error Mask[br]
    // 10 - 8-bit ECC Lane Error Mask[br]
    // All other values are reserved.
    // 
    // Bits[3:2], RO, default = 0x2
    //
    UINTX ecc_err_mask_width_cap : 2;
    //
    // Number of byte groups composing the error status for the data lanes (excluding
    // ECC byte group if supported) is encoded as follows:[br] 
    // 0 - 4-Byte Groups (One 32-bit Lane Error Status Register)[br]
    // 1 - 8-Byte Groups (Two 32-bit Lane Error Status Registers)
    // 
    // Bits[4:4], RO, default = 0x1
    //
    UINTX data_err_stat_cap : 1;
    //
    // This bit is set if ECC error status logging is supported
    // 
    // Bits[5:5], RO, default = 0x1
    //
    UINTX ecc_err_stat_cap : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:6], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
    //
    // This bit is set if error chunk logging capability is supported.
    // 
    // Bits[8:8], RO, default = 0x1
    //
    UINTX chunk_err_stat_cap : 1;
    //
    // This bit is set if command error capture is supported.
    // 
    // Bits[9:9], RO, default = 0x1
    //
    UINTX cmd_err_capt_cap : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[15:10], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 6;
    //
    // If this is set then error injection through disabling RD data Inversion/DC mask
    // rotation is supported. 
    // 
    // Bits[16:16], RO, default = 0x0
    //
    UINTX err_inj_cap : 1;
    //
    // If this bit is set error logging capabilities are supported and can be accessed
    // by the ERR_LOG registers. 
    // 
    // Bits[17:17], RO, default = 0x0
    //
    UINTX err_log_cap : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:18], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 14;
  } Bits;
  UINTX Data;
} CPGC_ERR_CAP_CPGC_STRUCT;
#endif // ASM_INC

#define CPGC_ERR_CTL_CPGC_REG                              0x00000284
#ifndef ASM_INC
typedef union {
  struct {
    //
    // If STOP_ON_ERR is set to Stop on Nth Error Mode, the test will stop after (SOP_ON_N
    // + 1) or more errors have been accumulated in the ERR_CNTR 
    // 
    // Bits[5:0], RW/P, default = 0x0
    //
    UINTX stop_on_n : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[11:6], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 6;
    //
    // Defines test stop conditions based on error checking as follows:[br]
    // 
    // 00 - Never stop: Prevents any error from stopping the test.[br]
    // 01 - Stop On Nth Error: Stop once ERR_CNTR has accumulated at least (STOP_ON_N
    // + 1) errors.[br] 
    // 10 - Stop On All Byte Groups Error:  Stop if every byte group indicates that at
    // least one of its lanes accumulated at least one error. 
    // That is, if all bits BYTEGRP_ERR_STAT, (and ECC_GRP_ERR_STAT if supported), are
    // all set.[br] 
    // 11 - Stop On All Lanes Error:  Stop if every lane within every byte group has
    // accumulated at least one error. 
    // That is, if all bits in LANE_ERR_STATLO, LANE_ERR_STATHI, (and ECC_LANE_ERR_STAT
    // if supported) are all set. 
    // 
    // Bits[13:12], RW/P, default = 0x0
    //
    UINTX stop_on_err_control : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[15:14], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 2;
    //
    // Defines which chunk within the burst of data (i.e. bit within a burst of 8-bits
    // for each lane) to check for errors. 
    // Only chunks with a corresponding bit value of '1' will be checked for errors.
    // 
    // Bits[23:16], RW/P, default = 0xFF
    //
    UINTX errchk_mask_chunk : 8;
    //
    // Defines a periodic burst (CAS command) mask that repeats every 8 CAS commands
    // as follows:[br] 
    // Bit 0 - Burst 0 (CAS command 0)[br]
    // Bit 1 - Burst 1 (CAS command 1)[br]
    // ...[br]
    // Bit 7 - Burst 7 (CAS command 7)[br]
    // Only bursts with a corresponding bit value of '1' will be checked for errors.
    // A burst is defined as a burst length 8 CAS commands. 
    // 
    // Bits[31:24], RW/P, default = 0xFF
    //
    UINTX errchk_mask_cacheline : 8;
  } Bits;
  UINTX Data;
} CPGC_ERR_CTL_CPGC_STRUCT;
#endif // ASM_INC

#define CPGC_ERR_LANE_MASK_LO_CPGC_REG                     0x00000288
#ifndef ASM_INC
typedef union {
  struct {
    //
    // A one-hot mask used to enable error checking on data lanes [31:0].  Only lanes
    // selected through this mask will be checked for errors. The lane-to-bit mapping
    // for this mask depends on the width of the mask but is in general given by the
    // following formula: Lane[n] -> bit[n % DATA_LNEN_MASK_WIDTH]. 
    // 
    // Bits[31:0], RW/P, default = 0xFFFFFFFF
    //
    UINTX data_errchk_mask_lo : 32;
  } Bits;
  UINTX Data;
} CPGC_ERR_LANE_MASK_LO_CPGC_STRUCT;
#endif // ASM_INC

#define CPGC_ERR_LANE_MASK_HI_CPGC_REG                     0x0000028C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // A one-hot mask used to enable error checking on data lanes [63:32].  Only lanes
    // selected through this mask will be checked for errors. The lane-to-bit mapping
    // for this mask depends on the width of the mask but is in general given by the
    // following formula: Lane[n] -> bit[n % DATA_LNEN_MASK_WIDTH]. 
    // 
    // Bits[31:0], RW/P, default = 0xFFFFFFFF
    //
    UINTX data_errchk_mask_hi : 32;
  } Bits;
  UINTX Data;
} CPGC_ERR_LANE_MASK_HI_CPGC_STRUCT;
#endif // ASM_INC

#define CPGC_ERR_ECC_MASK_CPGC_REG                         0x00000290
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Used as an error check enable mask for ECC lanes.  Only the lanes selected through
    // the mask will be checked for errors. The lane-to-bit mapping is 1-to-1 and hence
    // bit 1 corresponds to ECC lane 0, bit 1 corresponds to ECC lane 1, and so on.[br]
    // Note: This field is available only if ECC is supported and its width is defined
    // by the ECC_ERR_WIDTH_MASK_CAP field. 
    // 
    // Bits[7:0], RW/P, default = 0xFF
    //
    UINTX ecc_errchk_mask : 8;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:8], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 24;
  } Bits;
  UINTX Data;
} CPGC_ERR_ECC_MASK_CPGC_STRUCT;
#endif // ASM_INC

#define CPGC_ERR_ADDRESS_CPGC_REG                          0x00000294
#ifndef ASM_INC
typedef union {
  struct {
    //
    // N/A
    // 
    // Bits[31:0], RO/V, default = 0x0
    //
    UINTX err_logical_address : 32;
  } Bits;
  UINTX Data;
} CPGC_ERR_ADDRESS_CPGC_STRUCT;
#endif // ASM_INC

#define CPGC_ERR_STAT_LO_CPGC_REG                          0x00000298
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Indicates if a mismatch was detected between the WR and the RD data on one of
    // the lanes belonging to byte group 0.  Hence lanes [32:0] map to bits [32:0] respectively.
    //  The error status information is encoded as follows: [br] 
    // 0: No mismatches detected on corresponding lane.[br]
    // 1: At least one mismatch detected on corresponding lane.
    // 
    // Bits[7:0], RW/1C/V/P, default = 0x0
    //
    UINTX lane_err_status_lo_0 : 8;
    //
    // Indicates if a mismatch was detected between the WR and the RD data on one of
    // the lanes belonging to byte group 1.  Hence lanes [32:0] map to bits [32:0] respectively.
    //  The error status information is encoded as follows: [br] 
    // 0: No mismatches detected on corresponding lane.[br]
    // 1: At least one mismatch detected on corresponding lane.
    // 
    // Bits[15:8], RW/1C/V/P, default = 0x0
    //
    UINTX lane_err_status_lo_1 : 8;
    //
    // Indicates if a mismatch was detected between the WR and the RD data on one of
    // the lanes belonging to byte group 2.  Hence lanes [32:0] map to bits [32:0] respectively.
    //  The error status information is encoded as follows: [br] 
    // 0: No mismatches detected on corresponding lane.[br]
    // 1: At least one mismatch detected on corresponding lane.
    // 
    // Bits[23:16], RW/1C/V/P, default = 0x0
    //
    UINTX lane_err_status_lo_2 : 8;
    //
    // Indicates if a mismatch was detected between the WR and the RD data on one of
    // the lanes belonging to byte group 3.  Hence lanes [32:0] map to bits [32:0] respectively.
    //  The error status information is encoded as follows: [br] 
    // 0: No mismatches detected on corresponding lane.[br]
    // 1: At least one mismatch detected on corresponding lane.
    // 
    // Bits[31:24], RW/1C/V/P, default = 0x0
    //
    UINTX lane_err_status_lo_3 : 8;
  } Bits;
  UINTX Data;
} CPGC_ERR_STAT_LO_CPGC_STRUCT;
#endif // ASM_INC

#define CPGC_ERR_STAT_HI_CPGC_REG                          0x0000029C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Indicates if a mismatch was detected between the WR and the RD data on one of
    // the lanes belonging to byte group 4.  Hence lanes [63:32] map to bits [32:0] respectively.
    //  The error status information is encoded as follows: [br] 
    // 0: No mismatches detected on corresponding lane.[br]
    // 1: At least one mismatch detected on corresponding lane.
    // 
    // 
    // Bits[7:0], RW/1C/V/P, default = 0x0
    //
    UINTX lane_err_status_hi_0 : 8;
    //
    // Indicates if a mismatch was detected between the WR and the RD data on one of
    // the lanes belonging to byte group 5.  Hence lanes [63:32] map to bits [32:0] respectively.
    //  The error status information is encoded as follows: [br] 
    // 0: No mismatches detected on corresponding lane.[br]
    // 1: At least one mismatch detected on corresponding lane.
    // 
    // 
    // Bits[15:8], RW/1C/V/P, default = 0x0
    //
    UINTX lane_err_status_hi_1 : 8;
    //
    // Indicates if a mismatch was detected between the WR and the RD data on one of
    // the lanes belonging to byte group 6.  Hence lanes [63:32] map to bits [32:0] respectively.
    //  The error status information is encoded as follows: [br] 
    // 0: No mismatches detected on corresponding lane.[br]
    // 1: At least one mismatch detected on corresponding lane.
    // 
    // 
    // Bits[23:16], RW/1C/V/P, default = 0x0
    //
    UINTX lane_err_status_hi_2 : 8;
    //
    // Indicates if a mismatch was detected between the WR and the RD data on one of
    // the lanes belonging to byte group 7.  Hence lanes [63:32] map to bits [32:0] respectively.
    //  The error status information is encoded as follows: [br] 
    // 0: No mismatches detected on corresponding lane.[br]
    // 1: At least one mismatch detected on corresponding lane.
    // 
    // 
    // Bits[31:24], RW/1C/V/P, default = 0x0
    //
    UINTX lane_err_status_hi_3 : 8;
  } Bits;
  UINTX Data;
} CPGC_ERR_STAT_HI_CPGC_STRUCT;
#endif // ASM_INC

#define CPGC_ERR_ECC_CHUNK_RANK_STAT_CPGC_REG              0x000002A0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Indicates if a mismatch was detected between the WR and the RD data on one of
    // the lanes belonging to the ECC byte group.  The error status information is encoded
    // as follows:[br] 0: No mismatches detected on corresponding lane.[br] 1: At least
    // one mismatch detected on corresponding lane.[br] Note: this field is only available
    // if ECC is supported for the current implementation, otherwise it is reserved.
    // 
    // Bits[7:0], RW/V, default = 0x0
    //
    UINTX ecc_lane_err_stat : 8;
    //
    // A one-hot field where each bit corresponds to a specific chunk (i.e. bit within
    // a burst of 8-bits). If set, the corresponding chunk (UI) has accumulated at least
    // one error. 
    // 
    // Bits[15:8], RW/V, default = 0x0
    //
    UINTX chunk_err_stat : 8;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:16], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 16;
  } Bits;
  UINTX Data;
} CPGC_ERR_ECC_CHUNK_RANK_STAT_CPGC_STRUCT;
#endif // ASM_INC

#define CPGC_ERR_BYTE_NTH_STAT_CPGC_REG                    0x000002A4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // One-hot field with each bit corresponding to a specific byte group.  Bit 0 corresponds
    // to byte group 0, bit 1 corresponds to byte group 1, bit 1 corresponds to byte
    // group 1, and so on.  A set bit implies that the corresponding byte group has at
    // least one lane that accumulated at least one error. 
    // 
    // Bits[7:0], RW/V, default = 0x0
    //
    UINTX bytegrp_err_stat : 8;
    //
    // One-hot field with each bit corresponding to a specific byte group.  Bit 0 corresponds
    // to byte group 0, bit 1 corresponds to byte group 1, bit 1 corresponds to byte
    // group 1, and so on.  A set bit implies that the corresponding byte group has at
    // least one lane that accumulated at least one error. 
    // 
    // Bits[8:8], RW/V, default = 0x0
    //
    UINTX eccgrp_err_stat : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[15:9], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 7;
    //
    // Pointer to last executing subsequence before test exit.  When stopping on an error,
    // ERR_SEQ_POINTER will point to the subsequence that experienced the last error
    // before test exit.  ERR_SEQ_POINTER can be used with other status registers/fields
    // including ERR_LOOP and ERR_BURS to compute the address and pattern of the burst
    // that experienced an error.  
    // 
    // Bits[18:16], RO/V, default = 0x0
    //
    UINTX err_subsequence_pointer : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:19], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 13;
  } Bits;
  UINTX Data;
} CPGC_ERR_BYTE_NTH_STAT_CPGC_STRUCT;
#endif // ASM_INC

#define CPGC_ERR_COUNTER_OVERFLOW_STAT_CPGC_REG            0x000002AC
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Indicates that ERR_COUNTER# has wrapped around at least once.[br]Note:Bit 0 corresponds
    // to CPGC_ERR_COUNTER0_STATUS2:29 PM 
    // 
    // 
    // Bits[0:0], RW/1C/P, default = 0x0
    //
    UINTX err_counter_overflow : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:1], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 31;
  } Bits;
  UINTX Data;
} CPGC_ERR_COUNTER_OVERFLOW_STAT_CPGC_STRUCT;
#endif // ASM_INC

#define CPGC_ERR_LOOP_CPGC_REG                             0x000002B0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // The last command sequence executing before test exit. When stopping on an error,
    // ERR_LOOP will be the last command sequence loop that an error occurred within.
    // ERR_LOOP can be used with other status registers/fields including ERR_SEQ_POINTER
    // and ERR_BURST to compute the address and pattern of the burst that experienced
    // an error. 
    // 
    // Bits[31:0], RO/V, default = 0x0
    //
    UINTX err_loopcount : 32;
  } Bits;
  UINTX Data;
} CPGC_ERR_LOOP_CPGC_STRUCT;
#endif // ASM_INC

#define CPGC_ERR_BURST_CPGC_REG                            0x000002B4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // The last burst issued before test exit. When stopping on an error, ERR_BURST will
    // be the last burst issued that experienced an error. ERR_BURST can be used with
    // other status registers/fields including ERR_SEQ_POINTER and ERR_LOOP to compute
    // the address and pattern of the burst that experienced an error. 
    // 
    // Bits[31:0], RO/V, default = 0x0
    //
    UINTX err_burst : 32;
  } Bits;
  UINTX Data;
} CPGC_ERR_BURST_CPGC_STRUCT;
#endif // ASM_INC

#define CPGC_ERRLOG_CTL_STAT_CPGC_REG                      0x000002B8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Provides the current Read Pointer location indexed at the Read Data Buffer. This
    // will be used for knowing how many Reads the user need to issue to return the pointer
    // to the actual failing entry. This functionality is not supported on DNV 
    // 
    // Bits[3:0], RSV, default = 0x0
    //
    UINTX curr_rd_pointer : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[4:4], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 1;
    //
    // Provides the Read Pointer location that caused the error that triggered STOP_ON_ERR.
    // This will be used for knowing exactly which entry in the Read Data Buffer contains
    // the faulty cacheline data. This functionality is not supported on DNV. This functionality
    // is not supported on DNV 
    // 
    // Bits[8:5], RSV, default = 0x0
    //
    UINTX err_rd_pointer : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[11:9], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 3;
    //
    // Signal that will allow auto-increment feature for each PMI 32bit data chunk read
    // from the CPGC_ERRLOG_DATA register.[br] Note: If this bit is set, when doing the
    // last PMI 32bit chunk data access via reading the CPGC_ERRLOG_DATA register, the
    // CURR_RD_POINTER will auto increment as well. This functionality is not supported
    // on DNV 
    // 
    // Bits[12:12], RSV, default = 0x0
    //
    UINTX errlog_auto_chnk_inc : 1;
    //
    // Asserting this bit will have the effect of incrementing by one the Current Read
    // Pointer at the actual Read Data Buffer. User can manually browse through the Read
    // Data Buffer and dump its contents. This bit will always return '0' if read by
    // software. This functionality is not supported on DNV 
    // 
    // Bits[13:13], RSV, default = 0x0
    //
    UINTX errlog_move : 1;
    //
    // Asserting this bit will have the effect of CPGC automatically generating the needed
    // Read transactions such as the current Read Pointer targets the last failing cachline.
    // Instead of manually browsing, user can set this bit and logic will make sure that
    // CURR_RD_POINTER == ERR_RD_POINTER. This bit will always return '0' if read by
    // software. This functionality is not supported on DNV 
    // 
    // Bits[14:14], RSV, default = 0x0
    //
    UINTX errlog_auto : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:15], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 17;
  } Bits;
  UINTX Data;
} CPGC_ERRLOG_CTL_STAT_CPGC_STRUCT;
#endif // ASM_INC

#define CPGC_ERRLOG_DATA_CPGC_REG                          0x000002BC
#ifndef ASM_INC
typedef union {
  struct {
    //
    // 32 bits of data corresponding to one of eight (or four for ANN) 32 bit PMI chunks
    // available per Read Pointer location, If ERRLOG_AUTO_CHNK_INC is set, then each
    // read to this register will read out a successive 32 bit PMI chunk of data. This
    // functionality is not supported on DNV 
    // 
    // Bits[31:0], RSV, default = 0x0
    //
    UINTX errlog_data : 32;
  } Bits;
  UINTX Data;
} CPGC_ERRLOG_DATA_CPGC_STRUCT;
#endif // ASM_INC

#define CPGC_ERR_CNTRCTL0_CPGC_REG                         0x000002C0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Counter_Pointer is used in conjunction with Counter_Control to indicate what lane,
    // byte group, or chunk is desired for tracking errors in CPGC_ERR_COUNTER#_STATUS.[br]
    // If Counter_Control=0x01 (Lane) then the encoding is defined as:[br] 
    //  Counter_Pointer  = 0 indicates to count errors in for DQ0.[br]
    //  ...[br]
    //  Counter_Pointer  = 7 indicates to count errors in for DQ7.[br]
    //  ...[br]
    //  Counter_Pointer  = 64 indicates to count errors in for ECC0.[br]
    //  ...[br]
    //  Counter_Pointer  = 71 indicates to count errors in for ECC7.[br]
    // If Counter_Control=0x10 (Byte Group) then the encoding for x8 DIMMS byte groups
    // is defined as: [br] 
    //  Counter_Pointer  = 0 indicates to count errors in for Byte 0 (data lanes 0-7).[br]
    //  ...[br]
    //  Counter_Pointer  = 7 indicates to count errors in for Byte 7 (data lanes 56-63).[br]
    //  Counter_Pointer  = 8 indicates to count errors in for ECC (data lanes 64-71).[br]
    // If Counter_Control=0x11 (Chunk) then the encoding is defined as:[br]
    //  Counter_Pointer  = 0 indicates to count errors in chunk 0.[br]
    //  ...[br]
    //  Counter_Pointer  = 7 indicates to count errors in chunk 7.
    // 
    // Bits[6:0], RW/V/P, default = 0x7F
    //
    UINTX counter_pointer : 7;
    //
    // Counter Control determines what gets counted by the CPGC error checking logic.
    // Counter CPGC_ERR_COUNTER_STATUS#.[br] 
    // 
    // 00 = Count Errors on all Lanes - The Error Counter will capture the OR of all
    // error across all lanes in a chunk.  For example, if 1 lane or 72 lanes experience
    // an error in a chunk then the CPGC_ERR_COUNTER_STATUS# will be incremented by 1.[br][br]
    // 
    // 01 = Count Errors on a particular Lane - The Error Counter will count the number
    // of errors on the lane indicated by CPGC_ERR_COUNTER#_CTL.Counter_Pointer.[br][br]
    // 
    // 10 = Count Errors on a particular Byte Group - The Error Counter will count the
    // number of errors on the Byte group indicated by CPGC_ERR_COUNTER#_CTL.Counter_Pointer
    //  ECC is byte group 8 in x8 technology and ECC is byte group 8 and 17 in x4 technology.[br][br]
    // 
    // 11 = Count Errors on a particular Chunk - The Error Counter will count the number
    // of errors on a particular chunk in the cacheline indicated by CPGC_ERR_COUNTER#_CTL.Counter_Pointer.
    // 
    // Bits[8:7], RW/V/P, default = 0x0
    //
    UINTX counter_control : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:9], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 23;
  } Bits;
  UINTX Data;
} CPGC_ERR_CNTRCTL0_CPGC_STRUCT;
#endif // ASM_INC

#define CPGC_ERR_CNTRCTL0A_CPGC_REG                        0x000002C4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Errors accumulated for the error type selected through CPGC_ERR_COUNTER#_CTL.
    // 
    // Bits[22:0], RO/V, default = 0x0
    //
    UINTX err_counter : 23;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:23], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 9;
  } Bits;
  UINTX Data;
} CPGC_ERR_CNTRCTL0A_CPGC_STRUCT;
#endif // ASM_INC

#define CPGC_ERR_CNTRCTL0B_CPGC_REG                        0x000002C8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Errors accumulated for the error type selected through CPGC_ERR_COUNTER#_CTL.
    // 
    // Bits[22:0], RO/V, default = 0x0
    //
    UINTX err_counter : 23;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:23], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 9;
  } Bits;
  UINTX Data;
} CPGC_ERR_CNTRCTL0B_CPGC_STRUCT;
#endif // ASM_INC

#define CPGC_ERR_CNTRCTL0C_CPGC_REG                        0x000002CC
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Errors accumulated for the error type selected through CPGC_ERR_COUNTER#_CTL.
    // 
    // Bits[22:0], RO/V, default = 0x0
    //
    UINTX err_counter : 23;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:23], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 9;
  } Bits;
  UINTX Data;
} CPGC_ERR_CNTRCTL0C_CPGC_STRUCT;
#endif // ASM_INC

#define CPGC_ERR_CNTRCTL0D_CPGC_REG                        0x000002D0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Errors accumulated for the error type selected through CPGC_ERR_COUNTER#_CTL.
    // 
    // Bits[22:0], RO/V, default = 0x0
    //
    UINTX err_counter : 23;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:23], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 9;
  } Bits;
  UINTX Data;
} CPGC_ERR_CNTRCTL0D_CPGC_STRUCT;
#endif // ASM_INC

#define CPGC_ERR_CNTRCTL0E_CPGC_REG                        0x000002D4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Errors accumulated for the error type selected through CPGC_ERR_COUNTER#_CTL.
    // 
    // Bits[22:0], RO/V, default = 0x0
    //
    UINTX err_counter : 23;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:23], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 9;
  } Bits;
  UINTX Data;
} CPGC_ERR_CNTRCTL0E_CPGC_STRUCT;
#endif // ASM_INC

#define CPGC_ERR_CNTRCTL0F_CPGC_REG                        0x000002D8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Errors accumulated for the error type selected through CPGC_ERR_COUNTER#_CTL.
    // 
    // Bits[22:0], RO/V, default = 0x0
    //
    UINTX err_counter : 23;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:23], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 9;
  } Bits;
  UINTX Data;
} CPGC_ERR_CNTRCTL0F_CPGC_STRUCT;
#endif // ASM_INC

#define CPGC_ERR_CNTRCTL0G_CPGC_REG                        0x000002DC
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Errors accumulated for the error type selected through CPGC_ERR_COUNTER#_CTL.
    // 
    // Bits[22:0], RO/V, default = 0x0
    //
    UINTX err_counter : 23;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:23], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 9;
  } Bits;
  UINTX Data;
} CPGC_ERR_CNTRCTL0G_CPGC_STRUCT;
#endif // ASM_INC

#define CPGC_ERR_CNTR0_CPGC_REG                            0x000002E0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Errors accumulated for the error type selected through CPGC_ERR_COUNTER#_CTL.
    // 
    // Bits[22:0], RW/1C/V/P, default = 0x0
    //
    UINTX err_counter : 23;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:23], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 9;
  } Bits;
  UINTX Data;
} CPGC_ERR_CNTR0_CPGC_STRUCT;
#endif // ASM_INC

#define CPGC_ERR_CNTRCTL0H_CPGC_REG                        0x000002E4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Errors accumulated for the error type selected through CPGC_ERR_COUNTER#_CTL.
    // 
    // Bits[22:0], RO/V, default = 0x0
    //
    UINTX err_counter : 23;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:23], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 9;
  } Bits;
  UINTX Data;
} CPGC_ERR_CNTRCTL0H_CPGC_STRUCT;
#endif // ASM_INC

#define CPGC_ERR_CNTRCTL0I_CPGC_REG                        0x000002E8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Errors accumulated for the error type selected through CPGC_ERR_COUNTER#_CTL.
    // 
    // Bits[22:0], RO/V, default = 0x0
    //
    UINTX err_counter : 23;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:23], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 9;
  } Bits;
  UINTX Data;
} CPGC_ERR_CNTRCTL0I_CPGC_STRUCT;
#endif // ASM_INC

#define CPGC_ERR_CNTRCTL0J_CPGC_REG                        0x000002EC
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Errors accumulated for the error type selected through CPGC_ERR_COUNTER#_CTL.
    // 
    // Bits[22:0], RO/V, default = 0x0
    //
    UINTX err_counter : 23;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:23], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 9;
  } Bits;
  UINTX Data;
} CPGC_ERR_CNTRCTL0J_CPGC_STRUCT;
#endif // ASM_INC

#define CPGC_ERR_CNTRCTL0K_CPGC_REG                        0x000002F0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Errors accumulated for the error type selected through CPGC_ERR_COUNTER#_CTL.
    // 
    // Bits[22:0], RO/V, default = 0x0
    //
    UINTX err_counter : 23;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:23], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 9;
  } Bits;
  UINTX Data;
} CPGC_ERR_CNTRCTL0K_CPGC_STRUCT;
#endif // ASM_INC

#define CPGC_ERR_CNTRCTL0L_CPGC_REG                        0x000002F4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Errors accumulated for the error type selected through CPGC_ERR_COUNTER#_CTL.
    // 
    // Bits[22:0], RO/V, default = 0x0
    //
    UINTX err_counter : 23;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:23], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 9;
  } Bits;
  UINTX Data;
} CPGC_ERR_CNTRCTL0L_CPGC_STRUCT;
#endif // ASM_INC

#define CPGC_ERR_CNTRCTL0M_CPGC_REG                        0x000002F8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Errors accumulated for the error type selected through CPGC_ERR_COUNTER#_CTL.
    // 
    // Bits[22:0], RO/V, default = 0x0
    //
    UINTX err_counter : 23;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:23], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 9;
  } Bits;
  UINTX Data;
} CPGC_ERR_CNTRCTL0M_CPGC_STRUCT;
#endif // ASM_INC

#define CPGC_ERR_CNTRCTL0N_CPGC_REG                        0x000002FC
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Errors accumulated for the error type selected through CPGC_ERR_COUNTER#_CTL.
    // 
    // Bits[22:0], RO/V, default = 0x0
    //
    UINTX err_counter : 23;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:23], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 9;
  } Bits;
  UINTX Data;
} CPGC_ERR_CNTRCTL0N_CPGC_STRUCT;
#endif // ASM_INC

#define CPGC_ERR_CNTRCTL0P_CPGC_REG                        0x00000300
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Errors accumulated for the error type selected through CPGC_ERR_COUNTER#_CTL.
    // 
    // Bits[22:0], RO/V, default = 0x0
    //
    UINTX err_counter : 23;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:23], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 9;
  } Bits;
  UINTX Data;
} CPGC_ERR_CNTRCTL0P_CPGC_STRUCT;
#endif // ASM_INC

#define CPGC_ERR_CNTRCTL0Q_CPGC_REG                        0x00000304
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Errors accumulated for the error type selected through CPGC_ERR_COUNTER#_CTL.
    // 
    // Bits[22:0], RO/V, default = 0x0
    //
    UINTX err_counter : 23;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:23], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 9;
  } Bits;
  UINTX Data;
} CPGC_ERR_CNTRCTL0Q_CPGC_STRUCT;
#endif // ASM_INC

#define CPGC_DPAT_UNISEQ0_RDSAVE_CPGC_REG                  0x00000314
#ifndef ASM_INC
typedef union {
  struct {
    //
    // CPGC_DPAT_UNISEQ_RDSTAT reflects the current and final status of the pattern buffer
    // in the read domain.[br] 
    // If PATBUF mode, then Pattern_Buffer is used as a fixed buffer that is output in
    // serial fashion. After all the bits in the Pattern_Buffer have been transmitted
    // the pattern will simply repeat itself continuously while a Loopback Test is in
    // progress.[br] 
    // If LFSR mode, then Pattern_Buffer is used as a seed to a fixed LFSR that is output
    // in serial fashion. Over time the LFSR pattern will repeat itself continuously
    // while a Loopback Test is in progress. In LFSR Mode the contents of Pattern_Buffer
    // will interact with the LFSR in the following ways:[br] 
    // If LFSR_Save_Restore is set then CPGC_DPAT_UNISEQ_WRSAVE.Pattern_Buffer will interact
    // with CPGC_UNISEQ#_RDSTAT in the following ways:[br] 
    // 1) CPGC_UNISEQ#_RDSTAT will be periodically saved into CPGC_DPAT_UNISEQ#.Pattern_Buffer
    // based on Save_LFSR_Seed_Rate (see Save_LFSR_Seed_Rate for more details).[br] 
    // 2) CPGC_UNISEQ#_RDSTAT will be periodically reloaded with CPGC_DPAT_UNISEQ#.Pattern_Buffer
    // based on Reload_LFSR_Seed_Rate (see Reload_LFSR_Seed_Rate for more details). 
    // 
    // Bits[31:0], RO/V, default = 0x0
    //
    UINTX pattern_buffer : 32;
  } Bits;
  UINTX Data;
} CPGC_DPAT_UNISEQ0_RDSAVE_CPGC_STRUCT;
#endif // ASM_INC

#define CPGC_DPAT_UNISEQ1_RDSAVE_CPGC_REG                  0x00000318
#ifndef ASM_INC
typedef union {
  struct {
    //
    // CPGC_DPAT_UNISEQ_RDSTAT reflects the current and final status of the pattern buffer
    // in the read domain.[br] 
    // If PATBUF mode, then Pattern_Buffer is used as a fixed buffer that is output in
    // serial fashion. After all the bits in the Pattern_Buffer have been transmitted
    // the pattern will simply repeat itself continuously while a Loopback Test is in
    // progress.[br] 
    // If LFSR mode, then Pattern_Buffer is used as a seed to a fixed LFSR that is output
    // in serial fashion. Over time the LFSR pattern will repeat itself continuously
    // while a Loopback Test is in progress. In LFSR Mode the contents of Pattern_Buffer
    // will interact with the LFSR in the following ways:[br] 
    // If LFSR_Save_Restore is set then CPGC_DPAT_UNISEQ_WRSAVE.Pattern_Buffer will interact
    // with CPGC_UNISEQ#_RDSTAT in the following ways:[br] 
    // 1) CPGC_UNISEQ#_RDSTAT will be periodically saved into CPGC_DPAT_UNISEQ#.Pattern_Buffer
    // based on Save_LFSR_Seed_Rate (see Save_LFSR_Seed_Rate for more details).[br] 
    // 2) CPGC_UNISEQ#_RDSTAT will be periodically reloaded with CPGC_DPAT_UNISEQ#.Pattern_Buffer
    // based on Reload_LFSR_Seed_Rate (see Reload_LFSR_Seed_Rate for more details). 
    // 
    // Bits[31:0], RO/V, default = 0x0
    //
    UINTX pattern_buffer : 32;
  } Bits;
  UINTX Data;
} CPGC_DPAT_UNISEQ1_RDSAVE_CPGC_STRUCT;
#endif // ASM_INC

#define CPGC_DPAT_UNISEQ2_RDSAVE_CPGC_REG                  0x0000031C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // CPGC_DPAT_UNISEQ_RDSTAT reflects the current and final status of the pattern buffer
    // in the read domain.[br] 
    // If PATBUF mode, then Pattern_Buffer is used as a fixed buffer that is output in
    // serial fashion. After all the bits in the Pattern_Buffer have been transmitted
    // the pattern will simply repeat itself continuously while a Loopback Test is in
    // progress.[br] 
    // If LFSR mode, then Pattern_Buffer is used as a seed to a fixed LFSR that is output
    // in serial fashion. Over time the LFSR pattern will repeat itself continuously
    // while a Loopback Test is in progress. In LFSR Mode the contents of Pattern_Buffer
    // will interact with the LFSR in the following ways:[br] 
    // If LFSR_Save_Restore is set then CPGC_DPAT_UNISEQ_WRSAVE.Pattern_Buffer will interact
    // with CPGC_UNISEQ#_RDSTAT in the following ways:[br] 
    // 1) CPGC_UNISEQ#_RDSTAT will be periodically saved into CPGC_DPAT_UNISEQ#.Pattern_Buffer
    // based on Save_LFSR_Seed_Rate (see Save_LFSR_Seed_Rate for more details).[br] 
    // 2) CPGC_UNISEQ#_RDSTAT will be periodically reloaded with CPGC_DPAT_UNISEQ#.Pattern_Buffer
    // based on Reload_LFSR_Seed_Rate (see Reload_LFSR_Seed_Rate for more details). 
    // 
    // Bits[31:0], RO/V, default = 0x0
    //
    UINTX pattern_buffer : 32;
  } Bits;
  UINTX Data;
} CPGC_DPAT_UNISEQ2_RDSAVE_CPGC_STRUCT;
#endif // ASM_INC

#define CPGC_DPAT_LMN0_WRSTAT_CPGC_REG                     0x00000320
#ifndef ASM_INC
typedef union {
  struct {
    //
    // The current contents of the LMN buffer in write (Tx) domain. [br]
    // Software decode the current LMN information in this field as follows: [br][br]
    //   LMN_WRSTAT[18:17]  Sweep FSM Phase [br]
    //     2'b00: LCnt bit is driven by L Polarity or Xcount (refer to LMN register description)
    // bits is driven by L Polarity [br] 
    //     2'b01: Number of bits are driven with inverse of L Polarity [br]
    //     2'b10: Number of bits are driven with value of L Polarity [br]
    //     2'b11: Number of bits are driven with inverse of L Polarity [br][br]
    //   LMN_WRSTAT[16:9] Length of X count phase i.e current frequency of X count [br][br]
    //   LMN_WRSTAT[8:8] L Polarity [br][br]
    //   LMN_WRSTAT[7:0] Number of bits left to send for M or N stage  
    //         
    // 
    // Bits[18:0], RO/V, default = 0x0
    //
    UINTX lmn_wrstat : 19;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:19], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 13;
  } Bits;
  UINTX Data;
} CPGC_DPAT_LMN0_WRSTAT_CPGC_STRUCT;
#endif // ASM_INC

#define CPGC_DPAT_LMN1_WRSTAT_CPGC_REG                     0x00000324
#ifndef ASM_INC
typedef union {
  struct {
    //
    // The current contents of the LMN buffer in write (Tx) domain. [br]
    // Software decode the current LMN information in this field as follows: [br][br]
    //   LMN_WRSTAT[18:17]  Sweep FSM Phase [br]
    //     2'b00: LCnt bit is driven by L Polarity or Xcount (refer to LMN register description)
    // bits is driven by L Polarity [br] 
    //     2'b01: Number of bits are driven with inverse of L Polarity [br]
    //     2'b10: Number of bits are driven with value of L Polarity [br]
    //     2'b11: Number of bits are driven with inverse of L Polarity [br][br]
    //   LMN_WRSTAT[16:9] Length of X count phase i.e current frequency of X count [br][br]
    //   LMN_WRSTAT[8:8] L Polarity [br][br]
    //   LMN_WRSTAT[7:0] Number of bits left to send for M or N stage  
    //         
    // 
    // Bits[18:0], RO/V, default = 0x0
    //
    UINTX lmn_wrstat : 19;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:19], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 13;
  } Bits;
  UINTX Data;
} CPGC_DPAT_LMN1_WRSTAT_CPGC_STRUCT;
#endif // ASM_INC

#define CPGC_DPAT_LMN2_WRSTAT_CPGC_REG                     0x00000328
#ifndef ASM_INC
typedef union {
  struct {
    //
    // The current contents of the LMN buffer in write (Tx) domain. [br]
    // Software decode the current LMN information in this field as follows: [br][br]
    //   LMN_WRSTAT[18:17]  Sweep FSM Phase [br]
    //     2'b00: LCnt bit is driven by L Polarity or Xcount (refer to LMN register description)
    // bits is driven by L Polarity [br] 
    //     2'b01: Number of bits are driven with inverse of L Polarity [br]
    //     2'b10: Number of bits are driven with value of L Polarity [br]
    //     2'b11: Number of bits are driven with inverse of L Polarity [br][br]
    //   LMN_WRSTAT[16:9] Length of X count phase i.e current frequency of X count [br][br]
    //   LMN_WRSTAT[8:8] L Polarity [br][br]
    //   LMN_WRSTAT[7:0] Number of bits left to send for M or N stage  
    //         
    // 
    // Bits[18:0], RO/V, default = 0x0
    //
    UINTX lmn_wrstat : 19;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:19], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 13;
  } Bits;
  UINTX Data;
} CPGC_DPAT_LMN2_WRSTAT_CPGC_STRUCT;
#endif // ASM_INC

#define CPGC_SEQ_BASE_ADDR_SAVE_A_CPGC_REG                 0x0000035C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[2:0], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 3;
    //
    // Saved logical column address.Since DDR4 spec has special meaning for Col bits
    // [2:0], therefore the logical address should be 7 bits wide and pad 0's to make
    // it 10 bits before it goes to Phy 
    // 
    // Bits[12:3], RO/V, default = 0x0
    //
    UINTX column_address : 10;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[15:13], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 3;
    //
    // Saved logical rank address
    // 
    // Bits[19:16], RO/V, default = 0x0
    //
    UINTX rank_address : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:20], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 12;
  } Bits;
  UINTX Data;
} CPGC_SEQ_BASE_ADDR_SAVE_A_CPGC_STRUCT;
#endif // ASM_INC

#define CPGC_SEQ_BASE_ADDR_SAVE_B_CPGC_REG                 0x00000360
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Saved logical row address
    // 
    // Bits[17:0], RO/V, default = 0x0
    //
    UINTX row_address : 18;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:18], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 6;
    //
    // Saved logical bank address
    // 
    // Bits[27:24], RO/V, default = 0x0
    //
    UINTX bank_address : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:28], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 4;
  } Bits;
  UINTX Data;
} CPGC_SEQ_BASE_ADDR_SAVE_B_CPGC_STRUCT;
#endif // ASM_INC


#endif // _CPGC_H_
