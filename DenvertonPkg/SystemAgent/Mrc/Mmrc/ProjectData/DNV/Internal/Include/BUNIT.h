/** @file
  File name:    BUNIT.h
  Input File:   DNV_MRC.xlsx

  THIS FILE IS AUTO-GENERATED BY THE MSP TOOL. DO NOT CHANGE THIS CODE.

  If edits are needed in this file, they must be done via the MSP tool.

  If there is additional project-specific data required by the MSP, it
  can be placed in BUNIT.h, which is used for non-tool-generated
  data

  Includes register defines specific to a project.

  Copyright (c) 2005-2018 Intel Corporation. All rights reserved
  This software and associated documentation (if any) is furnished
  under a license and may only be used or copied in accordance
  with the terms of the license. Except as permitted by such
  license, no part of this software or documentation may be
  reproduced, stored in a retrieval system, or transmitted in any
  form or by any means without the express written consent of
  Intel Corporation.
**/
#ifndef _BUNIT_H_
#define _BUNIT_H_

#include "DataTypes.h"

#if USE_64_BIT_VARIABLES
#define UINTX UINT64
#else
#define UINTX UINT32
#endif

#define B_CR_P_U_CODERDWR_CP_BUNIT_REG                     0x00004C00
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Bit vector used to determine which agents are allowed access to the P_U_CODERDWR_RAC,
    // P_U_CODERDWR_WAC, and P_U_CODERDWR_CP registers, based on the value from the agent's
    // 6bit SAI field. 
    // 
    // Bits[63:0], RW, default = 0x40001000202
    //
    UINTX ia_ctrl_pol : 64;
  } Bits;
  UINTX Data;
} B_CR_P_U_CODERDWR_CP_BUNIT_STRUCT;
#endif // ASM_INC

#define B_CR_P_U_CODERDWR_RAC_BUNIT_REG                    0x00004C08
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Bit vector used to determine which agents are allowed read access to the B-Unit
    // IA Core Configuration registers, based on each agent's 6bit encoded SAI value.
    // 
    // Bits[63:0], RW, default = 0x40001000202
    //
    UINTX ia_sai_pol : 64;
  } Bits;
  UINTX Data;
} B_CR_P_U_CODERDWR_RAC_BUNIT_STRUCT;
#endif // ASM_INC

#define B_CR_P_U_CODERDWR_WAC_BUNIT_REG                    0x00004C10
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Bit vector used to determine which agents are allowed write access to the B-Unit
    // IA Core Configuration registers, based on each agent's 6bit encoded SAI value.
    // 
    // Bits[63:0], RW, default = 0x40001000202
    //
    UINTX ia_sai_pol : 64;
  } Bits;
  UINTX Data;
} B_CR_P_U_CODERDWR_WAC_BUNIT_STRUCT;
#endif // ASM_INC

#define B_CR_LPMODE_BUNIT_REG                              0x00004C18
#ifndef ASM_INC
typedef union {
  struct {
    //
    // When set, Core is in SMM mode.
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINTX smm_mode : 1;
    //
    // When set, Core is in Authenticated Code Module / NonPersistent Patch mode.
    // 
    // Bits[1:1], RW, default = 0x0
    //
    UINTX acm_npp_mode : 1;
    //
    // When set, Core is in Boot mode.
    // 
    // Bits[2:2], RW, default = 0x1
    //
    UINTX boot_mode : 1;
    //
    // Reserved
    // 
    // Bits[31:3], RO, default = 0x0
    //
    UINTX reserved_0 : 29;
  } Bits;
  UINTX Data;
} B_CR_LPMODE_BUNIT_STRUCT;
#endif // ASM_INC

#define B_CR_BT_IDLE_STATUS_BUNIT_REG                      0x00004C1C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // When set, T-Unit SB endpoint is not requesting SB clock.
    // 
    // Bits[0:0], RO/V, default = 0x1
    //
    UINTX t_sb_no_clkreq : 1;
    //
    // When set, T-Unit SB endpoint is not requesting SB clock.
    // 
    // Bits[1:1], RO/V, default = 0x1
    //
    UINTX b_sb_no_clkreq : 1;
    //
    // When set, T-Unit SB fabric ISM is in Idle state.
    // 
    // Bits[2:2], RO/V, default = 0x1
    //
    UINTX t_sb_fabric_idle : 1;
    //
    // When set, T-Unit SB agent ISM is in Idle state.
    // 
    // Bits[3:3], RO/V, default = 0x1
    //
    UINTX t_sb_agent_idle : 1;
    //
    // When set, B-Unit SB fabric ISM is in Idle state.
    // 
    // Bits[4:4], RO/V, default = 0x1
    //
    UINTX b_sb_fabric_idle : 1;
    //
    // When set, B-Unit SB agent ISM is in Idle state.
    // 
    // Bits[5:5], RO/V, default = 0x1
    //
    UINTX b_sb_agent_idle : 1;
    //
    // When set, T unit has no outbound SB message pending.
    // 
    // Bits[6:6], RO/V, default = 0x1
    //
    UINTX no_outb_sb_msg : 1;
    //
    // When set, T-Unit VLW is idle.
    // 
    // Bits[7:7], RO/V, default = 0x1
    //
    UINTX vlw_idle : 1;
    //
    // When set, T-Unit PICLET is idle.
    // 
    // Bits[8:8], RO/V, default = 0x1
    //
    UINTX piclet_idle : 1;
    //
    // When set, T-Unit OOAQ in slice 1 is empty.
    // 
    // Bits[9:9], RO/V, default = 0x1
    //
    UINTX ooaq_empty_s1 : 1;
    //
    // When set, T-Unit OOAQ in slice 0 is empty.
    // 
    // Bits[10:10], RO/V, default = 0x1
    //
    UINTX ooaq_empty_s0 : 1;
    //
    // When set, B-Unit MOT in slice 1 is idle.
    // 
    // Bits[11:11], RO/V, default = 0x1
    //
    UINTX mot_idle_s1 : 1;
    //
    // When set, B unit MOT in slice 0 is idle.
    // 
    // Bits[12:12], RO/V, default = 0x1
    //
    UINTX mot_idle_s0 : 1;
    //
    // When set, B-Unit scoreboard in slice 1 has no dirty entries.
    // 
    // Bits[13:13], RO/V, default = 0x1
    //
    UINTX no_dirty_entries_s1 : 1;
    //
    // When set, B unit scoreboard in slice 0 has no dirty entries.
    // 
    // Bits[14:14], RO/V, default = 0x1
    //
    UINTX no_dirty_entries_s0 : 1;
    //
    // When set, B-Unit scoreboard in slice 1 has no pending read requests.
    // 
    // Bits[15:15], RO/V, default = 0x1
    //
    UINTX no_pend_rd_req_s1 : 1;
    //
    // When set, B-Unit scoreboard in slice 0 has no pending read requests.
    // 
    // Bits[16:16], RO/V, default = 0x1
    //
    UINTX no_pend_rd_req_s0 : 1;
    //
    // When set, all B unit scoreboard refcnts in slice 1 are zero.
    // 
    // Bits[17:17], RO/V, default = 0x1
    //
    UINTX refcnts_zero_s1 : 1;
    //
    // When set, all B unit scoreboard refcnts in slice 0 are zero.
    // 
    // Bits[18:18], RO/V, default = 0x1
    //
    UINTX refcnts_zero_s0 : 1;
    //
    // When set, Lock queue is empty.
    // 
    // Bits[19:19], RO/V, default = 0x1
    //
    UINTX lockq_empty : 1;
    //
    // When set, Pondicherry Internal Interface conflict queues are empty.
    // 
    // Bits[20:20], RO/V, default = 0x1
    //
    UINTX pii_cq_empty : 1;
    //
    // When set, IDI conflict queue in slice 1 is empty.
    // 
    // Bits[21:21], RO/V, default = 0x1
    //
    UINTX idi_cq_empty_s1 : 1;
    //
    // When set, IDI conflict queue in slice 0 is empty.
    // 
    // Bits[22:22], RO/V, default = 0x1
    //
    UINTX idi_cq_empty_s0 : 1;
    //
    // When set, all PMI fabric ISM's for slice 1 (in D units) are in Idle state.
    // 
    // Bits[23:23], RO/V, default = 0x1
    //
    UINTX pmi_fabric_idle_s1 : 1;
    //
    // When set, all PMI agent ISM's for slice 1 (in B-Unit) are in Idle state.
    // 
    // Bits[24:24], RO/V, default = 0x1
    //
    UINTX pmi_agent_idle_s1 : 1;
    //
    // When set, all PMI fabric ISM's for slice 0 (in D-units) are in Idle state.
    // 
    // Bits[25:25], RO/V, default = 0x1
    //
    UINTX pmi_fabric_idle_s0 : 1;
    //
    // When set, all PMI agent ISM's for slice 0 (in B-Unit) are in Idle state.
    // 
    // Bits[26:26], RO/V, default = 0x1
    //
    UINTX pmi_agent_idle_s0 : 1;
    //
    // When set, A-Unit's IOSF interface is idle.
    // 
    // Bits[27:27], RO/V, default = 0x1
    //
    UINTX iosf_idle : 1;
    //
    // When set, Pondicherry Internal Interface fabric ISM (in B-Unit) is in Idle state.
    // 
    // Bits[28:28], RO/V, default = 0x1
    //
    UINTX pii_fabric_idle : 1;
    //
    // When set, Pondicherry Internal Interface agent ISM (in A-Unit) is in Idle state.
    // 
    // Bits[29:29], RO/V, default = 0x1
    //
    UINTX pii_agent_idle : 1;
    //
    // When set, all IDI interfaces are in SHUTDOWN state. If T_CR_MISC_CTL.SPARE[0]
    // is set, ACTIVE state with all credits available will cause this field being set
    // too. 
    // 
    // Bits[30:30], RO/V, default = 0x1
    //
    UINTX idi_shutdown : 1;
    //
    // Reserved
    // 
    // Bits[31:31], RO, default = 0x0
    //
    UINTX reserved_0 : 1;
  } Bits;
  UINTX Data;
} B_CR_BT_IDLE_STATUS_BUNIT_STRUCT;
#endif // ASM_INC

#define B_CR_BIOSWR_EXPOSE_CP_BUNIT_REG                    0x00004C20
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Bit vector used to determine which agents are allowed write access to the BIOSWR_EXPOSE_RAC,
    // BIOSWR_EXPOSE_WAC, and BIOSWR_EXPOSE_CP registers based on the value from the
    // agent's 6bit SAI field. 
    // 
    // Bits[63:0], RW, default = 0xC0061010212
    //
    UINTX mem_range_ctrl_pol : 64;
  } Bits;
  UINTX Data;
} B_CR_BIOSWR_EXPOSE_CP_BUNIT_STRUCT;
#endif // ASM_INC

#define B_CR_BIOSWR_EXPOSE_RAC_BUNIT_REG                   0x00004C28
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Bit vector used to determine which agents are allowed read access, based on each
    // agent's 6bit encoded SAI value. 
    // 
    // Bits[63:0], RW, default = 0x80000C0063010217
    //
    UINTX mem_range_pol : 64;
  } Bits;
  UINTX Data;
} B_CR_BIOSWR_EXPOSE_RAC_BUNIT_STRUCT;
#endif // ASM_INC

#define B_CR_BIOSWR_EXPOSE_WAC_BUNIT_REG                   0x00004C30
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Bit vector used to determine which agents are allowed write access, based on each
    // agent's 6bit encoded SAI value. 
    // 
    // Bits[63:0], RW, default = 0xC0061000212
    //
    UINTX mem_range_pol : 64;
  } Bits;
  UINTX Data;
} B_CR_BIOSWR_EXPOSE_WAC_BUNIT_STRUCT;
#endif // ASM_INC

#define B_CR_SCH_AC_MAPPING0_BUNIT_REG                     0x00004C38
#ifndef ASM_INC
typedef union {
  struct {
    //
    // N/A
    // 
    // Bits[3:0], RW, default = 0x0
    //
    UINTX ia_demand_ac : 4;
    //
    // Not supported by BXT/DNV.
    // 
    // Bits[7:4], RW, default = 0x0
    //
    UINTX ia_prefetch_ac : 4;
    //
    // N/A
    // 
    // Bits[11:8], RW, default = 0x4
    //
    UINTX gfx_ac : 4;
    //
    // N/A
    // 
    // Bits[15:12], RW, default = 0x0
    //
    UINTX mot : 4;
    //
    // Reserved
    // 
    // Bits[31:16], RO, default = 0x0
    //
    UINTX reserved_0 : 16;
  } Bits;
  UINTX Data;
} B_CR_SCH_AC_MAPPING0_BUNIT_STRUCT;
#endif // ASM_INC

#define B_CR_SCH_AC_MAPPING1_BUNIT_REG                     0x00004C3C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Access Class for Channel 0 BXT VC0a
    // 
    // Bits[3:0], RW, default = 0x0
    //
    UINTX channel0_ac : 4;
    //
    // Access Class for Channel 1 BXT VC0b.
    // 
    // Bits[7:4], RW, default = 0x0
    //
    UINTX channel1_ac : 4;
    //
    // Access Class for Channel 2 BXT VC1a.
    // 
    // Bits[11:8], RW, default = 0x1
    //
    UINTX channel2_ac : 4;
    //
    // Access Class for Channel 3 BXT VC1b.
    // 
    // Bits[15:12], RW, default = 0x1
    //
    UINTX channel3_ac : 4;
    //
    // Access Class for Channel 4 BXT VC2a.
    // 
    // Bits[19:16], RW, default = 0x2
    //
    UINTX channel4_ac : 4;
    //
    // Access Class for Channel 5 BXT VC2b.
    // 
    // Bits[23:20], RW, default = 0x2
    //
    UINTX channel5_ac : 4;
    //
    // Access Class for Channel 6 BXT VC2c.
    // 
    // Bits[27:24], RW, default = 0x2
    //
    UINTX channel6_ac : 4;
    //
    // Access Class for Channel 7 BXT VCbr.
    // 
    // Bits[31:28], RW, default = 0x0
    //
    UINTX channel7_ac : 4;
  } Bits;
  UINTX Data;
} B_CR_SCH_AC_MAPPING1_BUNIT_STRUCT;
#endif // ASM_INC

#define B_CR_SCH_AC_MAPPING2_BUNIT_REG                     0x00004C40
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Access Class for Channel 8 BXT VCiommu0a.
    // 
    // Bits[3:0], RW, default = 0x0
    //
    UINTX channel8_ac : 4;
    //
    // Access Class for Channel 9 BXT VCiommu0b.
    // 
    // Bits[7:4], RW, default = 0x0
    //
    UINTX channel9_ac : 4;
    //
    // Access Class for Channel 10 BXT VCiommu1b.
    // 
    // Bits[11:8], RW, default = 0x1
    //
    UINTX channel10_ac : 4;
    //
    // Access Class for Channel 11 BXT Reserved
    // 
    // Bits[15:12], RO, default = 0x0
    //
    UINTX channel11_ac : 4;
    //
    // Access Class for Channel 12 BXT Reserved
    // 
    // Bits[19:16], RO, default = 0x0
    //
    UINTX channel12_ac : 4;
    //
    // Access Class for Channel 13 BXT Reserved
    // 
    // Bits[23:20], RO, default = 0x0
    //
    UINTX channel13_ac : 4;
    //
    // Access Class for Channel 14 BXT Reserved
    // 
    // Bits[27:24], RO, default = 0x0
    //
    UINTX channel14_ac : 4;
    //
    // Access Class for Channel 15 BXT Reserved
    // 
    // Bits[31:28], RO, default = 0x0
    //
    UINTX channel15_ac : 4;
  } Bits;
  UINTX Data;
} B_CR_SCH_AC_MAPPING2_BUNIT_STRUCT;
#endif // ASM_INC

#define B_CR_BISOC_BUNIT_REG                               0x00004C44
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Enable PMI to move to an idle state: When set, B-Unit will cause a PMI interface
    // to move to an idle state, depending on various idle indicators.  When cleared,
    // B-Unit will always keep all PMI interfaces active. 
    // 
    // Bits[0:0], RW, default = 0x1
    //
    UINTX enable_pmi_idle : 1;
    //
    // Formerly called ENTER_SELF_REFRESH_DLY. Duration the B-Unit waits before asking
    // PMI interfaces to go idle. Each unit of time is 240ns. 
    // 
    // Bits[7:1], RW, default = 0x1
    //
    UINTX enter_pmi_idle_dly : 7;
    //
    // Reserved
    // 
    // Bits[9:8], RO, default = 0x0
    //
    UINTX reserved_0 : 2;
    //
    // [list]
    //               [*]0: Request in B-Unit scheduler scoreboard targeting any PMI channel
    // within the slice will cause all PMI channels to exit IDLE state.  
    //               [*]1: A PMI channel will exit IDLE state only when a request targeting
    // that PMI channel is available to be scheduled in the B-Unit scheduler scoreboard.
    //               [/list]
    // 
    // Bits[10:10], RW, default = 0x1
    //
    UINTX ch_exit_mode : 1;
    //
    // [list]
    //               [*]0: B-Unit causes all PMI channels in both slices to exit IDLE
    // state if a transaction targeting any slice is stalled in the BunitFE Badmit arbiter.
    //         [*]1: B-Unit causes all PMI channels in only the targeted slice to exit
    // IDLE state when a transaction is stalled in the BunitFE Badmit arbiter. 
    //               [/list]
    // 
    // Bits[11:11], RW, default = 0x0
    //
    UINTX slice_exit_mode : 1;
    //
    // Required latency to Exit Self Refresh in 240ns increments. Default is 0usec which
    // will cause any isoc request, regardless of its deadline indication, to cause PMI
    // to exit idle state. Note that best effort requests will always cause PMI to exit
    // idle state. NOTE: PND2 will always wake up PMI on any request regardless of the
    // request deadline, hence the default value of 0. 
    // 
    // Bits[18:12], RW, default = 0x0
    //
    UINTX exit_pmi_idle_latency : 7;
    //
    // Used by the P-Unit for reset flow.  When set to 1, B-Unit will abort all Pondicherry
    // Internal Interface transactions, i.e no PMI transactions will be launched for
    // the PII transactions. Reads will be completed with all 1's data and Abort bit
    // set on the PII completion. Writes will be dropped. This bit has no effect on transactions
    // admitted to the B-Unit prior to when the bit was set, and they will be handled
    // normally. When the bit is clear, all PII transactions will be handled normally.
    // 
    // Bits[19:19], RW, default = 0x0
    //
    UINTX abort_pii_requests : 1;
    //
    // Request latency below which an ISOC request is considered as a HiPriority Request.
    // Value programmed has 240ns resolution. Default is approximately 2usec. 
    // 
    // Bits[23:20], RW, default = 0x8
    //
    UINTX scheduler_latency : 4;
    //
    // Formerly ENTER_SELF_REFRESH_THRSH. Required request latency to allow PMI to enter
    // IDLE state. Value programmed has a 240ns resolution. If the B-Unit receives ISOC
    // requests that have a required latency less than this value, the B-Unit will keep
    // the memory out of Self Refresh. NOTE: PND2 will not need this and hence the default
    // of 0x0. 
    // 
    // Bits[31:24], RW, default = 0x0
    //
    UINTX enter_pmi_idle_deadline_thrsh : 8;
  } Bits;
  UINTX Data;
} B_CR_BISOC_BUNIT_STRUCT;
#endif // ASM_INC

#define B_CR_BCOSCAT_BUNIT_REG                             0x00004C4C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // N/A
    // 
    // Bits[1:0], RW, default = 0x0
    //
    UINTX cos_cat_agent0 : 2;
    //
    // N/A
    // 
    // Bits[3:2], RW, default = 0x0
    //
    UINTX cos_cat_agent1 : 2;
    //
    // N/A
    // 
    // Bits[5:4], RW, default = 0x0
    //
    UINTX cos_cat_agent2 : 2;
    //
    // N/A
    // 
    // Bits[7:6], RW, default = 0x0
    //
    UINTX cos_cat_agent3 : 2;
    //
    // N/A
    // 
    // Bits[9:8], RW, default = 0x0
    //
    UINTX cos_cat_agent4 : 2;
    //
    // N/A
    // 
    // Bits[11:10], RW, default = 0x0
    //
    UINTX cos_cat_agent5 : 2;
    //
    // N/A
    // 
    // Bits[13:12], RW, default = 0x0
    //
    UINTX cos_cat_agent6 : 2;
    //
    // N/A
    // 
    // Bits[15:14], RW, default = 0x0
    //
    UINTX cos_cat_agent7 : 2;
    //
    // N/A
    // 
    // Bits[17:16], RW, default = 0x0
    //
    UINTX cos_cat_agent8 : 2;
    //
    // N/A
    // 
    // Bits[19:18], RW, default = 0x0
    //
    UINTX cos_cat_agent9 : 2;
    //
    // N/A
    // 
    // Bits[21:20], RW, default = 0x0
    //
    UINTX cos_cat_agent10 : 2;
    //
    // N/A
    // 
    // Bits[23:22], RW, default = 0x0
    //
    UINTX cos_cat_agent11 : 2;
    //
    // N/A
    // 
    // Bits[25:24], RW, default = 0x0
    //
    UINTX cos_cat_agent12 : 2;
    //
    // N/A
    // 
    // Bits[27:26], RW, default = 0x0
    //
    UINTX cos_cat_agent13 : 2;
    //
    // N/A
    // 
    // Bits[29:28], RW, default = 0x0
    //
    UINTX cos_cat_agent14 : 2;
    //
    // N/A
    // 
    // Bits[31:30], RW, default = 0x0
    //
    UINTX cos_cat_agent15 : 2;
  } Bits;
  UINTX Data;
} B_CR_BCOSCAT_BUNIT_STRUCT;
#endif // ASM_INC

#define B_CR_BDPT_BUNIT_REG                                0x00004C50
#ifndef ASM_INC
typedef union {
  struct {
    //
    // N/A
    // 
    // Bits[5:0], RW, default = 0x8
    //
    UINTX dpt_lo_thresh : 6;
    //
    // Reserved
    // 
    // Bits[7:6], RO, default = 0x0
    //
    UINTX reserved_1 : 2;
    //
    // N/A
    // 
    // Bits[13:8], RW, default = 0x10
    //
    UINTX dpt_hi_thresh : 6;
    //
    // Reserved
    // 
    // Bits[30:14], RO, default = 0x0
    //
    UINTX reserved_0 : 17;
    //
    // When set, enables dynamic prefetch throttling of IDI requests.
    // 
    // Bits[31:31], RW, default = 0x0
    //
    UINTX dpt_mode : 1;
  } Bits;
  UINTX Data;
} B_CR_BDPT_BUNIT_STRUCT;
#endif // ASM_INC

#define B_CR_SLICE_CHANNEL_HASH_BUNIT_REG                  0x00004C58
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Slice 1 is disabled -- no memory address is mapped to Slice 1. All requests are
    // sent to Slice 0. 
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINTX slice_1_disabled : 1;
    //
    // [list]
    //               [*]0: HVM mode is disabled.  
    //               [*]1: HVM mode is enabled.
    //               [/list]  
    //       [p]When HVM mode is enabled, Slice Hash and Channel Hash are done as follows:[/p]
    //   
    //       [p]Both slices and all four PMI channels enabled: Slice Hash is Request
    // Physical Addr[29] and Channel Hash is PostRemap Addr[30]. [/p]  
    //       [p]Both slices enabled, but only one PMI channel in each slice enabled:
    // Slice Hash is Request Physical Addr[29].[/p]   
    //       [p]Only one SLICE0 enabled, but both PMI channels in SLICE0 enabled: Channel
    // Hash is PostRemap Addr[29]. [/p]   
    //       When HVM_MODE is enabled, TOLUD must be set at 2GB.
    // 
    // Bits[1:1], RW, default = 0x0
    //
    UINTX hvm_mode : 1;
    //
    // Default interleave mode that specifies how the Slice Selector and Channel Selector
    // bits are to be determined. Relevant only when HVM mode is disabled, and only for
    // system memory addresses that do not fall under the MOT region or the Asymmetric
    // memory region in the System Address Map. Legal encodings are 0h, 1h and 2h. An
    // encoding of 3h is treated as if it was 2h.  
    //          [p]When both slices and all four PMI channels are enabled:[/p]   
    //          [list]
    //          [*]0h: Default Slice Selector is Addr[10] and Default Channel Selector
    // is Addr[11]   
    //          [*]1h: Default Slice Selector is Addr[11] and Default Channel Selector
    // is Addr[12]   
    //          [*]2h: Default Slice Selector is Addr[12] and Default Channel Selector
    // is Addr[13] 
    //          [/list]  
    //          [p]When both slices are enabled, but only one channel in each slice is
    // enabled: [/p]   
    //          [list]
    //          [*]0h: Default Slice Selector is Addr[10]
    //          [*]1h: Default Slice Selector is Addr[11]  
    //          [*]2h: Default Slice Selector is Addr[12] 
    //          [/list]
    //          [p] When only SLICE0 is enabled, and both channels on that slice are
    // enabled: [/p]    
    //          [list]
    //          [*]0h: Default Channel Selector is Addr[10]  
    //          [*]1h: Default Channel Selector is Addr[11]  
    //          [*]2h: Default Channel Selector is Addr[12]
    //          [/list]  
    //         
    //          [p]When SLICE0 and only one channel in that slice is enabled this field
    // is not relevant.[/p]   
    //          B-Unit overrides the setting of the SLICE_HASH_MASK to always include
    // the Slice Selector bit. Similarly, B-Unit overrides the setting of the CH_HASH_MASK
    // to always include the Channel Selector bit. 
    // 
    // Bits[3:2], RW, default = 0x0
    //
    UINTX interleave_mode : 2;
    //
    // Slice 0 is disabled for memory accesses; no memory address mapped to Slice 0 and
    // all memory requests sent to Slice 1.  In BXT, this bit is RO with the value of
    // 0. 
    // 
    // Bits[4:4], RW, default = 0x0
    //
    UINTX slice_0_mem_disabled : 1;
    //
    // Reserved
    // 
    // Bits[5:5], RO, default = 0x0
    //
    UINTX reserved_0 : 1;
    //
    // When both slices are enabled, this field specifies that the Slice Hash Mask is
    // to be applied on Addr[19:6] physical address of the request, to compute which
    // slice a request must be routed to. Relevant only when HVM mode is disabled, and
    // only for physical addresses that do not fall under the Asymmetric Memory Region
    // and the MOT region.  B-Unit will override the programmed value to include the
    // Slice Selector bit. Additionally, B-Unit will remove the Channel Selector bit.
    // See INTERLEAVE_MODE field.  Note that HVM mode non-address IDI requests asymmetric
    // memory region and MOT regions have special hash requirements and hence they do
    // not use the SLICE_HASH_MASK. 
    // 
    // Bits[19:6], RW, default = 0x0
    //
    UINTX slice_hash_mask : 14;
    //
    // Reserved
    // 
    // Bits[30:20], RO, default = 0x0
    //
    UINTX reserved_1 : 11;
    //
    // TBD
    // 
    // Bits[31:31], RW, default = 0x0
    //
    UINTX spare : 1;
    //
    // B-Unit is divided into two slices, and each slice has two PMI channels to the
    // internal memory subsystem -- for a total of four channels. With this bit asserted,
    // channel 1 in both slices is disabled. Thus, no memory addresses are mapped to
    // the slice's ch 1. All requests are sent to the slice's channel 0. This bit has
    // no affect for DNV. The within-slice channel 1 is always disabled by the HW design.
    // Note that these channels are distinct from the external memory channels at the
    // package level, which more closely map to Bunit's slices. 
    // 
    // Bits[32:32], RO, default = 0x1
    //
    UINTX ch_1_disabled : 1;
    //
    // Reserved
    // 
    // Bits[37:33], RO, default = 0x0
    //
    UINTX reserved_2 : 5;
    //
    // When both PMI channels in a slice are enabled, this field specifies the Channel
    // Hash Mask to be applied on Addr[19:6] postremap DRAM address of the request to
    // compute which PMI channel a request must be routed to. Relevant only when HVM
    // mode is disabled, and only for requests that do not fall under the MOT region.
    // B-Unit will override the programmed value to include the Channel Selector bit.
    // Additionally, B-Unit will remove the Slice Selector bit. See INTERLEAVE_MODE field.
    // Note that HVM mode and MOT regions have special hash requirements and hence they
    // do not use the CH_HASH_MASK. 
    // 
    // Bits[51:38], RW, default = 0x0
    //
    UINTX ch_hash_mask : 14;
    //
    // Reserved
    // 
    // Bits[62:52], RO, default = 0x0
    //
    UINTX reserved_3 : 11;
    //
    // When set, microcode will disallow writes to the this register via the WRMSR path.
    // Intended usage is for BIOS to set the LOCK when it updates the CR, and Ucode to
    // check the LOCK bit to decide whether the WRMSR to this CR must be allowed. B-Unit
    // implements only storage for this bit. No hardware exists to implement hardware
    // locking. 
    // 
    // Bits[63:63], RW, default = 0x0
    //
    UINTX lock : 1;
  } Bits;
  UINTX Data;
} B_CR_SLICE_CHANNEL_HASH_BUNIT_STRUCT;
#endif // ASM_INC

#define B_CR_BSCHCTRL0_BUNIT_REG                           0x00004C60
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Reserved
    // 
    // Bits[23:0], RO, default = 0x0
    //
    UINTX reserved_1 : 24;
    //
    // This field specifies the max latency for scheduling Best Effort Traffic. The value
    // is added to the global timer value when a read request is granted at Badmit. After
    // the delay specified, the page scheduling is ignored for the requests, and the
    // request will be scheduled in order. Agent weights still affect the final scheduling
    // latency after the specified delay time has expired.  NOTE: No longer relevant,
    // since page aware scheduling has been removed. 
    // 
    // Bits[31:24], RW, default = 0x0
    //
    UINTX best_effort_max_latency : 8;
  } Bits;
  UINTX Data;
} B_CR_BSCHCTRL0_BUNIT_STRUCT;
#endif // ASM_INC

#define B_CR_BPMRVCTL_BUNIT_REG                            0x00004C68
#ifndef ASM_INC
typedef union {
  struct {
    //
    // This value indicates the Channel ID VC of the request that caused the last access
    // violation if the interrupt is enabled. If access violation was from an IDI attach
    // point, this field latches the LPID. 
    // 
    // Bits[7:0], RW/V, default = 0x0
    //
    UINTX violating_agent_chiid : 8;
    //
    // This 4bit value indicates which agent caused the last access violation if the
    // interrupt is enabled. The Agent ID values are assigned starting with the Goldmont
    // IDI Attach Points GT IDI Attach and followed by A-Unit. For 2GLM configuration,
    // AgentID 0 is GLM0, AgentID 1 is GLM1, AgentID 2 is GT, and AgentID 3 is A-Unit.
    // 
    // Bits[11:8], RW/V, default = 0x0
    //
    UINTX violating_agent_id : 4;
    //
    // This field is deprecated, which implies RTL functionality for correct setting
    // of this status field may not be validated. Future derivatives will remove this
    // status field altogether. Unsupported IDI length is logged a machine check error.
    // 
    // Bits[12:12], RW/V, default = 0x0
    //
    UINTX uns_idi_opc : 1;
    //
    // This field is deprecated, which implies RTL functionality for correct setting
    // of this status field may not be validated. Future derivatives will remove this
    // status field altogether. A-Unit is an internal IP, and as such it must be validated
    // to emit correct request opcodes. Unsupported opcodes should be coded as assertions.
    // 
    // Bits[13:13], RW/V, default = 0x0
    //
    UINTX uns_pfi_opc : 1;
    //
    // MMIO Access from a nonIDI agent. This field is deprecated, which implies RTL functionality
    // for correct setting of this status field may not be validated.  Future derivatives
    // will remove this status field altogether.  This is logged as machine check error.
    // 
    // Bits[14:14], RW/V, default = 0x0
    //
    UINTX pii_2_mmio : 1;
    //
    // Memory Access to APIC region from a nonIDI agent.
    // 
    // Bits[15:15], RW/V, default = 0x0
    //
    UINTX mem_axs_2apic : 1;
    //
    // This 6bit value indicates which region was last violated when the interrupt is
    // enabled. Encoding is as follows:    
    //              [list]
    //              [*]0h: Reserved  
    //              [*]1h: Graphics Stolen Memory violation  
    //              [*]2h: SMM region violation  
    //              [*]3h: PRMRR region violation  
    //              [*]4h: Reserved  
    //              [*]5h: VTd PMR Low region violation  
    //              [*]6h: VTd PMR High region violation  
    //              [*]7h: MOT region violation  
    //              [*]10h-23:h  Generic IMR region violation. 10h is for IMR0 violation
    // and 23h is for IMR19 violation. 
    //              [/list]
    // 
    // Bits[21:16], RW/V, default = 0x0
    //
    UINTX pmr_vio : 6;
    //
    // Reserved
    // 
    // Bits[22:22], RO, default = 0x0
    //
    UINTX reserved_0 : 1;
    //
    // IDI WB is not to DRAM space. This field is deprecated, which implies RTL functionality
    // for correct setting of this status field may not be validated. Future derivatives
    // will remove this status field altogether. WbMto targeting WB space is logged as
    // a machine check error. 
    // 
    // Bits[23:23], RW/V, default = 0x0
    //
    UINTX wb_non_dram_vio : 1;
    //
    // ECAM opcode is not PRD or WIL.
    // 
    // Bits[24:24], RW/V, default = 0x0
    //
    UINTX ecam_opc_vio : 1;
    //
    // This field is deprecated, which implies RTL functionality for correct setting
    // of this status field may not be validated.  Future derivatives will remove this
    // status field altogether.  RTL must code assertions to check for correct IDI lengths.
    // 
    // Bits[25:25], RW/V, default = 0x0
    //
    UINTX uns_idi_len : 1;
    //
    // This field is deprecated, which implies RTL functionality for correct setting
    // of this status field may not be validated. Future derivatives will remove this
    // status field altogether. A-Unit is an internal IP, and as such it must be validated
    // to emit correct request lengths. Unsupported lengths should be coded as assertions.
    // 
    // Bits[26:26], RW/V, default = 0x0
    //
    UINTX uns_pfi_len : 1;
    //
    // Pondicherry Internal Interface request address had Abort bit set and hence was
    // aborted. 
    // 
    // Bits[27:27], RW/V, default = 0x0
    //
    UINTX pii_abort : 1;
    //
    // Reserved
    // 
    // Bits[29:28], RO, default = 0x0
    //
    UINTX reserved_1 : 2;
    //
    // When set, the B-Unit will latch violation information into this register. This
    // bit is cleared upon first violation and must be reset by software in order to
    // log again. Memory protection is maintained even while the interrupt/capture mechanism
    // is disabled. 
    // 
    // Bits[30:30], RW/V, default = 0x0
    //
    UINTX enable_log : 1;
    //
    // When set, the BUnit will send an interrupt request on IOSF SB to the P-Unit. B-Unit
    // will send IOSF-SB message only on the first violation. 
    // 
    // Bits[31:31], RW/V, default = 0x0
    //
    UINTX enable_intr : 1;
  } Bits;
  UINTX Data;
} B_CR_BPMRVCTL_BUNIT_STRUCT;
#endif // ASM_INC

#define B_CR_B_SECURITY_STAT0_BUNIT_REG                    0x00004C6C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // First SAI violation detected.
    // 
    // Bits[0:0], RW/V, default = 0x0
    //
    UINTX vio_more_than_0 : 1;
    //
    // More than one SAI violation detected.
    // 
    // Bits[1:1], RW/V, default = 0x0
    //
    UINTX vio_more_than_1 : 1;
    //
    // Reserved
    // 
    // Bits[7:2], RO, default = 0x0
    //
    UINTX reserved_1 : 6;
    //
    // SAI bits that triggered the violation.
    // 
    // Bits[15:8], RW/V, default = 0x0
    //
    UINTX vio_sai : 8;
    //
    // Toggles sending of SAI violation messages on sideband.
    // 
    // Bits[16:16], RW, default = 0x0
    //
    UINTX sai_vio_msg_enable : 1;
    //
    // Toggles logging of SAI violations in the status registers.
    // 
    // Bits[17:17], RW, default = 0x0
    //
    UINTX sai_vio_log_enable : 1;
    //
    // Reserved
    // 
    // Bits[31:18], RO, default = 0x0
    //
    UINTX reserved_0 : 14;
  } Bits;
  UINTX Data;
} B_CR_B_SECURITY_STAT0_BUNIT_STRUCT;
#endif // ASM_INC

#define B_CR_B_SECURITY_STAT1_BUNIT_REG                    0x00004C70
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Opcode that triggered the violation.
    // 
    // Bits[7:0], RW/V, default = 0x0
    //
    UINTX vio_opc : 8;
    //
    // Port that sent the violation.
    // 
    // Bits[15:8], RW/V, default = 0x0
    //
    UINTX vio_src_port : 8;
    //
    // Address that triggered the violation.
    // 
    // Bits[31:16], RW/V, default = 0x0
    //
    UINTX vio_addr : 16;
  } Bits;
  UINTX Data;
} B_CR_B_SECURITY_STAT1_BUNIT_STRUCT;
#endif // ASM_INC

#define B_CR_BDEBUG0_BUNIT_REG                             0x00004C78
#ifndef ASM_INC
typedef union {
  struct {
    //
    // The casual watermark is used to trigger the B-Unit's casual flush mechanism. When
    // the number of dirty entries is below the casual watermark, no entries will be
    // flushed, even if the PMI interfaces are idle. 
    // 
    // Bits[7:0], RW, default = 0x0
    //
    UINTX casual_water_mark : 8;
    //
    // Chicken bits to change posted queue threshold.  Programming to a value greater
    // than 12 in BXT can cause deadlocks. 
    // 
    // Bits[15:8], RW, default = 0x10
    //
    UINTX posted_queue_threshold : 8;
    //
    // This will limit the number of downstream non-posted transactions that can be admitted
    // into each Slice. Be careful with programming the value of this register. Set to
    // high and you can cause deadlocks. 
    // 
    // Bits[20:16], RW, default = 0x10
    //
    UINTX total_downstream_np_limit : 5;
    //
    // Reserved
    // 
    // Bits[22:21], RO, default = 0x0
    //
    UINTX reserved_0 : 2;
    //
    // When set MOT will reflect aborted PMI transactions. The default behavior is that
    // MOT will not reflect aborted transactions. Note that this will also allow MOT
    // to trace requests to regions that have the TRC_EN bit cleared. 
    // 
    // Bits[23:23], RW, default = 0x0
    //
    UINTX enable_mot_trace_aborts : 1;
    //
    // [list]
    //               [*]0: Disables lock keepout timer. 
    //               [*]1: Enables lock keepout timer, which would prevent B-Unit from
    // processing successive lock transactions back to back. 
    //               [/list]
    // 
    // Bits[24:24], RW, default = 0x1
    //
    UINTX lock_keepout_enable : 1;
    //
    // Counter value that specifies how long the B-Unit will keep out a second lock transaction
    // after the first one has completed. Based on the usync clk frequency (16.67 MHz).
    //  
    //               [list]
    //               [*]0: 0.96us(16 usyncs) 
    //               [*]1: 1.92us(32 usyncs) 
    //               [*]2: 2.88us(48 usyncs) 
    //               [*]3: 3.84us(64 usyncs) 
    //               [*]7: 7.6us(128 usyncs)
    //               [/list]
    // 
    // Bits[27:25], RW, default = 0x0
    //
    UINTX lock_keepout_timer : 3;
    //
    // Intended for Post Silicon testing of parity logic.
    // 
    // Bits[28:28], RW, default = 0x0
    //
    UINTX invert_parity_err : 1;
    //
    // This bit is not used by the HW; it counts as a spare bit. There is an A-unit CR
    // bit that approximates this behavior. Was: Disable Badmit Urgent ISOC Requests:
    // Disables the ISOC high priority path in Badmit. When set all ISOC agent requests
    // are treated as Normal priority. 
    // 
    // Bits[29:29], RW, default = 0x0
    //
    UINTX disable_badmit_urgent_isoc : 1;
    //
    // When set, the B-Unit does not wait for a read completion from D-Unit to determine
    // read data availability. 
    // 
    // Bits[30:30], RW, default = 0x0
    //
    UINTX xsbft_mode : 1;
    //
    // When set, all accesses will be sent to memory, regardless of address.
    // 
    // Bits[31:31], RW, default = 0x0
    //
    UINTX send_all_access_mem : 1;
  } Bits;
  UINTX Data;
} B_CR_BDEBUG0_BUNIT_STRUCT;
#endif // ASM_INC

#define B_CR_BDEBUG1_BUNIT_REG                             0x00004C7C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // The B-Unit has byte enable capability, so it doesn't require a DRAM read when
    // there is a partial write. This bit forces it to perform the read anyway. 
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINTX enable_dram_read : 1;
    //
    // When set, B-unit will not grant a second Pondicherry Internal Interface transaction
    // until the first transaction has retired from the B-unit. If this CR is set to
    // 1 when PII transactions are still pending, B-Unit may not limit the outstanding
    // PII transactions to 1. 
    // 
    // Bits[1:1], RW, default = 0x0
    //
    UINTX enable_single_pii_request_outstanding : 1;
    //
    // When set, B-unit will allow at most one request per IDI agent to be queued up
    // in each of the IDI Conflict Queues. Enabling this mode will severely throttle
    // performance, even in the absence of address conflicts. 
    // 
    // Bits[2:2], RW, default = 0x0
    //
    UINTX enable_single_entry_idi_cq : 1;
    //
    // Maximum number of entries in each slice that IDI requests are allowed to allocate
    // in the B-Unit scoreboard/BRAM and the Tunit tracker.  Same CR is used as the limit
    // value for both B-Unit scoreboard/BRAM and the Tunit tracker.  Once either limit
    // - scoreboard/BRAM or tracker is reached, no IDI request will be accepted by the
    // Badmit arbiter.  Limit is global across all IDI agents and not enforced per IDI
    // agent.  In other words any IDI agent individually and together with other IDI
    // agents are allowed to use only up to TOTAL_IDI_LIMIT entries in each slice. NOTE:
    // In BXT, programming a value lower than 34 can lead to deadlocks. 
    // 
    // Bits[8:3], RW, default = 0x27
    //
    UINTX total_idi_limit : 6;
    //
    // These bits enable the bypass of the Read Data pipestage for those agents for which
    // the pipestage has been provisioned. When set, the Read Data will be returned one
    // clock cycle earlier. There is one bit per B-Unit requestorequestor with lower
    // bits corresponding to IDI agents followed by A-Unit. The bit may only be set for
    // those agents that have the pipestage provisioned.  FIXME:  Can we find another
    // home for this register 
    // 
    // Bits[9:9], RW, default = 0x0
    //
    UINTX read_data_bypass_enable : 1;
    //
    // This bit does nothing.  It is not connected.
    // 
    // Bits[10:10], RW, default = 0x0
    //
    UINTX enable_db_bypass : 1;
    //
    // PII2 ConflictQ s will accumulate credits in a counter and will not send the credits
    // to the AUnit immediately if the corresponding ConflictQ is not empty. Only when
    // the ConflictQ is empty will credits be sent to the AUnit. This is to avoid new
    // requests from continuously recycling through the ConflictQ. 
    // 
    // Bits[11:11], RW, default = 0x1
    //
    UINTX pii2_credit_acc : 1;
    //
    // Block B-Unit slice 0 from issuing any further commands to PMI, in preparation
    // for CPGC taking over control of memory. 
    // 
    // Bits[12:12], RW, default = 0x0
    //
    UINTX pmi_cpgc_block_s0 : 1;
    //
    // Block B-Unit slice 1 from issuing any further commands to PMI, in preparation
    // for CPGC taking over control of memory. 
    // 
    // Bits[13:13], RW, default = 0x0
    //
    UINTX pmi_cpgc_block_s1 : 1;
    //
    // Reserved
    // 
    // Bits[14:14], RO, default = 0x0
    //
    UINTX reserved_0 : 1;
    //
    // Conflict Queue spec changed to ignore conflict_block bit for new transactions
    // when the Conflict Queues are empty. And for re-arbitrated request, look at the
    // conflict_block bit if there are other Conflict Queues not empty.  This defeature
    // bit is to reverse these optimizations and behave like BXT-A0 
    // 
    // Bits[15:15], RW, default = 0x0
    //
    UINTX disable_prior_conflict_block_opt : 1;
    //
    // When set, these bits enable the use of Agent weights by the B-Unit scheduler regardless
    // of the COS Category configuration set for Agents 015. Normally the Agent weights
    // are only used when the COS Category for an Agent is configured for Best Effort.
    // When the Agent Weight Enable bit is set for an agent, the COS category is still
    // used as priority for the agent, but the agent is also limited by the weights specified
    // for the agent in the BARBCTRL and BSCHWTx registers. 
    // 
    // Bits[31:16], RW, default = 0xFF
    //
    UINTX agent_weight_enable : 16;
  } Bits;
  UINTX Data;
} B_CR_BDEBUG1_BUNIT_STRUCT;
#endif // ASM_INC

#define B_CR_BTHCTRL_BUNIT_REG                             0x00004C80
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Total number of read and write requests allowed to be sent during any throttle
    // interval across all PMI channels in slice0.  Slice0 is allowed to send up to THROTTLE_COUNT
    // requests. 
    // 
    // Bits[15:0], RW, default = 0x0
    //
    UINTX throttle_count : 16;
    //
    // Specifies the duration of the throttling interval as a multiple of 60ns N60ns.
    //  Example:  When programmed to 0x4 the throttling interval is 240ns. 
    // 
    // Bits[23:16], RW, default = 0x0
    //
    UINTX throttle_interval : 8;
    //
    // Reserved
    // 
    // Bits[30:24], RO, default = 0x0
    //
    UINTX reserved_0 : 7;
    //
    // 0: B-Unit scheduler will not throttle any transaction.  1: B-Unit scheduler will
    // implement throttling and limit the number of transactions sent during a throttling
    // window. 
    // 
    // Bits[31:31], RW, default = 0x0
    //
    UINTX throttle_enable : 1;
  } Bits;
  UINTX Data;
} B_CR_BTHCTRL_BUNIT_STRUCT;
#endif // ASM_INC

#define B_CR_BTH_CYCLE_COUNT_SLICE0_BUNIT_REG              0x00004C84
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Counts the number of cycles for which the B-Unit has an available request to send,
    // but the request is throttled. Counter is not saturating and will roll over to
    // zero. It is up to the consumer of the counter to handle roll over cases. 
    // 
    // Bits[31:0], RO/V, default = 0x0
    //
    UINTX throttle_cycle_count : 32;
  } Bits;
  UINTX Data;
} B_CR_BTH_CYCLE_COUNT_SLICE0_BUNIT_STRUCT;
#endif // ASM_INC

#define B_CR_BTH_CYCLE_COUNT_SLICE1_BUNIT_REG              0x00004C88
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Counts the number of cycles for which the B-Unit has an available request to send,
    // but the request is throttled. Counter is not saturating and will roll over to
    // zero. It is up to the consumer of the counter to handle roll over cases. 
    // 
    // Bits[31:0], RO/V, default = 0x0
    //
    UINTX throttle_cycle_count : 32;
  } Bits;
  UINTX Data;
} B_CR_BTH_CYCLE_COUNT_SLICE1_BUNIT_STRUCT;
#endif // ASM_INC

#define B_CR_BTHCTRL_SLICE1_BUNIT_REG                      0x00004C8C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Total number of read and write requests allowed to be sent during any throttle
    // interval across all PMI channels in slice1.  Slice1 is allowed to send up to THROTTLE_COUNT
    // requests. 
    // 
    // Bits[15:0], RW, default = 0x0
    //
    UINTX throttle_count : 16;
    //
    // Specifies the duration of the throttling interval as a multiple of 60ns N60ns.
    //  Example:  When programmed to 0x4 the throttling interval is 240ns. 
    // 
    // Bits[23:16], RW, default = 0x0
    //
    UINTX throttle_interval : 8;
    //
    // Reserved
    // 
    // Bits[30:24], RO, default = 0x0
    //
    UINTX reserved_0 : 7;
    //
    // Memory Throttling Enable: 0: Bunit scheduler will not throttle any transaction.
    //  1: Bunit scheduler will implement throttling and limit the number of transactions
    // sent during a throttling window 
    // 
    // Bits[31:31], RW, default = 0x0
    //
    UINTX throttle_enable : 1;
  } Bits;
  UINTX Data;
} B_CR_BTHCTRL_SLICE1_BUNIT_STRUCT;
#endif // ASM_INC

#define B_CR_IA_UNTRUSTED_CP_BUNIT_REG                     0x00004C90
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Bit vector used to determine which agents are allowed write access to the IA_UNTRUSTED_RAC
    // IA_UNTRUSTED_WAC and IA_UNTRUSTED_CP registers, based on the value from the agent's
    // 6bit SAI field. 
    // 
    // Bits[63:0], RW, default = 0xC0061010202
    //
    UINTX mem_range_ctrl_pol : 64;
  } Bits;
  UINTX Data;
} B_CR_IA_UNTRUSTED_CP_BUNIT_STRUCT;
#endif // ASM_INC

#define B_CR_IA_UNTRUSTED_RAC_BUNIT_REG                    0x00004C98
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Bit vector used to determine which agents are allowed read access, based on each
    // agent's 6bit encoded SAI value. 
    // 
    // Bits[63:0], RW, default = 0x80000C0063010217
    //
    UINTX mem_range_pol : 64;
  } Bits;
  UINTX Data;
} B_CR_IA_UNTRUSTED_RAC_BUNIT_STRUCT;
#endif // ASM_INC

#define B_CR_IA_UNTRUSTED_WAC_BUNIT_REG                    0x00004CA0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Bit vector used to determine which agents are allowed write access based on each
    // agent's 6bit encoded SAI value. 
    // 
    // Bits[63:0], RW, default = 0xC0061000217
    //
    UINTX mem_range_pol : 64;
  } Bits;
  UINTX Data;
} B_CR_IA_UNTRUSTED_WAC_BUNIT_STRUCT;
#endif // ASM_INC

#define B_CR_MISRCTL_BUNIT_REG                             0x00004CB4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // IDI select for U2C request MISR observation.
    // 
    // Bits[3:0], RW, default = 0x0
    //
    UINTX u2c_req_idi_sel : 4;
    //
    // IDI select for C2U request MISR observation.
    // 
    // Bits[7:4], RW, default = 0x0
    //
    UINTX c2u_req_idi_sel : 4;
    //
    // IDI select for U2C data MISR observation.
    // 
    // Bits[11:8], RW, default = 0x0
    //
    UINTX u2c_data_idi_sel : 4;
    //
    // IDI select for C2U data MISR observation.
    // 
    // Bits[15:12], RW, default = 0x0
    //
    UINTX c2u_data_idi_sel : 4;
    //
    // IDI select for U2C response MISR observation.
    // 
    // Bits[19:16], RW, default = 0x0
    //
    UINTX u2c_rsp_idi_sel : 4;
    //
    // IDI select for C2U reply MISR observation.
    // 
    // Bits[23:20], RW, default = 0x0
    //
    UINTX c2u_rpl_idi_sel : 4;
    //
    // When set, enables normal IDI MISRs
    // 
    // Bits[24:24], RW, default = 0x0
    //
    UINTX misr_en : 1;
    //
    // When set, enables FAB1 to IDI MISRs.
    // 
    // Bits[25:25], RW, default = 0x0
    //
    UINTX misr_fab1_en : 1;
    //
    // Reserved
    // 
    // Bits[26:26], RO, default = 0x0
    //
    UINTX reserved_0 : 1;
    //
    // Write 1 to reset MISRU2CREQSIG register to 0xFFFF_FFFF.
    // 
    // Bits[27:27], WO, default = 0x0
    //
    UINTX u2c_req_clr : 1;
    //
    // Write 1 to reset MISRC2UREQSIG register to 0xFFFF_FFFF.
    // 
    // Bits[28:28], WO, default = 0x0
    //
    UINTX c2u_req_clr : 1;
    //
    // Write 1 to reset MISRU2CDATSIG register to 0xFFFF_FFFF.
    // 
    // Bits[29:29], WO, default = 0x0
    //
    UINTX u2c_data_clr : 1;
    //
    // Write 1 to reset MISRC2UDATSIG register to 0xFFFF_FFFF.
    // 
    // Bits[30:30], WO, default = 0x0
    //
    UINTX c2u_data_clr : 1;
    //
    // Write 1 to reset MISRRPLSIG register to 0xFFFF_FFFF.
    // 
    // Bits[31:31], WO, default = 0x0
    //
    UINTX c2urpl_u2crsp_clr : 1;
  } Bits;
  UINTX Data;
} B_CR_MISRCTL_BUNIT_STRUCT;
#endif // ASM_INC

#define B_CR_MISRS2CREQSIG_BUNIT_REG                       0x00004CB8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // MISR signature for U2C request.
    // 
    // Bits[31:0], RO/V, default = 0xFFFFFFFF
    //
    UINTX u2c_req_sig : 32;
  } Bits;
  UINTX Data;
} B_CR_MISRS2CREQSIG_BUNIT_STRUCT;
#endif // ASM_INC

#define B_CR_MISRC2SREQSIG_BUNIT_REG                       0x00004CBC
#ifndef ASM_INC
typedef union {
  struct {
    //
    // MISR signature for C2U request.
    // 
    // Bits[31:0], RO/V, default = 0xFFFFFFFF
    //
    UINTX c2u_req_sig : 32;
  } Bits;
  UINTX Data;
} B_CR_MISRC2SREQSIG_BUNIT_STRUCT;
#endif // ASM_INC

#define B_CR_MISRS2CDATASIG_BUNIT_REG                      0x00004CC0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // MISR signature for U2C data.
    // 
    // Bits[31:0], RO/V, default = 0xFFFFFFFF
    //
    UINTX u2c_data_sig : 32;
  } Bits;
  UINTX Data;
} B_CR_MISRS2CDATASIG_BUNIT_STRUCT;
#endif // ASM_INC

#define B_CR_MISRC2SDATASIG_BUNIT_REG                      0x00004CC4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // MISR signature for C2U data.
    // 
    // Bits[31:0], RO/V, default = 0xFFFFFFFF
    //
    UINTX c2u_data_sig : 32;
  } Bits;
  UINTX Data;
} B_CR_MISRC2SDATASIG_BUNIT_STRUCT;
#endif // ASM_INC

#define B_CR_MISRRPLSIG_BUNIT_REG                          0x00004CC8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // MISR signature for U2C response and C2U reply.
    // 
    // Bits[31:0], RO/V, default = 0xFFFFFFFF
    //
    UINTX u2crsp_c2urpl_sig : 32;
  } Bits;
  UINTX Data;
} B_CR_MISRRPLSIG_BUNIT_STRUCT;
#endif // ASM_INC

#define B_CR_BCTRL_BUNIT_REG                               0x00004CD4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Enable signal for request specific B-Unit clock gating. Meaningful only when MasterClkGateEnable
    // signal is asserted. 
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINTX requestclk_gate_en : 1;
    //
    // Master enable signal for B-Unit clock gating.
    // 
    // Bits[1:1], RW, default = 0x0
    //
    UINTX masterclk_gate_en : 1;
    //
    // Enables clock gating for the byte enable storage when the MasterClkGateEnable
    // bit is set. Should be set in normal operation. 
    // 
    // Bits[2:2], RW, default = 0x0
    //
    UINTX beclk_gate_en : 1;
    //
    // When set, the B-Unit will only allow 1 access to each 32B chunk of the Tag entry
    // at a time. Note that when DISABLE_REQUEST_COMBINING is set for a VC, the B-Unit
    // will only allow one request to the entire Tag entry at a time. 
    // 
    // Bits[3:3], RW, default = 0x0
    //
    UINTX single_chunk_access : 1;
    //
    // [list]
    //               [*]0: Read/Write access type checks for request combining are done
    // separately for each of the two 32B chunks in a cache line.  
    //               [*]1: Read/Write access type checks for request combining are done
    // over the full line. In other words, when this bit is set, B-Unit will not admit
    // a read request if a write request to any chunk of the same line is still not retired.
    // Similarly, B-Unit will not admit a write request, if a read request to any chunk
    // of the same line is still pending.  
    //               [/list]
    // 
    // Bits[4:4], RW, default = 0x1
    //
    UINTX enable_rw_match_over_full_line : 1;
    //
    // When set to 1,  MOT will be forced to flush its pending buffers when any IDI or
    // PII write data interface is head-of-line blocked at the X2B arbiter waiting on
    // MOT to release its lock on the targeted BTag entry.  When clear, MOT will not
    // be forced to flush upon write data interface stalls due to MOT. 
    // 
    // Bits[5:5], RW, default = 0x1
    //
    UINTX force_mot_flush_for_x2b_write : 1;
    //
    // When set to 1, MOT will be forced to flush its pending buffers when the oldest
    // read request in the B-Unit scheduler is unable to be scheduled waiting on MOT
    // to release its lock on the targeted BTag entry. When clear, MOT will not be forced
    // to flush when the scheduling of oldest read request to PMI is stalled due to MOT.
    // 
    // Bits[6:6], RW, default = 0x1
    //
    UINTX force_mot_flush_for_read_sched : 1;
    //
    // When set to 1, B-Unit behavior will be such that MOT will be forced to flush its
    // pending buffers when all other idle conditions are met for atleast one PMI channel.
    // When clear, B-Unit will not proactively flush the MOT buffer, and will wait on
    // MOT buffer to naturally go empty (for example, after a periodic internal MOT flush
    // event) before any PMI channel is brought to an idle state. 
    // 
    // Bits[7:7], RW, default = 0x1
    //
    UINTX force_mot_flush_for_idle : 1;
    //
    // [list]
    //               [*]0: Disable IO space matching. Nonaddress requests will not cause
    // conflicts with themselves and with other requests. 
    //               [*]1: Enable IO space matching. Nonaddress requests can cause conflicts
    // with themselves and with other requests. 
    //               [/list]
    // 
    // Bits[8:8], RW, default = 0x0
    //
    UINTX enable_io_space_match : 1;
    //
    // When set, B-Unit will map all downstream transactions to the channel specified
    // by ALL_DOWNSTREAM_CHID, ignoring the results of the B-Unit system address decode
    // logic. 
    // 
    // Bits[9:9], RW, default = 0x0
    //
    UINTX all_downstream_chid_override : 1;
    //
    // When ALL_DOWNSTREAM_CHID_OVERRIDE bit is set to 1, B-Unit will map all downstream
    // MMIO and IO transactions to only one channel, specified by this ALL_DOWNSTREAM_CHID
    // bit -- ignoring the results of the system address decode logic. In SoCs where
    // there is only one downstream channel, e.g. DNV, specifying chid 1 will have undefined
    // behavior. It is the responsibility of BIOS or other system software to ensure
    // that downstream chid is not overridden to refer to a nonexistent channel. NOTE:
    // In BXT, usage of this override to send transactions to agents below PSF1 on VC0a
    // will lead to unexpected machine behavior, including hangs. 
    // 
    // Bits[10:10], RW, default = 0x0
    //
    UINTX all_downstream_chid : 1;
    //
    // When set, enables the B-Unit to flush entries from its write buffer in the order
    // they were enqueued into the B-Unit. 
    // 
    // Bits[11:11], RW, default = 0x0
    //
    UINTX inorder_flush_enable : 1;
    //
    // When set, enables the B-Unit to schedule read commands in the order they were
    // enqueued into the B-Unit. 
    // 
    // Bits[12:12], RW, default = 0x0
    //
    UINTX inorder_read_enable : 1;
    //
    // When set, the B-Unit will not used the Owned status for a tag entry.
    // 
    // Bits[13:13], RW, default = 0x0
    //
    UINTX disable_owned : 1;
    //
    // When clear and MOT is enabled, B-Unit admit arbiter will wait for valid Hammock
    // Harbor Time before granting any transaction. When clear or when MOT is disabled,
    // B-Unit admit arbiter will grant transactions without waiting for Hammock Harbor
    // time to be valid. 
    // 
    // Bits[14:14], RW, default = 0x0
    //
    UINTX disable_badmit_stall_for_mot_hh_time : 1;
    //
    // Disable Hammock Harbor Sync protocol and enable clock counting. NOTE: This does
    // not prevent badmit blocking for not having a valid sync'd time. 
    // 
    // Bits[15:15], RW, default = 0x0
    //
    UINTX hh_disable_sync : 1;
    //
    // For A2B requests, this field specifies which VCs are eligible for request combining.
    // DISABLE_REQUEST_COMBINING[16] specifies eligibility for channel 0 VC0a, DISABLE_REQUEST_COMBINING[17]
    // specifies eligibility for channel 1 VC0b, and so on. When the bit is set for a
    // VC, the VC is disabled for request combining. Any VC is eligible for request combining
    // only if either of the following holds: a) VC can accept only in-order read completions,
    // and T_WRITE_ORDERING specifies that the VC must receive in-order writepulls or
    // b) a VC provides the guarantee that it will never send snooped requests. 
    // 
    // Bits[31:16], RW, default = 0x0
    //
    UINTX disable_request_combining : 16;
  } Bits;
  UINTX Data;
} B_CR_BCTRL_BUNIT_STRUCT;
#endif // ASM_INC

#define B_CR_PRMRR_BASE_BUNIT_REG                          0x00004CD8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Reserved
    // 
    // Bits[11:0], RO, default = 0x0
    //
    UINTX reserved_2 : 12;
    //
    // This field corresponds to bits 38:12 of the base address memory range which is
    // allocated to PRMRR memory. PRMRR region size must be a strict poweroftwo, at least
    // 4KB, and naturally aligned to the size. These bits are compared with the result
    // of the RANGE_MASK[38:12] applied to bits 38:12 of the incoming address to determine
    // if an access falls within the PRMRR defined region. 
    // 
    // Bits[38:12], RW, default = 0x0
    //
    UINTX range_base : 27;
    //
    // Reserved
    // 
    // Bits[63:39], RO, default = 0x0
    //
    UINTX reserved_1 : 25;
  } Bits;
  UINTX Data;
} B_CR_PRMRR_BASE_BUNIT_STRUCT;
#endif // ASM_INC

#define B_CR_PRMRR_MASK_BUNIT_REG                          0x00004CE0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Reserved
    // 
    // Bits[7:0], RO, default = 0x0
    //
    UINTX reserved_2 : 8;
    //
    // [list]
    //               [*]1: Allows tracing of transactions to the PRMRR region by tracing
    // agents.           
    //               [*]0: Disallows tracing of transactions to the PRMRR region by tracing
    // agents. 
    //               [/list]
    // 
    // Bits[8:8], RW, default = 0x0
    //
    UINTX tr_en : 1;
    //
    // [list]
    //               [*]1: Enables IWB data from caching agents for requests targeting
    // PRMRR to be returned to requestor.   
    //               [*]0: Disables IWB data from caching agents for requests targeting
    // PRMRR to be returned to requestor. 
    //               [/list]  
    //               NOTE: PRMRR does not have separate IA_IWB_EN and GT_IWB_EN bits.
    // Since GT self-protects accesses to PRMRR, IWB_EN can be set to 1. 
    // 
    // Bits[9:9], RW, default = 0x1
    //
    UINTX iwb_en : 1;
    //
    // Reserved. Lock bit is unused by B-Unit. B-Unit uses policy registers to lock down
    // register. 
    // 
    // Bits[10:10], RW, default = 0x0
    //
    UINTX lock : 1;
    //
    // Indicates whether the PRMRR range is enabled and valid. 
    //               [list]
    //               [*]1: Enabled and Valid. Access control is enforced. 
    //               [*]0: Not enabled. Access control is not enforced.
    //               [/list]
    // 
    // Bits[11:11], RW, default = 0x0
    //
    UINTX range_en : 1;
    //
    // This field indicates which address bits must match PRMRR base in order to qualify
    // as an PRMRR access. These bits are ANDed with bits 38:12 of the incoming address
    // to determine if the combined result matches the RANGE_BASE[38:12] value. A match
    // indicates that the incoming address falls within the PRMRR region. 
    // 
    // Bits[38:12], RW, default = 0x0
    //
    UINTX range_mask : 27;
    //
    // Reserved
    // 
    // Bits[63:39], RO, default = 0x0
    //
    UINTX reserved_1 : 25;
  } Bits;
  UINTX Data;
} B_CR_PRMRR_MASK_BUNIT_STRUCT;
#endif // ASM_INC

#define B_CR_BPRMRRCP_BUNIT_REG                            0x00004CE8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Bit vector used to determine which agents are allowed access to the BPRMRRRAC,
    // BPRMRRWAC and BPRMRRCP registers, based on the value from each agent's 6bit SAI
    // field. 
    // 
    // Bits[63:0], RW, default = 0x40001000202
    //
    UINTX prmrr_ctrl_pol : 64;
  } Bits;
  UINTX Data;
} B_CR_BPRMRRCP_BUNIT_STRUCT;
#endif // ASM_INC

#define B_CR_BPRMRRRAC_BUNIT_REG                           0x00004CF0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Bit vector used to determine which agents are allowed read access to the PRMRR
    // region, based on each agent's 6bit encoded SAI value. 
    // 
    // Bits[0:0], RW, default = 0x1
    //
    UINTX prmrr_sai_pol_0 : 1;
    //
    // Bit vector used to determine which agents are allowed read access to the PRMRR
    // region, based on each agent's 6bit encoded SAI value. 
    // 
    // Bits[1:1], RW, default = 0x1
    //
    UINTX prmrr_sai_pol_1 : 1;
    //
    // Bit vector used to determine which agents are allowed read access to the PRMRR
    // region, based on each agent's 6bit encoded SAI value. 
    // 
    // Bits[2:2], RW, default = 0x1
    //
    UINTX prmrr_sai_pol_2 : 1;
    //
    // Bit vector used to determine which agents are allowed read access to the PRMRR
    // region, based on each agent's 6bit encoded SAI value. 
    // 
    // Bits[3:3], RW, default = 0x0
    //
    UINTX prmrr_sai_pol_3 : 1;
    //
    // Bit vector used to determine which agents are allowed read access to the PRMRR
    // region, based on each agent's 6bit encoded SAI value. 
    // 
    // Bits[4:4], RW, default = 0x1
    //
    UINTX prmrr_sai_pol_4 : 1;
    //
    // Bit vector used to determine which agents are allowed read access to the PRMRR
    // region, based on each agent's 6bit encoded SAI value. 
    // 
    // Bits[5:5], RW, default = 0x0
    //
    UINTX prmrr_sai_pol_5 : 1;
    //
    // Bit vector used to determine which agents are allowed read access to the PRMRR
    // region, based on each agent's 6bit encoded SAI value. 
    // 
    // Bits[6:6], RO, default = 0x0
    //
    UINTX prmrr_sai_pol_6 : 1;
    //
    // Bit vector used to determine which agents are allowed read access to the PRMRR
    // region, based on each agent's 6bit encoded SAI value. 
    // 
    // Bits[7:7], RO, default = 0x0
    //
    UINTX prmrr_sai_pol_7 : 1;
    //
    // Bit vector used to determine which agents are allowed read access to the PRMRR
    // region, based on each agent's 6bit encoded SAI value. 
    // 
    // Bits[8:8], RW, default = 0x0
    //
    UINTX prmrr_sai_pol_8 : 1;
    //
    // Bit vector used to determine which agents are allowed read access to the PRMRR
    // region, based on each agent's 6bit encoded SAI value. 
    // 
    // Bits[9:9], RO, default = 0x0
    //
    UINTX prmrr_sai_pol_9 : 1;
    //
    // Bit vector used to determine which agents are allowed read access to the PRMRR
    // region, based on each agent's 6bit encoded SAI value. 
    // 
    // Bits[10:10], RO, default = 0x0
    //
    UINTX prmrr_sai_pol_10 : 1;
    //
    // Bit vector used to determine which agents are allowed read access to the PRMRR
    // region, based on each agent's 6bit encoded SAI value. 
    // 
    // Bits[11:11], RO, default = 0x0
    //
    UINTX prmrr_sai_pol_11 : 1;
    //
    // Bit vector used to determine which agents are allowed read access to the PRMRR
    // region, based on each agent's 6bit encoded SAI value. 
    // 
    // Bits[12:12], RW, default = 0x0
    //
    UINTX prmrr_sai_pol_12 : 1;
    //
    // Bit vector used to determine which agents are allowed read access to the PRMRR
    // region, based on each agent's 6bit encoded SAI value. 
    // 
    // Bits[13:13], RW, default = 0x0
    //
    UINTX prmrr_sai_pol_13 : 1;
    //
    // Bit vector used to determine which agents are allowed read access to the PRMRR
    // region, based on each agent's 6bit encoded SAI value. 
    // 
    // Bits[14:14], RO, default = 0x0
    //
    UINTX prmrr_sai_pol_14 : 1;
    //
    // Bit vector used to determine which agents are allowed read access to the PRMRR
    // region, based on each agent's 6bit encoded SAI value. 
    // 
    // Bits[15:15], RO, default = 0x0
    //
    UINTX prmrr_sai_pol_15 : 1;
    //
    // Bit vector used to determine which agents are allowed read access to the PRMRR
    // region, based on each agent's 6bit encoded SAI value. 
    // 
    // Bits[16:16], RW, default = 0x0
    //
    UINTX prmrr_sai_pol_16 : 1;
    //
    // Bit vector used to determine which agents are allowed read access to the PRMRR
    // region, based on each agent's 6bit encoded SAI value. 
    // 
    // Bits[17:17], RW, default = 0x0
    //
    UINTX prmrr_sai_pol_17 : 1;
    //
    // Bit vector used to determine which agents are allowed read access to the PRMRR
    // region, based on each agent's 6bit encoded SAI value. 
    // 
    // Bits[18:18], RO, default = 0x0
    //
    UINTX prmrr_sai_pol_18 : 1;
    //
    // Bit vector used to determine which agents are allowed read access to the PRMRR
    // region, based on each agent's 6bit encoded SAI value. 
    // 
    // Bits[19:19], RO, default = 0x0
    //
    UINTX prmrr_sai_pol_19 : 1;
    //
    // Bit vector used to determine which agents are allowed read access to the PRMRR
    // region, based on each agent's 6bit encoded SAI value. 
    // 
    // Bits[20:20], RO, default = 0x0
    //
    UINTX prmrr_sai_pol_20 : 1;
    //
    // Bit vector used to determine which agents are allowed read access to the PRMRR
    // region, based on each agent's 6bit encoded SAI value. 
    // 
    // Bits[21:21], RW, default = 0x0
    //
    UINTX prmrr_sai_pol_21 : 1;
    //
    // Bit vector used to determine which agents are allowed read access to the PRMRR
    // region, based on each agent's 6bit encoded SAI value. 
    // 
    // Bits[22:22], RO, default = 0x0
    //
    UINTX prmrr_sai_pol_22 : 1;
    //
    // Bit vector used to determine which agents are allowed read access to the PRMRR
    // region, based on each agent's 6bit encoded SAI value. 
    // 
    // Bits[23:23], RO, default = 0x0
    //
    UINTX prmrr_sai_pol_23 : 1;
    //
    // Bit vector used to determine which agents are allowed read access to the PRMRR
    // region, based on each agent's 6bit encoded SAI value. 
    // 
    // Bits[24:24], RW, default = 0x0
    //
    UINTX prmrr_sai_pol_24 : 1;
    //
    // Bit vector used to determine which agents are allowed read access to the PRMRR
    // region, based on each agent's 6bit encoded SAI value. 
    // 
    // Bits[25:25], RW, default = 0x0
    //
    UINTX prmrr_sai_pol_25 : 1;
    //
    // Bit vector used to determine which agents are allowed read access to the PRMRR
    // region, based on each agent's 6bit encoded SAI value. 
    // 
    // Bits[26:26], RW, default = 0x0
    //
    UINTX prmrr_sai_pol_26 : 1;
    //
    // Bit vector used to determine which agents are allowed read access to the PRMRR
    // region, based on each agent's 6bit encoded SAI value. 
    // 
    // Bits[27:27], RW, default = 0x0
    //
    UINTX prmrr_sai_pol_27 : 1;
    //
    // Bit vector used to determine which agents are allowed read access to the PRMRR
    // region, based on each agent's 6bit encoded SAI value. 
    // 
    // Bits[28:28], RW, default = 0x0
    //
    UINTX prmrr_sai_pol_28 : 1;
    //
    // Bit vector used to determine which agents are allowed read access to the PRMRR
    // region, based on each agent's 6bit encoded SAI value. 
    // 
    // Bits[29:29], RW, default = 0x0
    //
    UINTX prmrr_sai_pol_29 : 1;
    //
    // Bit vector used to determine which agents are allowed read access to the PRMRR
    // region, based on each agent's 6bit encoded SAI value. 
    // 
    // Bits[30:30], RW, default = 0x0
    //
    UINTX prmrr_sai_pol_30 : 1;
    //
    // Bit vector used to determine which agents are allowed read access to the PRMRR
    // region, based on each agent's 6bit encoded SAI value. 
    // 
    // Bits[31:31], RO, default = 0x0
    //
    UINTX prmrr_sai_pol_31 : 1;
    //
    // Bit vector used to determine which agents are allowed read access to the PRMRR
    // region, based on each agent's 6bit encoded SAI value. 
    // 
    // Bits[32:32], RW, default = 0x0
    //
    UINTX prmrr_sai_pol_32 : 1;
    //
    // Bit vector used to determine which agents are allowed read access to the PRMRR
    // region, based on each agent's 6bit encoded SAI value. 
    // 
    // Bits[33:33], RW, default = 0x0
    //
    UINTX prmrr_sai_pol_33 : 1;
    //
    // Bit vector used to determine which agents are allowed read access to the PRMRR
    // region, based on each agent's 6bit encoded SAI value. 
    // 
    // Bits[34:34], RW, default = 0x0
    //
    UINTX prmrr_sai_pol_34 : 1;
    //
    // Bit vector used to determine which agents are allowed read access to the PRMRR
    // region, based on each agent's 6bit encoded SAI value. 
    // 
    // Bits[35:35], RO, default = 0x0
    //
    UINTX prmrr_sai_pol_35 : 1;
    //
    // Bit vector used to determine which agents are allowed read access to the PRMRR
    // region, based on each agent's 6bit encoded SAI value. 
    // 
    // Bits[36:36], RW, default = 0x0
    //
    UINTX prmrr_sai_pol_36 : 1;
    //
    // Bit vector used to determine which agents are allowed read access to the PRMRR
    // region, based on each agent's 6bit encoded SAI value. 
    // 
    // Bits[37:37], RO, default = 0x0
    //
    UINTX prmrr_sai_pol_37 : 1;
    //
    // Bit vector used to determine which agents are allowed read access to the PRMRR
    // region, based on each agent's 6bit encoded SAI value. 
    // 
    // Bits[38:38], RW, default = 0x0
    //
    UINTX prmrr_sai_pol_38 : 1;
    //
    // Bit vector used to determine which agents are allowed read access to the PRMRR
    // region, based on each agent's 6bit encoded SAI value. 
    // 
    // Bits[39:39], RO, default = 0x0
    //
    UINTX prmrr_sai_pol_39 : 1;
    //
    // Bit vector used to determine which agents are allowed read access to the PRMRR
    // region, based on each agent's 6bit encoded SAI value. 
    // 
    // Bits[40:40], RW, default = 0x0
    //
    UINTX prmrr_sai_pol_40 : 1;
    //
    // Bit vector used to determine which agents are allowed read access to the PRMRR
    // region, based on each agent's 6bit encoded SAI value. 
    // 
    // Bits[41:41], RW, default = 0x0
    //
    UINTX prmrr_sai_pol_41 : 1;
    //
    // Bit vector used to determine which agents are allowed read access to the PRMRR
    // region, based on each agent's 6bit encoded SAI value. 
    // 
    // Bits[42:42], RW, default = 0x0
    //
    UINTX prmrr_sai_pol_42 : 1;
    //
    // Bit vector used to determine which agents are allowed read access to the PRMRR
    // region, based on each agent's 6bit encoded SAI value. 
    // 
    // Bits[43:43], RW, default = 0x0
    //
    UINTX prmrr_sai_pol_43 : 1;
    //
    // Bit vector used to determine which agents are allowed read access to the PRMRR
    // region, based on each agent's 6bit encoded SAI value. 
    // 
    // Bits[44:44], RW, default = 0x0
    //
    UINTX prmrr_sai_pol_44 : 1;
    //
    // Bit vector used to determine which agents are allowed read access to the PRMRR
    // region, based on each agent's 6bit encoded SAI value. 
    // 
    // Bits[45:45], RO, default = 0x0
    //
    UINTX prmrr_sai_pol_45 : 1;
    //
    // Bit vector used to determine which agents are allowed read access to the PRMRR
    // region, based on each agent's 6bit encoded SAI value. 
    // 
    // Bits[46:46], RO, default = 0x0
    //
    UINTX prmrr_sai_pol_46 : 1;
    //
    // Bit vector used to determine which agents are allowed read access to the PRMRR
    // region, based on each agent's 6bit encoded SAI value. 
    // 
    // Bits[47:47], RO, default = 0x0
    //
    UINTX prmrr_sai_pol_47 : 1;
    //
    // Bit vector used to determine which agents are allowed read access to the PRMRR
    // region, based on each agent's 6bit encoded SAI value. 
    // 
    // Bits[48:48], RW, default = 0x0
    //
    UINTX prmrr_sai_pol_48 : 1;
    //
    // Bit vector used to determine which agents are allowed read access to the PRMRR
    // region, based on each agent's 6bit encoded SAI value. 
    // 
    // Bits[49:49], RW, default = 0x0
    //
    UINTX prmrr_sai_pol_49 : 1;
    //
    // Bit vector used to determine which agents are allowed read access to the PRMRR
    // region, based on each agent's 6bit encoded SAI value. 
    // 
    // Bits[50:50], RW, default = 0x0
    //
    UINTX prmrr_sai_pol_50 : 1;
    //
    // Bit vector used to determine which agents are allowed read access to the PRMRR
    // region, based on each agent's 6bit encoded SAI value. 
    // 
    // Bits[51:51], RO, default = 0x0
    //
    UINTX prmrr_sai_pol_51 : 1;
    //
    // Bit vector used to determine which agents are allowed read access to the PRMRR
    // region, based on each agent's 6bit encoded SAI value. 
    // 
    // Bits[52:52], RO, default = 0x0
    //
    UINTX prmrr_sai_pol_52 : 1;
    //
    // Bit vector used to determine which agents are allowed read access to the PRMRR
    // region, based on each agent's 6bit encoded SAI value. 
    // 
    // Bits[53:53], RO, default = 0x0
    //
    UINTX prmrr_sai_pol_53 : 1;
    //
    // Bit vector used to determine which agents are allowed read access to the PRMRR
    // region, based on each agent's 6bit encoded SAI value. 
    // 
    // Bits[54:54], RW, default = 0x0
    //
    UINTX prmrr_sai_pol_54 : 1;
    //
    // Bit vector used to determine which agents are allowed read access to the PRMRR
    // region, based on each agent's 6bit encoded SAI value. 
    // 
    // Bits[55:55], RW, default = 0x0
    //
    UINTX prmrr_sai_pol_55 : 1;
    //
    // Bit vector used to determine which agents are allowed read access to the PRMRR
    // region, based on each agent's 6bit encoded SAI value. 
    // 
    // Bits[56:56], RW, default = 0x0
    //
    UINTX prmrr_sai_pol_56 : 1;
    //
    // Bit vector used to determine which agents are allowed read access to the PRMRR
    // region, based on each agent's 6bit encoded SAI value. 
    // 
    // Bits[57:57], RO, default = 0x0
    //
    UINTX prmrr_sai_pol_57 : 1;
    //
    // Bit vector used to determine which agents are allowed read access to the PRMRR
    // region, based on each agent's 6bit encoded SAI value. 
    // 
    // Bits[58:58], RO, default = 0x0
    //
    UINTX prmrr_sai_pol_58 : 1;
    //
    // Bit vector used to determine which agents are allowed read access to the PRMRR
    // region, based on each agent's 6bit encoded SAI value. 
    // 
    // Bits[59:59], RO, default = 0x0
    //
    UINTX prmrr_sai_pol_59 : 1;
    //
    // Bit vector used to determine which agents are allowed read access to the PRMRR
    // region, based on each agent's 6bit encoded SAI value. 
    // 
    // Bits[60:60], RO, default = 0x0
    //
    UINTX prmrr_sai_pol_60 : 1;
    //
    // Bit vector used to determine which agents are allowed read access to the PRMRR
    // region, based on each agent's 6bit encoded SAI value. 
    // 
    // Bits[61:61], RO, default = 0x0
    //
    UINTX prmrr_sai_pol_61 : 1;
    //
    // Bit vector used to determine which agents are allowed read access to the PRMRR
    // region, based on each agent's 6bit encoded SAI value. 
    // 
    // Bits[62:62], RO, default = 0x0
    //
    UINTX prmrr_sai_pol_62 : 1;
    //
    // Bit vector used to determine which agents are allowed read access to the PRMRR
    // region, based on each agent's 6bit encoded SAI value. 
    // 
    // Bits[63:63], RW, default = 0x0
    //
    UINTX prmrr_sai_pol_63 : 1;
  } Bits;
  UINTX Data;
} B_CR_BPRMRRRAC_BUNIT_STRUCT;
#endif // ASM_INC

#define B_CR_BPRMRRWAC_BUNIT_REG                           0x00004CF8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Bit vector used to determine which agents are allowed write access to the B-Unit
    // PRMRR region, based on each agent's 6bit encoded SAI value. 
    // 
    // Bits[0:0], RW, default = 0x1
    //
    UINTX prmrr_sai_pol_0 : 1;
    //
    // Bit vector used to determine which agents are allowed write access to the B-Unit
    // PRMRR region, based on each agent's 6bit encoded SAI value. 
    // 
    // Bits[1:1], RW, default = 0x1
    //
    UINTX prmrr_sai_pol_1 : 1;
    //
    // Bit vector used to determine which agents are allowed write access to the B-Unit
    // PRMRR region, based on each agent's 6bit encoded SAI value. 
    // 
    // Bits[2:2], RW, default = 0x1
    //
    UINTX prmrr_sai_pol_2 : 1;
    //
    // Bit vector used to determine which agents are allowed write access to the B-Unit
    // PRMRR region, based on each agent's 6bit encoded SAI value. 
    // 
    // Bits[3:3], RW, default = 0x0
    //
    UINTX prmrr_sai_pol_3 : 1;
    //
    // Bit vector used to determine which agents are allowed write access to the B-Unit
    // PRMRR region, based on each agent's 6bit encoded SAI value. 
    // 
    // Bits[4:4], RW, default = 0x1
    //
    UINTX prmrr_sai_pol_4 : 1;
    //
    // Bit vector used to determine which agents are allowed write access to the B-Unit
    // PRMRR region, based on each agent's 6bit encoded SAI value. 
    // 
    // Bits[5:5], RW, default = 0x0
    //
    UINTX prmrr_sai_pol_5 : 1;
    //
    // Bit vector used to determine which agents are allowed write access to the B-Unit
    // PRMRR region, based on each agent's 6bit encoded SAI value. 
    // 
    // Bits[6:6], RO, default = 0x0
    //
    UINTX prmrr_sai_pol_6 : 1;
    //
    // Bit vector used to determine which agents are allowed write access to the B-Unit
    // PRMRR region, based on each agent's 6bit encoded SAI value. 
    // 
    // Bits[7:7], RO, default = 0x0
    //
    UINTX prmrr_sai_pol_7 : 1;
    //
    // Bit vector used to determine which agents are allowed write access to the B-Unit
    // PRMRR region, based on each agent's 6bit encoded SAI value. 
    // 
    // Bits[8:8], RW, default = 0x0
    //
    UINTX prmrr_sai_pol_8 : 1;
    //
    // Bit vector used to determine which agents are allowed write access to the B-Unit
    // PRMRR region, based on each agent's 6bit encoded SAI value. 
    // 
    // Bits[9:9], RO, default = 0x0
    //
    UINTX prmrr_sai_pol_9 : 1;
    //
    // Bit vector used to determine which agents are allowed write access to the B-Unit
    // PRMRR region, based on each agent's 6bit encoded SAI value. 
    // 
    // Bits[10:10], RO, default = 0x0
    //
    UINTX prmrr_sai_pol_10 : 1;
    //
    // Bit vector used to determine which agents are allowed write access to the B-Unit
    // PRMRR region, based on each agent's 6bit encoded SAI value. 
    // 
    // Bits[11:11], RO, default = 0x0
    //
    UINTX prmrr_sai_pol_11 : 1;
    //
    // Bit vector used to determine which agents are allowed write access to the B-Unit
    // PRMRR region, based on each agent's 6bit encoded SAI value. 
    // 
    // Bits[12:12], RW, default = 0x0
    //
    UINTX prmrr_sai_pol_12 : 1;
    //
    // Bit vector used to determine which agents are allowed write access to the B-Unit
    // PRMRR region, based on each agent's 6bit encoded SAI value. 
    // 
    // Bits[13:13], RW, default = 0x0
    //
    UINTX prmrr_sai_pol_13 : 1;
    //
    // Bit vector used to determine which agents are allowed write access to the B-Unit
    // PRMRR region, based on each agent's 6bit encoded SAI value. 
    // 
    // Bits[14:14], RO, default = 0x0
    //
    UINTX prmrr_sai_pol_14 : 1;
    //
    // Bit vector used to determine which agents are allowed write access to the B-Unit
    // PRMRR region, based on each agent's 6bit encoded SAI value. 
    // 
    // Bits[15:15], RO, default = 0x0
    //
    UINTX prmrr_sai_pol_15 : 1;
    //
    // Bit vector used to determine which agents are allowed write access to the B-Unit
    // PRMRR region, based on each agent's 6bit encoded SAI value. 
    // 
    // Bits[16:16], RW, default = 0x0
    //
    UINTX prmrr_sai_pol_16 : 1;
    //
    // Bit vector used to determine which agents are allowed write access to the B-Unit
    // PRMRR region, based on each agent's 6bit encoded SAI value. 
    // 
    // Bits[17:17], RW, default = 0x0
    //
    UINTX prmrr_sai_pol_17 : 1;
    //
    // Bit vector used to determine which agents are allowed write access to the B-Unit
    // PRMRR region, based on each agent's 6bit encoded SAI value. 
    // 
    // Bits[18:18], RO, default = 0x0
    //
    UINTX prmrr_sai_pol_18 : 1;
    //
    // Bit vector used to determine which agents are allowed write access to the B-Unit
    // PRMRR region, based on each agent's 6bit encoded SAI value. 
    // 
    // Bits[19:19], RO, default = 0x0
    //
    UINTX prmrr_sai_pol_19 : 1;
    //
    // Bit vector used to determine which agents are allowed write access to the B-Unit
    // PRMRR region, based on each agent's 6bit encoded SAI value. 
    // 
    // Bits[20:20], RO, default = 0x0
    //
    UINTX prmrr_sai_pol_20 : 1;
    //
    // Bit vector used to determine which agents are allowed write access to the B-Unit
    // PRMRR region, based on each agent's 6bit encoded SAI value. 
    // 
    // Bits[21:21], RW, default = 0x0
    //
    UINTX prmrr_sai_pol_21 : 1;
    //
    // Bit vector used to determine which agents are allowed write access to the B-Unit
    // PRMRR region, based on each agent's 6bit encoded SAI value. 
    // 
    // Bits[22:22], RO, default = 0x0
    //
    UINTX prmrr_sai_pol_22 : 1;
    //
    // Bit vector used to determine which agents are allowed write access to the B-Unit
    // PRMRR region, based on each agent's 6bit encoded SAI value. 
    // 
    // Bits[23:23], RO, default = 0x0
    //
    UINTX prmrr_sai_pol_23 : 1;
    //
    // Bit vector used to determine which agents are allowed write access to the B-Unit
    // PRMRR region, based on each agent's 6bit encoded SAI value. 
    // 
    // Bits[24:24], RW, default = 0x0
    //
    UINTX prmrr_sai_pol_24 : 1;
    //
    // Bit vector used to determine which agents are allowed write access to the B-Unit
    // PRMRR region, based on each agent's 6bit encoded SAI value. 
    // 
    // Bits[25:25], RW, default = 0x0
    //
    UINTX prmrr_sai_pol_25 : 1;
    //
    // Bit vector used to determine which agents are allowed write access to the B-Unit
    // PRMRR region, based on each agent's 6bit encoded SAI value. 
    // 
    // Bits[26:26], RW, default = 0x0
    //
    UINTX prmrr_sai_pol_26 : 1;
    //
    // Bit vector used to determine which agents are allowed write access to the B-Unit
    // PRMRR region, based on each agent's 6bit encoded SAI value. 
    // 
    // Bits[27:27], RW, default = 0x0
    //
    UINTX prmrr_sai_pol_27 : 1;
    //
    // Bit vector used to determine which agents are allowed write access to the B-Unit
    // PRMRR region, based on each agent's 6bit encoded SAI value. 
    // 
    // Bits[28:28], RW, default = 0x0
    //
    UINTX prmrr_sai_pol_28 : 1;
    //
    // Bit vector used to determine which agents are allowed write access to the B-Unit
    // PRMRR region, based on each agent's 6bit encoded SAI value. 
    // 
    // Bits[29:29], RW, default = 0x0
    //
    UINTX prmrr_sai_pol_29 : 1;
    //
    // Bit vector used to determine which agents are allowed write access to the B-Unit
    // PRMRR region, based on each agent's 6bit encoded SAI value. 
    // 
    // Bits[30:30], RW, default = 0x0
    //
    UINTX prmrr_sai_pol_30 : 1;
    //
    // Bit vector used to determine which agents are allowed write access to the B-Unit
    // PRMRR region, based on each agent's 6bit encoded SAI value. 
    // 
    // Bits[31:31], RO, default = 0x0
    //
    UINTX prmrr_sai_pol_31 : 1;
    //
    // Bit vector used to determine which agents are allowed write access to the B-Unit
    // PRMRR region, based on each agent's 6bit encoded SAI value. 
    // 
    // Bits[32:32], RW, default = 0x0
    //
    UINTX prmrr_sai_pol_32 : 1;
    //
    // Bit vector used to determine which agents are allowed write access to the B-Unit
    // PRMRR region, based on each agent's 6bit encoded SAI value. 
    // 
    // Bits[33:33], RW, default = 0x0
    //
    UINTX prmrr_sai_pol_33 : 1;
    //
    // Bit vector used to determine which agents are allowed write access to the B-Unit
    // PRMRR region, based on each agent's 6bit encoded SAI value. 
    // 
    // Bits[34:34], RW, default = 0x0
    //
    UINTX prmrr_sai_pol_34 : 1;
    //
    // Bit vector used to determine which agents are allowed write access to the B-Unit
    // PRMRR region, based on each agent's 6bit encoded SAI value. 
    // 
    // Bits[35:35], RO, default = 0x0
    //
    UINTX prmrr_sai_pol_35 : 1;
    //
    // Bit vector used to determine which agents are allowed write access to the B-Unit
    // PRMRR region, based on each agent's 6bit encoded SAI value. 
    // 
    // Bits[36:36], RW, default = 0x0
    //
    UINTX prmrr_sai_pol_36 : 1;
    //
    // Bit vector used to determine which agents are allowed write access to the B-Unit
    // PRMRR region, based on each agent's 6bit encoded SAI value. 
    // 
    // Bits[37:37], RO, default = 0x0
    //
    UINTX prmrr_sai_pol_37 : 1;
    //
    // Bit vector used to determine which agents are allowed write access to the B-Unit
    // PRMRR region, based on each agent's 6bit encoded SAI value. 
    // 
    // Bits[38:38], RW, default = 0x0
    //
    UINTX prmrr_sai_pol_38 : 1;
    //
    // Bit vector used to determine which agents are allowed write access to the B-Unit
    // PRMRR region, based on each agent's 6bit encoded SAI value. 
    // 
    // Bits[39:39], RO, default = 0x0
    //
    UINTX prmrr_sai_pol_39 : 1;
    //
    // Bit vector used to determine which agents are allowed write access to the B-Unit
    // PRMRR region, based on each agent's 6bit encoded SAI value. 
    // 
    // Bits[40:40], RW, default = 0x0
    //
    UINTX prmrr_sai_pol_40 : 1;
    //
    // Bit vector used to determine which agents are allowed write access to the B-Unit
    // PRMRR region, based on each agent's 6bit encoded SAI value. 
    // 
    // Bits[41:41], RW, default = 0x0
    //
    UINTX prmrr_sai_pol_41 : 1;
    //
    // Bit vector used to determine which agents are allowed write access to the B-Unit
    // PRMRR region, based on each agent's 6bit encoded SAI value. 
    // 
    // Bits[42:42], RW, default = 0x0
    //
    UINTX prmrr_sai_pol_42 : 1;
    //
    // Bit vector used to determine which agents are allowed write access to the B-Unit
    // PRMRR region, based on each agent's 6bit encoded SAI value. 
    // 
    // Bits[43:43], RW, default = 0x0
    //
    UINTX prmrr_sai_pol_43 : 1;
    //
    // Bit vector used to determine which agents are allowed write access to the B-Unit
    // PRMRR region, based on each agent's 6bit encoded SAI value. 
    // 
    // Bits[44:44], RW, default = 0x0
    //
    UINTX prmrr_sai_pol_44 : 1;
    //
    // Bit vector used to determine which agents are allowed write access to the B-Unit
    // PRMRR region, based on each agent's 6bit encoded SAI value. 
    // 
    // Bits[45:45], RO, default = 0x0
    //
    UINTX prmrr_sai_pol_45 : 1;
    //
    // Bit vector used to determine which agents are allowed write access to the B-Unit
    // PRMRR region, based on each agent's 6bit encoded SAI value. 
    // 
    // Bits[46:46], RO, default = 0x0
    //
    UINTX prmrr_sai_pol_46 : 1;
    //
    // Bit vector used to determine which agents are allowed write access to the B-Unit
    // PRMRR region, based on each agent's 6bit encoded SAI value. 
    // 
    // Bits[47:47], RO, default = 0x0
    //
    UINTX prmrr_sai_pol_47 : 1;
    //
    // Bit vector used to determine which agents are allowed write access to the B-Unit
    // PRMRR region, based on each agent's 6bit encoded SAI value. 
    // 
    // Bits[48:48], RW, default = 0x0
    //
    UINTX prmrr_sai_pol_48 : 1;
    //
    // Bit vector used to determine which agents are allowed write access to the B-Unit
    // PRMRR region, based on each agent's 6bit encoded SAI value. 
    // 
    // Bits[49:49], RW, default = 0x0
    //
    UINTX prmrr_sai_pol_49 : 1;
    //
    // Bit vector used to determine which agents are allowed write access to the B-Unit
    // PRMRR region, based on each agent's 6bit encoded SAI value. 
    // 
    // Bits[50:50], RW, default = 0x0
    //
    UINTX prmrr_sai_pol_50 : 1;
    //
    // Bit vector used to determine which agents are allowed write access to the B-Unit
    // PRMRR region, based on each agent's 6bit encoded SAI value. 
    // 
    // Bits[51:51], RO, default = 0x0
    //
    UINTX prmrr_sai_pol_51 : 1;
    //
    // Bit vector used to determine which agents are allowed write access to the B-Unit
    // PRMRR region, based on each agent's 6bit encoded SAI value. 
    // 
    // Bits[52:52], RO, default = 0x0
    //
    UINTX prmrr_sai_pol_52 : 1;
    //
    // Bit vector used to determine which agents are allowed write access to the B-Unit
    // PRMRR region, based on each agent's 6bit encoded SAI value. 
    // 
    // Bits[53:53], RO, default = 0x0
    //
    UINTX prmrr_sai_pol_53 : 1;
    //
    // Bit vector used to determine which agents are allowed write access to the B-Unit
    // PRMRR region, based on each agent's 6bit encoded SAI value. 
    // 
    // Bits[54:54], RW, default = 0x0
    //
    UINTX prmrr_sai_pol_54 : 1;
    //
    // Bit vector used to determine which agents are allowed write access to the B-Unit
    // PRMRR region, based on each agent's 6bit encoded SAI value. 
    // 
    // Bits[55:55], RW, default = 0x0
    //
    UINTX prmrr_sai_pol_55 : 1;
    //
    // Bit vector used to determine which agents are allowed write access to the B-Unit
    // PRMRR region, based on each agent's 6bit encoded SAI value. 
    // 
    // Bits[56:56], RW, default = 0x0
    //
    UINTX prmrr_sai_pol_56 : 1;
    //
    // Bit vector used to determine which agents are allowed write access to the B-Unit
    // PRMRR region, based on each agent's 6bit encoded SAI value. 
    // 
    // Bits[57:57], RO, default = 0x0
    //
    UINTX prmrr_sai_pol_57 : 1;
    //
    // Bit vector used to determine which agents are allowed write access to the B-Unit
    // PRMRR region, based on each agent's 6bit encoded SAI value. 
    // 
    // Bits[58:58], RO, default = 0x0
    //
    UINTX prmrr_sai_pol_58 : 1;
    //
    // Bit vector used to determine which agents are allowed write access to the B-Unit
    // PRMRR region, based on each agent's 6bit encoded SAI value. 
    // 
    // Bits[59:59], RO, default = 0x0
    //
    UINTX prmrr_sai_pol_59 : 1;
    //
    // Bit vector used to determine which agents are allowed write access to the B-Unit
    // PRMRR region, based on each agent's 6bit encoded SAI value. 
    // 
    // Bits[60:60], RO, default = 0x0
    //
    UINTX prmrr_sai_pol_60 : 1;
    //
    // Bit vector used to determine which agents are allowed write access to the B-Unit
    // PRMRR region, based on each agent's 6bit encoded SAI value. 
    // 
    // Bits[61:61], RO, default = 0x0
    //
    UINTX prmrr_sai_pol_61 : 1;
    //
    // Bit vector used to determine which agents are allowed write access to the B-Unit
    // PRMRR region, based on each agent's 6bit encoded SAI value. 
    // 
    // Bits[62:62], RO, default = 0x0
    //
    UINTX prmrr_sai_pol_62 : 1;
    //
    // Bit vector used to determine which agents are allowed write access to the B-Unit
    // PRMRR region, based on each agent's 6bit encoded SAI value. 
    // 
    // Bits[63:63], RW, default = 0x0
    //
    UINTX prmrr_sai_pol_63 : 1;
  } Bits;
  UINTX Data;
} B_CR_BPRMRRWAC_BUNIT_STRUCT;
#endif // ASM_INC


#endif // _BUNIT_H_
