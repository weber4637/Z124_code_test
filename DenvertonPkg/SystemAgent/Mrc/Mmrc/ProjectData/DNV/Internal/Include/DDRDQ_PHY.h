/** @file
  File name:    DDRDQ_PHY.h
  Input File:   DNV_MRC.xlsx

  THIS FILE IS AUTO-GENERATED BY THE MSP TOOL. DO NOT CHANGE THIS CODE.

  If edits are needed in this file, they must be done via the MSP tool.

  If there is additional project-specific data required by the MSP, it
  can be placed in DDRDQ_PHY.h, which is used for non-tool-generated
  data

  Includes register defines specific to a project.

  Copyright (c) 2005-2018 Intel Corporation. All rights reserved
  This software and associated documentation (if any) is furnished
  under a license and may only be used or copied in accordance
  with the terms of the license. Except as permitted by such
  license, no part of this software or documentation may be
  reproduced, stored in a retrieval system, or transmitted in any
  form or by any means without the express written consent of
  Intel Corporation.
**/
#ifndef _DDRDQ_PHY_H_
#define _DDRDQ_PHY_H_

#include "DataTypes.h"

#if USE_64_BIT_VARIABLES
#define UINTX UINT64
#else
#define UINTX UINT32
#endif

#define DRVENBCTL_B0N0_MISC_DDRDQ_PHY_REG                  0x00000198
#ifndef ASM_INC
typedef union {
  struct {
    //
    // DQ Drive Enable - Preamble0 Phase[br]00 - Rise & Fall - Low & Low[br]01 - Rise
    // & Fall - High & Low[br]10 - Rise & Fall - Low & High[br]11 - Rise & Fall - High
    // & High 
    // 
    // Bits[31:0], 0, default = 0x0
    //
    UINTX b0n0_dqdrvenbpream0 : 32;
  } Bits;
  UINTX Data;
} DRVENBCTL_B0N0_MISC_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define DRVENBCTL_B0N1_MISC_DDRDQ_PHY_REG                  0x0000019C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // DQ Drive Enable - Preamble0 Phase[br]00 - Rise & Fall - Low & Low[br]01 - Rise
    // & Fall - High & Low[br]10 - Rise & Fall - Low & High[br]11 - Rise & Fall - High
    // & High 
    // 
    // Bits[31:0], 0, default = 0x0
    //
    UINTX b0n1_dqdrvenbpream0 : 32;
  } Bits;
  UINTX Data;
} DRVENBCTL_B0N1_MISC_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define DRVENBCTL_B1N0_MISC_DDRDQ_PHY_REG                  0x000003C8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // DQ Drive Enable - Preamble0 Phase[br]00 - Rise & Fall - Low & Low[br]01 - Rise
    // & Fall - High & Low[br]10 - Rise & Fall - Low & High[br]11 - Rise & Fall - High
    // & High 
    // 
    // Bits[31:0], 0, default = 0x0
    //
    UINTX b1n0_dqdrvenbpream0 : 32;
  } Bits;
  UINTX Data;
} DRVENBCTL_B1N0_MISC_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define DRVENBCTL_B1N1_MISC_DDRDQ_PHY_REG                  0x000003CC
#ifndef ASM_INC
typedef union {
  struct {
    //
    // DQ Drive Enable - Preamble0 Phase[br]00 - Rise & Fall - Low & Low[br]01 - Rise
    // & Fall - High & Low[br]10 - Rise & Fall - Low & High[br]11 - Rise & Fall - High
    // & High 
    // 
    // Bits[31:0], 0, default = 0x0
    //
    UINTX b1n1_dqdrvenbpream0 : 32;
  } Bits;
  UINTX Data;
} DRVENBCTL_B1N1_MISC_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define TXDLLCFG0_DDRDQ_PHY_REG                            0x00000000
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Enable 2xclk output to rxdqssdl block for HVM testing
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINTX txdll_2xclkdfxen : 1;
    //
    // Charge pump trim bits. Currently the same as the drvsel[br][br]1600MHz = 010[br]1866MHz
    // = 011[br]2133MHz = 100[br]2400MHz = 101[br]2667MHz = 111 
    // 
    // Bits[3:1], RW, default = 0x1
    //
    UINTX txdll_cptrim : 3;
    //
    // Delay Cell bias strength[br][br]1600MHz = 010[br]1866MHz = 011[br]2133MHz = 100[br]2400MHz
    // = 101[br]2667MHz = 111 
    // 
    // Bits[6:4], RW, default = 0x2
    //
    UINTX txdll_drvsel : 3;
    //
    // Bypasses Master DLL so ref2xclk goes directly to pi outputs
    // 
    // Bits[7:7], RW, default = 0x0
    //
    UINTX txdll_mdllbypassen : 1;
    //
    // MDLL enable, from low to high
    // 
    // Bits[8:8], RW, default = 0x0
    //
    UINTX txdll_mdllen : 1;
    //
    // Set tuning for Phase Interpolator:[br][br]1600MHz = 100[br]1866MHz = 100[br]2133MHz
    // = 101[br]2400MHz = 101[br]2667MHz = 101 
    // 
    // Bits[11:9], RW, default = 0x1
    //
    UINTX txdll_pidrvsel : 3;
    //
    // enable process trim option. currently a placeholder
    // 
    // Bits[12:12], RW, default = 0x0
    //
    UINTX txdll_proctrimen : 1;
    //
    // process trim code
    // 
    // Bits[15:13], RW, default = 0x0
    //
    UINTX txdll_proctrim : 3;
    //
    // hiz pbias to allow overdrive in dfx mode
    // 
    // Bits[16:16], RW, default = 0x0
    //
    UINTX txdll_pbiashizdfxen : 1;
    //
    // hiz nbias to allow overdrive in dfx mode
    // 
    // Bits[17:17], RW, default = 0x0
    //
    UINTX txdll_nbiashizdfxen : 1;
    //
    // Reserved
    // 
    // Bits[31:18], RO, default = 0x0
    //
    UINTX reserved : 14;
  } Bits;
  UINTX Data;
} TXDLLCFG0_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define TXDLLCFG1_DDRDQ_PHY_REG                            0x00000004
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Tx ref Bypass ph0 enable. 0: Use PI Clk Output, 1: Bypass and use input 2x clk
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINTX txdll_ref2xph0pibypassen : 1;
    //
    // PI Code for ref PI phase 0 output
    // 
    // Bits[6:1], RW, default = 0x0
    //
    UINTX txdll_ref2xph0picode : 6;
    //
    // Enable TX ref PI phase 0 enable
    // 
    // Bits[7:7], RW, default = 0x0
    //
    UINTX txdll_ref2xph0pien : 1;
    //
    // Enable TX ref PI phase 0 output enable
    // 
    // Bits[8:8], RW, default = 0x0
    //
    UINTX txdll_ref2xph0piouten : 1;
    //
    // Tx ref Bypass ph90 enable. 0: Use PI Clk Output, 1: Bypass and use input 2x clk
    // 
    // Bits[9:9], RW, default = 0x0
    //
    UINTX txdll_ref2xph90pibypassen : 1;
    //
    // PI Code for ref PI phase 90 output
    // 
    // Bits[15:10], RW, default = 0x0
    //
    UINTX txdll_ref2xph90picode : 6;
    //
    // Enable TX ref PI phase 90 enable
    // 
    // Bits[16:16], RW, default = 0x0
    //
    UINTX txdll_ref2xph90pien : 1;
    //
    // Enable TX ref PI phase 90 output enable
    // 
    // Bits[17:17], RW, default = 0x0
    //
    UINTX txdll_ref2xph90piouten : 1;
    //
    // Reserved
    // 
    // Bits[31:18], RO, default = 0x0
    //
    UINTX reserved : 14;
  } Bits;
  UINTX Data;
} TXDLLCFG1_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define TXDLLCFG2_DDRDQ_PHY_REG                            0x00000008
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Tx ref Bypass ph180 enable. 0: Use PI Clk Output, 1: Bypass and use input 2x clk
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINTX txdll_ref2xph180pibypassen : 1;
    //
    // PI Code for ref PI phase 180 output
    // 
    // Bits[6:1], RW, default = 0x0
    //
    UINTX txdll_ref2xph180picode : 6;
    //
    // Enable TX ref PI phase 180 enable
    // 
    // Bits[7:7], RW, default = 0x0
    //
    UINTX txdll_ref2xph180pien : 1;
    //
    // Enable TX ref PI phase 180 output enable
    // 
    // Bits[8:8], RW, default = 0x0
    //
    UINTX txdll_ref2xph180piouten : 1;
    //
    // Tx ref Bypass ph270 enable. 0: Use PI Clk Output, 1: Bypass and use input 2x clk
    // 
    // Bits[9:9], RW, default = 0x0
    //
    UINTX txdll_ref2xph270pibypassen : 1;
    //
    // PI Code for ref PI phase 270 output
    // 
    // Bits[15:10], RW, default = 0x0
    //
    UINTX txdll_ref2xph270picode : 6;
    //
    // Enable TX ref PI phase 270 enable
    // 
    // Bits[16:16], RW, default = 0x0
    //
    UINTX txdll_ref2xph270pien : 1;
    //
    // Enable TX ref PI phase 270 output enable
    // 
    // Bits[17:17], RW, default = 0x1
    //
    UINTX txdll_ref2xph270piouten : 1;
    //
    // Reserved
    // 
    // Bits[31:18], RO, default = 0x0
    //
    UINTX reserved : 14;
  } Bits;
  UINTX Data;
} TXDLLCFG2_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define TXDLLCFG3_DDRDQ_PHY_REG                            0x0000000C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Byte0 Group[5:0] Bypass enable. 0: Use PI Clk Output, 1: Bypass and use ref clk
    // 
    // Bits[11:0], RW, default = 0x0
    //
    UINTX txdll_siggrppibypassen : 12;
    //
    // Enable TX Signal group[11:0] Phase Interpolator
    // 
    // Bits[23:12], RW, default = 0x0
    //
    UINTX txdll_siggrppien : 12;
    //
    // Reserved
    // 
    // Bits[31:24], RO, default = 0x0
    //
    UINTX reserved : 8;
  } Bits;
  UINTX Data;
} TXDLLCFG3_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define TXDLLCFG4_DDRDQ_PHY_REG                            0x00000010
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Enable TX Signal group[11:0] output
    // 
    // Bits[11:0], RW, default = 0x0
    //
    UINTX txdll_siggrppiouten : 12;
    //
    // DLL Startup signal is high for these many cycles after mdllen goes high:   00
    // (64 cycles)    01 (16 cycles)   10 (32 cycles)   11 (128 cycles) 
    // 
    // Bits[13:12], RW, default = 0x0
    //
    UINTX txdll_starttimesel : 2;
    //
    // Weak Lock enable
    // 
    // Bits[14:14], RW, default = 0x0
    //
    UINTX txdll_weaklocken : 1;
    //
    // 1 = prevents biasgen going into halfmode even in weaklock. 0= biasgen goes into
    // halfmode during weaklock 
    // 
    // Bits[15:15], RW, default = 0x0
    //
    UINTX txdll_weaklockhalfmodegate : 1;
    //
    // Allows nbiasgen to be set in halfmode outside of weaklock
    // 
    // Bits[16:16], RW, default = 0x0
    //
    UINTX txdll_weaklockhalfmodeoverride : 1;
    //
    // invert clk going into refmask related flops
    // 
    // Bits[17:17], RW, default = 0x0
    //
    UINTX txdll_weaklockrefmaskclkinvert : 1;
    //
    // Select how many clk cycles before stopping weaklock and enabling phase detector
    // 
    // Bits[20:18], RW, default = 0x0
    //
    UINTX txdll_weaklockrefmaskdly : 3;
    //
    // invert clk going into vcdl clock gating related flops
    // 
    // Bits[21:21], RW, default = 0x0
    //
    UINTX txdll_weaklockvcdlgateclkinvert : 1;
    //
    // Reserved
    // 
    // Bits[31:22], RO, default = 0x0
    //
    UINTX reserved : 10;
  } Bits;
  UINTX Data;
} TXDLLCFG4_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define TXDLLCFG5_DDRDQ_PHY_REG                            0x00000014
#ifndef ASM_INC
typedef union {
  struct {
    //
    // analog select mux for output 0
    // 
    // Bits[2:0], RW, default = 0x0
    //
    UINTX txdll_anaobs0sel : 3;
    //
    // analog select mux for output 1
    // 
    // Bits[5:3], RW, default = 0x0
    //
    UINTX txdll_anaobs1sel : 3;
    //
    // DFX digital 0 mux select
    // 
    // Bits[11:6], RW, default = 0x0
    //
    UINTX txdll_digobs0sel : 6;
    //
    // DFX digital 1 mux select
    // 
    // Bits[17:12], RW, default = 0x0
    //
    UINTX txdll_digobs1sel : 6;
    //
    // Reserved
    // 
    // Bits[31:18], RO, default = 0x0
    //
    UINTX reserved : 14;
  } Bits;
  UINTX Data;
} TXDLLCFG5_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define OBSCFG0_DDRDQ_PHY_REG                              0x00000018
#ifndef ASM_INC
typedef union {
  struct {
    //
    // select signal for analog obs mux a.
    // 
    // Bits[3:0], RW, default = 0x0
    //
    UINTX lcomp_anaobs0sel : 4;
    //
    // select signal for analog obs mux b.
    // 
    // Bits[7:4], RW, default = 0x0
    //
    UINTX lcomp_anaobs1sel : 4;
    //
    // select signal for digital obs mux a.
    // 
    // Bits[11:8], RW, default = 0x0
    //
    UINTX lcomp_digobs0sel : 4;
    //
    // select signal for digital obs mux b.
    // 
    // Bits[15:12], RW, default = 0x0
    //
    UINTX lcomp_digobs1sel : 4;
    //
    // Reserved
    // 
    // Bits[31:16], RO, default = 0x0
    //
    UINTX reserved : 16;
  } Bits;
  UINTX Data;
} OBSCFG0_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define LCOMPCFG0_DDRDQ_PHY_REG                            0x0000001C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // DQ buffer rcomp pull-down Vref control setting
    // 
    // Bits[7:0], RW, default = 0x0
    //
    UINTX lcomp_pdn_dq_vrefctrl : 8;
    //
    // DQS buffer rcomp pull-down Vref control setting
    // 
    // Bits[15:8], RW, default = 0x0
    //
    UINTX lcomp_pdn_dqs_vrefctrl : 8;
    //
    // DQ ODT rcomp pull-down Vref control setting
    // 
    // Bits[23:16], RW, default = 0x0
    //
    UINTX lcomp_pdn_dqodt_vrefctrl : 8;
    //
    // DQS ODT rcomp pull-down Vref control setting
    // 
    // Bits[31:24], RW, default = 0x0
    //
    UINTX lcomp_pdn_dqsodt_vrefctrl : 8;
  } Bits;
  UINTX Data;
} LCOMPCFG0_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define LCOMPCFG1_DDRDQ_PHY_REG                            0x00000020
#ifndef ASM_INC
typedef union {
  struct {
    //
    // DQ Delay c73ddr402_comp target configuring the Mux select signal
    // 
    // Bits[4:0], RW, default = 0x0
    //
    UINTX lcomp_dq_tapsel : 5;
    //
    // DQS Delay c73ddr402_comp target configuring the Mux select signal
    // 
    // Bits[9:5], RW, default = 0x0
    //
    UINTX lcomp_dqs_tapsel : 5;
    //
    // RCOMP PDN Static Bit Live Code.
    // 
    // Bits[12:10], RW, default = 0x7
    //
    UINTX lcomp_pdnrcompstaticlive : 3;
    //
    // Pull-up RCOMP code for driver static leg: Used for PDN Rcomp
    // 
    // Bits[15:13], RW, default = 0x7
    //
    UINTX lcomp_puprcompstatic : 3;
    //
    // DCOMP DFT pin to enable a static leg check for the delay cell.
    // 
    // Bits[16:16], RW, default = 0x1
    //
    UINTX lcomp_dlycellstaticlegen : 1;
    //
    // vrefrangesel
    // 
    // Bits[17:17], RW, default = 0x1
    //
    UINTX lcomp_vrefrangesel : 1;
    //
    // dfx legtest enable pin. Allows for independent control of the lower 4 legs of
    // the deley element which are controlled by the decoder. 1: enabled       0 : disbaled
    // (default) 
    // 
    // Bits[18:18], RW, default = 0x0
    //
    UINTX lcomp_pbddfxtesten : 1;
    //
    // new pin for testing each of the driver legs individually during per leg testing
    // mode. 
    // 
    // Bits[19:19], RW, default = 0x1
    //
    UINTX lcomp_drvseg0en : 1;
    //
    // RCOMP PDN DQS ODT Static Bit Live Code.
    // 
    // Bits[22:20], RW, default = 0x7
    //
    UINTX lcomp_pdnrcompdqsodtstaticlive : 3;
    //
    // Pull-up RCOMP code for DQS ODT static leg: Used for PDN Rcomp
    // 
    // Bits[25:23], RW, default = 0x7
    //
    UINTX lcomp_puprcompdqsodtstatic : 3;
    //
    // RCOMP PDN DQ ODT Static Bit Live Code.
    // 
    // Bits[28:26], RW, default = 0x7
    //
    UINTX lcomp_pdnrcompdqodtstaticlive : 3;
    //
    // Pull-up RCOMP code for DQ ODT static leg: Used for PDN Rcomp
    // 
    // Bits[31:29], RW, default = 0x7
    //
    UINTX lcomp_puprcompdqodtstatic : 3;
  } Bits;
  UINTX Data;
} LCOMPCFG1_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define DIGCTL_CMN_DDRDQ_PHY_REG                           0x00000024
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Ref2x divider counters async reset-bar. This is used to reset the flops of the
    // dividers counters. 
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINTX cmn_clkgenrst_b : 1;
    //
    // Reserved
    // 
    // Bits[31:1], RO, default = 0x0
    //
    UINTX reserved : 31;
  } Bits;
  UINTX Data;
} DIGCTL_CMN_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define COMP_RST_DDRDQ_PHY_REG                             0x00000028
#ifndef ASM_INC
typedef union {
  struct {
    //
    // c73ddr402_Comp unit reset-bar. Combined with PM reset control
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINTX comprst_b : 1;
    //
    // Reserved
    // 
    // Bits[31:1], RO, default = 0x0
    //
    UINTX reserved : 31;
  } Bits;
  UINTX Data;
} COMP_RST_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define SPIDCLK_CTRL1_DDRDQ_PHY_REG                        0x0000002C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // spidclk PLL selection
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINTX spidclk_pllsel : 1;
    //
    // Reserved
    // 
    // Bits[31:1], RO, default = 0x0
    //
    UINTX reserved : 31;
  } Bits;
  UINTX Data;
} SPIDCLK_CTRL1_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define DFXVISA_ULM0PATTGEN_DDRDQ_PHY_REG                  0x00000100
#ifndef ASM_INC
typedef union {
  struct {
    //
    // VISA Pattern Generation
    // 
    // Bits[3:0], RW, default = 0x0
    //
    UINTX dfxvisa_ulm0pattgen_lsb : 4;
    //
    // VISA Pattern Generation
    // 
    // Bits[6:4], RW, default = 0x0
    //
    UINTX dfxvisa_ulm0pattgen_msb : 3;
    //
    // Reserved
    // 
    // Bits[31:7], RO, default = 0x0
    //
    UINTX reserved : 25;
  } Bits;
  UINTX Data;
} DFXVISA_ULM0PATTGEN_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define DFXVISA_ULM0LN0_DDRDQ_PHY_REG                      0x00000104
#ifndef ASM_INC
typedef union {
  struct {
    //
    // VISA ULM0LN0 (DATA) Select
    // 
    // Bits[7:0], RW, default = 0x0
    //
    UINTX dfxvisa_ulm0ln0_datasel : 8;
    //
    // VISA ULM0LN0 CLK Select
    // 
    // Bits[15:8], RW, default = 0x0
    //
    UINTX dfxvisa_ulm0ln0_clksel : 8;
    //
    // VISA Bypass ULM0LN0
    // 
    // Bits[16:16], RW, default = 0x0
    //
    UINTX dfxvisa_ulm0ln0_bypass : 1;
    //
    // Reserved
    // 
    // Bits[31:17], RO, default = 0x0
    //
    UINTX reserved : 15;
  } Bits;
  UINTX Data;
} DFXVISA_ULM0LN0_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define DFXVISA_ULM0LN1_DDRDQ_PHY_REG                      0x00000108
#ifndef ASM_INC
typedef union {
  struct {
    //
    // VISA ULM0LN1 (DATA) Select
    // 
    // Bits[7:0], RW, default = 0x0
    //
    UINTX dfxvisa_ulm0ln1_datasel : 8;
    //
    // VISA ULM0LN1 CLK Select
    // 
    // Bits[15:8], RW, default = 0x0
    //
    UINTX dfxvisa_ulm0ln1_clksel : 8;
    //
    // VISA Bypass ULM0LN1
    // 
    // Bits[16:16], RW, default = 0x0
    //
    UINTX dfxvisa_ulm0ln1_bypass : 1;
    //
    // Reserved
    // 
    // Bits[31:17], RO, default = 0x0
    //
    UINTX reserved : 15;
  } Bits;
  UINTX Data;
} DFXVISA_ULM0LN1_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define DFXVISA_ULM1PATTGEN_DDRDQ_PHY_REG                  0x0000010C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // VISA Pattern Generation
    // 
    // Bits[3:0], RW, default = 0x0
    //
    UINTX dfxvisa_ulm1pattgen_lsb : 4;
    //
    // VISA Pattern Generation
    // 
    // Bits[6:4], RW, default = 0x0
    //
    UINTX dfxvisa_ulm1pattgen_msb : 3;
    //
    // Reserved
    // 
    // Bits[31:7], RO, default = 0x0
    //
    UINTX reserved : 25;
  } Bits;
  UINTX Data;
} DFXVISA_ULM1PATTGEN_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define DFXVISA_ULM1LN0_DDRDQ_PHY_REG                      0x00000110
#ifndef ASM_INC
typedef union {
  struct {
    //
    // VISA ULM1LN0 (DATA) Select
    // 
    // Bits[7:0], RW, default = 0x0
    //
    UINTX dfxvisa_ulm1ln0_datasel : 8;
    //
    // VISA ULM1LN0 CLK Select
    // 
    // Bits[15:8], RW, default = 0x0
    //
    UINTX dfxvisa_ulm1ln0_clksel : 8;
    //
    // VISA Bypass ULM1LN0
    // 
    // Bits[16:16], RW, default = 0x0
    //
    UINTX dfxvisa_ulm1ln0_bypass : 1;
    //
    // Reserved
    // 
    // Bits[31:17], RO, default = 0x0
    //
    UINTX reserved : 15;
  } Bits;
  UINTX Data;
} DFXVISA_ULM1LN0_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define DFXVISA_ULM1LN1_DDRDQ_PHY_REG                      0x00000114
#ifndef ASM_INC
typedef union {
  struct {
    //
    // VISA ULM1LN1 (DATA) Select
    // 
    // Bits[7:0], RW, default = 0x0
    //
    UINTX dfxvisa_ulm1ln1_datasel : 8;
    //
    // VISA ULM1LN1 CLK Select
    // 
    // Bits[15:8], RW, default = 0x0
    //
    UINTX dfxvisa_ulm1ln1_clksel : 8;
    //
    // VISA Bypass ULM1LN1
    // 
    // Bits[16:16], RW, default = 0x0
    //
    UINTX dfxvisa_ulm1ln1_bypass : 1;
    //
    // Reserved
    // 
    // Bits[31:17], RO, default = 0x0
    //
    UINTX reserved : 15;
  } Bits;
  UINTX Data;
} DFXVISA_ULM1LN1_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define DFXVISA_ULM2PATTGEN_DDRDQ_PHY_REG                  0x00000118
#ifndef ASM_INC
typedef union {
  struct {
    //
    // VISA Pattern Generation
    // 
    // Bits[3:0], RW, default = 0x0
    //
    UINTX dfxvisa_ulm2pattgen_lsb : 4;
    //
    // VISA Pattern Generation
    // 
    // Bits[6:4], RW, default = 0x0
    //
    UINTX dfxvisa_ulm2pattgen_msb : 3;
    //
    // Reserved
    // 
    // Bits[31:7], RO, default = 0x0
    //
    UINTX reserved : 25;
  } Bits;
  UINTX Data;
} DFXVISA_ULM2PATTGEN_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define DFXVISA_ULM2LN0_DDRDQ_PHY_REG                      0x0000011C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // VISA ULM2LN0 (DATA) Select
    // 
    // Bits[7:0], RW, default = 0x0
    //
    UINTX dfxvisa_ulm2ln0_datasel : 8;
    //
    // VISA ULM2LN0 CLK Select
    // 
    // Bits[15:8], RW, default = 0x0
    //
    UINTX dfxvisa_ulm2ln0_clksel : 8;
    //
    // VISA Bypass ULM2LN0
    // 
    // Bits[16:16], RW, default = 0x0
    //
    UINTX dfxvisa_ulm2ln0_bypass : 1;
    //
    // Reserved
    // 
    // Bits[31:17], RO, default = 0x0
    //
    UINTX reserved : 15;
  } Bits;
  UINTX Data;
} DFXVISA_ULM2LN0_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define DFXVISA_ULM2LN1_DDRDQ_PHY_REG                      0x00000120
#ifndef ASM_INC
typedef union {
  struct {
    //
    // VISA ULM2LN1 (DATA) Select
    // 
    // Bits[7:0], RW, default = 0x0
    //
    UINTX dfxvisa_ulm2ln1_datasel : 8;
    //
    // VISA ULM2LN1 CLK Select
    // 
    // Bits[15:8], RW, default = 0x0
    //
    UINTX dfxvisa_ulm2ln1_clksel : 8;
    //
    // VISA Bypass ULM2LN1
    // 
    // Bits[16:16], RW, default = 0x0
    //
    UINTX dfxvisa_ulm2ln1_bypass : 1;
    //
    // Reserved
    // 
    // Bits[31:17], RO, default = 0x0
    //
    UINTX reserved : 15;
  } Bits;
  UINTX Data;
} DFXVISA_ULM2LN1_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define DFXVISA_ULM3PATTGEN_DDRDQ_PHY_REG                  0x00000124
#ifndef ASM_INC
typedef union {
  struct {
    //
    // VISA Pattern Generation
    // 
    // Bits[3:0], RW, default = 0x0
    //
    UINTX dfxvisa_ulm3pattgen_lsb : 4;
    //
    // VISA Pattern Generation
    // 
    // Bits[6:4], RW, default = 0x0
    //
    UINTX dfxvisa_ulm3pattgen_msb : 3;
    //
    // Reserved
    // 
    // Bits[31:7], RO, default = 0x0
    //
    UINTX reserved : 25;
  } Bits;
  UINTX Data;
} DFXVISA_ULM3PATTGEN_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define DFXVISA_ULM3LN0_DDRDQ_PHY_REG                      0x00000128
#ifndef ASM_INC
typedef union {
  struct {
    //
    // VISA ULM3LN0 (DATA) Select
    // 
    // Bits[7:0], RW, default = 0x0
    //
    UINTX dfxvisa_ulm3ln0_datasel : 8;
    //
    // VISA ULM3LN0 CLK Select
    // 
    // Bits[15:8], RW, default = 0x0
    //
    UINTX dfxvisa_ulm3ln0_clksel : 8;
    //
    // VISA Bypass ULM3LN0
    // 
    // Bits[16:16], RW, default = 0x0
    //
    UINTX dfxvisa_ulm3ln0_bypass : 1;
    //
    // Reserved
    // 
    // Bits[31:17], RO, default = 0x0
    //
    UINTX reserved : 15;
  } Bits;
  UINTX Data;
} DFXVISA_ULM3LN0_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define DFXVISA_ULM3LN1_DDRDQ_PHY_REG                      0x0000012C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // VISA ULM3LN1 (DATA) Select
    // 
    // Bits[7:0], RW, default = 0x0
    //
    UINTX dfxvisa_ulm3ln1_datasel : 8;
    //
    // VISA ULM3LN1 CLK Select
    // 
    // Bits[15:8], RW, default = 0x0
    //
    UINTX dfxvisa_ulm3ln1_clksel : 8;
    //
    // VISA Bypass ULM3LN1
    // 
    // Bits[16:16], RW, default = 0x0
    //
    UINTX dfxvisa_ulm3ln1_bypass : 1;
    //
    // Reserved
    // 
    // Bits[31:17], RO, default = 0x0
    //
    UINTX reserved : 15;
  } Bits;
  UINTX Data;
} DFXVISA_ULM3LN1_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define DFXVISA_ULM4PATTGEN_DDRDQ_PHY_REG                  0x00000130
#ifndef ASM_INC
typedef union {
  struct {
    //
    // VISA Pattern Generation
    // 
    // Bits[3:0], RW, default = 0x0
    //
    UINTX dfxvisa_ulm4pattgen_lsb : 4;
    //
    // VISA Pattern Generation
    // 
    // Bits[6:4], RW, default = 0x0
    //
    UINTX dfxvisa_ulm4pattgen_msb : 3;
    //
    // Reserved
    // 
    // Bits[31:7], RO, default = 0x0
    //
    UINTX reserved : 25;
  } Bits;
  UINTX Data;
} DFXVISA_ULM4PATTGEN_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define DFXVISA_ULM4LN0_DDRDQ_PHY_REG                      0x00000134
#ifndef ASM_INC
typedef union {
  struct {
    //
    // VISA ULM4LN0 (DATA) Select
    // 
    // Bits[7:0], RW, default = 0x0
    //
    UINTX dfxvisa_ulm4ln0_datasel : 8;
    //
    // VISA ULM4LN0 CLK Select
    // 
    // Bits[15:8], RW, default = 0x0
    //
    UINTX dfxvisa_ulm4ln0_clksel : 8;
    //
    // VISA Bypass ULM4LN0
    // 
    // Bits[16:16], RW, default = 0x0
    //
    UINTX dfxvisa_ulm4ln0_bypass : 1;
    //
    // Reserved
    // 
    // Bits[31:17], RO, default = 0x0
    //
    UINTX reserved : 15;
  } Bits;
  UINTX Data;
} DFXVISA_ULM4LN0_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define DFXVISA_ULM4LN1_DDRDQ_PHY_REG                      0x00000138
#ifndef ASM_INC
typedef union {
  struct {
    //
    // VISA ULM4LN1 (DATA) Select
    // 
    // Bits[7:0], RW, default = 0x0
    //
    UINTX dfxvisa_ulm4ln1_datasel : 8;
    //
    // VISA ULM4LN1 CLK Select
    // 
    // Bits[15:8], RW, default = 0x0
    //
    UINTX dfxvisa_ulm4ln1_clksel : 8;
    //
    // VISA Bypass ULM4LN1
    // 
    // Bits[16:16], RW, default = 0x0
    //
    UINTX dfxvisa_ulm4ln1_bypass : 1;
    //
    // Reserved
    // 
    // Bits[31:17], RO, default = 0x0
    //
    UINTX reserved : 15;
  } Bits;
  UINTX Data;
} DFXVISA_ULM4LN1_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define MON0CFG_DDRDQ_PHY_REG                              0x0000013C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // master enable for both anamux0 and anamux1 in all ckebb cells. 1 = anamux0 and
    // anamux1 can be used. 0 = anamux0 and anamux1 disabled reguardless of any other
    // programming 
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINTX mon0_anaen : 1;
    //
    // mon port analog mux 0 enable
    // 
    // Bits[1:1], RW, default = 0x0
    //
    UINTX mon0_anaobs0en : 1;
    //
    // code for mon port analog mux 0
    // 
    // Bits[4:2], RW, default = 0x0
    //
    UINTX mon0_anaobs0sel : 3;
    //
    // mon port analog mux 1 enable
    // 
    // Bits[5:5], RW, default = 0x0
    //
    UINTX mon0_anaobs1en : 1;
    //
    // code for mon port analog mux 1
    // 
    // Bits[8:6], RW, default = 0x0
    //
    UINTX mon0_anaobs1sel : 3;
    //
    // mon port comparator input switch
    // 
    // Bits[9:9], RW, default = 0x0
    //
    UINTX mon0_compswitch : 1;
    //
    // code for mon port digital mux 0
    // 
    // Bits[14:10], RW, default = 0x0
    //
    UINTX mon0_digobs0sel : 5;
    //
    // code for mon port digital mux 1
    // 
    // Bits[19:15], RW, default = 0x0
    //
    UINTX mon0_digobs1sel : 5;
    //
    // code for mon port vref for comparator
    // 
    // Bits[25:20], RW, default = 0x0
    //
    UINTX mon0_vrefctrl : 6;
    //
    // mon port vref and comparator enable
    // 
    // Bits[26:26], RW, default = 0x0
    //
    UINTX mon0_vrefen : 1;
    //
    // mon port comparator output 0 to digital register (region 0)
    // 
    // Bits[27:27], RO/V, default = 0x0
    //
    UINTX mon0_compout0 : 1;
    //
    // mon port comparator output 1 to digital register (region 0)
    // 
    // Bits[28:28], RO/V, default = 0x0
    //
    UINTX mon0_compout1 : 1;
    //
    // Reserved
    // 
    // Bits[31:29], RO, default = 0x0
    //
    UINTX reserved : 3;
  } Bits;
  UINTX Data;
} MON0CFG_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define MON1CFG_DDRDQ_PHY_REG                              0x00000140
#ifndef ASM_INC
typedef union {
  struct {
    //
    // master enable for both anamux0 and anamux1 in all ckebb cells. 1 = anamux0 and
    // anamux1 can be used. 0 = anamux0 and anamux1 disabled reguardless of any other
    // programming 
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINTX mon1_anaen : 1;
    //
    // mon port analog mux 0 enable
    // 
    // Bits[1:1], RW, default = 0x0
    //
    UINTX mon1_anaobs0en : 1;
    //
    // code for mon port analog mux 0
    // 
    // Bits[4:2], RW, default = 0x0
    //
    UINTX mon1_anaobs0sel : 3;
    //
    // mon port analog mux 1 enable
    // 
    // Bits[5:5], RW, default = 0x0
    //
    UINTX mon1_anaobs1en : 1;
    //
    // code for mon port analog mux 1
    // 
    // Bits[8:6], RW, default = 0x0
    //
    UINTX mon1_anaobs1sel : 3;
    //
    // mon port comparator input switch
    // 
    // Bits[9:9], RW, default = 0x0
    //
    UINTX mon1_compswitch : 1;
    //
    // code for mon port digital mux 0
    // 
    // Bits[14:10], RW, default = 0x0
    //
    UINTX mon1_digobs0sel : 5;
    //
    // code for mon port digital mux 1
    // 
    // Bits[19:15], RW, default = 0x0
    //
    UINTX mon1_digobs1sel : 5;
    //
    // code for mon port vref for comparator
    // 
    // Bits[25:20], RW, default = 0x0
    //
    UINTX mon1_vrefctrl : 6;
    //
    // mon port vref and comparator enable
    // 
    // Bits[26:26], RW, default = 0x0
    //
    UINTX mon1_vrefen : 1;
    //
    // mon port comparator output 0 to digital register (region 1)
    // 
    // Bits[27:27], RO/V, default = 0x0
    //
    UINTX mon1_compout0 : 1;
    //
    // mon port comparator output 1 to digital register (region 1)
    // 
    // Bits[28:28], RO/V, default = 0x0
    //
    UINTX mon1_compout1 : 1;
    //
    // Reserved
    // 
    // Bits[31:29], RO, default = 0x0
    //
    UINTX reserved : 3;
  } Bits;
  UINTX Data;
} MON1CFG_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define DIGCTL_BL0_DDRDQ_PHY_REG                           0x00000180
#ifndef ASM_INC
typedef union {
  struct {
    //
    // SPID clock clock domain reset-bar. Combined with PM reset control
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINTX b0_spidrst_b : 1;
    //
    // RX FIFO reset-bar. Combined with PM reset control
    // 
    // Bits[1:1], RW, default = 0x0
    //
    UINTX b0_rxfiforst_b : 1;
    //
    // Reserved
    // 
    // Bits[4:2], RO, default = 0x0
    //
    UINTX reserved : 3;
    //
    // CC1 I/O buffer activate: Reset for final TX flops in CC1 upartition.[br]Tristates
    // IO buffers.[br]Disable Rx sections of IO buffers.[br]0 = reset , 1 = out of reset
    // 
    // Bits[5:5], RW, default = 0x0
    //
    UINTX b0_iobufact : 1;
    //
    // Multi Cycle Path Control. 0 = NO Pipelining, 1 = Pipelining (1 Stage)
    // 
    // Bits[6:6], RW, default = 0x0
    //
    UINTX b0_rdmcpsel : 1;
    //
    // Reserved
    // 
    // Bits[8:7], RO, default = 0x0
    //
    UINTX reserved_1 : 2;
    //
    // Reserved
    // 
    // Bits[10:9], RO, default = 0x0
    //
    UINTX reserved_2 : 2;
    //
    // Write Leveling Enable: 0 = Write Leveling off (normal mode). 1 - Write Leveling
    // on (training) 
    // 
    // Bits[11:11], RW, default = 0x0
    //
    UINTX b0_wrlvl : 1;
    //
    // Reserved
    // 
    // Bits[12:12], RO, default = 0x0
    //
    UINTX reserved_3 : 1;
    //
    // HVM read test stretch mode:[br]00: normal read[br]01: x4 stretch mode[br]10: x8
    // stretch mode[br]11: x16 stretch mode 
    // 
    // Bits[14:13], RW, default = 0x0
    //
    UINTX b0_stretchmode : 2;
    //
    // Reserved
    // 
    // Bits[15:15], RO, default = 0x0
    //
    UINTX reserved_4 : 1;
    //
    // Reserved
    // 
    // Bits[16:16], RO, default = 0x0
    //
    UINTX reserved_5 : 1;
    //
    // Reserved
    // 
    // Bits[17:17], RO, default = 0x0
    //
    UINTX reserved_6 : 1;
    //
    // 1 = Enable TX equalization: on-the-fly eqenb generation from dqdata and dqdrvenb.
    // 0 = Disable TX equalization, eqenb = 1 
    // 
    // Bits[18:18], RW, default = 0x0
    //
    UINTX b0_txdqequalizer_en : 1;
    //
    // Enable early data. 1: the data will be enable 2 2xclk early. Two early data will
    // be the same as the first actual valid data burst (UI0). 
    // 
    // Bits[19:19], RW, default = 0x0
    //
    UINTX b0_early_dqen : 1;
    //
    // Reserved
    // 
    // Bits[31:20], RO, default = 0x0
    //
    UINTX reserved_7 : 12;
  } Bits;
  UINTX Data;
} DIGCTL_BL0_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define PTROFFSET_B0N0_DDRDQ_PHY_REG                       0x00000184
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Initial offset for DQ 2x clock read pointers
    // 
    // Bits[4:0], RW, default = 0x0
    //
    UINTX b0n0_dq_ref2xrdptrinit : 5;
    //
    // Initial offset for 1x clock read pointers
    // 
    // Bits[7:5], RW, default = 0x0
    //
    UINTX b0n0_ref1xrdptrinit : 3;
    //
    // SPID to 1x clock FIFO read pointer offset
    // 
    // Bits[10:8], RW, default = 0x0
    //
    UINTX b0n0_ref1xrdptroffset : 3;
    //
    // Initial offset for  DQ Drive, DQS, rcven, diffampen, rxodten, rxodtseg 2x clock
    // read pointers 
    // 
    // Bits[14:11], RW, default = 0x0
    //
    UINTX b0n0_others_ref2xrdptrinit : 4;
    //
    // Reserved
    // 
    // Bits[31:15], RO, default = 0x0
    //
    UINTX reserved : 17;
  } Bits;
  UINTX Data;
} PTROFFSET_B0N0_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define PTROFFSET_B0N1_DDRDQ_PHY_REG                       0x00000188
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Initial offset for DQ 2x clock read pointers
    // 
    // Bits[4:0], RW, default = 0x0
    //
    UINTX b0n1_dq_ref2xrdptrinit : 5;
    //
    // Initial offset for  DQ Drive, DQS, rcven, diffampen, rxodten, rxodtseg 2x clock
    // read pointers 
    // 
    // Bits[8:5], RW, default = 0x0
    //
    UINTX b0n1_others_ref2xrdptrinit : 4;
    //
    // Reserved
    // 
    // Bits[31:9], RO, default = 0x0
    //
    UINTX reserved : 23;
  } Bits;
  UINTX Data;
} PTROFFSET_B0N1_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define DQSMUX_BL0_DDRDQ_PHY_REG                           0x0000018C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // DQS rank 0 nibble 0 dqs/dqsb source select. 0 = RXFIFO nibble 0 from AFE nibble
    // 0. 1 = RXFIFO nibble 0 from AFE nibble 1 
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINTX b0n0_rk0rxdqsmuxsel : 1;
    //
    // DQS rank 1 nibble 0 dqs/dqsb source select. 0 = RXFIFO nibble 0 from AFE nibble
    // 0. 1 = RXFIFO nibble 0 from AFE nibble 1 
    // 
    // Bits[1:1], RW, default = 0x0
    //
    UINTX b0n0_rk1rxdqsmuxsel : 1;
    //
    // DQS rank 2 nibble 0 dqs/dqsb source select. 0 = RXFIFO nibble 0 from AFE nibble
    // 0. 1 = RXFIFO nibble 0 from AFE nibble 1 
    // 
    // Bits[2:2], RW, default = 0x0
    //
    UINTX b0n0_rk2rxdqsmuxsel : 1;
    //
    // DQS rank 3 nibble 0 dqs/dqsb source select. 0 = RXFIFO nibble 0 from AFE nibble
    // 0. 1 = RXFIFO nibble 0 from AFE nibble 1 
    // 
    // Bits[3:3], RW, default = 0x0
    //
    UINTX b0n0_rk3rxdqsmuxsel : 1;
    //
    // DQS rank 0 nibble 1 dqs/dqsb source select. 0 = RXFIFO nibble 1 from AFE nibble
    // 0. 1 = RXFIFO nibble 1 from AFE nibble 1 
    // 
    // Bits[4:4], RW, default = 0x0
    //
    UINTX b0n1_rk0rxdqsmuxsel : 1;
    //
    // DQS rank 1 nibble 1 dqs/dqsb source select. 0 = RXFIFO nibble 1 from AFE nibble
    // 0. 1 = RXFIFO nibble 1 from AFE nibble 1 
    // 
    // Bits[5:5], RW, default = 0x0
    //
    UINTX b0n1_rk1rxdqsmuxsel : 1;
    //
    // DQS rank 2 nibble 1 dqs/dqsb source select. 0 = RXFIFO nibble 1 from AFE nibble
    // 0. 1 = RXFIFO nibble 1 from AFE nibble 1 
    // 
    // Bits[6:6], RW, default = 0x0
    //
    UINTX b0n1_rk2rxdqsmuxsel : 1;
    //
    // DQS rank 3 nibble 1 dqs/dqsb source select. 0 = RXFIFO nibble 1 from AFE nibble
    // 0. 1 = RXFIFO nibble 1 from AFE nibble 1 
    // 
    // Bits[7:7], RW, default = 0x0
    //
    UINTX b0n1_rk3rxdqsmuxsel : 1;
    //
    // Reserved
    // 
    // Bits[31:8], RO, default = 0x0
    //
    UINTX reserved : 24;
  } Bits;
  UINTX Data;
} DQSMUX_BL0_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define DQSFSM_B0N0_DDRDQ_PHY_REG                          0x00000190
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Latency from write command to start of DQS generation FSM (in 1x cycles)
    // 
    // Bits[4:0], RW, default = 0x0
    //
    UINTX b0n0_wrcmd2dqsstart : 5;
    //
    // 1 = Enable the two-cycle write Pre-amable. If set to  1, both Pre-am0 and Pre-am1
    // will  be used. 
    // 
    // Bits[5:5], RW, default = 0x0
    //
    UINTX b0n0_wrpream0en : 1;
    //
    // DQS Generation Mode - Pream0 Phase[br]00 - Fall & Rise - Low & Low[br]01 - Fall
    // & Rise - Low & High[br]10 -  Fall & Rise - High & Low[br]11 -  Fall & Rise - High
    // & High 
    // 
    // Bits[7:6], RW, default = 0x0
    //
    UINTX b0n0_dqspream0 : 2;
    //
    // DQS Generation Mode - Pream1 Phase[br]00 - Fall & Rise - Low & Low[br]01 - Fall
    // & Rise - Low & High[br]10 -  Fall & Rise - High & Low[br]11 -  Fall & Rise - High
    // & High 
    // 
    // Bits[9:8], RW, default = 0x0
    //
    UINTX b0n0_dqspream1 : 2;
    //
    // DQS Generation Mode - Phase 1[br]00 - Fall & Rise - Low & Low[br]01 - Fall & Rise
    // - Low & High[br]10 -  Fall & Rise - High & Low[br]11 -  Fall & Rise - High & High
    // 
    // Bits[11:10], RW, default = 0x0
    //
    UINTX b0n0_dqsph1 : 2;
    //
    // DQS Generation Mode - Last Phase[br]00 - Fall & Rise - Low & Low[br]01 - Fall
    // & Rise - Low & High[br]10 -  Fall & Rise - High & Low[br]11 -  Fall & Rise - High
    // & High 
    // 
    // Bits[13:12], RW, default = 0x0
    //
    UINTX b0n0_dqslastph : 2;
    //
    // Reserved
    // 
    // Bits[15:14], RO, default = 0x0
    //
    UINTX reserved : 2;
    //
    // Reserved
    // 
    // Bits[31:16], RO, default = 0x0
    //
    UINTX reserved_1 : 16;
  } Bits;
  UINTX Data;
} DQSFSM_B0N0_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define DQSFSM_B0N1_DDRDQ_PHY_REG                          0x00000194
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Latency from write command to start of DQS generation FSM (in 1x cycles)
    // 
    // Bits[4:0], RW, default = 0x0
    //
    UINTX b0n1_wrcmd2dqsstart : 5;
    //
    // 1 = Enable the two-cycle write Pre-amable. If set to  1, both Pre-am0 and Pre-am1
    // will  be used. 
    // 
    // Bits[5:5], RW, default = 0x0
    //
    UINTX b0n1_wrpream0en : 1;
    //
    // DQS Generation Mode - Pream0 Phase[br]00 - Fall & Rise - Low & Low[br]01 - Fall
    // & Rise - Low & High[br]10 -  Fall & Rise - High & Low[br]11 -  Fall & Rise - High
    // & High 
    // 
    // Bits[7:6], RW, default = 0x0
    //
    UINTX b0n1_dqspream0 : 2;
    //
    // DQS Generation Mode - Pream1 Phase[br]00 - Fall & Rise - Low & Low[br]01 - Fall
    // & Rise - Low & High[br]10 -  Fall & Rise - High & Low[br]11 -  Fall & Rise - High
    // & High 
    // 
    // Bits[9:8], RW, default = 0x0
    //
    UINTX b0n1_dqspream1 : 2;
    //
    // DQS Generation Mode - Phase 1[br]00 - Fall & Rise - Low & Low[br]01 - Fall & Rise
    // - Low & High[br]10 -  Fall & Rise - High & Low[br]11 -  Fall & Rise - High & High
    // 
    // Bits[11:10], RW, default = 0x0
    //
    UINTX b0n1_dqsph1 : 2;
    //
    // DQS Generation Mode - Last Phase[br]00 - Fall & Rise - Low & Low[br]01 - Fall
    // & Rise - Low & High[br]10 -  Fall & Rise - High & Low[br]11 -  Fall & Rise - High
    // & High 
    // 
    // Bits[13:12], RW, default = 0x0
    //
    UINTX b0n1_dqslastph : 2;
    //
    // Reserved
    // 
    // Bits[15:14], RO, default = 0x0
    //
    UINTX reserved : 2;
    //
    // Reserved
    // 
    // Bits[31:16], RO, default = 0x0
    //
    UINTX reserved_1 : 16;
  } Bits;
  UINTX Data;
} DQSFSM_B0N1_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define DRVENBCTL_B0N0_DDRDQ_PHY_REG                       0x00000198
#ifndef ASM_INC
typedef union {
  struct {
    //
    // DQ Drive Enable - Preamble0 Phase[br]00 - Rise & Fall - Low & Low[br]01 - Rise
    // & Fall - High & Low[br]10 - Rise & Fall - Low & High[br]11 - Rise & Fall - High
    // & High 
    // 
    // Bits[1:0], RW, default = 0x0
    //
    UINTX b0n0_dqdrvenbpream0 : 2;
    //
    // DQ Drive Enable - Preamble1 Phase[br]00 - Rise & Fall - Low & Low[br]01 - Rise
    // & Fall - High & Low[br]10 - Rise & Fall - Low & High[br]11 - Rise & Fall - High
    // & High 
    // 
    // Bits[3:2], RW, default = 0x0
    //
    UINTX b0n0_dqdrvenbpream1 : 2;
    //
    // DQ Drive Enable - Phase 1[br]00 - Rise & Fall - Low & Low[br]01 - Rise & Fall
    // - High & Low[br]10 - Rise & Fall - Low & High[br]11 - Rise & Fall - High & High
    // 
    // Bits[5:4], RW, default = 0x0
    //
    UINTX b0n0_dqdrvenbph1 : 2;
    //
    // DQ Drive Enable - Last Phase[br]00 - Rise & Fall - Low & Low[br]01 - Rise & Fall
    // - High & Low[br]10 - Rise & Fall - Low & High[br]11 - Rise & Fall - High & High
    // 
    // Bits[7:6], RW, default = 0x0
    //
    UINTX b0n0_dqdrvenblastph : 2;
    //
    // Reserved
    // 
    // Bits[9:8], RO, default = 0x0
    //
    UINTX reserved : 2;
    //
    // DQS Drive Enable - Preamble0 Phase[br]00 - Rise & Fall - Low & Low[br]01 - Rise
    // & Fall - High & Low[br]10 - Rise & Fall - Low & High[br]11 - Rise & Fall - High
    // & High 
    // 
    // Bits[11:10], RW, default = 0x0
    //
    UINTX b0n0_dqsdrvenbpream0 : 2;
    //
    // DQS Drive Enable - Preamble1 Phase[br]00 - Rise & Fall - Low & Low[br]01 - Rise
    // & Fall - High & Low[br]10 - Rise & Fall - Low & High[br]11 - Rise & Fall - High
    // & High 
    // 
    // Bits[13:12], RW, default = 0x0
    //
    UINTX b0n0_dqsdrvenbpream1 : 2;
    //
    // DQS Drive Enable - Phase 1[br]00 - Rise & Fall - Low & Low[br]01 - Rise & Fall
    // - High & Low[br]10 - Rise & Fall - Low & High[br]11 - Rise & Fall - High & High
    // 
    // Bits[15:14], RW, default = 0x0
    //
    UINTX b0n0_dqsdrvenbph1 : 2;
    //
    // DQS Drive Enable - Last Phase[br]00 - Rise & Fall - Low & Low[br]01 - Rise & Fall
    // - High & Low[br]10 - Rise & Fall - Low & High[br]11 - Rise & Fall - High & High
    // 
    // Bits[17:16], RW, default = 0x0
    //
    UINTX b0n0_dqsdrvenblastph : 2;
    //
    // Reserved
    // 
    // Bits[19:18], RO, default = 0x0
    //
    UINTX reserved_1 : 2;
    //
    // DQS Drive Enable - IDLE State (used for write leveling)[br]00 - Rise & Fall -
    // Low & Low[br]01 - Rise & Fall - High & Low[br]10 - Rise & Fall - Low & High[br]11
    // - Rise & Fall - High & High 
    // 
    // Bits[21:20], RW, default = 0x3
    //
    UINTX b0n0_dqsdrvenbidle : 2;
    //
    // Reserved
    // 
    // Bits[31:22], RO, default = 0x0
    //
    UINTX reserved_2 : 10;
  } Bits;
  UINTX Data;
} DRVENBCTL_B0N0_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define DRVENBCTL_B0N1_DDRDQ_PHY_REG                       0x0000019C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // DQ Drive Enable - Preamble0 Phase[br]00 - Rise & Fall - Low & Low[br]01 - Rise
    // & Fall - High & Low[br]10 - Rise & Fall - Low & High[br]11 - Rise & Fall - High
    // & High 
    // 
    // Bits[1:0], RW, default = 0x0
    //
    UINTX b0n1_dqdrvenbpream0 : 2;
    //
    // DQ Drive Enable - Preamble1 Phase[br]00 - Rise & Fall - Low & Low[br]01 - Rise
    // & Fall - High & Low[br]10 - Rise & Fall - Low & High[br]11 - Rise & Fall - High
    // & High 
    // 
    // Bits[3:2], RW, default = 0x0
    //
    UINTX b0n1_dqdrvenbpream1 : 2;
    //
    // DQ Drive Enable - Phase 1[br]00 - Rise & Fall - Low & Low[br]01 - Rise & Fall
    // - High & Low[br]10 - Rise & Fall - Low & High[br]11 - Rise & Fall - High & High
    // 
    // Bits[5:4], RW, default = 0x0
    //
    UINTX b0n1_dqdrvenbph1 : 2;
    //
    // DQ Drive Enable - Last Phase[br]00 - Rise & Fall - Low & Low[br]01 - Rise & Fall
    // - High & Low[br]10 - Rise & Fall - Low & High[br]11 - Rise & Fall - High & High
    // 
    // Bits[7:6], RW, default = 0x0
    //
    UINTX b0n1_dqdrvenblastph : 2;
    //
    // Reserved
    // 
    // Bits[9:8], RO, default = 0x0
    //
    UINTX reserved : 2;
    //
    // DQS Drive Enable - Preamble0 Phase[br]00 - Rise & Fall - Low & Low[br]01 - Rise
    // & Fall - High & Low[br]10 - Rise & Fall - Low & High[br]11 - Rise & Fall - High
    // & High 
    // 
    // Bits[11:10], RW, default = 0x0
    //
    UINTX b0n1_dqsdrvenbpream0 : 2;
    //
    // DQS Drive Enable - Preamble1 Phase[br]00 - Rise & Fall - Low & Low[br]01 - Rise
    // & Fall - High & Low[br]10 - Rise & Fall - Low & High[br]11 - Rise & Fall - High
    // & High 
    // 
    // Bits[13:12], RW, default = 0x0
    //
    UINTX b0n1_dqsdrvenbpream1 : 2;
    //
    // DQS Drive Enable - Phase 1[br]00 - Rise & Fall - Low & Low[br]01 - Rise & Fall
    // - High & Low[br]10 - Rise & Fall - Low & High[br]11 - Rise & Fall - High & High
    // 
    // Bits[15:14], RW, default = 0x0
    //
    UINTX b0n1_dqsdrvenbph1 : 2;
    //
    // DQS Drive Enable - Last Phase[br]00 - Rise & Fall - Low & Low[br]01 - Rise & Fall
    // - High & Low[br]10 - Rise & Fall - Low & High[br]11 - Rise & Fall - High & High
    // 
    // Bits[17:16], RW, default = 0x0
    //
    UINTX b0n1_dqsdrvenblastph : 2;
    //
    // Reserved
    // 
    // Bits[19:18], RO, default = 0x0
    //
    UINTX reserved_1 : 2;
    //
    // DQS Drive Enable - CRC Phase[br]00 - Rise & Fall - Low & Low[br]01 - Rise & Fall
    // - High & Low[br]10 - Rise & Fall - Low & High[br]11 - Rise & Fall - High & High
    // 
    // Bits[21:20], RW, default = 0x3
    //
    UINTX b0n1_dqsdrvenbidle : 2;
    //
    // Reserved
    // 
    // Bits[31:22], RO, default = 0x0
    //
    UINTX reserved_2 : 10;
  } Bits;
  UINTX Data;
} DRVENBCTL_B0N1_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define RDVLDCTL_BL0_DDRDQ_PHY_REG                         0x000001A0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Latency from read command to start of ospid_rddata_valid generation (in spidclk
    // cycles) 
    // 
    // Bits[4:0], RW, default = 0x0
    //
    UINTX b0_rdcmd2rdvld : 5;
    //
    // rdcmd can launch in phase 0 or phase1. The calculation of rdcmd2rdvalid is based
    // on RL + BL4/2 + dqs_pushout + setup from RX fifo output to spidclk flop. This
    // calculation after round up will get extra time if rdcmd launch from phase1. Hence
    // adding this bit to preciced re-adjust the performance. 
    // 
    // Bits[5:5], RW, default = 0x0
    //
    UINTX b0_rdcmd2rdvld_plus1sel : 1;
    //
    // Early Read Valid setting:[br]0 - No Early Read Valid Generation[br]1 - 1 spidclk
    // early valid[br]2 - 2 spidclks early valid[br]3 - 3 spidclks early valid[br]4 -
    // 4 spidclks early valid    [br]>4 - Illegal 
    // 
    // Bits[8:6], RW, default = 0x0
    //
    UINTX b0_earlyrdvld : 3;
    //
    // Reserved
    // 
    // Bits[31:9], RO, default = 0x0
    //
    UINTX reserved : 23;
  } Bits;
  UINTX Data;
} RDVLDCTL_BL0_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define RCVENCTL_B0N0_DDRDQ_PHY_REG                        0x000001A4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Latency from read command to start of receive enable generation FSM (in 1x cycles)
    // 
    // Bits[4:0], RW, default = 0x0
    //
    UINTX b0n0_rdcmd2rcven : 5;
    //
    // Receive Enable - Preamble0 Phase[br]00 - Rise & Fall - Low & Low[br]01 - Rise
    // & Fall - High & Low[br]10 - Rise & Fall - Low & High[br]11 - Rise & Fall - High
    // & High 
    // 
    // Bits[6:5], RW, default = 0x0
    //
    UINTX b0n0_rcvenpre0 : 2;
    //
    // Receive Enable - Postamble0 Phase[br]00 - Rise & Fall - Low & Low[br]01 - Rise
    // & Fall - High & Low[br]10 - Rise & Fall - Low & High[br]11 - Rise & Fall - High
    // & High 
    // 
    // Bits[8:7], RW, default = 0x0
    //
    UINTX b0n0_rcvenpst0 : 2;
    //
    // Receive Enable - Preamble1 Phase[br]00 - Rise & Fall - Low & Low[br]01 - Rise
    // & Fall - High & Low[br]10 - Rise & Fall - Low & High[br]11 - Rise & Fall - High
    // & High 
    // 
    // Bits[10:9], RW, default = 0x0
    //
    UINTX b0n0_rcvenpre1 : 2;
    //
    // Receive Enable - Postamble1 Phase[br]00 - Rise & Fall - Low & Low[br]01 - Rise
    // & Fall - High & Low[br]10 - Rise & Fall - Low & High[br]11 - Rise & Fall - High
    // & High 
    // 
    // Bits[12:11], RW, default = 0x0
    //
    UINTX b0n0_rcvenpst1 : 2;
    //
    // Receive Enable Length in number of 1x clocks (for a burst length of 4). Burst
    // length 8 is 2 of these. 
    // 
    // Bits[18:13], RW, default = 0x0
    //
    UINTX b0n0_rcvenlenbl4 : 6;
    //
    // Receive Enable override enable. 1 = use override value. 0 = use receive enable
    // from FIFO logic 
    // 
    // Bits[19:19], RW, default = 0x0
    //
    UINTX b0n0_rcven_ovr : 1;
    //
    // Receive Enable override value
    // 
    // Bits[20:20], RW, default = 0x0
    //
    UINTX b0n0_rcven_val : 1;
    //
    // Reserved
    // 
    // Bits[31:21], RO, default = 0x0
    //
    UINTX reserved : 11;
  } Bits;
  UINTX Data;
} RCVENCTL_B0N0_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define RCVENCTL_B0N1_DDRDQ_PHY_REG                        0x000001A8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Latency from read command to start of receive enable generation FSM (in 1x cycles)
    // 
    // Bits[4:0], RW, default = 0x0
    //
    UINTX b0n1_rdcmd2rcven : 5;
    //
    // Receive Enable - Preamble0 Phase[br]00 - Rise & Fall - Low & Low[br]01 - Rise
    // & Fall - High & Low[br]10 - Rise & Fall - Low & High[br]11 - Rise & Fall - High
    // & High 
    // 
    // Bits[6:5], RW, default = 0x0
    //
    UINTX b0n1_rcvenpre0 : 2;
    //
    // Receive Enable - Postamble0 Phase[br]00 - Rise & Fall - Low & Low[br]01 - Rise
    // & Fall - High & Low[br]10 - Rise & Fall - Low & High[br]11 - Rise & Fall - High
    // & High 
    // 
    // Bits[8:7], RW, default = 0x0
    //
    UINTX b0n1_rcvenpst0 : 2;
    //
    // Receive Enable - Preamble1 Phase[br]00 - Rise & Fall - Low & Low[br]01 - Rise
    // & Fall - High & Low[br]10 - Rise & Fall - Low & High[br]11 - Rise & Fall - High
    // & High 
    // 
    // Bits[10:9], RW, default = 0x0
    //
    UINTX b0n1_rcvenpre1 : 2;
    //
    // Receive Enable - Postamble1 Phase[br]00 - Rise & Fall - Low & Low[br]01 - Rise
    // & Fall - High & Low[br]10 - Rise & Fall - Low & High[br]11 - Rise & Fall - High
    // & High 
    // 
    // Bits[12:11], RW, default = 0x0
    //
    UINTX b0n1_rcvenpst1 : 2;
    //
    // Receive Enable Length in number of 1x clocks (for a burst length of 4). Burst
    // length 8 is 2 of these. 
    // 
    // Bits[18:13], RW, default = 0x0
    //
    UINTX b0n1_rcvenlenbl4 : 6;
    //
    // Receive Enable override enable. 1 = use override value. 0 = use receive enable
    // from FIFO logic 
    // 
    // Bits[19:19], RW, default = 0x0
    //
    UINTX b0n1_rcven_ovr : 1;
    //
    // Receive Enable override value
    // 
    // Bits[20:20], RW, default = 0x0
    //
    UINTX b0n1_rcven_val : 1;
    //
    // Reserved
    // 
    // Bits[31:21], RO, default = 0x0
    //
    UINTX reserved : 11;
  } Bits;
  UINTX Data;
} RCVENCTL_B0N1_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define DIFFAMPCTL_BL0_DDRDQ_PHY_REG                       0x000001AC
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Latency from read command to start of diffamp enable generation (in 1x cycles)
    // 
    // Bits[4:0], RW, default = 0x0
    //
    UINTX b0_rdcmd2diffampen : 5;
    //
    // Reserved
    // 
    // Bits[10:5], RO, default = 0x0
    //
    UINTX reserved : 6;
    //
    // Diffamp Enable - Preamble0 Phase[br]00 - Rise & Fall - Low & Low[br]01 - Rise
    // & Fall - High & Low[br]10 - Rise & Fall - Low & High[br]11 - Rise & Fall - High
    // & High 
    // 
    // Bits[12:11], RW, default = 0x0
    //
    UINTX b0_diffampenpre0 : 2;
    //
    // Diffamp Enable - Postamble0 Phase[br]00 - Rise & Fall - Low & Low[br]01 - Rise
    // & Fall - High & Low[br]10 - Rise & Fall - Low & High[br]11 - Rise & Fall - High
    // & High 
    // 
    // Bits[14:13], RW, default = 0x0
    //
    UINTX b0_diffampenpst0 : 2;
    //
    // Diffamp Enable - Preamble1 Phase[br]00 - Rise & Fall - Low & Low[br]01 - Rise
    // & Fall - High & Low[br]10 - Rise & Fall - Low & High[br]11 - Rise & Fall - High
    // & High 
    // 
    // Bits[16:15], RW, default = 0x0
    //
    UINTX b0_diffampenpre1 : 2;
    //
    // Diffamp Enable - Postamble1 Phase[br]00 - Rise & Fall - Low & Low[br]01 - Rise
    // & Fall - High & Low[br]10 - Rise & Fall - Low & High[br]11 - Rise & Fall - High
    // & High 
    // 
    // Bits[18:17], RW, default = 0x0
    //
    UINTX b0_diffampenpst1 : 2;
    //
    // Diffamp Enable Length in number of 1x clocks (for a burst length of 4). Burst
    // length 8 is 2 of these. 
    // 
    // Bits[24:19], RW, default = 0x0
    //
    UINTX b0_diffampenlenbl4 : 6;
    //
    // DQS diffamp enable override value
    // 
    // Bits[25:25], RW, default = 0x0
    //
    UINTX b0_dqsdiffampenval : 1;
    //
    // DQS diffamp enable override enable. 1 = use override value. 0 = use diffampen
    // from FIFO logic 
    // 
    // Bits[26:26], RW, default = 0x0
    //
    UINTX b0_dqsdiffampenovr : 1;
    //
    // DQ diffamp enable override value
    // 
    // Bits[27:27], RW, default = 0x0
    //
    UINTX b0_dqdiffampenval : 1;
    //
    // DQ diffamp enable override enable. 1 = use override value. 0 = use diffampen from
    // FIFO logic 
    // 
    // Bits[28:28], RW, default = 0x0
    //
    UINTX b0_dqdiffampenovr : 1;
    //
    // Not used in DNV. Set to 0
    // 
    // Bits[29:29], RW, default = 0x0
    //
    UINTX b0_dmdiffampenval : 1;
    //
    // Not used in DNV. Set to 0
    // 
    // Bits[30:30], RW, default = 0x0
    //
    UINTX b0_dmdiffampenovr : 1;
    //
    // Reserved
    // 
    // Bits[31:31], RO, default = 0x0
    //
    UINTX reserved_1 : 1;
  } Bits;
  UINTX Data;
} DIFFAMPCTL_BL0_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define RXODTENCTL_BL0_DDRDQ_PHY_REG                       0x000001B0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Latency from read command to start of rxodt generation (in 1x cycles)
    // 
    // Bits[4:0], RW, default = 0x0
    //
    UINTX b0_rdcmd2rxodten : 5;
    //
    // Reserved
    // 
    // Bits[10:5], RO, default = 0x0
    //
    UINTX reserved : 6;
    //
    // RXODT Enable - Preamble0 Phase[br]00 - Rise & Fall - Low & Low[br]01 - Rise &
    // Fall - High & Low[br]10 - Rise & Fall - Low & High[br]11 - Rise & Fall - High
    // & High 
    // 
    // Bits[12:11], RW, default = 0x0
    //
    UINTX b0_rxodtenpre0 : 2;
    //
    // RXODT Enable - Postamble0 Phase[br]00 - Rise & Fall - Low & Low[br]01 - Rise &
    // Fall - High & Low[br]10 - Rise & Fall - Low & High[br]11 - Rise & Fall - High
    // & High 
    // 
    // Bits[14:13], RW, default = 0x0
    //
    UINTX b0_rxodtenpst0 : 2;
    //
    // RXODT Enable - Preamble1 Phase[br]00 - Rise & Fall - Low & Low[br]01 - Rise &
    // Fall - High & Low[br]10 - Rise & Fall - Low & High[br]11 - Rise & Fall - High
    // & High 
    // 
    // Bits[16:15], RW, default = 0x0
    //
    UINTX b0_rxodtenpre1 : 2;
    //
    // RXODT Enable - Postamble1 Phase[br]00 - Rise & Fall - Low & Low[br]01 - Rise &
    // Fall - High & Low[br]10 - Rise & Fall - Low & High[br]11 - Rise & Fall - High
    // & High 
    // 
    // Bits[18:17], RW, default = 0x0
    //
    UINTX b0_rxodtenpst1 : 2;
    //
    // RXODT enable Length in number of 1x clocks (for a burst length of 4). Burst length
    // 8 is 2 of these. 
    // 
    // Bits[24:19], RW, default = 0x0
    //
    UINTX b0_rxodtenlenbl4 : 6;
    //
    // RXODT enable override value
    // 
    // Bits[25:25], RW, default = 0x0
    //
    UINTX b0_rxodtenb_ovr : 1;
    //
    // RXODT enable override enable. 1 = use override value. 0 = use RXODTEN from FIFO
    // logic 
    // 
    // Bits[26:26], RW, default = 0x0
    //
    UINTX b0_rxodtenb_val : 1;
    //
    // Reserved
    // 
    // Bits[31:27], RO, default = 0x0
    //
    UINTX reserved_1 : 5;
  } Bits;
  UINTX Data;
} RXODTENCTL_BL0_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define RXODTENOFST_BL0_DDRDQ_PHY_REG                      0x000001B4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // RXODT Enable Rank 0 FIFO ref2x clock read pointer offset
    // 
    // Bits[3:0], RW, default = 0x0
    //
    UINTX b0_rk0odtenrdptroffset : 4;
    //
    // RXODT Enable Rank 1 FIFO ref2x clock read pointer offset
    // 
    // Bits[7:4], RW, default = 0x0
    //
    UINTX b0_rk1odtenrdptroffset : 4;
    //
    // RXODT Enable Rank 2 FIFO ref2x clock read pointer offset
    // 
    // Bits[11:8], RW, default = 0x0
    //
    UINTX b0_rk2odtenrdptroffset : 4;
    //
    // RXODT Enable Rank 3 FIFO ref2x clock read pointer offset
    // 
    // Bits[15:12], RW, default = 0x0
    //
    UINTX b0_rk3odtenrdptroffset : 4;
    //
    // Reserved
    // 
    // Bits[31:16], RO, default = 0x0
    //
    UINTX reserved : 16;
  } Bits;
  UINTX Data;
} RXODTENOFST_BL0_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define RXODTSEGCTL_BL0_DDRDQ_PHY_REG                      0x000001B8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Latency from read command to start of dynamic rxodt segment generation (in 1x
    // cycles) 
    // 
    // Bits[4:0], RW, default = 0x0
    //
    UINTX b0_rdcmd2rxodtseg : 5;
    //
    // Reserved
    // 
    // Bits[10:5], RO, default = 0x0
    //
    UINTX reserved : 6;
    //
    // RXODT segment control - Preamble0 Phase[br]00 - Rise & Fall - Low & Low[br]01
    // - Rise & Fall - High & Low[br]10 - Rise & Fall - Low & High[br]11 - Rise & Fall
    // - High & High 
    // 
    // Bits[12:11], RW, default = 0x0
    //
    UINTX b0_rxodtsegpre0 : 2;
    //
    // RXODT segment control - Postamble0 Phase[br]00 - Rise & Fall - Low & Low[br]01
    // - Rise & Fall - High & Low[br]10 - Rise & Fall - Low & High[br]11 - Rise & Fall
    // - High & High 
    // 
    // Bits[14:13], RW, default = 0x0
    //
    UINTX b0_rxodtsegpst0 : 2;
    //
    // RXODT segment control - Preamble1 Phase[br]00 - Rise & Fall - Low & Low[br]01
    // - Rise & Fall - High & Low[br]10 - Rise & Fall - Low & High[br]11 - Rise & Fall
    // - High & High 
    // 
    // Bits[16:15], RW, default = 0x0
    //
    UINTX b0_rxodtsegpre1 : 2;
    //
    // RXODT segment control - Postamble1+C47 Phase[br]00 - Rise & Fall - Low & Low[br]01
    // - Rise & Fall - High & Low[br]10 - Rise & Fall - Low & High[br]11 - Rise & Fall
    // - High & High 
    // 
    // Bits[18:17], RW, default = 0x0
    //
    UINTX b0_rxodtsegpst1 : 2;
    //
    // RXODT segment control length in number of 1x clocks (for a burst length of 4).
    // Burst length 8 is 2 of these. 
    // 
    // Bits[24:19], RW, default = 0x0
    //
    UINTX b0_rxodtseglenbl4 : 6;
    //
    // RXODT segment enable generation scheme: 1-hot or 2-hot:[br]0: rxodtsegen: 001->010->100->001->
    // and so on  (DDR3)[br]1: rxodtsegen: 011->110->101->011-> and so on  (DDR4) 
    // 
    // Bits[25:25], RW, default = 0x0
    //
    UINTX b0_rxodtsegentwohot : 1;
    //
    // RXODT segment control override value
    // 
    // Bits[28:26], RW, default = 0x1
    //
    UINTX b0_rxodtsegen_val : 3;
    //
    // RXODT segment control override enable. 1 = use override value, 0 = use dynamic
    // segment generation 
    // 
    // Bits[29:29], RW, default = 0x0
    //
    UINTX b0_rxodtsegen_ovr : 1;
    //
    // Reserved
    // 
    // Bits[31:30], RO, default = 0x0
    //
    UINTX reserved_1 : 2;
  } Bits;
  UINTX Data;
} RXODTSEGCTL_BL0_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define RXODTSEGOFST_BL0_DDRDQ_PHY_REG                     0x000001BC
#ifndef ASM_INC
typedef union {
  struct {
    //
    // RXODT segment control Rank 0 FIFO ref2x clock read pointer offset
    // 
    // Bits[3:0], RW, default = 0x0
    //
    UINTX b0_rk0odtsegenrdptroffset : 4;
    //
    // RXODT segment control Rank 1 FIFO ref2x clock read pointer offset
    // 
    // Bits[7:4], RW, default = 0x0
    //
    UINTX b0_rk1odtsegenrdptroffset : 4;
    //
    // RXODT segment control Rank 2 FIFO ref2x clock read pointer offset
    // 
    // Bits[11:8], RW, default = 0x0
    //
    UINTX b0_rk2odtsegenrdptroffset : 4;
    //
    // RXODT segment control Rank 3 FIFO ref2x clock read pointer offset
    // 
    // Bits[15:12], RW, default = 0x0
    //
    UINTX b0_rk3odtsegenrdptroffset : 4;
    //
    // Reserved
    // 
    // Bits[31:16], RO, default = 0x0
    //
    UINTX reserved : 16;
  } Bits;
  UINTX Data;
} RXODTSEGOFST_BL0_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define RK2RKCTL0_BL0_DDRDQ_PHY_REG                        0x000001C0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // RK2RK Enable for TXDQ (PIcodes /sigrdptroffset/sigdbsel):[br]1 =  enabled, 0 =
    // disabled 
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINTX b0_rk2rken_txdq : 1;
    //
    // RK2RK Enable for TXDQS (PIcodes /sigrdptroffset/sigdbsel):[br]1 =  enabled, 0
    // = disabled 
    // 
    // Bits[1:1], RW, default = 0x0
    //
    UINTX b0_rk2rken_txdqs : 1;
    //
    // RK2RK Enable for RXDQS (PIcodes):[br]1 =  enabled, 0 = disabled
    // 
    // Bits[2:2], RW, default = 0x0
    //
    UINTX b0_rk2rken_rxdqs : 1;
    //
    // RK2RK Enable for TXRCVEN (PIcodes/sigrdptroffset/sigdbsel):[br]1 =  enabled, 0
    // = disabled 
    // 
    // Bits[3:3], RW, default = 0x0
    //
    UINTX b0_rk2rken_txrcven : 1;
    //
    // RK2RK Enable for RXDQ (rxpbd): 1 =  enabled, 0 = disabled
    // 
    // Bits[4:4], RW, default = 0x0
    //
    UINTX b0_rk2rken_rxdq : 1;
    //
    // Delay the switch of rxdqspi from rcvenpicode switch. 0: 0 delay,1 1 1x delay,
    // 2 or 3 : 2 1x delay 
    // 
    // Bits[6:5], RW, default = 0x0
    //
    UINTX b0_rk2rk_rxdqspiswitch_dly : 2;
    //
    // Rank pointers changes to Rank Pi changes delay. 0: 1 1xclk delay from pointers
    // rank change to pi rank change. 1: 2 1xclk delay from pointers rank change to pi
    // rank change. 
    // 
    // Bits[7:7], RW, default = 0x0
    //
    UINTX b0_rk2rk_rkptrchange2pichange_dly : 1;
    //
    // Reserved
    // 
    // Bits[31:8], RO, default = 0x0
    //
    UINTX reserved : 24;
  } Bits;
  UINTX Data;
} RK2RKCTL0_BL0_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define RK2RKCTL1_B0N0_DDRDQ_PHY_REG                       0x000001C4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Pattern for rk2rk_iodrvenb first cycle (bits 0 and 1) 1 = disable. Recommended
    // value = 3 
    // 
    // Bits[1:0], RW, default = 0x0
    //
    UINTX b0n0_rk2rkdrvenbpre : 2;
    //
    // Pattern for rk2rk_iodrvenb last cycle (bits 0 and 1) 1 = disable. Recommended
    // value = 1 
    // 
    // Bits[3:2], RW, default = 0x0
    //
    UINTX b0n0_rk2rkdrvenbpst : 2;
    //
    // rk2rk_iodrvenb length. in 1xclk cycles. Recommended value = 0
    // 
    // Bits[7:4], RW, default = 0x0
    //
    UINTX b0n0_rk2rkdrvenblen : 4;
    //
    // Pattern for rk2rk_rden first cycle (bits 0 and 1) 1 = disable. Recommended value
    // = 3 
    // 
    // Bits[9:8], RW, default = 0x0
    //
    UINTX b0n0_rk2rkrdenbpre : 2;
    //
    // Pattern for rk2rk_rden last cycle (bits 0 and 1) 1 = disable. Recommended value
    // = 1 
    // 
    // Bits[11:10], RW, default = 0x0
    //
    UINTX b0n0_rk2rkrdenbpst : 2;
    //
    // rk2rk_rden length. in 1xclk cycles. Recommended value = 0
    // 
    // Bits[15:12], RW, default = 0x0
    //
    UINTX b0n0_rk2rkrdenblen : 4;
    //
    // When set, pushes out the upload of txdq new rank information one more mio2xclk
    // addition to wrcmd2rkchglatency number of 1xclk delays. 
    // 
    // Bits[16:16], RW, default = 0x0
    //
    UINTX b0n0_rk2rktxdqmio2xclkpushout : 1;
    //
    // When set, pushes out the upload of txdqs new rank information one more mio2xclk
    // addition to wrcmd2rkchglatency number of 1xclk delays. 
    // 
    // Bits[17:17], RW, default = 0x0
    //
    UINTX b0n0_rk2rktxdqsmio2xclkpushout : 1;
    //
    // When set, pushes out the de-assertion of rk2rk_drvenb_txdq / rk2rk_drvenb_txdqs
    // one more mio2xclk addition to wrcmd2rkchglatency number of 1xclk delays. 
    // 
    // Bits[18:18], RW, default = 0x0
    //
    UINTX b0n0_rk2rkiodrvenmio2xclkpushout : 1;
    //
    // When set, pushes out the upload of rxdqs new rank information one more mio2xclk
    // addition to rdcmd2rkchglatency number of 1xclk delays. 
    // 
    // Bits[19:19], RW, default = 0x0
    //
    UINTX b0n0_rk2rkrxdqsmio2xclkpushout : 1;
    //
    // When set, pushes out the upload of txrcven new rank information one more mio2xclk
    // addition to rdcmd2rkchglatency number of 1xclk delays. 
    // 
    // Bits[20:20], RW, default = 0x0
    //
    UINTX b0n0_rk2rktxrcvenmio2xclkpushout : 1;
    //
    // When set, pushes out the de-assertion  of rk2rk_rden one more mio2xclk addition
    // to rdcmd2rkchglatency number of 1xclk delays. 
    // 
    // Bits[21:21], RW, default = 0x0
    //
    UINTX b0n0_rk2rkrdenmio2xclkpushout : 1;
    //
    // When set, pushes out the upload of rxdq new rank information one more mio2xclk
    // addition to rdcmd2rkchglatency number of 1xclk delays. 
    // 
    // Bits[22:22], RW, default = 0x0
    //
    UINTX b0n0_rk2rkrxdqmio2xclkpushout : 1;
    //
    // Reserved
    // 
    // Bits[31:23], RO, default = 0x0
    //
    UINTX reserved : 9;
  } Bits;
  UINTX Data;
} RK2RKCTL1_B0N0_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define RK2RKCTL2_B0N0_DDRDQ_PHY_REG                       0x000001C8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Latency from write command to Rank information update (in 1x cycles)
    // 
    // Bits[4:0], RW, default = 0x0
    //
    UINTX b0n0_wrcmd2rkchglatency : 5;
    //
    // Latency from read command to Rank information update (in 1x cycles)
    // 
    // Bits[9:5], RW, default = 0x0
    //
    UINTX b0n0_rdcmd2rkchglatency : 5;
    //
    // Reserved
    // 
    // Bits[31:10], RO, default = 0x0
    //
    UINTX reserved : 22;
  } Bits;
  UINTX Data;
} RK2RKCTL2_B0N0_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define RK2RKCTL1_B0N1_DDRDQ_PHY_REG                       0x000001CC
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Pattern for rk2rk_iodrvenb first cycle (bits 0 and 1) 1 = disable. Recommended
    // value = 3 
    // 
    // Bits[1:0], RW, default = 0x0
    //
    UINTX b0n1_rk2rkdrvenbpre : 2;
    //
    // Pattern for rk2rk_iodrvenb last cycle (bits 0 and 1) 1 = disable. Recommended
    // value = 1 
    // 
    // Bits[3:2], RW, default = 0x0
    //
    UINTX b0n1_rk2rkdrvenbpst : 2;
    //
    // rk2rk_iodrvenb length. in 1xclk cycles. Recommended value = 0
    // 
    // Bits[7:4], RW, default = 0x0
    //
    UINTX b0n1_rk2rkdrvenblen : 4;
    //
    // Pattern for rk2rk_rden first cycle (bits 0 and 1) 1 = disable. Recommended value
    // = 3 
    // 
    // Bits[9:8], RW, default = 0x0
    //
    UINTX b0n1_rk2rkrdenbpre : 2;
    //
    // Pattern for rk2rk_rden last cycle (bits 0 and 1) 1 = disable. Recommended value
    // = 1 
    // 
    // Bits[11:10], RW, default = 0x0
    //
    UINTX b0n1_rk2rkrdenbpst : 2;
    //
    // rk2rk_rden length. in 1xclk cycles. Recommended value = 0
    // 
    // Bits[15:12], RW, default = 0x0
    //
    UINTX b0n1_rk2rkrdenblen : 4;
    //
    // When set, pushes out the upload of txdq new rank information one more mio2xclk
    // addition to wrcmd2rkchglatency number of 1xclk delays. 
    // 
    // Bits[16:16], RW, default = 0x0
    //
    UINTX b0n1_rk2rktxdqmio2xclkpushout : 1;
    //
    // When set, pushes out the upload of txdqs new rank information one more mio2xclk
    // addition to wrcmd2rkchglatency number of 1xclk delays. 
    // 
    // Bits[17:17], RW, default = 0x0
    //
    UINTX b0n1_rk2rktxdqsmio2xclkpushout : 1;
    //
    // When set, pushes out the de-assertion of rk2rk_drvenb_txdq / rk2rk_drvenb_txdqs
    // one more mio2xclk addition to wrcmd2rkchglatency number of 1xclk delays. 
    // 
    // Bits[18:18], RW, default = 0x0
    //
    UINTX b0n1_rk2rkiodrvenmio2xclkpushout : 1;
    //
    // When set, pushes out the upload of rxdqs new rank information one more mio2xclk
    // addition to rdcmd2rkchglatency number of 1xclk delays. 
    // 
    // Bits[19:19], RW, default = 0x0
    //
    UINTX b0n1_rk2rkrxdqsmio2xclkpushout : 1;
    //
    // When set, pushes out the upload of txrcven new rank information one more mio2xclk
    // addition to rdcmd2rkchglatency number of 1xclk delays. 
    // 
    // Bits[20:20], RW, default = 0x0
    //
    UINTX b0n1_rk2rktxrcvenmio2xclkpushout : 1;
    //
    // When set, pushes out the de-assertion  of rk2rk_rden one more mio2xclk addition
    // to rdcmd2rkchglatency number of 1xclk delays. 
    // 
    // Bits[21:21], RW, default = 0x0
    //
    UINTX b0n1_rk2rkrdenmio2xclkpushout : 1;
    //
    // When set, pushes out the upload of rxdq new rank information one more mio2xclk
    // addition to rdcmd2rkchglatency number of 1xclk delays. 
    // 
    // Bits[22:22], RW, default = 0x0
    //
    UINTX b0n1_rk2rkrxdqmio2xclkpushout : 1;
    //
    // Reserved
    // 
    // Bits[31:23], RO, default = 0x0
    //
    UINTX reserved : 9;
  } Bits;
  UINTX Data;
} RK2RKCTL1_B0N1_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define RK2RKCTL2_B0N1_DDRDQ_PHY_REG                       0x000001D0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Latency from write command to Rank information update (in 1x cycles)
    // 
    // Bits[4:0], RW, default = 0x0
    //
    UINTX b0n1_wrcmd2rkchglatency : 5;
    //
    // Latency from read command to Rank information update (in 1x cycles)
    // 
    // Bits[9:5], RW, default = 0x0
    //
    UINTX b0n1_rdcmd2rkchglatency : 5;
    //
    // Reserved
    // 
    // Bits[31:10], RO, default = 0x0
    //
    UINTX reserved : 22;
  } Bits;
  UINTX Data;
} RK2RKCTL2_B0N1_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define DQSIGCTL0_B0N0_DDRDQ_PHY_REG                       0x000001D4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // DQ data rank 0 signal clock deadband select. 00: No Deadband Zone[br]01: No Deadband
    // Zone 270 pathsel[br]10: Deadband 90 degree path sel[br]11: Deadband 180 degree
    // path sel. 
    // 
    // Bits[1:0], RW, default = 0x0
    //
    UINTX b0n0_rk0dqsigdbsel : 2;
    //
    // DQ data rank 1 signal clock deadband select. 00: No Deadband Zone[br]01: No Deadband
    // Zone 270 pathsel[br]10: Deadband 90 degree path sel[br]11: Deadband 180 degree
    // path sel. 
    // 
    // Bits[3:2], RW, default = 0x0
    //
    UINTX b0n0_rk1dqsigdbsel : 2;
    //
    // DQ data rank 2 signal clock deadband select. 00: No Deadband Zone[br]01: No Deadband
    // Zone 270 pathsel[br]10: Deadband 90 degree path sel[br]11: Deadband 180 degree
    // path sel. 
    // 
    // Bits[5:4], RW, default = 0x0
    //
    UINTX b0n0_rk2dqsigdbsel : 2;
    //
    // DQ data rank 3 signal clock deadband select. 00: No Deadband Zone[br]01: No Deadband
    // Zone 270 pathsel[br]10: Deadband 90 degree path sel[br]11: Deadband 180 degree
    // path sel. 
    // 
    // Bits[7:6], RW, default = 0x0
    //
    UINTX b0n0_rk3dqsigdbsel : 2;
    //
    // DQ data rank 0 signal clock read pointer offset
    // 
    // Bits[12:8], RW, default = 0x0
    //
    UINTX b0n0_rk0dqsigrdptroffset : 5;
    //
    // DQ data rank 1 signal clock read pointer offset
    // 
    // Bits[17:13], RW, default = 0x0
    //
    UINTX b0n0_rk1dqsigrdptroffset : 5;
    //
    // DQ data rank 2 signal clock read pointer offset
    // 
    // Bits[22:18], RW, default = 0x0
    //
    UINTX b0n0_rk2dqsigrdptroffset : 5;
    //
    // DQ data rank 3 signal clock read pointer offset
    // 
    // Bits[27:23], RW, default = 0x0
    //
    UINTX b0n0_rk3dqsigrdptroffset : 5;
    //
    // Reserved
    // 
    // Bits[31:28], RO, default = 0x0
    //
    UINTX reserved : 4;
  } Bits;
  UINTX Data;
} DQSIGCTL0_B0N0_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define DQSIGCTL0_B0N1_DDRDQ_PHY_REG                       0x000001D8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // DQ data rank 0 signal clock deadband select. 00: No Deadband Zone[br]01: No Deadband
    // Zone 270 pathsel[br]10: Deadband 90 degree path sel[br]11: Deadband 180 degree
    // path sel. 
    // 
    // Bits[1:0], RW, default = 0x0
    //
    UINTX b0n1_rk0dqsigdbsel : 2;
    //
    // DQ data rank 1 signal clock deadband select. 00: No Deadband Zone[br]01: No Deadband
    // Zone 270 pathsel[br]10: Deadband 90 degree path sel[br]11: Deadband 180 degree
    // path sel. 
    // 
    // Bits[3:2], RW, default = 0x0
    //
    UINTX b0n1_rk1dqsigdbsel : 2;
    //
    // DQ data rank 2 signal clock deadband select. 00: No Deadband Zone[br]01: No Deadband
    // Zone 270 pathsel[br]10: Deadband 90 degree path sel[br]11: Deadband 180 degree
    // path sel. 
    // 
    // Bits[5:4], RW, default = 0x0
    //
    UINTX b0n1_rk2dqsigdbsel : 2;
    //
    // DQ data rank 3 signal clock deadband select. 00: No Deadband Zone[br]01: No Deadband
    // Zone 270 pathsel[br]10: Deadband 90 degree path sel[br]11: Deadband 180 degree
    // path sel. 
    // 
    // Bits[7:6], RW, default = 0x0
    //
    UINTX b0n1_rk3dqsigdbsel : 2;
    //
    // DQ data rank 0 signal clock read pointer offset
    // 
    // Bits[12:8], RW, default = 0x0
    //
    UINTX b0n1_rk0dqsigrdptroffset : 5;
    //
    // DQ data rank 1 signal clock read pointer offset
    // 
    // Bits[17:13], RW, default = 0x0
    //
    UINTX b0n1_rk1dqsigrdptroffset : 5;
    //
    // DQ data rank 2 signal clock read pointer offset
    // 
    // Bits[22:18], RW, default = 0x0
    //
    UINTX b0n1_rk2dqsigrdptroffset : 5;
    //
    // DQ data rank 3 signal clock read pointer offset
    // 
    // Bits[27:23], RW, default = 0x0
    //
    UINTX b0n1_rk3dqsigrdptroffset : 5;
    //
    // Reserved
    // 
    // Bits[31:28], RO, default = 0x0
    //
    UINTX reserved : 4;
  } Bits;
  UINTX Data;
} DQSIGCTL0_B0N1_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define DQSIGCTL1_B0N0_DDRDQ_PHY_REG                       0x000001DC
#ifndef ASM_INC
typedef union {
  struct {
    //
    // DQ drvenb rank 0 signal clock deadband select. 00: No Deadband Zone[br]01: No
    // Deadband Zone 270 pathsel[br]10: Deadband 90 degree path sel[br]11: Deadband 180
    // degree path sel. 
    // 
    // Bits[1:0], RW, default = 0x0
    //
    UINTX b0n0_rk0dqdrvsigdbsel : 2;
    //
    // DQ drvenb rank 1 signal clock deadband select. 00: No Deadband Zone[br]01: No
    // Deadband Zone 270 pathsel[br]10: Deadband 90 degree path sel[br]11: Deadband 180
    // degree path sel. 
    // 
    // Bits[3:2], RW, default = 0x0
    //
    UINTX b0n0_rk1dqdrvsigdbsel : 2;
    //
    // DQ drvenb rank 2 signal clock deadband select. 00: No Deadband Zone[br]01: No
    // Deadband Zone 270 pathsel[br]10: Deadband 90 degree path sel[br]11: Deadband 180
    // degree path sel. 
    // 
    // Bits[5:4], RW, default = 0x0
    //
    UINTX b0n0_rk2dqdrvsigdbsel : 2;
    //
    // DQ drvenb rank 3 signal clock deadband select. 00: No Deadband Zone[br]01: No
    // Deadband Zone 270 pathsel[br]10: Deadband 90 degree path sel[br]11: Deadband 180
    // degree path sel. 
    // 
    // Bits[7:6], RW, default = 0x0
    //
    UINTX b0n0_rk3dqdrvsigdbsel : 2;
    //
    // DQ drvenb rank 0 signal clock read pointer offset
    // 
    // Bits[11:8], RW, default = 0x0
    //
    UINTX b0n0_rk0dqdrvsigrdptroffset : 4;
    //
    // DQ drvenb rank 1 signal clock read pointer offset
    // 
    // Bits[15:12], RW, default = 0x0
    //
    UINTX b0n0_rk1dqdrvsigrdptroffset : 4;
    //
    // DQ drvenb rank 2 signal clock read pointer offset
    // 
    // Bits[19:16], RW, default = 0x0
    //
    UINTX b0n0_rk2dqdrvsigrdptroffset : 4;
    //
    // DQ drvenb rank 3 signal clock read pointer offset
    // 
    // Bits[23:20], RW, default = 0x0
    //
    UINTX b0n0_rk3dqdrvsigrdptroffset : 4;
    //
    // Reserved
    // 
    // Bits[31:24], RO, default = 0x0
    //
    UINTX reserved : 8;
  } Bits;
  UINTX Data;
} DQSIGCTL1_B0N0_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define DQSIGCTL1_B0N1_DDRDQ_PHY_REG                       0x000001E0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // DQ drvenb rank 0 signal clock deadband select. 00: No Deadband Zone[br]01: No
    // Deadband Zone 270 pathsel[br]10: Deadband 90 degree path sel[br]11: Deadband 180
    // degree path sel. 
    // 
    // Bits[1:0], RW, default = 0x0
    //
    UINTX b0n1_rk0dqdrvsigdbsel : 2;
    //
    // DQ drvenb rank 1 signal clock deadband select. 00: No Deadband Zone[br]01: No
    // Deadband Zone 270 pathsel[br]10: Deadband 90 degree path sel[br]11: Deadband 180
    // degree path sel. 
    // 
    // Bits[3:2], RW, default = 0x0
    //
    UINTX b0n1_rk1dqdrvsigdbsel : 2;
    //
    // DQ drvenb rank 2 signal clock deadband select. 00: No Deadband Zone[br]01: No
    // Deadband Zone 270 pathsel[br]10: Deadband 90 degree path sel[br]11: Deadband 180
    // degree path sel. 
    // 
    // Bits[5:4], RW, default = 0x0
    //
    UINTX b0n1_rk2dqdrvsigdbsel : 2;
    //
    // DQ drvenb rank 3 signal clock deadband select. 00: No Deadband Zone[br]01: No
    // Deadband Zone 270 pathsel[br]10: Deadband 90 degree path sel[br]11: Deadband 180
    // degree path sel. 
    // 
    // Bits[7:6], RW, default = 0x0
    //
    UINTX b0n1_rk3dqdrvsigdbsel : 2;
    //
    // DQ drvenb rank 0 signal clock read pointer offset
    // 
    // Bits[11:8], RW, default = 0x0
    //
    UINTX b0n1_rk0dqdrvsigrdptroffset : 4;
    //
    // DQ drvenb rank 1 signal clock read pointer offset
    // 
    // Bits[15:12], RW, default = 0x0
    //
    UINTX b0n1_rk1dqdrvsigrdptroffset : 4;
    //
    // DQ drvenb rank 2 signal clock read pointer offset
    // 
    // Bits[19:16], RW, default = 0x0
    //
    UINTX b0n1_rk2dqdrvsigrdptroffset : 4;
    //
    // DQ drvenb rank 3 signal clock read pointer offset
    // 
    // Bits[23:20], RW, default = 0x0
    //
    UINTX b0n1_rk3dqdrvsigrdptroffset : 4;
    //
    // Reserved
    // 
    // Bits[31:24], RO, default = 0x0
    //
    UINTX reserved : 8;
  } Bits;
  UINTX Data;
} DQSIGCTL1_B0N1_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define DQSIGCTL2_B0N0_DDRDQ_PHY_REG                       0x000001E4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Nibble 0 DQ rank 0 sigclk PI code
    // 
    // Bits[5:0], RW, default = 0x0
    //
    UINTX b0n0_txdll_rk0siggrp01picode : 6;
    //
    // Nibble 0 DQ rank 1 sigclk PI code
    // 
    // Bits[11:6], RW, default = 0x0
    //
    UINTX b0n0_txdll_rk1siggrp01picode : 6;
    //
    // Nibble 0 DQ rank 2 sigclk PI code
    // 
    // Bits[17:12], RW, default = 0x0
    //
    UINTX b0n0_txdll_rk2siggrp01picode : 6;
    //
    // Nibble 0 DQ rank 3 sigclk PI code
    // 
    // Bits[23:18], RW, default = 0x0
    //
    UINTX b0n0_txdll_rk3siggrp01picode : 6;
    //
    // Reserved
    // 
    // Bits[31:24], RO, default = 0x0
    //
    UINTX reserved : 8;
  } Bits;
  UINTX Data;
} DQSIGCTL2_B0N0_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define DQSIGCTL2_B0N1_DDRDQ_PHY_REG                       0x000001E8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Nibble 1 DQ rank 0 sigclk PI code
    // 
    // Bits[5:0], RW, default = 0x0
    //
    UINTX b0n1_txdll_rk0siggrp04picode : 6;
    //
    // Nibble 1 DQ rank 1 sigclk PI code
    // 
    // Bits[11:6], RW, default = 0x0
    //
    UINTX b0n1_txdll_rk1siggrp04picode : 6;
    //
    // Nibble 1 DQ rank 2 sigclk PI code
    // 
    // Bits[17:12], RW, default = 0x0
    //
    UINTX b0n1_txdll_rk2siggrp04picode : 6;
    //
    // Nibble 1 DQ rank 3 sigclk PI code
    // 
    // Bits[23:18], RW, default = 0x0
    //
    UINTX b0n1_txdll_rk3siggrp04picode : 6;
    //
    // Reserved
    // 
    // Bits[31:24], RO, default = 0x0
    //
    UINTX reserved : 8;
  } Bits;
  UINTX Data;
} DQSIGCTL2_B0N1_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define DQSSIGCTL0_B0N0_DDRDQ_PHY_REG                      0x000001EC
#ifndef ASM_INC
typedef union {
  struct {
    //
    // DQS rank 0 signal clock deadband select. 00: No Deadband Zone[br]01: No Deadband
    // Zone 270 pathsel[br]10: Deadband 90 degree path sel[br]11: Deadband 180 degree
    // path sel. 
    // 
    // Bits[1:0], RW, default = 0x0
    //
    UINTX b0n0_rk0dqssigdbsel : 2;
    //
    // DQS rank 1 signal clock deadband select. 00: No Deadband Zone[br]01: No Deadband
    // Zone 270 pathsel[br]10: Deadband 90 degree path sel[br]11: Deadband 180 degree
    // path sel. 
    // 
    // Bits[3:2], RW, default = 0x0
    //
    UINTX b0n0_rk1dqssigdbsel : 2;
    //
    // DQS rank 2 signal clock deadband select. 00: No Deadband Zone[br]01: No Deadband
    // Zone 270 pathsel[br]10: Deadband 90 degree path sel[br]11: Deadband 180 degree
    // path sel. 
    // 
    // Bits[5:4], RW, default = 0x0
    //
    UINTX b0n0_rk2dqssigdbsel : 2;
    //
    // DQS rank 3 signal clock deadband select. 00: No Deadband Zone[br]01: No Deadband
    // Zone 270 pathsel[br]10: Deadband 90 degree path sel[br]11: Deadband 180 degree
    // path sel. 
    // 
    // Bits[7:6], RW, default = 0x0
    //
    UINTX b0n0_rk3dqssigdbsel : 2;
    //
    // DQS rank 0 signal clock read pointer offset
    // 
    // Bits[11:8], RW, default = 0x0
    //
    UINTX b0n0_rk0dqssigrdptroffset : 4;
    //
    // DQS rank 1 signal clock read pointer offset
    // 
    // Bits[15:12], RW, default = 0x0
    //
    UINTX b0n0_rk1dqssigrdptroffset : 4;
    //
    // DQS rank 2 signal clock read pointer offset
    // 
    // Bits[19:16], RW, default = 0x0
    //
    UINTX b0n0_rk2dqssigrdptroffset : 4;
    //
    // DQS rank 3 signal clock read pointer offset
    // 
    // Bits[23:20], RW, default = 0x0
    //
    UINTX b0n0_rk3dqssigrdptroffset : 4;
    //
    // Reserved
    // 
    // Bits[31:24], RO, default = 0x0
    //
    UINTX reserved : 8;
  } Bits;
  UINTX Data;
} DQSSIGCTL0_B0N0_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define DQSSIGCTL0_B0N1_DDRDQ_PHY_REG                      0x000001F0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // DQS rank 0 signal clock deadband select. 00: No Deadband Zone[br]01: No Deadband
    // Zone 270 pathsel[br]10: Deadband 90 degree path sel[br]11: Deadband 180 degree
    // path sel. 
    // 
    // Bits[1:0], RW, default = 0x0
    //
    UINTX b0n1_rk0dqssigdbsel : 2;
    //
    // DQS rank 1 signal clock deadband select. 00: No Deadband Zone[br]01: No Deadband
    // Zone 270 pathsel[br]10: Deadband 90 degree path sel[br]11: Deadband 180 degree
    // path sel. 
    // 
    // Bits[3:2], RW, default = 0x0
    //
    UINTX b0n1_rk1dqssigdbsel : 2;
    //
    // DQS rank 2 signal clock deadband select. 00: No Deadband Zone[br]01: No Deadband
    // Zone 270 pathsel[br]10: Deadband 90 degree path sel[br]11: Deadband 180 degree
    // path sel. 
    // 
    // Bits[5:4], RW, default = 0x0
    //
    UINTX b0n1_rk2dqssigdbsel : 2;
    //
    // DQS rank 3 signal clock deadband select. 00: No Deadband Zone[br]01: No Deadband
    // Zone 270 pathsel[br]10: Deadband 90 degree path sel[br]11: Deadband 180 degree
    // path sel. 
    // 
    // Bits[7:6], RW, default = 0x0
    //
    UINTX b0n1_rk3dqssigdbsel : 2;
    //
    // DQS rank 0 signal clock read pointer offset
    // 
    // Bits[11:8], RW, default = 0x0
    //
    UINTX b0n1_rk0dqssigrdptroffset : 4;
    //
    // DQS rank 1 signal clock read pointer offset
    // 
    // Bits[15:12], RW, default = 0x0
    //
    UINTX b0n1_rk1dqssigrdptroffset : 4;
    //
    // DQS rank 2 signal clock read pointer offset
    // 
    // Bits[19:16], RW, default = 0x0
    //
    UINTX b0n1_rk2dqssigrdptroffset : 4;
    //
    // DQS rank 3 signal clock read pointer offset
    // 
    // Bits[23:20], RW, default = 0x0
    //
    UINTX b0n1_rk3dqssigrdptroffset : 4;
    //
    // Reserved
    // 
    // Bits[31:24], RO, default = 0x0
    //
    UINTX reserved : 8;
  } Bits;
  UINTX Data;
} DQSSIGCTL0_B0N1_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define DQSSIGCTL1_B0N0_DDRDQ_PHY_REG                      0x000001F4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Nibble 0 DQS rank 0 sigclk PI code
    // 
    // Bits[5:0], RW, default = 0x0
    //
    UINTX b0n0_txdll_rk0siggrp00picode : 6;
    //
    // Nibble 0 DQS rank 1 sigclk PI code
    // 
    // Bits[11:6], RW, default = 0x0
    //
    UINTX b0n0_txdll_rk1siggrp00picode : 6;
    //
    // Nibble 0 DQS rank 2 sigclk PI code
    // 
    // Bits[17:12], RW, default = 0x0
    //
    UINTX b0n0_txdll_rk2siggrp00picode : 6;
    //
    // Nibble 0 DQS rank 3 sigclk PI code
    // 
    // Bits[23:18], RW, default = 0x0
    //
    UINTX b0n0_txdll_rk3siggrp00picode : 6;
    //
    // Reserved
    // 
    // Bits[31:24], RO, default = 0x0
    //
    UINTX reserved : 8;
  } Bits;
  UINTX Data;
} DQSSIGCTL1_B0N0_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define DQSSIGCTL1_B0N1_DDRDQ_PHY_REG                      0x000001F8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Nibble 1 DQS rank 0 sigclk PI code
    // 
    // Bits[5:0], RW, default = 0x0
    //
    UINTX b0n1_txdll_rk0siggrp03picode : 6;
    //
    // Nibble 1 DQS rank 1 sigclk PI code
    // 
    // Bits[11:6], RW, default = 0x0
    //
    UINTX b0n1_txdll_rk1siggrp03picode : 6;
    //
    // Nibble 1 DQS rank 2 sigclk PI code
    // 
    // Bits[17:12], RW, default = 0x0
    //
    UINTX b0n1_txdll_rk2siggrp03picode : 6;
    //
    // Nibble 1 DQS rank 3 sigclk PI code
    // 
    // Bits[23:18], RW, default = 0x0
    //
    UINTX b0n1_txdll_rk3siggrp03picode : 6;
    //
    // Reserved
    // 
    // Bits[31:24], RO, default = 0x0
    //
    UINTX reserved : 8;
  } Bits;
  UINTX Data;
} DQSSIGCTL1_B0N1_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define RCVENSIGCTL0_B0N0_DDRDQ_PHY_REG                    0x000001FC
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Receive Enable rank 0 signal clock deadband select. 00: No Deadband Zone[br]01:
    // No Deadband Zone 270 pathsel[br]10: Deadband 90 degree path sel[br]11: Deadband
    // 180 degree path sel. 
    // 
    // Bits[1:0], RW, default = 0x0
    //
    UINTX b0n0_rk0rcvensigdbsel : 2;
    //
    // Receive Enable rank 1 signal clock deadband select. 00: No Deadband Zone[br]01:
    // No Deadband Zone 270 pathsel[br]10: Deadband 90 degree path sel[br]11: Deadband
    // 180 degree path sel. 
    // 
    // Bits[3:2], RW, default = 0x0
    //
    UINTX b0n0_rk1rcvensigdbsel : 2;
    //
    // Receive Enable rank 2 signal clock deadband select. 00: No Deadband Zone[br]01:
    // No Deadband Zone 270 pathsel[br]10: Deadband 90 degree path sel[br]11: Deadband
    // 180 degree path sel. 
    // 
    // Bits[5:4], RW, default = 0x0
    //
    UINTX b0n0_rk2rcvensigdbsel : 2;
    //
    // Receive Enable rank 3 signal clock deadband select. 00: No Deadband Zone[br]01:
    // No Deadband Zone 270 pathsel[br]10: Deadband 90 degree path sel[br]11: Deadband
    // 180 degree path sel. 
    // 
    // Bits[7:6], RW, default = 0x0
    //
    UINTX b0n0_rk3rcvensigdbsel : 2;
    //
    // Receive Enable rank 0 signal clock read pointer offset
    // 
    // Bits[11:8], RW, default = 0x0
    //
    UINTX b0n0_rk0rcvensigrdptroffset : 4;
    //
    // Receive Enable rank 1 signal clock read pointer offset
    // 
    // Bits[15:12], RW, default = 0x0
    //
    UINTX b0n0_rk1rcvensigrdptroffset : 4;
    //
    // Receive Enable rank 2 signal clock read pointer offset
    // 
    // Bits[19:16], RW, default = 0x0
    //
    UINTX b0n0_rk2rcvensigrdptroffset : 4;
    //
    // Receive Enable rank 3 signal clock read pointer offset
    // 
    // Bits[23:20], RW, default = 0x0
    //
    UINTX b0n0_rk3rcvensigrdptroffset : 4;
    //
    // Reserved
    // 
    // Bits[31:24], RO, default = 0x0
    //
    UINTX reserved : 8;
  } Bits;
  UINTX Data;
} RCVENSIGCTL0_B0N0_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define RCVENSIGCTL0_B0N1_DDRDQ_PHY_REG                    0x00000200
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Receive Enable rank 0 signal clock deadband select. 00: No Deadband Zone[br]01:
    // No Deadband Zone 270 pathsel[br]10: Deadband 90 degree path sel[br]11: Deadband
    // 180 degree path sel. 
    // 
    // Bits[1:0], RW, default = 0x0
    //
    UINTX b0n1_rk0rcvensigdbsel : 2;
    //
    // Receive Enable rank 1 signal clock deadband select. 00: No Deadband Zone[br]01:
    // No Deadband Zone 270 pathsel[br]10: Deadband 90 degree path sel[br]11: Deadband
    // 180 degree path sel. 
    // 
    // Bits[3:2], RW, default = 0x0
    //
    UINTX b0n1_rk1rcvensigdbsel : 2;
    //
    // Receive Enable rank 2 signal clock deadband select. 00: No Deadband Zone[br]01:
    // No Deadband Zone 270 pathsel[br]10: Deadband 90 degree path sel[br]11: Deadband
    // 180 degree path sel. 
    // 
    // Bits[5:4], RW, default = 0x0
    //
    UINTX b0n1_rk2rcvensigdbsel : 2;
    //
    // Receive Enable rank 3 signal clock deadband select. 00: No Deadband Zone[br]01:
    // No Deadband Zone 270 pathsel[br]10: Deadband 90 degree path sel[br]11: Deadband
    // 180 degree path sel. 
    // 
    // Bits[7:6], RW, default = 0x0
    //
    UINTX b0n1_rk3rcvensigdbsel : 2;
    //
    // Receive Enable rank 0 signal clock read pointer offset
    // 
    // Bits[11:8], RW, default = 0x0
    //
    UINTX b0n1_rk0rcvensigrdptroffset : 4;
    //
    // Receive Enable rank 1 signal clock read pointer offset
    // 
    // Bits[15:12], RW, default = 0x0
    //
    UINTX b0n1_rk1rcvensigrdptroffset : 4;
    //
    // Receive Enable rank 2 signal clock read pointer offset
    // 
    // Bits[19:16], RW, default = 0x0
    //
    UINTX b0n1_rk2rcvensigrdptroffset : 4;
    //
    // Receive Enable rank 3 signal clock read pointer offset
    // 
    // Bits[23:20], RW, default = 0x0
    //
    UINTX b0n1_rk3rcvensigrdptroffset : 4;
    //
    // Reserved
    // 
    // Bits[31:24], RO, default = 0x0
    //
    UINTX reserved : 8;
  } Bits;
  UINTX Data;
} RCVENSIGCTL0_B0N1_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define RCVENSIGCTL1_B0N0_DDRDQ_PHY_REG                    0x00000204
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Nibble0 Receive Enable rank 1 sigclk PI code
    // 
    // Bits[5:0], RW, default = 0x0
    //
    UINTX b0n0_txdll_rk0siggrp02picode : 6;
    //
    // Nibble0 Receive Enable rank 1 sigclk PI code
    // 
    // Bits[11:6], RW, default = 0x0
    //
    UINTX b0n0_txdll_rk1siggrp02picode : 6;
    //
    // Nibble0 Receive Enable rank 1 sigclk PI code
    // 
    // Bits[17:12], RW, default = 0x0
    //
    UINTX b0n0_txdll_rk2siggrp02picode : 6;
    //
    // Nibble0 Receive Enable rank 1 sigclk PI code
    // 
    // Bits[23:18], RW, default = 0x0
    //
    UINTX b0n0_txdll_rk3siggrp02picode : 6;
    //
    // Reserved
    // 
    // Bits[31:24], RO, default = 0x0
    //
    UINTX reserved : 8;
  } Bits;
  UINTX Data;
} RCVENSIGCTL1_B0N0_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define RCVENSIGCTL1_B0N1_DDRDQ_PHY_REG                    0x00000208
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Nibble1 Receive Enable rank 1 sigclk PI code
    // 
    // Bits[5:0], RW, default = 0x0
    //
    UINTX b0n1_txdll_rk0siggrp05picode : 6;
    //
    // Nibble1 Receive Enable rank 1 sigclk PI code
    // 
    // Bits[11:6], RW, default = 0x0
    //
    UINTX b0n1_txdll_rk1siggrp05picode : 6;
    //
    // Nibble1 Receive Enable rank 1 sigclk PI code
    // 
    // Bits[17:12], RW, default = 0x0
    //
    UINTX b0n1_txdll_rk2siggrp05picode : 6;
    //
    // Nibble1 Receive Enable rank 1 sigclk PI code
    // 
    // Bits[23:18], RW, default = 0x0
    //
    UINTX b0n1_txdll_rk3siggrp05picode : 6;
    //
    // Reserved
    // 
    // Bits[31:24], RO, default = 0x0
    //
    UINTX reserved : 8;
  } Bits;
  UINTX Data;
} RCVENSIGCTL1_B0N1_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define DQSRXDLL_B0N0_DDRDQ_PHY_REG                        0x0000020C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Nibble 0 DQS rank 1 RX slave delay line PI code. This is used to centre the DQS
    // in the DQ eye 
    // 
    // Bits[6:0], RW, default = 0x0
    //
    UINTX b0n0_rxdll_rk0dqspicode : 7;
    //
    // Nibble 0 DQS rank 1 RX slave delay line PI code. This is used to centre the DQS
    // in the DQ eye 
    // 
    // Bits[13:7], RW, default = 0x0
    //
    UINTX b0n0_rxdll_rk1dqspicode : 7;
    //
    // Nibble 0 DQS rank 1 RX slave delay line PI code. This is used to centre the DQS
    // in the DQ eye 
    // 
    // Bits[20:14], RW, default = 0x0
    //
    UINTX b0n0_rxdll_rk2dqspicode : 7;
    //
    // Nibble 0 DQS rank 1 RX slave delay line PI code. This is used to centre the DQS
    // in the DQ eye 
    // 
    // Bits[27:21], RW, default = 0x0
    //
    UINTX b0n0_rxdll_rk3dqspicode : 7;
    //
    // Reserved
    // 
    // Bits[31:28], RO, default = 0x0
    //
    UINTX reserved : 4;
  } Bits;
  UINTX Data;
} DQSRXDLL_B0N0_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define DQSRXDLL_B0N1_DDRDQ_PHY_REG                        0x00000210
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Nibble 1 DQS rank 1 RX slave delay line PI code. This is used to centre the DQS
    // in the DQ eye 
    // 
    // Bits[6:0], RW, default = 0x0
    //
    UINTX b0n1_rxdll_rk0dqspicode : 7;
    //
    // Nibble 1 DQS rank 1 RX slave delay line PI code. This is used to centre the DQS
    // in the DQ eye 
    // 
    // Bits[13:7], RW, default = 0x0
    //
    UINTX b0n1_rxdll_rk1dqspicode : 7;
    //
    // Nibble 1 DQS rank 1 RX slave delay line PI code. This is used to centre the DQS
    // in the DQ eye 
    // 
    // Bits[20:14], RW, default = 0x0
    //
    UINTX b0n1_rxdll_rk2dqspicode : 7;
    //
    // Nibble 1 DQS rank 1 RX slave delay line PI code. This is used to centre the DQS
    // in the DQ eye 
    // 
    // Bits[27:21], RW, default = 0x0
    //
    UINTX b0n1_rxdll_rk3dqspicode : 7;
    //
    // Reserved
    // 
    // Bits[31:28], RO, default = 0x0
    //
    UINTX reserved : 4;
  } Bits;
  UINTX Data;
} DQSRXDLL_B0N1_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define DQSBRXDLL_B0N0_DDRDQ_PHY_REG                       0x00000214
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Nibble 0 DQSB rank 1 RX slave delay line PI code. This is used to centre the DQSB
    // in the DQ eye 
    // 
    // Bits[6:0], RW, default = 0x0
    //
    UINTX b0n0_rxdll_rk0dqsbpicode : 7;
    //
    // Nibble 0 DQSB rank 1 RX slave delay line PI code. This is used to centre the DQSB
    // in the DQ eye 
    // 
    // Bits[13:7], RW, default = 0x0
    //
    UINTX b0n0_rxdll_rk1dqsbpicode : 7;
    //
    // Nibble 0 DQSB rank 1 RX slave delay line PI code. This is used to centre the DQSB
    // in the DQ eye 
    // 
    // Bits[20:14], RW, default = 0x0
    //
    UINTX b0n0_rxdll_rk2dqsbpicode : 7;
    //
    // Nibble 0 DQSB rank 1 RX slave delay line PI code. This is used to centre the DQSB
    // in the DQ eye 
    // 
    // Bits[27:21], RW, default = 0x0
    //
    UINTX b0n0_rxdll_rk3dqsbpicode : 7;
    //
    // Reserved
    // 
    // Bits[31:28], RO, default = 0x0
    //
    UINTX reserved : 4;
  } Bits;
  UINTX Data;
} DQSBRXDLL_B0N0_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define DQSBRXDLL_B0N1_DDRDQ_PHY_REG                       0x00000218
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Nibble 1 DQSB rank 1 RX slave delay line PI code. This is used to centre the DQSB
    // in the DQ eye 
    // 
    // Bits[6:0], RW, default = 0x0
    //
    UINTX b0n1_rxdll_rk0dqsbpicode : 7;
    //
    // Nibble 1 DQSB rank 1 RX slave delay line PI code. This is used to centre the DQSB
    // in the DQ eye 
    // 
    // Bits[13:7], RW, default = 0x0
    //
    UINTX b0n1_rxdll_rk1dqsbpicode : 7;
    //
    // Nibble 1 DQSB rank 1 RX slave delay line PI code. This is used to centre the DQSB
    // in the DQ eye 
    // 
    // Bits[20:14], RW, default = 0x0
    //
    UINTX b0n1_rxdll_rk2dqsbpicode : 7;
    //
    // Nibble 1 DQSB rank 1 RX slave delay line PI code. This is used to centre the DQSB
    // in the DQ eye 
    // 
    // Bits[27:21], RW, default = 0x0
    //
    UINTX b0n1_rxdll_rk3dqsbpicode : 7;
    //
    // Reserved
    // 
    // Bits[31:28], RO, default = 0x0
    //
    UINTX reserved : 4;
  } Bits;
  UINTX Data;
} DQSBRXDLL_B0N1_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define CLKGATE0_BL0_DDRDQ_PHY_REG                         0x0000021C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Reserved
    // 
    // Bits[8:0], RO, default = 0x0
    //
    UINTX reserved : 9;
    //
    // Dynamic spidclk clock enable for common  (to enable gspidclk)
    // 
    // Bits[9:9], RW, default = 0x0
    //
    UINTX b0_dynspidclken : 1;
    //
    // Dynamic ref1xclk clock enable for common (to enable gref1xclk)
    // 
    // Bits[10:10], RW, default = 0x0
    //
    UINTX b0_dynref1xclken : 1;
    //
    // Dynamic ref2xclk clock enable for common (to enable gref2xclk)
    // 
    // Bits[11:11], RW, default = 0x0
    //
    UINTX b0_dynref2xclken : 1;
    //
    // Dynamic sigclk group enable for commom   (to enable ref2xclk180siggrpen/ref2xclk270siggrpen/ref2xclk90siggrpen)
    // 
    // Bits[12:12], RW, default = 0x0
    //
    UINTX b0_dynsiggrpen : 1;
    //
    // Dynamic spidclk clock enable for write command  (to enable gspidwrclk)
    // 
    // Bits[13:13], RW, default = 0x0
    //
    UINTX b0_dynwritespidclken : 1;
    //
    // Dynamic ref1xclk clock enable for write command (to enable grefwr1xclk)
    // 
    // Bits[14:14], RW, default = 0x0
    //
    UINTX b0_dynwriteref1xclken : 1;
    //
    // Dynamic ref2xclk clock enable for write command (to enable grefwr2xclk)
    // 
    // Bits[15:15], RW, default = 0x0
    //
    UINTX b0_dynwriteref2xclken : 1;
    //
    // Dynamic sigclk group enable for write command   (to enable dqsigclk/dqsigclk)
    // 
    // Bits[16:16], RW, default = 0x0
    //
    UINTX b0_dynwritesiggrpen : 1;
    //
    // Dynamic spidclk clock enable for read command  (to enable gspidrdclk)
    // 
    // Bits[17:17], RW, default = 0x0
    //
    UINTX b0_dynreadspidclken : 1;
    //
    // Dynamic ref1xclk clock enable for read command (to enable grefrd1xclk)
    // 
    // Bits[18:18], RW, default = 0x0
    //
    UINTX b0_dynreadref1xclken : 1;
    //
    // Dynamic ref2xclk clock enable for read command (to enable grefrd2xclk)
    // 
    // Bits[19:19], RW, default = 0x0
    //
    UINTX b0_dynreadref2xclken : 1;
    //
    // Dynamic sigclk group enable for read command   (to enable rcvensigclk)
    // 
    // Bits[20:20], RW, default = 0x0
    //
    UINTX b0_dynreadsiggrpen : 1;
    //
    // Reserved
    // 
    // Bits[26:21], RO, default = 0x0
    //
    UINTX reserved_1 : 6;
    //
    // Reserved
    // 
    // Bits[31:27], RO, default = 0x0
    //
    UINTX reserved_2 : 5;
  } Bits;
  UINTX Data;
} CLKGATE0_BL0_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define CLKGATE1_BL0_DDRDQ_PHY_REG                         0x00000220
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Clock Gating register: IDLE timer counter max value for clock gating on Tx/RX
    // . Counter timeout based on last WRCMD/RDCMD received. 6 bits are good enough since
    // it increments in spidclk. 
    // 
    // Bits[5:0], RW, default = 0x0
    //
    UINTX b0_clkgate_maxcntr : 6;
    //
    // Clock Gating register: IDLE timer counter max value for clock gating on TX . Counter
    // timeout based on last WRCMD/RDCMD received. 6 bits are good enough since it increments
    // in spidclk. 
    // 
    // Bits[11:6], RW, default = 0x0
    //
    UINTX b0_writeclkgate_maxcntr : 6;
    //
    // After wrcmd received, enable drven after scr_write_startdrv clocks.
    // 
    // Bits[14:12], RW, default = 0x0
    //
    UINTX b0_write_startdrv : 3;
    //
    // Stop the drven scr_write_stopdrv clocks before clock gated.
    // 
    // Bits[17:15], RW, default = 0x0
    //
    UINTX b0_write_stopdrv : 3;
    //
    // Clock Gating register: IDLE timer counter max value for clock gating on RX . Counter
    // timeout based on last WRCMD/RDCMD received. 6 bits are good enough since it increments
    // in spidclk. 
    // 
    // Bits[23:18], RW, default = 0x0
    //
    UINTX b0_readclkgate_maxcntr : 6;
    //
    // After rdcmd received, enable rden after scr_read_startrden clocks.
    // 
    // Bits[26:24], RW, default = 0x0
    //
    UINTX b0_read_startrden : 3;
    //
    // Stop the rden scr_read_stoprden  clocks before clock gated.
    // 
    // Bits[29:27], RW, default = 0x0
    //
    UINTX b0_read_stoprden : 3;
    //
    // Reserved
    // 
    // Bits[31:30], RO, default = 0x0
    //
    UINTX reserved : 2;
  } Bits;
  UINTX Data;
} CLKGATE1_BL0_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define WRLVL_BL0_DDRDQ_PHY_REG                            0x00000224
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write leveling RX data
    // 
    // Bits[3:0], RO/V, default = 0x0
    //
    UINTX b0n0_wrlvl_sample : 4;
    //
    // Write leveling RX data - ANDed together
    // 
    // Bits[4:4], RO/V, default = 0x0
    //
    UINTX b0n0_wrlvl_and_sample : 1;
    //
    // Write leveling RX data - ORed together
    // 
    // Bits[5:5], RO/V, default = 0x0
    //
    UINTX b0n0_wrlvl_or_sample : 1;
    //
    // Write leveling RX data
    // 
    // Bits[9:6], RO/V, default = 0x0
    //
    UINTX b0n1_wrlvl_sample : 4;
    //
    // Write leveling RX data - ANDed together
    // 
    // Bits[10:10], RO/V, default = 0x0
    //
    UINTX b0n1_wrlvl_and_sample : 1;
    //
    // Write leveling RX data - ORed together
    // 
    // Bits[11:11], RO/V, default = 0x0
    //
    UINTX b0n1_wrlvl_or_sample : 1;
    //
    // Reserved
    // 
    // Bits[31:12], RO, default = 0x0
    //
    UINTX reserved : 20;
  } Bits;
  UINTX Data;
} WRLVL_BL0_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define RCVENMARG_BL0_DDRDQ_PHY_REG                        0x00000228
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Receive enable margining data
    // 
    // Bits[0:0], RO/V, default = 0x0
    //
    UINTX b0n0_rcven_margin : 1;
    //
    // Receive enable margining data
    // 
    // Bits[1:1], RO/V, default = 0x0
    //
    UINTX b0n1_rcven_margin : 1;
    //
    // Reserved
    // 
    // Bits[31:2], RO, default = 0x0
    //
    UINTX reserved : 30;
  } Bits;
  UINTX Data;
} RCVENMARG_BL0_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define MRGMODE_BL0_DDRDQ_PHY_REG                          0x00000280
#ifndef ASM_INC
typedef union {
  struct {
    //
    // DFX margin mode TX fall data phase 0
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINTX b0_dfxmrgtxd_fall_ph0 : 1;
    //
    // DFX margin mode TX fall data phase 1
    // 
    // Bits[1:1], RW, default = 0x0
    //
    UINTX b0_dfxmrgtxd_fall_ph1 : 1;
    //
    // DFX margin mode TX rise data phase 0
    // 
    // Bits[2:2], RW, default = 0x0
    //
    UINTX b0_dfxmrgtxd_rise_ph0 : 1;
    //
    // DFX margin mode TX rise data phase 1
    // 
    // Bits[3:3], RW, default = 0x0
    //
    UINTX b0_dfxmrgtxd_rise_ph1 : 1;
    //
    // DFX margin mode RX compare values
    // 
    // Bits[11:4], RW, default = 0x0
    //
    UINTX b0_dfxmrgtxd_cmp : 8;
    //
    // DFX margin mode TX override enable
    // 
    // Bits[12:12], RW, default = 0x0
    //
    UINTX b0_dfxmrgtx_ovren : 1;
    //
    // DFX margin mode TX write enable
    // 
    // Bits[13:13], RW, default = 0x0
    //
    UINTX b0_dfxmrgtxwren : 1;
    //
    // Reserved
    // 
    // Bits[31:14], RO, default = 0x0
    //
    UINTX reserved : 18;
  } Bits;
  UINTX Data;
} MRGMODE_BL0_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define MRGMODE2_BL0_DDRDQ_PHY_REG                         0x00000284
#ifndef ASM_INC
typedef union {
  struct {
    //
    // DFX margin mode TX fall data phase 0 strobe
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINTX b0_dfxmrgtxdqsfall : 1;
    //
    // DFX margin mode TX rise data phase 1 strobe
    // 
    // Bits[1:1], RW, default = 0x0
    //
    UINTX b0_dfxmrgtxdqsrise : 1;
    //
    // Reserved
    // 
    // Bits[31:2], RO, default = 0x0
    //
    UINTX reserved : 30;
  } Bits;
  UINTX Data;
} MRGMODE2_BL0_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define DATLVL_BL0_DDRDQ_PHY_REG                           0x000002B0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Binary Vmode EQ (Deemphasis) coefficient.These bits will be set based on SIE input
    // to choose the Eq coef. value . Each bit represents each of the static legs. [br][2:0]
    // [br]------------------[br]000      TBD  [br]001      TBD[br]010      TBD[br]011
    //      TBD[br]100      TBD[br]101      TBD[br]110      TBD[br]111      TBD 
    // 
    // Bits[2:0], RW, default = 0x0
    //
    UINTX datlvl_b0_eqcoeff : 3;
    //
    // Tap select for Imode data.[br]0 : After the TCO delay cell(after first segment)
    // [br]1: after first delay cell(after second segment) 
    // 
    // Bits[3:3], RW, default = 0x1
    //
    UINTX datlvl_b0_imodedatadlysel : 1;
    //
    // This signal is purposed turn-on weak PU termination during Idle mode (drvenb=odtenb=iobufrstb=1).
    // Active low. It is recommended to enable it for DDR4 only due to PU termination.
    // 
    // Bits[4:4], RW, default = 0x0
    //
    UINTX datlvl_b0_idlemodepuen : 1;
    //
    // DQ Swing boost enable -  Active high.
    // 
    // Bits[8:5], RW, default = 0x0
    //
    UINTX datlvl_b0n0_dqswingboosten : 4;
    //
    // DQS Swing boost enable -  Active high.
    // 
    // Bits[9:9], RW, default = 0x0
    //
    UINTX datlvl_b0n0_dqsswingboosten : 1;
    //
    // DQ Swing boost enable -  Active high.
    // 
    // Bits[13:10], RW, default = 0x0
    //
    UINTX datlvl_b0n1_dqswingboosten : 4;
    //
    // DQS Swing boost enable -  Active high.
    // 
    // Bits[14:14], RW, default = 0x0
    //
    UINTX datlvl_b0n1_dqsswingboosten : 1;
    //
    // Reserved
    // 
    // Bits[31:15], RO, default = 0x0
    //
    UINTX reserved : 17;
  } Bits;
  UINTX Data;
} DATLVL_BL0_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define DQSTX_BL0_DDRDQ_PHY_REG                            0x000002B4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Fall TCO c73ddr402_COMP code
    // 
    // Bits[5:0], RW, default = 0x3F
    //
    UINTX dqstx_b0_tcocompfall : 6;
    //
    // Rise TCO c73ddr402_COMP code
    // 
    // Bits[11:6], RW, default = 0x3F
    //
    UINTX dqstx_b0_tcocomprise : 6;
    //
    // Reserved
    // 
    // Bits[31:12], RO, default = 0x0
    //
    UINTX reserved : 20;
  } Bits;
  UINTX Data;
} DQSTX_BL0_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define DXTX_BL0_2_DDRDQ_PHY_REG                           0x000002B8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // reserved
    // 
    // Bits[2:0], RW, default = 0x7
    //
    UINTX dxtx_b0r0_drvsegen_predfx : 3;
    //
    // reserved
    // 
    // Bits[5:3], RW, default = 0x7
    //
    UINTX dxtx_b0r1_drvsegen_predfx : 3;
    //
    // Reserved
    // 
    // Bits[31:6], RO, default = 0x0
    //
    UINTX reserved : 26;
  } Bits;
  UINTX Data;
} DXTX_BL0_2_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define DXTX_BL0_DDRDQ_PHY_REG                             0x000002BC
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Stretches falling edge of Buffer enable pulse to support Early DQ mode.  [br]00=default
    // pulse width[br] 01=minimum stretch on width[br]10=intermediate stretch on pulse[br]11=maximum
    // stretch on pulse. 
    // 
    // Bits[1:0], RW, default = 0x2
    //
    UINTX dxtx_b0_drvenstretch : 2;
    //
    // Bias control for Swing Boost Imode Buffer (00=1kohm (default), 01=0.5kohm, 10=0.25kohm,
    // 11=0.1kohm 
    // 
    // Bits[3:2], RW, default = 0x0
    //
    UINTX dqtx_b0_swingboostbiasctrl : 2;
    //
    // Binary Imode Coefficients, and will be set based on SIE input.[br]Coeff[3:0] 
    // %mV[br]------------------[br]0000        TBD  [br]0001        [br]0010       
    //  [br]  *  [br]  * [br]  *[br]1111       TBD 
    // 
    // Bits[7:4], RW, default = 0x0
    //
    UINTX dxtx_b0_imodecoeff : 4;
    //
    // Swing boost segment enable, support DFX Per leg test feature
    // 
    // Bits[11:8], RW, default = 0xF
    //
    UINTX dxtx_b0_swingboostsegen : 4;
    //
    // Fall TCO c73ddr402_COMP code
    // 
    // Bits[17:12], RW, default = 0x3F
    //
    UINTX dqtx_b0_tcocompfall : 6;
    //
    // Rise TCO c73ddr402_COMP code
    // 
    // Bits[23:18], RW, default = 0x3F
    //
    UINTX dqtx_b0_tcocomprise : 6;
    //
    // Transmitter segment enable. Only used to enable DFX Per Leg checks.
    // 
    // Bits[26:24], RW, default = 0x7
    //
    UINTX dqtx_b0_drvsegen : 3;
    //
    // delay cell static leg enable;support dfx per leg testing of delay cells in predriver
    // logic/delay c73ddr402_comp. 1: enabled (default) 0: disabled 
    // 
    // Bits[27:27], RW, default = 0x1
    //
    UINTX dxtx_b0_dlycellstaticlegen : 1;
    //
    // dfx legtest enable pin. Allows for independent control of the lower 4 legs of
    // the deley element which are controlled by the decoder. 1: enabled       0 : disbaled
    // (default) 
    // 
    // Bits[28:28], RW, default = 0x0
    //
    UINTX dx_b0_pbddfxtesten : 1;
    //
    // Reserved
    // 
    // Bits[31:29], RO, default = 0x0
    //
    UINTX reserved : 3;
  } Bits;
  UINTX Data;
} DXTX_BL0_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define DQRX_BL0_DDRDQ_PHY_REG                             0x000002C0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Enable offset cancellation mode (0= enable, 1 = disable (default)), share it with
    // tco delay cell 
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINTX dqrx_b0_ampoffseten : 1;
    //
    // Bias control for CTLE Amp (00=1kohm (default), 01=0.5kohm, 10=0.25kohm, 11=0.1kohm
    // 
    // Bits[3:1], RW, default = 0x0
    //
    UINTX rxbias_b0_ctlebiasctrl : 3;
    //
    // rxbiasovrval config. If rxbiasovren =1, rxbias = rxbiasovrval
    // 
    // Bits[4:4], RW, default = 0x0
    //
    UINTX rxbias_b0_biasovrval : 1;
    //
    // Override enable function: 0: rxbias is the same as diffampen function, 1: rxbias
    // is equal rxbiasovrval config 
    // 
    // Bits[5:5], RW, default = 0x0
    //
    UINTX rxbias_b0_biasovren : 1;
    //
    // CTLE enable
    // 
    // Bits[6:6], RW, default = 0x1
    //
    UINTX dqrx_b0_ctleen : 1;
    //
    // cap tuning, 00 = 0.5pF, 01 = 1pF, 10 = 1.5pF, 11 = 2pF
    // 
    // Bits[8:7], RW, default = 0x1
    //
    UINTX dqrx_b0_ctlecap : 2;
    //
    // resistor tuning ,00 = 0.5kOhm, 01 = 1kOhm, 10 = 1.5kOhm, 11 =2kOhm
    // 
    // Bits[10:9], RW, default = 0x0
    //
    UINTX dqrx_b0_ctleres : 2;
    //
    // Reserved
    // 
    // Bits[31:11], RO, default = 0x0
    //
    UINTX reserved : 21;
  } Bits;
  UINTX Data;
} DQRX_BL0_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define DQRX_B0N0_DDRDQ_PHY_REG                            0x000002C4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Tuning bits for offset cancellation
    // 
    // Bits[3:0], RW, default = 0x0
    //
    UINTX dqrx_b0n0dq0_ampoffset : 4;
    //
    // Tuning bits for offset cancellation
    // 
    // Bits[7:4], RW, default = 0x0
    //
    UINTX dqrx_b0n0dq1_ampoffset : 4;
    //
    // Tuning bits for offset cancellation
    // 
    // Bits[11:8], RW, default = 0x0
    //
    UINTX dqrx_b0n0dq2_ampoffset : 4;
    //
    // Tuning bits for offset cancellation
    // 
    // Bits[15:12], RW, default = 0x0
    //
    UINTX dqrx_b0n0dq3_ampoffset : 4;
    //
    // Reserved
    // 
    // Bits[31:16], RO, default = 0x0
    //
    UINTX reserved : 16;
  } Bits;
  UINTX Data;
} DQRX_B0N0_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define DQRX_B0N1_DDRDQ_PHY_REG                            0x000002C8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Tuning bits for offset cancellation
    // 
    // Bits[3:0], RW, default = 0x0
    //
    UINTX dqrx_b0n1dq0_ampoffset : 4;
    //
    // Tuning bits for offset cancellation
    // 
    // Bits[7:4], RW, default = 0x0
    //
    UINTX dqrx_b0n1dq1_ampoffset : 4;
    //
    // Tuning bits for offset cancellation
    // 
    // Bits[11:8], RW, default = 0x0
    //
    UINTX dqrx_b0n1dq2_ampoffset : 4;
    //
    // Tuning bits for offset cancellation
    // 
    // Bits[15:12], RW, default = 0x0
    //
    UINTX dqrx_b0n1dq3_ampoffset : 4;
    //
    // Reserved
    // 
    // Bits[31:16], RO, default = 0x0
    //
    UINTX reserved : 16;
  } Bits;
  UINTX Data;
} DQRX_B0N1_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define DQSRX_BL0_DDRDQ_PHY_REG                            0x000002CC
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Enable offset cancellation mode (0= enable, 1 = disable (default)), share it with
    // tco delay cell 
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINTX dqsrx_b0_ampoffseten : 1;
    //
    // CTLE enable
    // 
    // Bits[1:1], RW, default = 0x1
    //
    UINTX dqsrx_b0_ctleen : 1;
    //
    // This is the dqs counter reset signal. 0 = reset. Combined with PM control
    // 
    // Bits[2:2], RW, default = 0x0
    //
    UINTX dqsrx_b0_dqscountrstb : 1;
    //
    // Tuning bits for offset cancellation
    // 
    // Bits[6:3], RW, default = 0x0
    //
    UINTX dqsrx_b0n0_ampoffset : 4;
    //
    // Tuning bits for offset cancellation
    // 
    // Bits[10:7], RW, default = 0x0
    //
    UINTX dqsrx_b0n1_ampoffset : 4;
    //
    // cap tuning, 00 = 0.5pF, 01 = 1pF, 10 = 1.5pF, 11 = 2pF
    // 
    // Bits[12:11], RW, default = 0x1
    //
    UINTX dqsrx_b0_ctlecap : 2;
    //
    // resistor tuning ,00 = 0.5kOhm, 01 = 1kOhm, 10 = 1.5kOhm, 11 =2kOhm
    // 
    // Bits[14:13], RW, default = 0x0
    //
    UINTX dqsrx_b0_ctleres : 2;
    //
    // Dfx Rx enable for the Dqs/dqsb
    // 
    // Bits[15:15], RW, default = 0x0
    //
    UINTX dqsdfxrx_b0n0_dfxrxen : 1;
    //
    // Dfx Rx enable for the Dqs/dqsb
    // 
    // Bits[16:16], RW, default = 0x0
    //
    UINTX dqsdfxrx_b0n1_dfxrxen : 1;
    //
    // masking out the first dqs negedge during rcven handling in ddr4 (0-ddr4;1-ddr3l)
    // 
    // Bits[17:17], RW, default = 0x0
    //
    UINTX dqsrx_b0_dqsnegedgemask : 1;
    //
    // Reserved
    // 
    // Bits[31:18], RO, default = 0x0
    //
    UINTX reserved : 14;
  } Bits;
  UINTX Data;
} DQSRX_BL0_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define DQTXPBD0_B0N0_DDRDQ_PHY_REG                        0x000002D0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // DQ TX rank 0 bit 0 fine bit setting for tx per bit deskew
    // 
    // Bits[3:0], RW, default = 0xF
    //
    UINTX dqtxpbd_b0n0dq0_rk0fine : 4;
    //
    // DQ TX rank 0 bit 0 coarse bit setting for tx per bit deskew
    // 
    // Bits[9:4], RW, default = 0x3D
    //
    UINTX dqtxpbd_b0n0dq0_rk0coarse : 6;
    //
    // DQ TX rank 1 bit 0 fine bit setting for tx per bit deskew
    // 
    // Bits[13:10], RW, default = 0xF
    //
    UINTX dqtxpbd_b0n0dq0_rk1fine : 4;
    //
    // DQ TX rank 1 bit 0 coarse bit setting for tx per bit deskew
    // 
    // Bits[19:14], RW, default = 0x3D
    //
    UINTX dqtxpbd_b0n0dq0_rk1coarse : 6;
    //
    // per bit deskew enable . 1:enabled (default) 0:disabled
    // 
    // Bits[20:20], RW, default = 0x1
    //
    UINTX dqtxpbd_b0_en : 1;
    //
    // per bit deskew delay cell static leg enable;support dfx per leg testing of delay
    // cells in tx pbd. 1: enabled (default) 0: disabled 
    // 
    // Bits[21:21], RW, default = 0x1
    //
    UINTX dqtxpbd_b0_staticlegen : 1;
    //
    // Reserved
    // 
    // Bits[31:22], RO, default = 0x0
    //
    UINTX reserved : 10;
  } Bits;
  UINTX Data;
} DQTXPBD0_B0N0_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define DQTXPBD1_B0N0_DDRDQ_PHY_REG                        0x000002D4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // DQ TX rank 2 bit 0 fine bit setting for tx per bit deskew
    // 
    // Bits[3:0], RW, default = 0xF
    //
    UINTX dqtxpbd_b0n0dq0_rk2fine : 4;
    //
    // DQ TX rank 2 bit 0 coarse bit setting for tx per bit deskew
    // 
    // Bits[9:4], RW, default = 0x3D
    //
    UINTX dqtxpbd_b0n0dq0_rk2coarse : 6;
    //
    // DQ TX rank 3 bit 0 fine bit setting for tx per bit deskew
    // 
    // Bits[13:10], RW, default = 0xF
    //
    UINTX dqtxpbd_b0n0dq0_rk3fine : 4;
    //
    // DQ TX rank 3 bit 0 coarse bit setting for tx per bit deskew
    // 
    // Bits[19:14], RW, default = 0x3D
    //
    UINTX dqtxpbd_b0n0dq0_rk3coarse : 6;
    //
    // Reserved
    // 
    // Bits[31:20], RO, default = 0x0
    //
    UINTX reserved : 12;
  } Bits;
  UINTX Data;
} DQTXPBD1_B0N0_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define DQTXPBD2_B0N0_DDRDQ_PHY_REG                        0x000002D8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // DQ TX rank 0 bit 1 fine bit setting for tx per bit deskew
    // 
    // Bits[3:0], RW, default = 0xF
    //
    UINTX dqtxpbd_b0n0dq1_rk0fine : 4;
    //
    // DQ TX rank 0 bit 1 coarse bit setting for tx per bit deskew
    // 
    // Bits[9:4], RW, default = 0x3D
    //
    UINTX dqtxpbd_b0n0dq1_rk0coarse : 6;
    //
    // DQ TX rank 1 bit 1 fine bit setting for tx per bit deskew
    // 
    // Bits[13:10], RW, default = 0xF
    //
    UINTX dqtxpbd_b0n0dq1_rk1fine : 4;
    //
    // DQ TX rank 1 bit 1 coarse bit setting for tx per bit deskew
    // 
    // Bits[19:14], RW, default = 0x3D
    //
    UINTX dqtxpbd_b0n0dq1_rk1coarse : 6;
    //
    // Reserved
    // 
    // Bits[31:20], RO, default = 0x0
    //
    UINTX reserved : 12;
  } Bits;
  UINTX Data;
} DQTXPBD2_B0N0_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define DQTXPBD3_B0N0_DDRDQ_PHY_REG                        0x000002DC
#ifndef ASM_INC
typedef union {
  struct {
    //
    // DQ TX rank 2 bit 1 fine bit setting for tx per bit deskew
    // 
    // Bits[3:0], RW, default = 0xF
    //
    UINTX dqtxpbd_b0n0dq1_rk2fine : 4;
    //
    // DQ TX rank 2 bit 1 coarse bit setting for tx per bit deskew
    // 
    // Bits[9:4], RW, default = 0x3D
    //
    UINTX dqtxpbd_b0n0dq1_rk2coarse : 6;
    //
    // DQ TX rank 3 bit 1 fine bit setting for tx per bit deskew
    // 
    // Bits[13:10], RW, default = 0xF
    //
    UINTX dqtxpbd_b0n0dq1_rk3fine : 4;
    //
    // DQ TX rank 3 bit 1 coarse bit setting for tx per bit deskew
    // 
    // Bits[19:14], RW, default = 0x3D
    //
    UINTX dqtxpbd_b0n0dq1_rk3coarse : 6;
    //
    // Reserved
    // 
    // Bits[31:20], RO, default = 0x0
    //
    UINTX reserved : 12;
  } Bits;
  UINTX Data;
} DQTXPBD3_B0N0_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define DQTXPBD4_B0N0_DDRDQ_PHY_REG                        0x000002E0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // DQ TX rank 0 bit 2 fine bit setting for tx per bit deskew
    // 
    // Bits[3:0], RW, default = 0xF
    //
    UINTX dqtxpbd_b0n0dq2_rk0fine : 4;
    //
    // DQ TX rank 0 bit 2 coarse bit setting for tx per bit deskew
    // 
    // Bits[9:4], RW, default = 0x3D
    //
    UINTX dqtxpbd_b0n0dq2_rk0coarse : 6;
    //
    // DQ TX rank 1 bit 2 fine bit setting for tx per bit deskew
    // 
    // Bits[13:10], RW, default = 0xF
    //
    UINTX dqtxpbd_b0n0dq2_rk1fine : 4;
    //
    // DQ TX rank 1 bit 2 coarse bit setting for tx per bit deskew
    // 
    // Bits[19:14], RW, default = 0x3D
    //
    UINTX dqtxpbd_b0n0dq2_rk1coarse : 6;
    //
    // Reserved
    // 
    // Bits[31:20], RO, default = 0x0
    //
    UINTX reserved : 12;
  } Bits;
  UINTX Data;
} DQTXPBD4_B0N0_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define DQTXPBD5_B0N0_DDRDQ_PHY_REG                        0x000002E4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // DQ TX rank 2 bit 2 fine bit setting for tx per bit deskew
    // 
    // Bits[3:0], RW, default = 0xF
    //
    UINTX dqtxpbd_b0n0dq2_rk2fine : 4;
    //
    // DQ TX rank 2 bit 2 coarse bit setting for tx per bit deskew
    // 
    // Bits[9:4], RW, default = 0x3D
    //
    UINTX dqtxpbd_b0n0dq2_rk2coarse : 6;
    //
    // DQ TX rank 3 bit 2 fine bit setting for tx per bit deskew
    // 
    // Bits[13:10], RW, default = 0xF
    //
    UINTX dqtxpbd_b0n0dq2_rk3fine : 4;
    //
    // DQ TX rank 3 bit 2 coarse bit setting for tx per bit deskew
    // 
    // Bits[19:14], RW, default = 0x3D
    //
    UINTX dqtxpbd_b0n0dq2_rk3coarse : 6;
    //
    // Reserved
    // 
    // Bits[31:20], RO, default = 0x0
    //
    UINTX reserved : 12;
  } Bits;
  UINTX Data;
} DQTXPBD5_B0N0_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define DQTXPBD6_B0N0_DDRDQ_PHY_REG                        0x000002E8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // DQ TX rank 0 bit 3 fine bit setting for tx per bit deskew
    // 
    // Bits[3:0], RW, default = 0xF
    //
    UINTX dqtxpbd_b0n0dq3_rk0fine : 4;
    //
    // DQ TX rank 0 bit 3 coarse bit setting for tx per bit deskew
    // 
    // Bits[9:4], RW, default = 0x3D
    //
    UINTX dqtxpbd_b0n0dq3_rk0coarse : 6;
    //
    // DQ TX rank 1 bit 3 fine bit setting for tx per bit deskew
    // 
    // Bits[13:10], RW, default = 0xF
    //
    UINTX dqtxpbd_b0n0dq3_rk1fine : 4;
    //
    // DQ TX rank 1 bit 3 coarse bit setting for tx per bit deskew
    // 
    // Bits[19:14], RW, default = 0x3D
    //
    UINTX dqtxpbd_b0n0dq3_rk1coarse : 6;
    //
    // Reserved
    // 
    // Bits[31:20], RO, default = 0x0
    //
    UINTX reserved : 12;
  } Bits;
  UINTX Data;
} DQTXPBD6_B0N0_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define DQTXPBD7_B0N0_DDRDQ_PHY_REG                        0x000002EC
#ifndef ASM_INC
typedef union {
  struct {
    //
    // DQ TX rank 2 bit 3 fine bit setting for tx per bit deskew
    // 
    // Bits[3:0], RW, default = 0xF
    //
    UINTX dqtxpbd_b0n0dq3_rk2fine : 4;
    //
    // DQ TX rank 2 bit 3 coarse bit setting for tx per bit deskew
    // 
    // Bits[9:4], RW, default = 0x3D
    //
    UINTX dqtxpbd_b0n0dq3_rk2coarse : 6;
    //
    // DQ TX rank 3 bit 3 fine bit setting for tx per bit deskew
    // 
    // Bits[13:10], RW, default = 0xF
    //
    UINTX dqtxpbd_b0n0dq3_rk3fine : 4;
    //
    // DQ TX rank 3 bit 3 coarse bit setting for tx per bit deskew
    // 
    // Bits[19:14], RW, default = 0x3D
    //
    UINTX dqtxpbd_b0n0dq3_rk3coarse : 6;
    //
    // Reserved
    // 
    // Bits[31:20], RO, default = 0x0
    //
    UINTX reserved : 12;
  } Bits;
  UINTX Data;
} DQTXPBD7_B0N0_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define DQTXPBD0_B0N1_DDRDQ_PHY_REG                        0x000002F0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // DQ TX rank 0 bit 0 fine bit setting for tx per bit deskew
    // 
    // Bits[3:0], RW, default = 0xF
    //
    UINTX dqtxpbd_b0n1dq0_rk0fine : 4;
    //
    // DQ TX rank 0 bit 0 coarse bit setting for tx per bit deskew
    // 
    // Bits[9:4], RW, default = 0x3D
    //
    UINTX dqtxpbd_b0n1dq0_rk0coarse : 6;
    //
    // DQ TX rank 1 bit 0 fine bit setting for tx per bit deskew
    // 
    // Bits[13:10], RW, default = 0xF
    //
    UINTX dqtxpbd_b0n1dq0_rk1fine : 4;
    //
    // DQ TX rank 1 bit 0 coarse bit setting for tx per bit deskew
    // 
    // Bits[19:14], RW, default = 0x3D
    //
    UINTX dqtxpbd_b0n1dq0_rk1coarse : 6;
    //
    // Reserved
    // 
    // Bits[31:20], RO, default = 0x0
    //
    UINTX reserved : 12;
  } Bits;
  UINTX Data;
} DQTXPBD0_B0N1_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define DQTXPBD1_B0N1_DDRDQ_PHY_REG                        0x000002F4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // DQ TX rank 2 bit 0 fine bit setting for tx per bit deskew
    // 
    // Bits[3:0], RW, default = 0xF
    //
    UINTX dqtxpbd_b0n1dq0_rk2fine : 4;
    //
    // DQ TX rank 2 bit 0 coarse bit setting for tx per bit deskew
    // 
    // Bits[9:4], RW, default = 0x3D
    //
    UINTX dqtxpbd_b0n1dq0_rk2coarse : 6;
    //
    // DQ TX rank 3 bit 0 fine bit setting for tx per bit deskew
    // 
    // Bits[13:10], RW, default = 0xF
    //
    UINTX dqtxpbd_b0n1dq0_rk3fine : 4;
    //
    // DQ TX rank 3 bit 0 coarse bit setting for tx per bit deskew
    // 
    // Bits[19:14], RW, default = 0x3D
    //
    UINTX dqtxpbd_b0n1dq0_rk3coarse : 6;
    //
    // Reserved
    // 
    // Bits[31:20], RO, default = 0x0
    //
    UINTX reserved : 12;
  } Bits;
  UINTX Data;
} DQTXPBD1_B0N1_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define DQTXPBD2_B0N1_DDRDQ_PHY_REG                        0x000002F8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // DQ TX rank 0 bit 1 fine bit setting for tx per bit deskew
    // 
    // Bits[3:0], RW, default = 0xF
    //
    UINTX dqtxpbd_b0n1dq1_rk0fine : 4;
    //
    // DQ TX rank 0 bit 1 coarse bit setting for tx per bit deskew
    // 
    // Bits[9:4], RW, default = 0x3D
    //
    UINTX dqtxpbd_b0n1dq1_rk0coarse : 6;
    //
    // DQ TX rank 1 bit 1 fine bit setting for tx per bit deskew
    // 
    // Bits[13:10], RW, default = 0xF
    //
    UINTX dqtxpbd_b0n1dq1_rk1fine : 4;
    //
    // DQ TX rank 1 bit 1 coarse bit setting for tx per bit deskew
    // 
    // Bits[19:14], RW, default = 0x3D
    //
    UINTX dqtxpbd_b0n1dq1_rk1coarse : 6;
    //
    // Reserved
    // 
    // Bits[31:20], RO, default = 0x0
    //
    UINTX reserved : 12;
  } Bits;
  UINTX Data;
} DQTXPBD2_B0N1_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define DQTXPBD3_B0N1_DDRDQ_PHY_REG                        0x000002FC
#ifndef ASM_INC
typedef union {
  struct {
    //
    // DQ TX rank 2 bit 1 fine bit setting for tx per bit deskew
    // 
    // Bits[3:0], RW, default = 0xF
    //
    UINTX dqtxpbd_b0n1dq1_rk2fine : 4;
    //
    // DQ TX rank 2 bit 1 coarse bit setting for tx per bit deskew
    // 
    // Bits[9:4], RW, default = 0x3D
    //
    UINTX dqtxpbd_b0n1dq1_rk2coarse : 6;
    //
    // DQ TX rank 3 bit 1 fine bit setting for tx per bit deskew
    // 
    // Bits[13:10], RW, default = 0xF
    //
    UINTX dqtxpbd_b0n1dq1_rk3fine : 4;
    //
    // DQ TX rank 3 bit 1 coarse bit setting for tx per bit deskew
    // 
    // Bits[19:14], RW, default = 0x3D
    //
    UINTX dqtxpbd_b0n1dq1_rk3coarse : 6;
    //
    // Reserved
    // 
    // Bits[31:20], RO, default = 0x0
    //
    UINTX reserved : 12;
  } Bits;
  UINTX Data;
} DQTXPBD3_B0N1_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define DQTXPBD4_B0N1_DDRDQ_PHY_REG                        0x00000300
#ifndef ASM_INC
typedef union {
  struct {
    //
    // DQ TX rank 0 bit 2 fine bit setting for tx per bit deskew
    // 
    // Bits[3:0], RW, default = 0xF
    //
    UINTX dqtxpbd_b0n1dq2_rk0fine : 4;
    //
    // DQ TX rank 0 bit 2 coarse bit setting for tx per bit deskew
    // 
    // Bits[9:4], RW, default = 0x3D
    //
    UINTX dqtxpbd_b0n1dq2_rk0coarse : 6;
    //
    // DQ TX rank 1 bit 2 fine bit setting for tx per bit deskew
    // 
    // Bits[13:10], RW, default = 0xF
    //
    UINTX dqtxpbd_b0n1dq2_rk1fine : 4;
    //
    // DQ TX rank 1 bit 2 coarse bit setting for tx per bit deskew
    // 
    // Bits[19:14], RW, default = 0x3D
    //
    UINTX dqtxpbd_b0n1dq2_rk1coarse : 6;
    //
    // Reserved
    // 
    // Bits[31:20], RO, default = 0x0
    //
    UINTX reserved : 12;
  } Bits;
  UINTX Data;
} DQTXPBD4_B0N1_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define DQTXPBD5_B0N1_DDRDQ_PHY_REG                        0x00000304
#ifndef ASM_INC
typedef union {
  struct {
    //
    // DQ TX rank 2 bit 2 fine bit setting for tx per bit deskew
    // 
    // Bits[3:0], RW, default = 0xF
    //
    UINTX dqtxpbd_b0n1dq2_rk2fine : 4;
    //
    // DQ TX rank 2 bit 2 coarse bit setting for tx per bit deskew
    // 
    // Bits[9:4], RW, default = 0x3D
    //
    UINTX dqtxpbd_b0n1dq2_rk2coarse : 6;
    //
    // DQ TX rank 3 bit 2 fine bit setting for tx per bit deskew
    // 
    // Bits[13:10], RW, default = 0xF
    //
    UINTX dqtxpbd_b0n1dq2_rk3fine : 4;
    //
    // DQ TX rank 3 bit 2 coarse bit setting for tx per bit deskew
    // 
    // Bits[19:14], RW, default = 0x3D
    //
    UINTX dqtxpbd_b0n1dq2_rk3coarse : 6;
    //
    // Reserved
    // 
    // Bits[31:20], RO, default = 0x0
    //
    UINTX reserved : 12;
  } Bits;
  UINTX Data;
} DQTXPBD5_B0N1_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define DQTXPBD6_B0N1_DDRDQ_PHY_REG                        0x00000308
#ifndef ASM_INC
typedef union {
  struct {
    //
    // DQ TX rank 0 bit 3 fine bit setting for tx per bit deskew
    // 
    // Bits[3:0], RW, default = 0xF
    //
    UINTX dqtxpbd_b0n1dq3_rk0fine : 4;
    //
    // DQ TX rank 0 bit 3 coarse bit setting for tx per bit deskew
    // 
    // Bits[9:4], RW, default = 0x3D
    //
    UINTX dqtxpbd_b0n1dq3_rk0coarse : 6;
    //
    // DQ TX rank 1 bit 3 fine bit setting for tx per bit deskew
    // 
    // Bits[13:10], RW, default = 0xF
    //
    UINTX dqtxpbd_b0n1dq3_rk1fine : 4;
    //
    // DQ TX rank 1 bit 3 coarse bit setting for tx per bit deskew
    // 
    // Bits[19:14], RW, default = 0x3D
    //
    UINTX dqtxpbd_b0n1dq3_rk1coarse : 6;
    //
    // Reserved
    // 
    // Bits[31:20], RO, default = 0x0
    //
    UINTX reserved : 12;
  } Bits;
  UINTX Data;
} DQTXPBD6_B0N1_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define DQTXPBD7_B0N1_DDRDQ_PHY_REG                        0x0000030C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // DQ TX rank 2 bit 3 fine bit setting for tx per bit deskew
    // 
    // Bits[3:0], RW, default = 0xF
    //
    UINTX dqtxpbd_b0n1dq3_rk2fine : 4;
    //
    // DQ TX rank 2 bit 3 coarse bit setting for tx per bit deskew
    // 
    // Bits[9:4], RW, default = 0x3D
    //
    UINTX dqtxpbd_b0n1dq3_rk2coarse : 6;
    //
    // DQ TX rank 3 bit 3 fine bit setting for tx per bit deskew
    // 
    // Bits[13:10], RW, default = 0xF
    //
    UINTX dqtxpbd_b0n1dq3_rk3fine : 4;
    //
    // DQ TX rank 3 bit 3 coarse bit setting for tx per bit deskew
    // 
    // Bits[19:14], RW, default = 0x3D
    //
    UINTX dqtxpbd_b0n1dq3_rk3coarse : 6;
    //
    // Reserved
    // 
    // Bits[31:20], RO, default = 0x0
    //
    UINTX reserved : 12;
  } Bits;
  UINTX Data;
} DQTXPBD7_B0N1_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define DQSTXPBD0_B0N0_DDRDQ_PHY_REG                       0x00000310
#ifndef ASM_INC
typedef union {
  struct {
    //
    // DQS rank 0 fine bit setting for tx per bit deskew
    // 
    // Bits[3:0], RW, default = 0xF
    //
    UINTX dqstxpbd_b0n0_rk0fine : 4;
    //
    // DQS rank 0 coarse bit setting for tx per bit deskew
    // 
    // Bits[9:4], RW, default = 0x3D
    //
    UINTX dqstxpbd_b0n0_rk0coarse : 6;
    //
    // DQS rank 1 fine bit setting for tx per bit deskew
    // 
    // Bits[13:10], RW, default = 0xF
    //
    UINTX dqstxpbd_b0n0_rk1fine : 4;
    //
    // DQS rank 1 coarse bit setting for tx per bit deskew
    // 
    // Bits[19:14], RW, default = 0x3D
    //
    UINTX dqstxpbd_b0n0_rk1coarse : 6;
    //
    // per bit deskew enable . 1:enabled (default) 0:disabled
    // 
    // Bits[20:20], RW, default = 0x1
    //
    UINTX dqstxpbd_b0_en : 1;
    //
    // per bit deskew delay cell static leg enable;support dfx per leg testing of delay
    // cells in tx pbd. 1: enabled (default) 0: disabled 
    // 
    // Bits[21:21], RW, default = 0x1
    //
    UINTX dqstxpbd_b0_staticlegen : 1;
    //
    // Reserved
    // 
    // Bits[31:22], RO, default = 0x0
    //
    UINTX reserved : 10;
  } Bits;
  UINTX Data;
} DQSTXPBD0_B0N0_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define DQSTXPBD1_B0N0_DDRDQ_PHY_REG                       0x00000314
#ifndef ASM_INC
typedef union {
  struct {
    //
    // DQS rank 2 fine bit setting for tx per bit deskew
    // 
    // Bits[3:0], RW, default = 0xF
    //
    UINTX dqstxpbd_b0n0_rk2fine : 4;
    //
    // DQS rank 2 coarse bit setting for tx per bit deskew
    // 
    // Bits[9:4], RW, default = 0x3D
    //
    UINTX dqstxpbd_b0n0_rk2coarse : 6;
    //
    // DQS rank 3 fine bit setting for tx per bit deskew
    // 
    // Bits[13:10], RW, default = 0xF
    //
    UINTX dqstxpbd_b0n0_rk3fine : 4;
    //
    // DQS rank 3 coarse bit setting for tx per bit deskew
    // 
    // Bits[19:14], RW, default = 0x3D
    //
    UINTX dqstxpbd_b0n0_rk3coarse : 6;
    //
    // Reserved
    // 
    // Bits[31:20], RO, default = 0x0
    //
    UINTX reserved : 12;
  } Bits;
  UINTX Data;
} DQSTXPBD1_B0N0_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define DQSTXPBD0_B0N1_DDRDQ_PHY_REG                       0x00000318
#ifndef ASM_INC
typedef union {
  struct {
    //
    // DQS rank 0 fine bit setting for tx per bit deskew
    // 
    // Bits[3:0], RW, default = 0xF
    //
    UINTX dqstxpbd_b0n1_rk0fine : 4;
    //
    // DQS rank 0 coarse bit setting for tx per bit deskew
    // 
    // Bits[9:4], RW, default = 0x3D
    //
    UINTX dqstxpbd_b0n1_rk0coarse : 6;
    //
    // DQS rank 1 fine bit setting for tx per bit deskew
    // 
    // Bits[13:10], RW, default = 0xF
    //
    UINTX dqstxpbd_b0n1_rk1fine : 4;
    //
    // DQS rank 1 coarse bit setting for tx per bit deskew
    // 
    // Bits[19:14], RW, default = 0x3D
    //
    UINTX dqstxpbd_b0n1_rk1coarse : 6;
    //
    // Reserved
    // 
    // Bits[31:20], RO, default = 0x0
    //
    UINTX reserved : 12;
  } Bits;
  UINTX Data;
} DQSTXPBD0_B0N1_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define DQSTXPBD1_B0N1_DDRDQ_PHY_REG                       0x0000031C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // DQS rank 2 fine bit setting for tx per bit deskew
    // 
    // Bits[3:0], RW, default = 0xF
    //
    UINTX dqstxpbd_b0n1_rk2fine : 4;
    //
    // DQS rank 2 coarse bit setting for tx per bit deskew
    // 
    // Bits[9:4], RW, default = 0x3D
    //
    UINTX dqstxpbd_b0n1_rk2coarse : 6;
    //
    // DQS rank 3 fine bit setting for tx per bit deskew
    // 
    // Bits[13:10], RW, default = 0xF
    //
    UINTX dqstxpbd_b0n1_rk3fine : 4;
    //
    // DQS rank 3 coarse bit setting for tx per bit deskew
    // 
    // Bits[19:14], RW, default = 0x3D
    //
    UINTX dqstxpbd_b0n1_rk3coarse : 6;
    //
    // Reserved
    // 
    // Bits[31:20], RO, default = 0x0
    //
    UINTX reserved : 12;
  } Bits;
  UINTX Data;
} DQSTXPBD1_B0N1_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define DQRXPBD0_B0N0_DDRDQ_PHY_REG                        0x00000320
#ifndef ASM_INC
typedef union {
  struct {
    //
    // DQ RX rank 0 bit 0 fine bit setting for rx per bit deskew
    // 
    // Bits[3:0], RW, default = 0xF
    //
    UINTX dqrxpbd_b0n0dq0_rk0fine : 4;
    //
    // DQ RX rank 0 bit 0 coarse bit setting for rx per bit deskew
    // 
    // Bits[9:4], RW, default = 0x3D
    //
    UINTX dqrxpbd_b0n0dq0_rk0coarse : 6;
    //
    // DQ RX rank 1 bit 0 fine bit setting for rx per bit deskew
    // 
    // Bits[13:10], RW, default = 0xF
    //
    UINTX dqrxpbd_b0n0dq0_rk1fine : 4;
    //
    // DQ RX rank 1 bit 0 coarse bit setting for rx per bit deskew
    // 
    // Bits[19:14], RW, default = 0x3D
    //
    UINTX dqrxpbd_b0n0dq0_rk1coarse : 6;
    //
    // per bit deskew enable . 1:enabled (default) 0:disabled
    // 
    // Bits[20:20], RW, default = 0x1
    //
    UINTX dqrxpbd_b0_en : 1;
    //
    // per bit deskew delay cell static leg enable;support dfx per leg testing of delay
    // cells in rx pbd. 1: enabled (default) 0: disabled 
    // 
    // Bits[21:21], RW, default = 0x1
    //
    UINTX dqrxpbd_b0_staticlegen : 1;
    //
    // Reserved
    // 
    // Bits[31:22], RO, default = 0x0
    //
    UINTX reserved : 10;
  } Bits;
  UINTX Data;
} DQRXPBD0_B0N0_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define DQRXPBD1_B0N0_DDRDQ_PHY_REG                        0x00000324
#ifndef ASM_INC
typedef union {
  struct {
    //
    // DQ RX rank 2 bit 0 fine bit setting for rx per bit deskew
    // 
    // Bits[3:0], RW, default = 0xF
    //
    UINTX dqrxpbd_b0n0dq0_rk2fine : 4;
    //
    // DQ RX rank 2 bit 0 coarse bit setting for rx per bit deskew
    // 
    // Bits[9:4], RW, default = 0x3D
    //
    UINTX dqrxpbd_b0n0dq0_rk2coarse : 6;
    //
    // DQ RX rank 3 bit 0 fine bit setting for rx per bit deskew
    // 
    // Bits[13:10], RW, default = 0xF
    //
    UINTX dqrxpbd_b0n0dq0_rk3fine : 4;
    //
    // DQ RX rank 3 bit 0 coarse bit setting for rx per bit deskew
    // 
    // Bits[19:14], RW, default = 0x3D
    //
    UINTX dqrxpbd_b0n0dq0_rk3coarse : 6;
    //
    // Reserved
    // 
    // Bits[31:20], RO, default = 0x0
    //
    UINTX reserved : 12;
  } Bits;
  UINTX Data;
} DQRXPBD1_B0N0_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define DQRXPBD2_B0N0_DDRDQ_PHY_REG                        0x00000328
#ifndef ASM_INC
typedef union {
  struct {
    //
    // DQ RX rank 0 bit 1 fine bit setting for rx per bit deskew
    // 
    // Bits[3:0], RW, default = 0xF
    //
    UINTX dqrxpbd_b0n0dq1_rk0fine : 4;
    //
    // DQ RX rank 0 bit 1 coarse bit setting for rx per bit deskew
    // 
    // Bits[9:4], RW, default = 0x3D
    //
    UINTX dqrxpbd_b0n0dq1_rk0coarse : 6;
    //
    // DQ RX rank 1 bit 1 fine bit setting for rx per bit deskew
    // 
    // Bits[13:10], RW, default = 0xF
    //
    UINTX dqrxpbd_b0n0dq1_rk1fine : 4;
    //
    // DQ RX rank 1 bit 1 coarse bit setting for rx per bit deskew
    // 
    // Bits[19:14], RW, default = 0x3D
    //
    UINTX dqrxpbd_b0n0dq1_rk1coarse : 6;
    //
    // Reserved
    // 
    // Bits[31:20], RO, default = 0x0
    //
    UINTX reserved : 12;
  } Bits;
  UINTX Data;
} DQRXPBD2_B0N0_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define DQRXPBD3_B0N0_DDRDQ_PHY_REG                        0x0000032C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // DQ RX rank 2 bit 1 fine bit setting for rx per bit deskew
    // 
    // Bits[3:0], RW, default = 0xF
    //
    UINTX dqrxpbd_b0n0dq1_rk2fine : 4;
    //
    // DQ RX rank 2 bit 1 coarse bit setting for rx per bit deskew
    // 
    // Bits[9:4], RW, default = 0x3D
    //
    UINTX dqrxpbd_b0n0dq1_rk2coarse : 6;
    //
    // DQ RX rank 3 bit 1 fine bit setting for rx per bit deskew
    // 
    // Bits[13:10], RW, default = 0xF
    //
    UINTX dqrxpbd_b0n0dq1_rk3fine : 4;
    //
    // DQ RX rank 3 bit 1 coarse bit setting for rx per bit deskew
    // 
    // Bits[19:14], RW, default = 0x3D
    //
    UINTX dqrxpbd_b0n0dq1_rk3coarse : 6;
    //
    // Reserved
    // 
    // Bits[31:20], RO, default = 0x0
    //
    UINTX reserved : 12;
  } Bits;
  UINTX Data;
} DQRXPBD3_B0N0_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define DQRXPBD4_B0N0_DDRDQ_PHY_REG                        0x00000330
#ifndef ASM_INC
typedef union {
  struct {
    //
    // DQ RX rank 0 bit 2 fine bit setting for rx per bit deskew
    // 
    // Bits[3:0], RW, default = 0xF
    //
    UINTX dqrxpbd_b0n0dq2_rk0fine : 4;
    //
    // DQ RX rank 0 bit 2 coarse bit setting for rx per bit deskew
    // 
    // Bits[9:4], RW, default = 0x3D
    //
    UINTX dqrxpbd_b0n0dq2_rk0coarse : 6;
    //
    // DQ RX rank 1 bit 2 fine bit setting for rx per bit deskew
    // 
    // Bits[13:10], RW, default = 0xF
    //
    UINTX dqrxpbd_b0n0dq2_rk1fine : 4;
    //
    // DQ RX rank 1 bit 2 coarse bit setting for rx per bit deskew
    // 
    // Bits[19:14], RW, default = 0x3D
    //
    UINTX dqrxpbd_b0n0dq2_rk1coarse : 6;
    //
    // Reserved
    // 
    // Bits[31:20], RO, default = 0x0
    //
    UINTX reserved : 12;
  } Bits;
  UINTX Data;
} DQRXPBD4_B0N0_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define DQRXPBD5_B0N0_DDRDQ_PHY_REG                        0x00000334
#ifndef ASM_INC
typedef union {
  struct {
    //
    // DQ RX rank 2 bit 2 fine bit setting for rx per bit deskew
    // 
    // Bits[3:0], RW, default = 0xF
    //
    UINTX dqrxpbd_b0n0dq2_rk2fine : 4;
    //
    // DQ RX rank 2 bit 2 coarse bit setting for rx per bit deskew
    // 
    // Bits[9:4], RW, default = 0x3D
    //
    UINTX dqrxpbd_b0n0dq2_rk2coarse : 6;
    //
    // DQ RX rank 3 bit 2 fine bit setting for rx per bit deskew
    // 
    // Bits[13:10], RW, default = 0xF
    //
    UINTX dqrxpbd_b0n0dq2_rk3fine : 4;
    //
    // DQ RX rank 3 bit 2 coarse bit setting for rx per bit deskew
    // 
    // Bits[19:14], RW, default = 0x3D
    //
    UINTX dqrxpbd_b0n0dq2_rk3coarse : 6;
    //
    // Reserved
    // 
    // Bits[31:20], RO, default = 0x0
    //
    UINTX reserved : 12;
  } Bits;
  UINTX Data;
} DQRXPBD5_B0N0_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define DQRXPBD6_B0N0_DDRDQ_PHY_REG                        0x00000338
#ifndef ASM_INC
typedef union {
  struct {
    //
    // DQ RX rank 0 bit 3 fine bit setting for rx per bit deskew
    // 
    // Bits[3:0], RW, default = 0xF
    //
    UINTX dqrxpbd_b0n0dq3_rk0fine : 4;
    //
    // DQ RX rank 0 bit 3 coarse bit setting for rx per bit deskew
    // 
    // Bits[9:4], RW, default = 0x3D
    //
    UINTX dqrxpbd_b0n0dq3_rk0coarse : 6;
    //
    // DQ RX rank 1 bit 3 fine bit setting for rx per bit deskew
    // 
    // Bits[13:10], RW, default = 0xF
    //
    UINTX dqrxpbd_b0n0dq3_rk1fine : 4;
    //
    // DQ RX rank 1 bit 3 coarse bit setting for rx per bit deskew
    // 
    // Bits[19:14], RW, default = 0x3D
    //
    UINTX dqrxpbd_b0n0dq3_rk1coarse : 6;
    //
    // Reserved
    // 
    // Bits[31:20], RO, default = 0x0
    //
    UINTX reserved : 12;
  } Bits;
  UINTX Data;
} DQRXPBD6_B0N0_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define DQRXPBD7_B0N0_DDRDQ_PHY_REG                        0x0000033C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // DQ RX rank 2 bit 3 fine bit setting for rx per bit deskew
    // 
    // Bits[3:0], RW, default = 0xF
    //
    UINTX dqrxpbd_b0n0dq3_rk2fine : 4;
    //
    // DQ RX rank 2 bit 3 coarse bit setting for rx per bit deskew
    // 
    // Bits[9:4], RW, default = 0x3D
    //
    UINTX dqrxpbd_b0n0dq3_rk2coarse : 6;
    //
    // DQ RX rank 3 bit 3 fine bit setting for rx per bit deskew
    // 
    // Bits[13:10], RW, default = 0xF
    //
    UINTX dqrxpbd_b0n0dq3_rk3fine : 4;
    //
    // DQ RX rank 3 bit 3 coarse bit setting for rx per bit deskew
    // 
    // Bits[19:14], RW, default = 0x3D
    //
    UINTX dqrxpbd_b0n0dq3_rk3coarse : 6;
    //
    // Reserved
    // 
    // Bits[31:20], RO, default = 0x0
    //
    UINTX reserved : 12;
  } Bits;
  UINTX Data;
} DQRXPBD7_B0N0_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define DQRXPBD0_B0N1_DDRDQ_PHY_REG                        0x00000340
#ifndef ASM_INC
typedef union {
  struct {
    //
    // DQ RX rank 0 bit 0 fine bit setting for rx per bit deskew
    // 
    // Bits[3:0], RW, default = 0xF
    //
    UINTX dqrxpbd_b0n1dq0_rk0fine : 4;
    //
    // DQ RX rank 0 bit 0 coarse bit setting for rx per bit deskew
    // 
    // Bits[9:4], RW, default = 0x3D
    //
    UINTX dqrxpbd_b0n1dq0_rk0coarse : 6;
    //
    // DQ RX rank 1 bit 0 fine bit setting for rx per bit deskew
    // 
    // Bits[13:10], RW, default = 0xF
    //
    UINTX dqrxpbd_b0n1dq0_rk1fine : 4;
    //
    // DQ RX rank 1 bit 0 coarse bit setting for rx per bit deskew
    // 
    // Bits[19:14], RW, default = 0x3D
    //
    UINTX dqrxpbd_b0n1dq0_rk1coarse : 6;
    //
    // Reserved
    // 
    // Bits[31:20], RO, default = 0x0
    //
    UINTX reserved : 12;
  } Bits;
  UINTX Data;
} DQRXPBD0_B0N1_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define DQRXPBD1_B0N1_DDRDQ_PHY_REG                        0x00000344
#ifndef ASM_INC
typedef union {
  struct {
    //
    // DQ RX rank 2 bit 0 fine bit setting for rx per bit deskew
    // 
    // Bits[3:0], RW, default = 0xF
    //
    UINTX dqrxpbd_b0n1dq0_rk2fine : 4;
    //
    // DQ RX rank 2 bit 0 coarse bit setting for rx per bit deskew
    // 
    // Bits[9:4], RW, default = 0x3D
    //
    UINTX dqrxpbd_b0n1dq0_rk2coarse : 6;
    //
    // DQ RX rank 3 bit 0 fine bit setting for rx per bit deskew
    // 
    // Bits[13:10], RW, default = 0xF
    //
    UINTX dqrxpbd_b0n1dq0_rk3fine : 4;
    //
    // DQ RX rank 3 bit 0 coarse bit setting for rx per bit deskew
    // 
    // Bits[19:14], RW, default = 0x3D
    //
    UINTX dqrxpbd_b0n1dq0_rk3coarse : 6;
    //
    // Reserved
    // 
    // Bits[31:20], RO, default = 0x0
    //
    UINTX reserved : 12;
  } Bits;
  UINTX Data;
} DQRXPBD1_B0N1_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define DQRXPBD2_B0N1_DDRDQ_PHY_REG                        0x00000348
#ifndef ASM_INC
typedef union {
  struct {
    //
    // DQ RX rank 0 bit 1 fine bit setting for rx per bit deskew
    // 
    // Bits[3:0], RW, default = 0xF
    //
    UINTX dqrxpbd_b0n1dq1_rk0fine : 4;
    //
    // DQ RX rank 0 bit 1 coarse bit setting for rx per bit deskew
    // 
    // Bits[9:4], RW, default = 0x3D
    //
    UINTX dqrxpbd_b0n1dq1_rk0coarse : 6;
    //
    // DQ RX rank 1 bit 1 fine bit setting for rx per bit deskew
    // 
    // Bits[13:10], RW, default = 0xF
    //
    UINTX dqrxpbd_b0n1dq1_rk1fine : 4;
    //
    // DQ RX rank 1 bit 1 coarse bit setting for rx per bit deskew
    // 
    // Bits[19:14], RW, default = 0x3D
    //
    UINTX dqrxpbd_b0n1dq1_rk1coarse : 6;
    //
    // Reserved
    // 
    // Bits[31:20], RO, default = 0x0
    //
    UINTX reserved : 12;
  } Bits;
  UINTX Data;
} DQRXPBD2_B0N1_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define DQRXPBD3_B0N1_DDRDQ_PHY_REG                        0x0000034C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // DQ RX rank 2 bit 1 fine bit setting for rx per bit deskew
    // 
    // Bits[3:0], RW, default = 0xF
    //
    UINTX dqrxpbd_b0n1dq1_rk2fine : 4;
    //
    // DQ RX rank 2 bit 1 coarse bit setting for rx per bit deskew
    // 
    // Bits[9:4], RW, default = 0x3D
    //
    UINTX dqrxpbd_b0n1dq1_rk2coarse : 6;
    //
    // DQ RX rank 3 bit 1 fine bit setting for rx per bit deskew
    // 
    // Bits[13:10], RW, default = 0xF
    //
    UINTX dqrxpbd_b0n1dq1_rk3fine : 4;
    //
    // DQ RX rank 3 bit 1 coarse bit setting for rx per bit deskew
    // 
    // Bits[19:14], RW, default = 0x3D
    //
    UINTX dqrxpbd_b0n1dq1_rk3coarse : 6;
    //
    // Reserved
    // 
    // Bits[31:20], RO, default = 0x0
    //
    UINTX reserved : 12;
  } Bits;
  UINTX Data;
} DQRXPBD3_B0N1_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define DQRXPBD4_B0N1_DDRDQ_PHY_REG                        0x00000350
#ifndef ASM_INC
typedef union {
  struct {
    //
    // DQ RX rank 0 bit 2 fine bit setting for rx per bit deskew
    // 
    // Bits[3:0], RW, default = 0xF
    //
    UINTX dqrxpbd_b0n1dq2_rk0fine : 4;
    //
    // DQ RX rank 0 bit 2 coarse bit setting for rx per bit deskew
    // 
    // Bits[9:4], RW, default = 0x3D
    //
    UINTX dqrxpbd_b0n1dq2_rk0coarse : 6;
    //
    // DQ RX rank 1 bit 2 fine bit setting for rx per bit deskew
    // 
    // Bits[13:10], RW, default = 0xF
    //
    UINTX dqrxpbd_b0n1dq2_rk1fine : 4;
    //
    // DQ RX rank 1 bit 2 coarse bit setting for rx per bit deskew
    // 
    // Bits[19:14], RW, default = 0x3D
    //
    UINTX dqrxpbd_b0n1dq2_rk1coarse : 6;
    //
    // Reserved
    // 
    // Bits[31:20], RO, default = 0x0
    //
    UINTX reserved : 12;
  } Bits;
  UINTX Data;
} DQRXPBD4_B0N1_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define DQRXPBD5_B0N1_DDRDQ_PHY_REG                        0x00000354
#ifndef ASM_INC
typedef union {
  struct {
    //
    // DQ RX rank 2 bit 2 fine bit setting for rx per bit deskew
    // 
    // Bits[3:0], RW, default = 0xF
    //
    UINTX dqrxpbd_b0n1dq2_rk2fine : 4;
    //
    // DQ RX rank 2 bit 2 coarse bit setting for rx per bit deskew
    // 
    // Bits[9:4], RW, default = 0x3D
    //
    UINTX dqrxpbd_b0n1dq2_rk2coarse : 6;
    //
    // DQ RX rank 3 bit 2 fine bit setting for rx per bit deskew
    // 
    // Bits[13:10], RW, default = 0xF
    //
    UINTX dqrxpbd_b0n1dq2_rk3fine : 4;
    //
    // DQ RX rank 3 bit 2 coarse bit setting for rx per bit deskew
    // 
    // Bits[19:14], RW, default = 0x3D
    //
    UINTX dqrxpbd_b0n1dq2_rk3coarse : 6;
    //
    // Reserved
    // 
    // Bits[31:20], RO, default = 0x0
    //
    UINTX reserved : 12;
  } Bits;
  UINTX Data;
} DQRXPBD5_B0N1_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define DQRXPBD6_B0N1_DDRDQ_PHY_REG                        0x00000358
#ifndef ASM_INC
typedef union {
  struct {
    //
    // DQ RX rank 0 bit 3 fine bit setting for rx per bit deskew
    // 
    // Bits[3:0], RW, default = 0xF
    //
    UINTX dqrxpbd_b0n1dq3_rk0fine : 4;
    //
    // DQ RX rank 0 bit 3 coarse bit setting for rx per bit deskew
    // 
    // Bits[9:4], RW, default = 0x3D
    //
    UINTX dqrxpbd_b0n1dq3_rk0coarse : 6;
    //
    // DQ RX rank 1 bit 3 fine bit setting for rx per bit deskew
    // 
    // Bits[13:10], RW, default = 0xF
    //
    UINTX dqrxpbd_b0n1dq3_rk1fine : 4;
    //
    // DQ RX rank 1 bit 3 coarse bit setting for rx per bit deskew
    // 
    // Bits[19:14], RW, default = 0x3D
    //
    UINTX dqrxpbd_b0n1dq3_rk1coarse : 6;
    //
    // Reserved
    // 
    // Bits[31:20], RO, default = 0x0
    //
    UINTX reserved : 12;
  } Bits;
  UINTX Data;
} DQRXPBD6_B0N1_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define DQRXPBD7_B0N1_DDRDQ_PHY_REG                        0x0000035C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // DQ RX rank 2 bit 3 fine bit setting for rx per bit deskew
    // 
    // Bits[3:0], RW, default = 0xF
    //
    UINTX dqrxpbd_b0n1dq3_rk2fine : 4;
    //
    // DQ RX rank 2 bit 3 coarse bit setting for rx per bit deskew
    // 
    // Bits[9:4], RW, default = 0x3D
    //
    UINTX dqrxpbd_b0n1dq3_rk2coarse : 6;
    //
    // DQ RX rank 3 bit 3 fine bit setting for rx per bit deskew
    // 
    // Bits[13:10], RW, default = 0xF
    //
    UINTX dqrxpbd_b0n1dq3_rk3fine : 4;
    //
    // DQ RX rank 3 bit 3 coarse bit setting for rx per bit deskew
    // 
    // Bits[19:14], RW, default = 0x3D
    //
    UINTX dqrxpbd_b0n1dq3_rk3coarse : 6;
    //
    // Reserved
    // 
    // Bits[31:20], RO, default = 0x0
    //
    UINTX reserved : 12;
  } Bits;
  UINTX Data;
} DQRXPBD7_B0N1_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define DQSRXPBD0_B0N0_DDRDQ_PHY_REG                       0x00000360
#ifndef ASM_INC
typedef union {
  struct {
    //
    // DQS RX rank 0 fine bit setting for rx per bit deskew
    // 
    // Bits[3:0], RW, default = 0xF
    //
    UINTX dqsrxpbd_b0n0_rk0fine : 4;
    //
    // DQS RX rank 0 coarse bit setting for rx per bit deskew
    // 
    // Bits[9:4], RW, default = 0x3D
    //
    UINTX dqsrxpbd_b0n0_rk0coarse : 6;
    //
    // DQS RX rank 1 fine bit setting for rx per bit deskew
    // 
    // Bits[13:10], RW, default = 0xF
    //
    UINTX dqsrxpbd_b0n0_rk1fine : 4;
    //
    // DQS RX rank 1 coarse bit setting for rx per bit deskew
    // 
    // Bits[19:14], RW, default = 0x3D
    //
    UINTX dqsrxpbd_b0n0_rk1coarse : 6;
    //
    // DQS per bit deskew enable . 1:enabled (default) 0:disabled
    // 
    // Bits[20:20], RW, default = 0x1
    //
    UINTX dqsrxpbd_b0_en : 1;
    //
    // DQS per bit deskew delay cell static leg enable;support dfx per leg testing of
    // delay cells in rx pbd. 1: enabled (default) 0: disabled 
    // 
    // Bits[21:21], RW, default = 0x1
    //
    UINTX dqsrxpbd_b0_staticlegen : 1;
    //
    // Reserved
    // 
    // Bits[31:22], RO, default = 0x0
    //
    UINTX reserved : 10;
  } Bits;
  UINTX Data;
} DQSRXPBD0_B0N0_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define DQSRXPBD1_B0N0_DDRDQ_PHY_REG                       0x00000364
#ifndef ASM_INC
typedef union {
  struct {
    //
    // DQS RX rank 0 fine bit setting for rx per bit deskew
    // 
    // Bits[3:0], RW, default = 0xF
    //
    UINTX dqsrxpbd_b0n0_rk2fine : 4;
    //
    // DQS RX rank 0 coarse bit setting for rx per bit deskew
    // 
    // Bits[9:4], RW, default = 0x3D
    //
    UINTX dqsrxpbd_b0n0_rk2coarse : 6;
    //
    // DQS RX rank 1 fine bit setting for rx per bit deskew
    // 
    // Bits[13:10], RW, default = 0xF
    //
    UINTX dqsrxpbd_b0n0_rk3fine : 4;
    //
    // DQS RX rank 1 coarse bit setting for rx per bit deskew
    // 
    // Bits[19:14], RW, default = 0x3D
    //
    UINTX dqsrxpbd_b0n0_rk3coarse : 6;
    //
    // Reserved
    // 
    // Bits[31:20], RO, default = 0x0
    //
    UINTX reserved : 12;
  } Bits;
  UINTX Data;
} DQSRXPBD1_B0N0_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define DQSRXPBD0_B0N1_DDRDQ_PHY_REG                       0x00000368
#ifndef ASM_INC
typedef union {
  struct {
    //
    // DQS RX rank 0 fine bit setting for rx per bit deskew
    // 
    // Bits[3:0], RW, default = 0xF
    //
    UINTX dqsrxpbd_b0n1_rk0fine : 4;
    //
    // DQS RX rank 0 coarse bit setting for rx per bit deskew
    // 
    // Bits[9:4], RW, default = 0x3D
    //
    UINTX dqsrxpbd_b0n1_rk0coarse : 6;
    //
    // DQS RX rank 1 fine bit setting for rx per bit deskew
    // 
    // Bits[13:10], RW, default = 0xF
    //
    UINTX dqsrxpbd_b0n1_rk1fine : 4;
    //
    // DQS RX rank 1 coarse bit setting for rx per bit deskew
    // 
    // Bits[19:14], RW, default = 0x3D
    //
    UINTX dqsrxpbd_b0n1_rk1coarse : 6;
    //
    // Reserved
    // 
    // Bits[31:20], RO, default = 0x0
    //
    UINTX reserved : 12;
  } Bits;
  UINTX Data;
} DQSRXPBD0_B0N1_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define DQSRXPBD1_B0N1_DDRDQ_PHY_REG                       0x0000036C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // DQS RX rank 0 fine bit setting for rx per bit deskew
    // 
    // Bits[3:0], RW, default = 0xF
    //
    UINTX dqsrxpbd_b0n1_rk2fine : 4;
    //
    // DQS RX rank 0 coarse bit setting for rx per bit deskew
    // 
    // Bits[9:4], RW, default = 0x3D
    //
    UINTX dqsrxpbd_b0n1_rk2coarse : 6;
    //
    // DQS RX rank 1 fine bit setting for rx per bit deskew
    // 
    // Bits[13:10], RW, default = 0xF
    //
    UINTX dqsrxpbd_b0n1_rk3fine : 4;
    //
    // DQS RX rank 1 coarse bit setting for rx per bit deskew
    // 
    // Bits[19:14], RW, default = 0x3D
    //
    UINTX dqsrxpbd_b0n1_rk3coarse : 6;
    //
    // Reserved
    // 
    // Bits[31:20], RO, default = 0x0
    //
    UINTX reserved : 12;
  } Bits;
  UINTX Data;
} DQSRXPBD1_B0N1_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define RXDLLCFG_B0N0_DDRDQ_PHY_REG                        0x00000370
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Slave Delay line enable signal. 1= power up DL, 0= power down DL
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINTX rxdll_b0n0_dqssdllen : 1;
    //
    // Enable DQS PI block. 1= enable DQS PI block, 0=disable DQS PI block
    // 
    // Bits[1:1], RW, default = 0x0
    //
    UINTX rxdll_b0n0_dqspien : 1;
    //
    // DQS PI output gate enable. 1= gate DQS output off, 0= DQS output not gated
    // 
    // Bits[2:2], RW, default = 0x0
    //
    UINTX rxdll_b0n0_dqspiouten : 1;
    //
    // Enable DQSB PI block. 1= enable DQSB PI block, 0=disable DQSB PI block
    // 
    // Bits[3:3], RW, default = 0x0
    //
    UINTX rxdll_b0n0_dqsbpien : 1;
    //
    // DQSB PI output gate enable. 1= gate DQBS output off, 0= DQSB output not gated
    // 
    // Bits[4:4], RW, default = 0x0
    //
    UINTX rxdll_b0n0_dqsbpiouten : 1;
    //
    // Bypass Delay line and PI block for both DQS and DQSB output and route delay line
    // input to both DQS and DQSB outputs 
    // 
    // Bits[5:5], RW, default = 0x0
    //
    UINTX rxdll_b0n0_dqsbypassen : 1;
    //
    // 2x clk enable for DFX mode. This muxes a 2x clk to the rxdqssdl block input for
    // DFX 
    // 
    // Bits[6:6], RW, default = 0x0
    //
    UINTX rxdll_b0n0_2xdfxen : 1;
    //
    // Reserved
    // 
    // Bits[31:7], RO, default = 0x0
    //
    UINTX reserved : 25;
  } Bits;
  UINTX Data;
} RXDLLCFG_B0N0_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define RXDLLCFG_B0N1_DDRDQ_PHY_REG                        0x00000374
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Slave Delay line enable signal. 1= power up DL, 0= power down DL
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINTX rxdll_b0n1_dqssdllen : 1;
    //
    // Enable DQS PI block. 1= enable DQS PI block, 0=disable DQS PI block
    // 
    // Bits[1:1], RW, default = 0x0
    //
    UINTX rxdll_b0n1_dqspien : 1;
    //
    // DQS PI output gate enable. 1= gate DQS output off, 0= DQS output not gated
    // 
    // Bits[2:2], RW, default = 0x0
    //
    UINTX rxdll_b0n1_dqspiouten : 1;
    //
    // Enable DQSB PI block. 1= enable DQSB PI block, 0=disable DQSB PI block
    // 
    // Bits[3:3], RW, default = 0x0
    //
    UINTX rxdll_b0n1_dqsbpien : 1;
    //
    // DQSB PI output gate enable. 1= gate DQBS output off, 0= DQSB output not gated
    // 
    // Bits[4:4], RW, default = 0x0
    //
    UINTX rxdll_b0n1_dqsbpiouten : 1;
    //
    // Bypass Delay line and PI block for both DQS and DQSB output and route delay line
    // input to both DQS and DQSB outputs 
    // 
    // Bits[5:5], RW, default = 0x0
    //
    UINTX rxdll_b0n1_dqsbypassen : 1;
    //
    // 2x clk enable for DFX mode. This muxes a 2x clk to the rxdqssdl block input for
    // DFX 
    // 
    // Bits[6:6], RW, default = 0x0
    //
    UINTX rxdll_b0n1_2xdfxen : 1;
    //
    // Reserved
    // 
    // Bits[31:7], RO, default = 0x0
    //
    UINTX reserved : 25;
  } Bits;
  UINTX Data;
} RXDLLCFG_B0N1_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define OBSCFG_BL0_DDRDQ_PHY_REG                           0x00000378
#ifndef ASM_INC
typedef union {
  struct {
    //
    // ANA Buf mux select 0
    // 
    // Bits[1:0], RW, default = 0x0
    //
    UINTX dqbuf_b0_anaobs0sel : 2;
    //
    // ANA Buf mux select 1
    // 
    // Bits[3:2], RW, default = 0x0
    //
    UINTX dqbuf_b0_anaobs1sel : 2;
    //
    // DIG Buf mux select 0
    // 
    // Bits[7:4], RW, default = 0x0
    //
    UINTX dqbuf_b0_digobs0sel : 4;
    //
    // DIG Buf mux select 1
    // 
    // Bits[11:8], RW, default = 0x0
    //
    UINTX dqbuf_b0_digobs1sel : 4;
    //
    // ANA Buf mux select 0
    // 
    // Bits[13:12], RW, default = 0x0
    //
    UINTX dqsbuf_b0_anaobs0sel : 2;
    //
    // ANA Buf mux select 1
    // 
    // Bits[15:14], RW, default = 0x0
    //
    UINTX dqsbuf_b0_anaobs1sel : 2;
    //
    // DIG Buf mux select 0
    // 
    // Bits[19:16], RW, default = 0x0
    //
    UINTX dqsbuf_b0_digobs0sel : 4;
    //
    // DIG Buf mux select 1
    // 
    // Bits[23:20], RW, default = 0x0
    //
    UINTX dqsbuf_b0_digobs1sel : 4;
    //
    // Digital obs select lines for obs port 0
    // 
    // Bits[25:24], RW, default = 0x0
    //
    UINTX rxdll_b0n0_digobs0sel : 2;
    //
    // Digital obs select lines for obs port 1
    // 
    // Bits[27:26], RW, default = 0x0
    //
    UINTX rxdll_b0n0_digobs1sel : 2;
    //
    // Digital obs select lines for obs port 0
    // 
    // Bits[29:28], RW, default = 0x0
    //
    UINTX rxdll_b0n1_digobs0sel : 2;
    //
    // Digital obs select lines for obs port 1
    // 
    // Bits[31:30], RW, default = 0x0
    //
    UINTX rxdll_b0n1_digobs1sel : 2;
  } Bits;
  UINTX Data;
} OBSCFG_BL0_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define RXDQMINDLY_BL0_DDRDQ_PHY_REG                       0x0000037C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // RXDQMINDLY PI output gate enable. 1= gate RXDQMINDLY output off, 0= RXDQMINDLY
    // output not gated 
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINTX rxdqmindly_b0_dqpiouten : 1;
    //
    // Enable RXDQMINDLY PI block. 1= enable RXDQMINDLY PI block, 0=disable RXDQMINDLY
    // PI block 
    // 
    // Bits[1:1], RW, default = 0x0
    //
    UINTX rxdqmindly_b0_dqdllpien : 1;
    //
    // Bypass Delay line and PI block for RXDQMINDLY output and route delay line input
    // to RXDQMINDLY output 
    // 
    // Bits[2:2], RW, default = 0x0
    //
    UINTX rxdqmindly_b0_dqbypassen : 1;
    //
    // Digital obs select lines for RXDQMINDLY obs port 1
    // 
    // Bits[4:3], RW, default = 0x0
    //
    UINTX rxdqmindly_b0_digobs1sel : 2;
    //
    // Digital obs select lines for RXDQMINDLY obs port 0
    // 
    // Bits[6:5], RW, default = 0x0
    //
    UINTX rxdqmindly_b0_digobs0sel : 2;
    //
    // Reserved
    // 
    // Bits[31:7], RO, default = 0x0
    //
    UINTX reserved : 25;
  } Bits;
  UINTX Data;
} RXDQMINDLY_BL0_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define RXVREFCFG_BL0_DDRDQ_PHY_REG                        0x00000380
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Enable VREF
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINTX rxvref_b0_vrefen : 1;
    //
    // VREF Code
    // 
    // Bits[6:1], RW, default = 0x20
    //
    UINTX rxvref_b0_vrefctrl : 6;
    //
    // Range select to pick between DDR3 and DDR4. [br]0 - DDR3 (Default)  [br]1- DDR4
    // 
    // Bits[7:7], RW, default = 0x0
    //
    UINTX rxvref_b0_vrefrangesel : 1;
    //
    // Reserved
    // 
    // Bits[31:8], RO, default = 0x0
    //
    UINTX reserved : 24;
  } Bits;
  UINTX Data;
} RXVREFCFG_BL0_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define COMPSTATIC_BL0_DDRDQ_PHY_REG                       0x00000384
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Pull-down RCOMP code for driver static leg for DQ buffers
    // 
    // Bits[2:0], RW, default = 0x7
    //
    UINTX comp_b0_dqpdndrvstatic : 3;
    //
    // Pull-down RCOMP code for ODT static leg. [br]3'b010 : DDR3L[br]3'b010 : DDR4 weak[br]3'b111
    // : DDR4 strong 
    // 
    // Bits[5:3], RW, default = 0x7
    //
    UINTX comp_b0_dqpdnodtstatic : 3;
    //
    // Pull-up RCOMP code for driver static leg for DQ buffers
    // 
    // Bits[8:6], RW, default = 0x7
    //
    UINTX comp_b0_dqpupdrvstatic : 3;
    //
    // Pull-up RCOMP code for ODT static leg. [br]3'b010 : DDR3L[br]3'b010 : DDR4 weak[br]3'b111
    // : DDR4 strong 
    // 
    // Bits[11:9], RW, default = 0x7
    //
    UINTX comp_b0_dqpupodtstatic : 3;
    //
    // Pull-down RCOMP code for driver static leg for DQ buffers
    // 
    // Bits[14:12], RW, default = 0x7
    //
    UINTX comp_b0_dqspdndrvstatic : 3;
    //
    // Pull-down RCOMP code for ODT static leg. [br]3'b010 : DDR3L[br]3'b010 : DDR4 weak[br]3'b111
    // : DDR4 strong 
    // 
    // Bits[17:15], RW, default = 0x7
    //
    UINTX comp_b0_dqspdnodtstatic : 3;
    //
    // Pull-up RCOMP code for driver static leg for DQ buffers
    // 
    // Bits[20:18], RW, default = 0x7
    //
    UINTX comp_b0_dqspupdrvstatic : 3;
    //
    // Pull-up RCOMP code for ODT static leg. [br]3'b010 : DDR3L[br]3'b010 : DDR4 weak[br]3'b111
    // : DDR4 strong 
    // 
    // Bits[23:21], RW, default = 0x7
    //
    UINTX comp_b0_dqspupodtstatic : 3;
    //
    // Reserved
    // 
    // Bits[31:24], RO, default = 0x0
    //
    UINTX reserved : 8;
  } Bits;
  UINTX Data;
} COMPSTATIC_BL0_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define DIGCTL_BL1_DDRDQ_PHY_REG                           0x000003B0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // SPID clock clock domain reset-bar. Combined with PM reset control
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINTX b1_spidrst_b : 1;
    //
    // RX FIFO reset-bar. Combined with PM reset control
    // 
    // Bits[1:1], RW, default = 0x0
    //
    UINTX b1_rxfiforst_b : 1;
    //
    // Reserved
    // 
    // Bits[4:2], RO, default = 0x0
    //
    UINTX reserved : 3;
    //
    // CC1 I/O buffer activate: Reset for final TX flops in CC1 upartition.[br]Tristates
    // IO buffers.[br]Disable Rx sections of IO buffers.[br]0 = reset , 1 = out of reset
    // 
    // Bits[5:5], RW, default = 0x0
    //
    UINTX b1_iobufact : 1;
    //
    // Multi Cycle Path Control. 0 = NO Pipelining, 1 = Pipelining (1 Stage)
    // 
    // Bits[6:6], RW, default = 0x0
    //
    UINTX b1_rdmcpsel : 1;
    //
    // Reserved
    // 
    // Bits[8:7], RO, default = 0x0
    //
    UINTX reserved_1 : 2;
    //
    // Reserved
    // 
    // Bits[10:9], RO, default = 0x0
    //
    UINTX reserved_2 : 2;
    //
    // Write Leveling Enable: 0 = Write Leveling off (normal mode). 1 - Write Leveling
    // on (training) 
    // 
    // Bits[11:11], RW, default = 0x0
    //
    UINTX b1_wrlvl : 1;
    //
    // Reserved
    // 
    // Bits[12:12], RO, default = 0x0
    //
    UINTX reserved_3 : 1;
    //
    // HVM read test stretch mode:[br]00: normal read[br]01: x4 stretch mode[br]10: x8
    // stretch mode[br]11: x16 stretch mode 
    // 
    // Bits[14:13], RW, default = 0x0
    //
    UINTX b1_stretchmode : 2;
    //
    // Reserved
    // 
    // Bits[15:15], RO, default = 0x0
    //
    UINTX reserved_4 : 1;
    //
    // Reserved
    // 
    // Bits[16:16], RO, default = 0x0
    //
    UINTX reserved_5 : 1;
    //
    // Reserved
    // 
    // Bits[17:17], RO, default = 0x0
    //
    UINTX reserved_6 : 1;
    //
    // 1 = Enable TX equalization: on-the-fly eqenb generation from dqdata and dqdrvenb.
    // 0 = Disable TX equalization, eqenb = 1 
    // 
    // Bits[18:18], RW, default = 0x0
    //
    UINTX b1_txdqequalizer_en : 1;
    //
    // Enable early data. 1: the data will be enable 2 2xclk early. Two early data will
    // be the same as the first actual valid data burst (UI0). 
    // 
    // Bits[19:19], RW, default = 0x0
    //
    UINTX b1_early_dqen : 1;
    //
    // Reserved
    // 
    // Bits[31:20], RO, default = 0x0
    //
    UINTX reserved_7 : 12;
  } Bits;
  UINTX Data;
} DIGCTL_BL1_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define PTROFFSET_B1N0_DDRDQ_PHY_REG                       0x000003B4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Initial offset for DQ 2x clock read pointers
    // 
    // Bits[4:0], RW, default = 0x0
    //
    UINTX b1n0_dq_ref2xrdptrinit : 5;
    //
    // Initial offset for 1x clock read pointers
    // 
    // Bits[7:5], RW, default = 0x0
    //
    UINTX b1n0_ref1xrdptrinit : 3;
    //
    // SPID to 1x clock FIFO read pointer offset
    // 
    // Bits[10:8], RW, default = 0x0
    //
    UINTX b1n0_ref1xrdptroffset : 3;
    //
    // Initial offset for dq drive enable, dqs, rcven, diffampen, rxodten, rxodtseg 2x
    // clock read pointers 
    // 
    // Bits[14:11], RW, default = 0x0
    //
    UINTX b1n0_others_ref2xrdptrinit : 4;
    //
    // Reserved
    // 
    // Bits[31:15], RO, default = 0x0
    //
    UINTX reserved : 17;
  } Bits;
  UINTX Data;
} PTROFFSET_B1N0_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define PTROFFSET_B1N1_DDRDQ_PHY_REG                       0x000003B8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Initial offset for DQ 2x clock read pointers
    // 
    // Bits[4:0], RW, default = 0x0
    //
    UINTX b1n1_dq_ref2xrdptrinit : 5;
    //
    // Initial offset for dq drive enable, dqs, rcven, diffampen, rxodten, rxodtseg 2x
    // clock read pointers 
    // 
    // Bits[8:5], RW, default = 0x0
    //
    UINTX b1n1_others_ref2xrdptrinit : 4;
    //
    // Reserved
    // 
    // Bits[31:9], RO, default = 0x0
    //
    UINTX reserved : 23;
  } Bits;
  UINTX Data;
} PTROFFSET_B1N1_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define DQSMUX_BL1_DDRDQ_PHY_REG                           0x000003BC
#ifndef ASM_INC
typedef union {
  struct {
    //
    // DQS rank 0 nibble 0 dqs/dqsb source select. 0 = RXFIFO nibble 0 from AFE nibble
    // 0. 1 = RXFIFO nibble 0 from AFE nibble 1 
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINTX b1n0_rk0rxdqsmuxsel : 1;
    //
    // DQS rank 1 nibble 0 dqs/dqsb source select. 0 = RXFIFO nibble 0 from AFE nibble
    // 0. 1 = RXFIFO nibble 0 from AFE nibble 1 
    // 
    // Bits[1:1], RW, default = 0x0
    //
    UINTX b1n0_rk1rxdqsmuxsel : 1;
    //
    // DQS rank 2 nibble 0 dqs/dqsb source select. 0 = RXFIFO nibble 0 from AFE nibble
    // 0. 1 = RXFIFO nibble 0 from AFE nibble 1 
    // 
    // Bits[2:2], RW, default = 0x0
    //
    UINTX b1n0_rk2rxdqsmuxsel : 1;
    //
    // DQS rank 3 nibble 0 dqs/dqsb source select. 0 = RXFIFO nibble 0 from AFE nibble
    // 0. 1 = RXFIFO nibble 0 from AFE nibble 1 
    // 
    // Bits[3:3], RW, default = 0x0
    //
    UINTX b1n0_rk3rxdqsmuxsel : 1;
    //
    // DQS rank 0 nibble 1 dqs/dqsb source select. 0 = RXFIFO nibble 1 from AFE nibble
    // 0. 1 = RXFIFO nibble 1 from AFE nibble 1 
    // 
    // Bits[4:4], RW, default = 0x0
    //
    UINTX b1n1_rk0rxdqsmuxsel : 1;
    //
    // DQS rank 1 nibble 1 dqs/dqsb source select. 0 = RXFIFO nibble 1 from AFE nibble
    // 0. 1 = RXFIFO nibble 1 from AFE nibble 1 
    // 
    // Bits[5:5], RW, default = 0x0
    //
    UINTX b1n1_rk1rxdqsmuxsel : 1;
    //
    // DQS rank 2 nibble 1 dqs/dqsb source select. 0 = RXFIFO nibble 1 from AFE nibble
    // 0. 1 = RXFIFO nibble 1 from AFE nibble 1 
    // 
    // Bits[6:6], RW, default = 0x0
    //
    UINTX b1n1_rk2rxdqsmuxsel : 1;
    //
    // DQS rank 3 nibble 1 dqs/dqsb source select. 0 = RXFIFO nibble 1 from AFE nibble
    // 0. 1 = RXFIFO nibble 1 from AFE nibble 1 
    // 
    // Bits[7:7], RW, default = 0x0
    //
    UINTX b1n1_rk3rxdqsmuxsel : 1;
    //
    // Reserved
    // 
    // Bits[31:8], RO, default = 0x0
    //
    UINTX reserved : 24;
  } Bits;
  UINTX Data;
} DQSMUX_BL1_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define DQSFSM_B1N0_DDRDQ_PHY_REG                          0x000003C0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Latency from write command to start of DQS generation FSM (in 1x cycles)
    // 
    // Bits[4:0], RW, default = 0x0
    //
    UINTX b1n0_wrcmd2dqsstart : 5;
    //
    // 1 = Enable the two-cycle write Pre-amable. If set to  1, both Pre-am0 and Pre-am1
    // will  be used. 
    // 
    // Bits[5:5], RW, default = 0x0
    //
    UINTX b1n0_wrpream0en : 1;
    //
    // DQS Generation Mode - Pream0 Phase[br]00 - Fall & Rise - Low & Low[br]01 - Fall
    // & Rise - Low & High[br]10 -  Fall & Rise - High & Low[br]11 -  Fall & Rise - High
    // & High 
    // 
    // Bits[7:6], RW, default = 0x0
    //
    UINTX b1n0_dqspream0 : 2;
    //
    // DQS Generation Mode - Pream1 Phase[br]00 - Fall & Rise - Low & Low[br]01 - Fall
    // & Rise - Low & High[br]10 -  Fall & Rise - High & Low[br]11 -  Fall & Rise - High
    // & High 
    // 
    // Bits[9:8], RW, default = 0x0
    //
    UINTX b1n0_dqspream1 : 2;
    //
    // DQS Generation Mode - Phase 1[br]00 - Fall & Rise - Low & Low[br]01 - Fall & Rise
    // - Low & High[br]10 -  Fall & Rise - High & Low[br]11 -  Fall & Rise - High & High
    // 
    // Bits[11:10], RW, default = 0x0
    //
    UINTX b1n0_dqsph1 : 2;
    //
    // DQS Generation Mode - Last Phase[br]00 - Fall & Rise - Low & Low[br]01 - Fall
    // & Rise - Low & High[br]10 -  Fall & Rise - High & Low[br]11 -  Fall & Rise - High
    // & High 
    // 
    // Bits[13:12], RW, default = 0x0
    //
    UINTX b1n0_dqslastph : 2;
    //
    // Reserved
    // 
    // Bits[15:14], RO, default = 0x0
    //
    UINTX reserved : 2;
    //
    // Reserved
    // 
    // Bits[31:16], RO, default = 0x0
    //
    UINTX reserved_1 : 16;
  } Bits;
  UINTX Data;
} DQSFSM_B1N0_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define DQSFSM_B1N1_DDRDQ_PHY_REG                          0x000003C4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Latency from write command to start of DQS generation FSM (in 1x cycles)
    // 
    // Bits[4:0], RW, default = 0x0
    //
    UINTX b1n1_wrcmd2dqsstart : 5;
    //
    // 1 = Enable the two-cycle write Pre-amable. If set to  1, both Pre-am0 and Pre-am1
    // will  be used. 
    // 
    // Bits[5:5], RW, default = 0x0
    //
    UINTX b1n1_wrpream0en : 1;
    //
    // DQS Generation Mode - Pream0 Phase[br]00 - Fall & Rise - Low & Low[br]01 - Fall
    // & Rise - Low & High[br]10 -  Fall & Rise - High & Low[br]11 -  Fall & Rise - High
    // & High 
    // 
    // Bits[7:6], RW, default = 0x0
    //
    UINTX b1n1_dqspream0 : 2;
    //
    // DQS Generation Mode - Pream1 Phase[br]00 - Fall & Rise - Low & Low[br]01 - Fall
    // & Rise - Low & High[br]10 -  Fall & Rise - High & Low[br]11 -  Fall & Rise - High
    // & High 
    // 
    // Bits[9:8], RW, default = 0x0
    //
    UINTX b1n1_dqspream1 : 2;
    //
    // DQS Generation Mode - Phase 1[br]00 - Fall & Rise - Low & Low[br]01 - Fall & Rise
    // - Low & High[br]10 -  Fall & Rise - High & Low[br]11 -  Fall & Rise - High & High
    // 
    // Bits[11:10], RW, default = 0x0
    //
    UINTX b1n1_dqsph1 : 2;
    //
    // DQS Generation Mode - Last Phase[br]00 - Fall & Rise - Low & Low[br]01 - Fall
    // & Rise - Low & High[br]10 -  Fall & Rise - High & Low[br]11 -  Fall & Rise - High
    // & High 
    // 
    // Bits[13:12], RW, default = 0x0
    //
    UINTX b1n1_dqslastph : 2;
    //
    // Reserved
    // 
    // Bits[15:14], RO, default = 0x0
    //
    UINTX reserved : 2;
    //
    // Reserved
    // 
    // Bits[31:16], RO, default = 0x0
    //
    UINTX reserved_1 : 16;
  } Bits;
  UINTX Data;
} DQSFSM_B1N1_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define DRVENBCTL_B1N0_DDRDQ_PHY_REG                       0x000003C8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // DQ Drive Enable - Preamble0 Phase[br]00 - Rise & Fall - Low & Low[br]01 - Rise
    // & Fall - High & Low[br]10 - Rise & Fall - Low & High[br]11 - Rise & Fall - High
    // & High 
    // 
    // Bits[1:0], RW, default = 0x0
    //
    UINTX b1n0_dqdrvenbpream0 : 2;
    //
    // DQ Drive Enable - Preamble1 Phase[br]00 - Rise & Fall - Low & Low[br]01 - Rise
    // & Fall - High & Low[br]10 - Rise & Fall - Low & High[br]11 - Rise & Fall - High
    // & High 
    // 
    // Bits[3:2], RW, default = 0x0
    //
    UINTX b1n0_dqdrvenbpream1 : 2;
    //
    // DQ Drive Enable - Phase 1[br]00 - Rise & Fall - Low & Low[br]01 - Rise & Fall
    // - High & Low[br]10 - Rise & Fall - Low & High[br]11 - Rise & Fall - High & High
    // 
    // Bits[5:4], RW, default = 0x0
    //
    UINTX b1n0_dqdrvenbph1 : 2;
    //
    // DQ Drive Enable - Last Phase[br]00 - Rise & Fall - Low & Low[br]01 - Rise & Fall
    // - High & Low[br]10 - Rise & Fall - Low & High[br]11 - Rise & Fall - High & High
    // 
    // Bits[7:6], RW, default = 0x0
    //
    UINTX b1n0_dqdrvenblastph : 2;
    //
    // Reserved
    // 
    // Bits[9:8], RO, default = 0x0
    //
    UINTX reserved : 2;
    //
    // DQS Drive Enable - Preamble0 Phase[br]00 - Rise & Fall - Low & Low[br]01 - Rise
    // & Fall - High & Low[br]10 - Rise & Fall - Low & High[br]11 - Rise & Fall - High
    // & High 
    // 
    // Bits[11:10], RW, default = 0x0
    //
    UINTX b1n0_dqsdrvenbpream0 : 2;
    //
    // DQS Drive Enable - Preamble1 Phase[br]00 - Rise & Fall - Low & Low[br]01 - Rise
    // & Fall - High & Low[br]10 - Rise & Fall - Low & High[br]11 - Rise & Fall - High
    // & High 
    // 
    // Bits[13:12], RW, default = 0x0
    //
    UINTX b1n0_dqsdrvenbpream1 : 2;
    //
    // DQS Drive Enable - Phase 1[br]00 - Rise & Fall - Low & Low[br]01 - Rise & Fall
    // - High & Low[br]10 - Rise & Fall - Low & High[br]11 - Rise & Fall - High & High
    // 
    // Bits[15:14], RW, default = 0x0
    //
    UINTX b1n0_dqsdrvenbph1 : 2;
    //
    // DQS Drive Enable - Last Phase[br]00 - Rise & Fall - Low & Low[br]01 - Rise & Fall
    // - High & Low[br]10 - Rise & Fall - Low & High[br]11 - Rise & Fall - High & High
    // 
    // Bits[17:16], RW, default = 0x0
    //
    UINTX b1n0_dqsdrvenblastph : 2;
    //
    // Reserved
    // 
    // Bits[19:18], RO, default = 0x0
    //
    UINTX reserved_1 : 2;
    //
    // DQS Drive Enable - CRC Phase[br]00 - Rise & Fall - Low & Low[br]01 - Rise & Fall
    // - High & Low[br]10 - Rise & Fall - Low & High[br]11 - Rise & Fall - High & High
    // 
    // Bits[21:20], RW, default = 0x3
    //
    UINTX b1n0_dqsdrvenbidle : 2;
    //
    // Reserved
    // 
    // Bits[31:22], RO, default = 0x0
    //
    UINTX reserved_2 : 10;
  } Bits;
  UINTX Data;
} DRVENBCTL_B1N0_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define DRVENBCTL_B1N1_DDRDQ_PHY_REG                       0x000003CC
#ifndef ASM_INC
typedef union {
  struct {
    //
    // DQ Drive Enable - Preamble0 Phase[br]00 - Rise & Fall - Low & Low[br]01 - Rise
    // & Fall - High & Low[br]10 - Rise & Fall - Low & High[br]11 - Rise & Fall - High
    // & High 
    // 
    // Bits[1:0], RW, default = 0x0
    //
    UINTX b1n1_dqdrvenbpream0 : 2;
    //
    // DQ Drive Enable - Preamble1 Phase[br]00 - Rise & Fall - Low & Low[br]01 - Rise
    // & Fall - High & Low[br]10 - Rise & Fall - Low & High[br]11 - Rise & Fall - High
    // & High 
    // 
    // Bits[3:2], RW, default = 0x0
    //
    UINTX b1n1_dqdrvenbpream1 : 2;
    //
    // DQ Drive Enable - Phase 1[br]00 - Rise & Fall - Low & Low[br]01 - Rise & Fall
    // - High & Low[br]10 - Rise & Fall - Low & High[br]11 - Rise & Fall - High & High
    // 
    // Bits[5:4], RW, default = 0x0
    //
    UINTX b1n1_dqdrvenbph1 : 2;
    //
    // DQ Drive Enable - Last Phase[br]00 - Rise & Fall - Low & Low[br]01 - Rise & Fall
    // - High & Low[br]10 - Rise & Fall - Low & High[br]11 - Rise & Fall - High & High
    // 
    // Bits[7:6], RW, default = 0x0
    //
    UINTX b1n1_dqdrvenblastph : 2;
    //
    // Reserved
    // 
    // Bits[9:8], RO, default = 0x0
    //
    UINTX reserved : 2;
    //
    // DQS Drive Enable - Preamble0 Phase[br]00 - Rise & Fall - Low & Low[br]01 - Rise
    // & Fall - High & Low[br]10 - Rise & Fall - Low & High[br]11 - Rise & Fall - High
    // & High 
    // 
    // Bits[11:10], RW, default = 0x0
    //
    UINTX b1n1_dqsdrvenbpream0 : 2;
    //
    // DQS Drive Enable - Preamble1 Phase[br]00 - Rise & Fall - Low & Low[br]01 - Rise
    // & Fall - High & Low[br]10 - Rise & Fall - Low & High[br]11 - Rise & Fall - High
    // & High 
    // 
    // Bits[13:12], RW, default = 0x0
    //
    UINTX b1n1_dqsdrvenbpream1 : 2;
    //
    // DQS Drive Enable - Phase 1[br]00 - Rise & Fall - Low & Low[br]01 - Rise & Fall
    // - High & Low[br]10 - Rise & Fall - Low & High[br]11 - Rise & Fall - High & High
    // 
    // Bits[15:14], RW, default = 0x0
    //
    UINTX b1n1_dqsdrvenbph1 : 2;
    //
    // DQS Drive Enable - Last Phase[br]00 - Rise & Fall - Low & Low[br]01 - Rise & Fall
    // - High & Low[br]10 - Rise & Fall - Low & High[br]11 - Rise & Fall - High & High
    // 
    // Bits[17:16], RW, default = 0x0
    //
    UINTX b1n1_dqsdrvenblastph : 2;
    //
    // Reserved
    // 
    // Bits[19:18], RO, default = 0x0
    //
    UINTX reserved_1 : 2;
    //
    // DQS Drive Enable - CRC Phase[br]00 - Rise & Fall - Low & Low[br]01 - Rise & Fall
    // - High & Low[br]10 - Rise & Fall - Low & High[br]11 - Rise & Fall - High & High
    // 
    // Bits[21:20], RW, default = 0x3
    //
    UINTX b1n1_dqsdrvenbidle : 2;
    //
    // Reserved
    // 
    // Bits[31:22], RO, default = 0x0
    //
    UINTX reserved_2 : 10;
  } Bits;
  UINTX Data;
} DRVENBCTL_B1N1_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define RDVLDCTL_BL1_DDRDQ_PHY_REG                         0x000003D0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Latency from read command to start of ospid_rddata_valid generation (in spidclk
    // cycles) 
    // 
    // Bits[4:0], RW, default = 0x0
    //
    UINTX b1_rdcmd2rdvld : 5;
    //
    // rdcmd can launch in phase 0 or phase1. The calculation of rdcmd2rdvalid is based
    // on RL + BL4/2 + dqs_pushout + setup from RX fifo output to spidclk flop. This
    // calculation after round up will get extra time if rdcmd launch from phase1. Hence
    // adding this bit to preciced re-adjust the performance. 
    // 
    // Bits[5:5], RW, default = 0x0
    //
    UINTX b1_rdcmd2rdvld_plus1sel : 1;
    //
    // Early Read Valid setting:[br]0 - No Early Read Valid Generation[br]1 - 1 spidclk
    // early valid[br]2 - 2 spidclks early valid[br]3 - 3 spidclks early valid[br]4 -
    // 4 spidclks early valid    [br]>4 - Illegal 
    // 
    // Bits[8:6], RW, default = 0x0
    //
    UINTX b1_earlyrdvld : 3;
    //
    // Reserved
    // 
    // Bits[31:9], RO, default = 0x0
    //
    UINTX reserved : 23;
  } Bits;
  UINTX Data;
} RDVLDCTL_BL1_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define RCVENCTL_B1N0_DDRDQ_PHY_REG                        0x000003D4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Latency from read command to start of receive enable generation FSM (in 1x cycles)
    // 
    // Bits[4:0], RW, default = 0x0
    //
    UINTX b1n0_rdcmd2rcven : 5;
    //
    // Receive Enable - Preamble0 Phase[br]00 - Rise & Fall - Low & Low[br]01 - Rise
    // & Fall - High & Low[br]10 - Rise & Fall - Low & High[br]11 - Rise & Fall - High
    // & High 
    // 
    // Bits[6:5], RW, default = 0x0
    //
    UINTX b1n0_rcvenpre0 : 2;
    //
    // Receive Enable - Postamble0 Phase[br]00 - Rise & Fall - Low & Low[br]01 - Rise
    // & Fall - High & Low[br]10 - Rise & Fall - Low & High[br]11 - Rise & Fall - High
    // & High 
    // 
    // Bits[8:7], RW, default = 0x0
    //
    UINTX b1n0_rcvenpst0 : 2;
    //
    // Receive Enable - Preamble1 Phase[br]00 - Rise & Fall - Low & Low[br]01 - Rise
    // & Fall - High & Low[br]10 - Rise & Fall - Low & High[br]11 - Rise & Fall - High
    // & High 
    // 
    // Bits[10:9], RW, default = 0x0
    //
    UINTX b1n0_rcvenpre1 : 2;
    //
    // Receive Enable - Postamble1 Phase[br]00 - Rise & Fall - Low & Low[br]01 - Rise
    // & Fall - High & Low[br]10 - Rise & Fall - Low & High[br]11 - Rise & Fall - High
    // & High 
    // 
    // Bits[12:11], RW, default = 0x0
    //
    UINTX b1n0_rcvenpst1 : 2;
    //
    // Receive Enable Length in number of 1x clocks (for a burst length of 4). Burst
    // length 8 is 2 of these. 
    // 
    // Bits[18:13], RW, default = 0x0
    //
    UINTX b1n0_rcvenlenbl4 : 6;
    //
    // Receive Enable override enable. 1 = use override value. 0 = use receive enable
    // from FIFO logic 
    // 
    // Bits[19:19], RW, default = 0x0
    //
    UINTX b1n0_rcven_ovr : 1;
    //
    // Receive Enable override value
    // 
    // Bits[20:20], RW, default = 0x0
    //
    UINTX b1n0_rcven_val : 1;
    //
    // Reserved
    // 
    // Bits[31:21], RO, default = 0x0
    //
    UINTX reserved : 11;
  } Bits;
  UINTX Data;
} RCVENCTL_B1N0_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define RCVENCTL_B1N1_DDRDQ_PHY_REG                        0x000003D8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Latency from read command to start of receive enable generation FSM (in 1x cycles)
    // 
    // Bits[4:0], RW, default = 0x0
    //
    UINTX b1n1_rdcmd2rcven : 5;
    //
    // Receive Enable - Preamble0 Phase[br]00 - Rise & Fall - Low & Low[br]01 - Rise
    // & Fall - High & Low[br]10 - Rise & Fall - Low & High[br]11 - Rise & Fall - High
    // & High 
    // 
    // Bits[6:5], RW, default = 0x0
    //
    UINTX b1n1_rcvenpre0 : 2;
    //
    // Receive Enable - Postamble0 Phase[br]00 - Rise & Fall - Low & Low[br]01 - Rise
    // & Fall - High & Low[br]10 - Rise & Fall - Low & High[br]11 - Rise & Fall - High
    // & High 
    // 
    // Bits[8:7], RW, default = 0x0
    //
    UINTX b1n1_rcvenpst0 : 2;
    //
    // Receive Enable - Preamble1 Phase[br]00 - Rise & Fall - Low & Low[br]01 - Rise
    // & Fall - High & Low[br]10 - Rise & Fall - Low & High[br]11 - Rise & Fall - High
    // & High 
    // 
    // Bits[10:9], RW, default = 0x0
    //
    UINTX b1n1_rcvenpre1 : 2;
    //
    // Receive Enable - Postamble1 Phase[br]00 - Rise & Fall - Low & Low[br]01 - Rise
    // & Fall - High & Low[br]10 - Rise & Fall - Low & High[br]11 - Rise & Fall - High
    // & High 
    // 
    // Bits[12:11], RW, default = 0x0
    //
    UINTX b1n1_rcvenpst1 : 2;
    //
    // Receive Enable Length in number of 1x clocks (for a burst length of 4). Burst
    // length 8 is 2 of these. 
    // 
    // Bits[18:13], RW, default = 0x0
    //
    UINTX b1n1_rcvenlenbl4 : 6;
    //
    // Receive Enable override enable. 1 = use override value. 0 = use receive enable
    // from FIFO logic 
    // 
    // Bits[19:19], RW, default = 0x0
    //
    UINTX b1n1_rcven_ovr : 1;
    //
    // Receive Enable override value
    // 
    // Bits[20:20], RW, default = 0x0
    //
    UINTX b1n1_rcven_val : 1;
    //
    // Reserved
    // 
    // Bits[31:21], RO, default = 0x0
    //
    UINTX reserved : 11;
  } Bits;
  UINTX Data;
} RCVENCTL_B1N1_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define DIFFAMPCTL_BL1_DDRDQ_PHY_REG                       0x000003DC
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Latency from read command to start of diffamp enable generation (in 1x cycles)
    // 
    // Bits[4:0], RW, default = 0x0
    //
    UINTX b1_rdcmd2diffampen : 5;
    //
    // Reserved
    // 
    // Bits[10:5], RO, default = 0x0
    //
    UINTX reserved : 6;
    //
    // Diffamp Enable - Preamble0 Phase[br]00 - Rise & Fall - Low & Low[br]01 - Rise
    // & Fall - High & Low[br]10 - Rise & Fall - Low & High[br]11 - Rise & Fall - High
    // & High 
    // 
    // Bits[12:11], RW, default = 0x0
    //
    UINTX b1_diffampenpre0 : 2;
    //
    // Diffamp Enable - Postamble0 Phase[br]00 - Rise & Fall - Low & Low[br]01 - Rise
    // & Fall - High & Low[br]10 - Rise & Fall - Low & High[br]11 - Rise & Fall - High
    // & High 
    // 
    // Bits[14:13], RW, default = 0x0
    //
    UINTX b1_diffampenpst0 : 2;
    //
    // Diffamp Enable - Preamble1 Phase[br]00 - Rise & Fall - Low & Low[br]01 - Rise
    // & Fall - High & Low[br]10 - Rise & Fall - Low & High[br]11 - Rise & Fall - High
    // & High 
    // 
    // Bits[16:15], RW, default = 0x0
    //
    UINTX b1_diffampenpre1 : 2;
    //
    // Diffamp Enable - Postamble1 Phase[br]00 - Rise & Fall - Low & Low[br]01 - Rise
    // & Fall - High & Low[br]10 - Rise & Fall - Low & High[br]11 - Rise & Fall - High
    // & High 
    // 
    // Bits[18:17], RW, default = 0x0
    //
    UINTX b1_diffampenpst1 : 2;
    //
    // Diffamp Enable Length in number of 1x clocks (for a burst length of 4). Burst
    // length 8 is 2 of these. 
    // 
    // Bits[24:19], RW, default = 0x0
    //
    UINTX b1_diffampenlenbl4 : 6;
    //
    // DQS diffamp enable override value
    // 
    // Bits[25:25], RW, default = 0x0
    //
    UINTX b1_dqsdiffampenval : 1;
    //
    // DQS diffamp enable override enable. 1 = use override value. 0 = use diffampen
    // from FIFO logic 
    // 
    // Bits[26:26], RW, default = 0x0
    //
    UINTX b1_dqsdiffampenovr : 1;
    //
    // DQ diffamp enable override value
    // 
    // Bits[27:27], RW, default = 0x0
    //
    UINTX b1_dqdiffampenval : 1;
    //
    // DQ diffamp enable override enable. 1 = use override value. 0 = use diffampen from
    // FIFO logic 
    // 
    // Bits[28:28], RW, default = 0x0
    //
    UINTX b1_dqdiffampenovr : 1;
    //
    // Not used in DNV. Set to 0
    // 
    // Bits[29:29], RW, default = 0x0
    //
    UINTX b1_dmdiffampenval : 1;
    //
    // Not used in DNV. Set to 0
    // 
    // Bits[30:30], RW, default = 0x0
    //
    UINTX b1_dmdiffampenovr : 1;
    //
    // Reserved
    // 
    // Bits[31:31], RO, default = 0x0
    //
    UINTX reserved_1 : 1;
  } Bits;
  UINTX Data;
} DIFFAMPCTL_BL1_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define RXODTENCTL_BL1_DDRDQ_PHY_REG                       0x000003E0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Latency from read command to start of rxodt generation (in 1x cycles)
    // 
    // Bits[4:0], RW, default = 0x0
    //
    UINTX b1_rdcmd2rxodten : 5;
    //
    // Reserved
    // 
    // Bits[10:5], RO, default = 0x0
    //
    UINTX reserved : 6;
    //
    // RXODT Enable - Preamble0 Phase[br]00 - Rise & Fall - Low & Low[br]01 - Rise &
    // Fall - High & Low[br]10 - Rise & Fall - Low & High[br]11 - Rise & Fall - High
    // & High 
    // 
    // Bits[12:11], RW, default = 0x0
    //
    UINTX b1_rxodtenpre0 : 2;
    //
    // RXODT Enable - Postamble0 Phase[br]00 - Rise & Fall - Low & Low[br]01 - Rise &
    // Fall - High & Low[br]10 - Rise & Fall - Low & High[br]11 - Rise & Fall - High
    // & High 
    // 
    // Bits[14:13], RW, default = 0x0
    //
    UINTX b1_rxodtenpst0 : 2;
    //
    // RXODT Enable - Preamble1 Phase[br]00 - Rise & Fall - Low & Low[br]01 - Rise &
    // Fall - High & Low[br]10 - Rise & Fall - Low & High[br]11 - Rise & Fall - High
    // & High 
    // 
    // Bits[16:15], RW, default = 0x0
    //
    UINTX b1_rxodtenpre1 : 2;
    //
    // RXODT Enable - Postamble1 Phase[br]00 - Rise & Fall - Low & Low[br]01 - Rise &
    // Fall - High & Low[br]10 - Rise & Fall - Low & High[br]11 - Rise & Fall - High
    // & High 
    // 
    // Bits[18:17], RW, default = 0x0
    //
    UINTX b1_rxodtenpst1 : 2;
    //
    // RXODT enable Length in number of 1x clocks (for a burst length of 4). Burst length
    // 8 is 2 of these. 
    // 
    // Bits[24:19], RW, default = 0x0
    //
    UINTX b1_rxodtenlenbl4 : 6;
    //
    // RXODT enable override value
    // 
    // Bits[25:25], RW, default = 0x0
    //
    UINTX b1_rxodtenb_ovr : 1;
    //
    // RXODT enable override enable. 1 = use override value. 0 = use RXODTEN from FIFO
    // logic 
    // 
    // Bits[26:26], RW, default = 0x0
    //
    UINTX b1_rxodtenb_val : 1;
    //
    // Reserved
    // 
    // Bits[31:27], RO, default = 0x0
    //
    UINTX reserved_1 : 5;
  } Bits;
  UINTX Data;
} RXODTENCTL_BL1_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define RXODTENOFST_BL1_DDRDQ_PHY_REG                      0x000003E4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // RXODT Enable Rank 0 FIFO ref2x clock read pointer offset
    // 
    // Bits[3:0], RW, default = 0x0
    //
    UINTX b1_rk0odtenrdptroffset : 4;
    //
    // RXODT Enable Rank 1 FIFO ref2x clock read pointer offset
    // 
    // Bits[7:4], RW, default = 0x0
    //
    UINTX b1_rk1odtenrdptroffset : 4;
    //
    // RXODT Enable Rank 2 FIFO ref2x clock read pointer offset
    // 
    // Bits[11:8], RW, default = 0x0
    //
    UINTX b1_rk2odtenrdptroffset : 4;
    //
    // RXODT Enable Rank 3 FIFO ref2x clock read pointer offset
    // 
    // Bits[15:12], RW, default = 0x0
    //
    UINTX b1_rk3odtenrdptroffset : 4;
    //
    // Reserved
    // 
    // Bits[31:16], RO, default = 0x0
    //
    UINTX reserved : 16;
  } Bits;
  UINTX Data;
} RXODTENOFST_BL1_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define RXODTSEGCTL_BL1_DDRDQ_PHY_REG                      0x000003E8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Latency from read command to start of dynamic rxodt segment generation (in 1x
    // cycles) 
    // 
    // Bits[4:0], RW, default = 0x0
    //
    UINTX b1_rdcmd2rxodtseg : 5;
    //
    // Reserved
    // 
    // Bits[10:5], RO, default = 0x0
    //
    UINTX reserved : 6;
    //
    // RXODT segment control - Preamble0 Phase[br]00 - Rise & Fall - Low & Low[br]01
    // - Rise & Fall - High & Low[br]10 - Rise & Fall - Low & High[br]11 - Rise & Fall
    // - High & High 
    // 
    // Bits[12:11], RW, default = 0x0
    //
    UINTX b1_rxodtsegpre0 : 2;
    //
    // RXODT segment control - Postamble0 Phase[br]00 - Rise & Fall - Low & Low[br]01
    // - Rise & Fall - High & Low[br]10 - Rise & Fall - Low & High[br]11 - Rise & Fall
    // - High & High 
    // 
    // Bits[14:13], RW, default = 0x0
    //
    UINTX b1_rxodtsegpst0 : 2;
    //
    // RXODT segment control - Preamble1 Phase[br]00 - Rise & Fall - Low & Low[br]01
    // - Rise & Fall - High & Low[br]10 - Rise & Fall - Low & High[br]11 - Rise & Fall
    // - High & High 
    // 
    // Bits[16:15], RW, default = 0x0
    //
    UINTX b1_rxodtsegpre1 : 2;
    //
    // RXODT segment control - Postamble1+C47 Phase[br]00 - Rise & Fall - Low & Low[br]01
    // - Rise & Fall - High & Low[br]10 - Rise & Fall - Low & High[br]11 - Rise & Fall
    // - High & High 
    // 
    // Bits[18:17], RW, default = 0x0
    //
    UINTX b1_rxodtsegpst1 : 2;
    //
    // RXODT segment control length in number of 1x clocks (for a burst length of 4).
    // Burst length 8 is 2 of these. 
    // 
    // Bits[24:19], RW, default = 0x0
    //
    UINTX b1_rxodtseglenbl4 : 6;
    //
    // RXODT segment enable generation scheme: 1-hot or 2-hot:[br]0: rxodtsegen: 001->010->100->001->
    // and so on  (DDR3)[br]1: rxodtsegen: 011->110->101->011-> and so on  (DDR4) 
    // 
    // Bits[25:25], RW, default = 0x0
    //
    UINTX b1_rxodtsegentwohot : 1;
    //
    // RXODT segment control override value
    // 
    // Bits[28:26], RW, default = 0x1
    //
    UINTX b1_rxodtsegen_val : 3;
    //
    // RXODT segment control override enable. 1 = use override value, 0 = use dynamic
    // segment generation 
    // 
    // Bits[29:29], RW, default = 0x0
    //
    UINTX b1_rxodtsegen_ovr : 1;
    //
    // Reserved
    // 
    // Bits[31:30], RO, default = 0x0
    //
    UINTX reserved_1 : 2;
  } Bits;
  UINTX Data;
} RXODTSEGCTL_BL1_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define RXODTSEGOFST_BL1_DDRDQ_PHY_REG                     0x000003EC
#ifndef ASM_INC
typedef union {
  struct {
    //
    // RXODT segment control Rank 0 FIFO ref2x clock read pointer offset
    // 
    // Bits[3:0], RW, default = 0x0
    //
    UINTX b1_rk0odtsegenrdptroffset : 4;
    //
    // RXODT segment control Rank 1 FIFO ref2x clock read pointer offset
    // 
    // Bits[7:4], RW, default = 0x0
    //
    UINTX b1_rk1odtsegenrdptroffset : 4;
    //
    // RXODT segment control Rank 2 FIFO ref2x clock read pointer offset
    // 
    // Bits[11:8], RW, default = 0x0
    //
    UINTX b1_rk2odtsegenrdptroffset : 4;
    //
    // RXODT segment control Rank 3 FIFO ref2x clock read pointer offset
    // 
    // Bits[15:12], RW, default = 0x0
    //
    UINTX b1_rk3odtsegenrdptroffset : 4;
    //
    // Reserved
    // 
    // Bits[31:16], RO, default = 0x0
    //
    UINTX reserved : 16;
  } Bits;
  UINTX Data;
} RXODTSEGOFST_BL1_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define RK2RKCTL0_BL1_DDRDQ_PHY_REG                        0x000003F0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // RK2RK Enable for TXDQ (PIcodes /sigrdptroffset/sigdbsel):[br]1 =  enabled, 0 =
    // disabled 
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINTX b1_rk2rken_txdq : 1;
    //
    // RK2RK Enable for TXDQS (PIcodes /sigrdptroffset/sigdbsel):[br]1 =  enabled, 0
    // = disabled 
    // 
    // Bits[1:1], RW, default = 0x0
    //
    UINTX b1_rk2rken_txdqs : 1;
    //
    // RK2RK Enable for RXDQS (PIcodes):[br]1 =  enabled, 0 = disabled
    // 
    // Bits[2:2], RW, default = 0x0
    //
    UINTX b1_rk2rken_rxdqs : 1;
    //
    // RK2RK Enable for TXRCVEN (PIcodes/sigrdptroffset/sigdbsel):[br]1 =  enabled, 0
    // = disabled 
    // 
    // Bits[3:3], RW, default = 0x0
    //
    UINTX b1_rk2rken_txrcven : 1;
    //
    // RK2RK Enable for RXDQ (rxpbd): 1 =  enabled, 0 = disabled
    // 
    // Bits[4:4], RW, default = 0x0
    //
    UINTX b1_rk2rken_rxdq : 1;
    //
    // Delay the switch of rxdqspi from rcvenpicode switch. 0: 0 delay,1 1 1x delay,
    // 2 or 3 : 2 1x delay 
    // 
    // Bits[6:5], RW, default = 0x0
    //
    UINTX b1_rk2rk_rxdqspiswitch_dly : 2;
    //
    // Rank pointers changes to Rank Pi changes delay. 0: 1 1xclk delay from pointers
    // rank change to pi rank change. 1: 2 1xclk delay from pointers rank change to pi
    // rank change. 
    // 
    // Bits[7:7], RW, default = 0x0
    //
    UINTX b1_rk2rk_rkptrchange2pichange_dly : 1;
    //
    // Reserved
    // 
    // Bits[31:8], RO, default = 0x0
    //
    UINTX reserved : 24;
  } Bits;
  UINTX Data;
} RK2RKCTL0_BL1_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define RK2RKCTL1_B1N0_DDRDQ_PHY_REG                       0x000003F4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Pattern for rk2rk_iodrvenb first cycle (bits 0 and 1) 1 = disable. Recommended
    // value = 3 
    // 
    // Bits[1:0], RW, default = 0x0
    //
    UINTX b1n0_rk2rkdrvenbpre : 2;
    //
    // Pattern for rk2rk_iodrvenb last cycle (bits 0 and 1) 1 = disable. Recommended
    // value = 1 
    // 
    // Bits[3:2], RW, default = 0x0
    //
    UINTX b1n0_rk2rkdrvenbpst : 2;
    //
    // rk2rk_iodrvenb length. in 1xclk cycles. Recommended value = 0
    // 
    // Bits[7:4], RW, default = 0x0
    //
    UINTX b1n0_rk2rkdrvenblen : 4;
    //
    // Pattern for rk2rk_rden first cycle (bits 0 and 1) 1 = disable. Recommended value
    // = 3 
    // 
    // Bits[9:8], RW, default = 0x0
    //
    UINTX b1n0_rk2rkrdenbpre : 2;
    //
    // Pattern for rk2rk_rden last cycle (bits 0 and 1) 1 = disable. Recommended value
    // = 1 
    // 
    // Bits[11:10], RW, default = 0x0
    //
    UINTX b1n0_rk2rkrdenbpst : 2;
    //
    // rk2rk_rden length. in 1xclk cycles. Recommended value = 0
    // 
    // Bits[15:12], RW, default = 0x0
    //
    UINTX b1n0_rk2rkrdenblen : 4;
    //
    // When set, pushes out the upload of txdq new rank information one more mio2xclk
    // addition to wrcmd2rkchglatency number of 1xclk delays. 
    // 
    // Bits[16:16], RW, default = 0x0
    //
    UINTX b1n0_rk2rktxdqmio2xclkpushout : 1;
    //
    // When set, pushes out the upload of txdqs new rank information one more mio2xclk
    // addition to wrcmd2rkchglatency number of 1xclk delays. 
    // 
    // Bits[17:17], RW, default = 0x0
    //
    UINTX b1n0_rk2rktxdqsmio2xclkpushout : 1;
    //
    // When set, pushes out the de-assertion of rk2rk_drvenb_txdq / rk2rk_drvenb_txdqs
    // one more mio2xclk addition to wrcmd2rkchglatency number of 1xclk delays. 
    // 
    // Bits[18:18], RW, default = 0x0
    //
    UINTX b1n0_rk2rkiodrvenmio2xclkpushout : 1;
    //
    // When set, pushes out the upload of rxdqs new rank information one more mio2xclk
    // addition to rdcmd2rkchglatency number of 1xclk delays. 
    // 
    // Bits[19:19], RW, default = 0x0
    //
    UINTX b1n0_rk2rkrxdqsmio2xclkpushout : 1;
    //
    // When set, pushes out the upload of txrcven new rank information one more mio2xclk
    // addition to rdcmd2rkchglatency number of 1xclk delays. 
    // 
    // Bits[20:20], RW, default = 0x0
    //
    UINTX b1n0_rk2rktxrcvenmio2xclkpushout : 1;
    //
    // When set, pushes out the de-assertion  of rk2rk_rden one more mio2xclk addition
    // to rdcmd2rkchglatency number of 1xclk delays. 
    // 
    // Bits[21:21], RW, default = 0x0
    //
    UINTX b1n0_rk2rkrdenmio2xclkpushout : 1;
    //
    // When set, pushes out the upload of rxdq new rank information one more mio2xclk
    // addition to rdcmd2rkchglatency number of 1xclk delays. 
    // 
    // Bits[22:22], RW, default = 0x0
    //
    UINTX b1n0_rk2rkrxdqmio2xclkpushout : 1;
    //
    // Reserved
    // 
    // Bits[31:23], RO, default = 0x0
    //
    UINTX reserved : 9;
  } Bits;
  UINTX Data;
} RK2RKCTL1_B1N0_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define RK2RKCTL2_B1N0_DDRDQ_PHY_REG                       0x000003F8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Latency from write command to Rank information update (in 1x cycles)
    // 
    // Bits[4:0], RW, default = 0x0
    //
    UINTX b1n0_wrcmd2rkchglatency : 5;
    //
    // Latency from read command to Rank information update (in 1x cycles)
    // 
    // Bits[9:5], RW, default = 0x0
    //
    UINTX b1n0_rdcmd2rkchglatency : 5;
    //
    // Reserved
    // 
    // Bits[31:10], RO, default = 0x0
    //
    UINTX reserved : 22;
  } Bits;
  UINTX Data;
} RK2RKCTL2_B1N0_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define RK2RKCTL1_B1N1_DDRDQ_PHY_REG                       0x000003FC
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Pattern for rk2rk_iodrvenb first cycle (bits 0 and 1) 1 = disable. Recommended
    // value = 3 
    // 
    // Bits[1:0], RW, default = 0x0
    //
    UINTX b1n1_rk2rkdrvenbpre : 2;
    //
    // Pattern for rk2rk_iodrvenb last cycle (bits 0 and 1) 1 = disable. Recommended
    // value = 1 
    // 
    // Bits[3:2], RW, default = 0x0
    //
    UINTX b1n1_rk2rkdrvenbpst : 2;
    //
    // rk2rk_iodrvenb length. in 1xclk cycles. Recommended value = 0
    // 
    // Bits[7:4], RW, default = 0x0
    //
    UINTX b1n1_rk2rkdrvenblen : 4;
    //
    // Pattern for rk2rk_rden first cycle (bits 0 and 1) 1 = disable. Recommended value
    // = 3 
    // 
    // Bits[9:8], RW, default = 0x0
    //
    UINTX b1n1_rk2rkrdenbpre : 2;
    //
    // Pattern for rk2rk_rden last cycle (bits 0 and 1) 1 = disable. Recommended value
    // = 1 
    // 
    // Bits[11:10], RW, default = 0x0
    //
    UINTX b1n1_rk2rkrdenbpst : 2;
    //
    // rk2rk_rden length. in 1xclk cycles. Recommended value = 0
    // 
    // Bits[15:12], RW, default = 0x0
    //
    UINTX b1n1_rk2rkrdenblen : 4;
    //
    // When set, pushes out the upload of txdq new rank information one more mio2xclk
    // addition to wrcmd2rkchglatency number of 1xclk delays. 
    // 
    // Bits[16:16], RW, default = 0x0
    //
    UINTX b1n1_rk2rktxdqmio2xclkpushout : 1;
    //
    // When set, pushes out the upload of txdqs new rank information one more mio2xclk
    // addition to wrcmd2rkchglatency number of 1xclk delays. 
    // 
    // Bits[17:17], RW, default = 0x0
    //
    UINTX b1n1_rk2rktxdqsmio2xclkpushout : 1;
    //
    // When set, pushes out the de-assertion of rk2rk_drvenb_txdq / rk2rk_drvenb_txdqs
    // one more mio2xclk addition to wrcmd2rkchglatency number of 1xclk delays. 
    // 
    // Bits[18:18], RW, default = 0x0
    //
    UINTX b1n1_rk2rkiodrvenmio2xclkpushout : 1;
    //
    // When set, pushes out the upload of rxdqs new rank information one more mio2xclk
    // addition to rdcmd2rkchglatency number of 1xclk delays. 
    // 
    // Bits[19:19], RW, default = 0x0
    //
    UINTX b1n1_rk2rkrxdqsmio2xclkpushout : 1;
    //
    // When set, pushes out the upload of txrcven new rank information one more mio2xclk
    // addition to rdcmd2rkchglatency number of 1xclk delays. 
    // 
    // Bits[20:20], RW, default = 0x0
    //
    UINTX b1n1_rk2rktxrcvenmio2xclkpushout : 1;
    //
    // When set, pushes out the de-assertion  of rk2rk_rden one more mio2xclk addition
    // to rdcmd2rkchglatency number of 1xclk delays. 
    // 
    // Bits[21:21], RW, default = 0x0
    //
    UINTX b1n1_rk2rkrdenmio2xclkpushout : 1;
    //
    // When set, pushes out the upload of rxdq new rank information one more mio2xclk
    // addition to rdcmd2rkchglatency number of 1xclk delays. 
    // 
    // Bits[22:22], RW, default = 0x0
    //
    UINTX b1n1_rk2rkrxdqmio2xclkpushout : 1;
    //
    // Reserved
    // 
    // Bits[31:23], RO, default = 0x0
    //
    UINTX reserved : 9;
  } Bits;
  UINTX Data;
} RK2RKCTL1_B1N1_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define RK2RKCTL2_B1N1_DDRDQ_PHY_REG                       0x00000400
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Latency from write command to Rank information update (in 1x cycles)
    // 
    // Bits[4:0], RW, default = 0x0
    //
    UINTX b1n1_wrcmd2rkchglatency : 5;
    //
    // Latency from read command to Rank information update (in 1x cycles)
    // 
    // Bits[9:5], RW, default = 0x0
    //
    UINTX b1n1_rdcmd2rkchglatency : 5;
    //
    // Reserved
    // 
    // Bits[31:10], RO, default = 0x0
    //
    UINTX reserved : 22;
  } Bits;
  UINTX Data;
} RK2RKCTL2_B1N1_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define DQSIGCTL0_B1N0_DDRDQ_PHY_REG                       0x00000404
#ifndef ASM_INC
typedef union {
  struct {
    //
    // DQ data rank 0 signal clock deadband select. 00: No Deadband Zone[br]01: No Deadband
    // Zone 270 pathsel[br]10: Deadband 90 degree path sel[br]11: Deadband 180 degree
    // path sel. 
    // 
    // Bits[1:0], RW, default = 0x0
    //
    UINTX b1n0_rk0dqsigdbsel : 2;
    //
    // DQ data rank 1 signal clock deadband select. 00: No Deadband Zone[br]01: No Deadband
    // Zone 270 pathsel[br]10: Deadband 90 degree path sel[br]11: Deadband 180 degree
    // path sel. 
    // 
    // Bits[3:2], RW, default = 0x0
    //
    UINTX b1n0_rk1dqsigdbsel : 2;
    //
    // DQ data rank 2 signal clock deadband select. 00: No Deadband Zone[br]01: No Deadband
    // Zone 270 pathsel[br]10: Deadband 90 degree path sel[br]11: Deadband 180 degree
    // path sel. 
    // 
    // Bits[5:4], RW, default = 0x0
    //
    UINTX b1n0_rk2dqsigdbsel : 2;
    //
    // DQ data rank 3 signal clock deadband select. 00: No Deadband Zone[br]01: No Deadband
    // Zone 270 pathsel[br]10: Deadband 90 degree path sel[br]11: Deadband 180 degree
    // path sel. 
    // 
    // Bits[7:6], RW, default = 0x0
    //
    UINTX b1n0_rk3dqsigdbsel : 2;
    //
    // DQ data rank 0 signal clock read pointer offset
    // 
    // Bits[12:8], RW, default = 0x0
    //
    UINTX b1n0_rk0dqsigrdptroffset : 5;
    //
    // DQ data rank 1 signal clock read pointer offset
    // 
    // Bits[17:13], RW, default = 0x0
    //
    UINTX b1n0_rk1dqsigrdptroffset : 5;
    //
    // DQ data rank 2 signal clock read pointer offset
    // 
    // Bits[22:18], RW, default = 0x0
    //
    UINTX b1n0_rk2dqsigrdptroffset : 5;
    //
    // DQ data rank 3 signal clock read pointer offset
    // 
    // Bits[27:23], RW, default = 0x0
    //
    UINTX b1n0_rk3dqsigrdptroffset : 5;
    //
    // Reserved
    // 
    // Bits[31:28], RO, default = 0x0
    //
    UINTX reserved : 4;
  } Bits;
  UINTX Data;
} DQSIGCTL0_B1N0_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define DQSIGCTL0_B1N1_DDRDQ_PHY_REG                       0x00000408
#ifndef ASM_INC
typedef union {
  struct {
    //
    // DQ data rank 0 signal clock deadband select. 00: No Deadband Zone[br]01: No Deadband
    // Zone 270 pathsel[br]10: Deadband 90 degree path sel[br]11: Deadband 180 degree
    // path sel. 
    // 
    // Bits[1:0], RW, default = 0x0
    //
    UINTX b1n1_rk0dqsigdbsel : 2;
    //
    // DQ data rank 1 signal clock deadband select. 00: No Deadband Zone[br]01: No Deadband
    // Zone 270 pathsel[br]10: Deadband 90 degree path sel[br]11: Deadband 180 degree
    // path sel. 
    // 
    // Bits[3:2], RW, default = 0x0
    //
    UINTX b1n1_rk1dqsigdbsel : 2;
    //
    // DQ data rank 2 signal clock deadband select. 00: No Deadband Zone[br]01: No Deadband
    // Zone 270 pathsel[br]10: Deadband 90 degree path sel[br]11: Deadband 180 degree
    // path sel. 
    // 
    // Bits[5:4], RW, default = 0x0
    //
    UINTX b1n1_rk2dqsigdbsel : 2;
    //
    // DQ data rank 3 signal clock deadband select. 00: No Deadband Zone[br]01: No Deadband
    // Zone 270 pathsel[br]10: Deadband 90 degree path sel[br]11: Deadband 180 degree
    // path sel. 
    // 
    // Bits[7:6], RW, default = 0x0
    //
    UINTX b1n1_rk3dqsigdbsel : 2;
    //
    // DQ data rank 0 signal clock read pointer offset
    // 
    // Bits[12:8], RW, default = 0x0
    //
    UINTX b1n1_rk0dqsigrdptroffset : 5;
    //
    // DQ data rank 1 signal clock read pointer offset
    // 
    // Bits[17:13], RW, default = 0x0
    //
    UINTX b1n1_rk1dqsigrdptroffset : 5;
    //
    // DQ data rank 2 signal clock read pointer offset
    // 
    // Bits[22:18], RW, default = 0x0
    //
    UINTX b1n1_rk2dqsigrdptroffset : 5;
    //
    // DQ data rank 3 signal clock read pointer offset
    // 
    // Bits[27:23], RW, default = 0x0
    //
    UINTX b1n1_rk3dqsigrdptroffset : 5;
    //
    // Reserved
    // 
    // Bits[31:28], RO, default = 0x0
    //
    UINTX reserved : 4;
  } Bits;
  UINTX Data;
} DQSIGCTL0_B1N1_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define DQSIGCTL1_B1N0_DDRDQ_PHY_REG                       0x0000040C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // DQ drvenb rank 0 signal clock deadband select. 00: No Deadband Zone[br]01: No
    // Deadband Zone 270 pathsel[br]10: Deadband 90 degree path sel[br]11: Deadband 180
    // degree path sel. 
    // 
    // Bits[1:0], RW, default = 0x0
    //
    UINTX b1n0_rk0dqdrvsigdbsel : 2;
    //
    // DQ drvenb rank 1 signal clock deadband select. 00: No Deadband Zone[br]01: No
    // Deadband Zone 270 pathsel[br]10: Deadband 90 degree path sel[br]11: Deadband 180
    // degree path sel. 
    // 
    // Bits[3:2], RW, default = 0x0
    //
    UINTX b1n0_rk1dqdrvsigdbsel : 2;
    //
    // DQ drvenb rank 2 signal clock deadband select. 00: No Deadband Zone[br]01: No
    // Deadband Zone 270 pathsel[br]10: Deadband 90 degree path sel[br]11: Deadband 180
    // degree path sel. 
    // 
    // Bits[5:4], RW, default = 0x0
    //
    UINTX b1n0_rk2dqdrvsigdbsel : 2;
    //
    // DQ drvenb rank 3 signal clock deadband select. 00: No Deadband Zone[br]01: No
    // Deadband Zone 270 pathsel[br]10: Deadband 90 degree path sel[br]11: Deadband 180
    // degree path sel. 
    // 
    // Bits[7:6], RW, default = 0x0
    //
    UINTX b1n0_rk3dqdrvsigdbsel : 2;
    //
    // DQ drvenb rank 0 signal clock read pointer offset
    // 
    // Bits[11:8], RW, default = 0x0
    //
    UINTX b1n0_rk0dqdrvsigrdptroffset : 4;
    //
    // DQ drvenb rank 1 signal clock read pointer offset
    // 
    // Bits[15:12], RW, default = 0x0
    //
    UINTX b1n0_rk1dqdrvsigrdptroffset : 4;
    //
    // DQ drvenb rank 2 signal clock read pointer offset
    // 
    // Bits[19:16], RW, default = 0x0
    //
    UINTX b1n0_rk2dqdrvsigrdptroffset : 4;
    //
    // DQ drvenb rank 3 signal clock read pointer offset
    // 
    // Bits[23:20], RW, default = 0x0
    //
    UINTX b1n0_rk3dqdrvsigrdptroffset : 4;
    //
    // Reserved
    // 
    // Bits[31:24], RO, default = 0x0
    //
    UINTX reserved : 8;
  } Bits;
  UINTX Data;
} DQSIGCTL1_B1N0_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define DQSIGCTL1_B1N1_DDRDQ_PHY_REG                       0x00000410
#ifndef ASM_INC
typedef union {
  struct {
    //
    // DQ drvenb rank 0 signal clock deadband select. 00: No Deadband Zone[br]01: No
    // Deadband Zone 270 pathsel[br]10: Deadband 90 degree path sel[br]11: Deadband 180
    // degree path sel. 
    // 
    // Bits[1:0], RW, default = 0x0
    //
    UINTX b1n1_rk0dqdrvsigdbsel : 2;
    //
    // DQ drvenb rank 1 signal clock deadband select. 00: No Deadband Zone[br]01: No
    // Deadband Zone 270 pathsel[br]10: Deadband 90 degree path sel[br]11: Deadband 180
    // degree path sel. 
    // 
    // Bits[3:2], RW, default = 0x0
    //
    UINTX b1n1_rk1dqdrvsigdbsel : 2;
    //
    // DQ drvenb rank 2 signal clock deadband select. 00: No Deadband Zone[br]01: No
    // Deadband Zone 270 pathsel[br]10: Deadband 90 degree path sel[br]11: Deadband 180
    // degree path sel. 
    // 
    // Bits[5:4], RW, default = 0x0
    //
    UINTX b1n1_rk2dqdrvsigdbsel : 2;
    //
    // DQ drvenb rank 3 signal clock deadband select. 00: No Deadband Zone[br]01: No
    // Deadband Zone 270 pathsel[br]10: Deadband 90 degree path sel[br]11: Deadband 180
    // degree path sel. 
    // 
    // Bits[7:6], RW, default = 0x0
    //
    UINTX b1n1_rk3dqdrvsigdbsel : 2;
    //
    // DQ drvenb rank 0 signal clock read pointer offset
    // 
    // Bits[11:8], RW, default = 0x0
    //
    UINTX b1n1_rk0dqdrvsigrdptroffset : 4;
    //
    // DQ drvenb rank 1 signal clock read pointer offset
    // 
    // Bits[15:12], RW, default = 0x0
    //
    UINTX b1n1_rk1dqdrvsigrdptroffset : 4;
    //
    // DQ drvenb rank 2 signal clock read pointer offset
    // 
    // Bits[19:16], RW, default = 0x0
    //
    UINTX b1n1_rk2dqdrvsigrdptroffset : 4;
    //
    // DQ drvenb rank 3 signal clock read pointer offset
    // 
    // Bits[23:20], RW, default = 0x0
    //
    UINTX b1n1_rk3dqdrvsigrdptroffset : 4;
    //
    // Reserved
    // 
    // Bits[31:24], RO, default = 0x0
    //
    UINTX reserved : 8;
  } Bits;
  UINTX Data;
} DQSIGCTL1_B1N1_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define DQSIGCTL2_B1N0_DDRDQ_PHY_REG                       0x00000414
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Nibble 0 DQ rank 0 sigclk PI code
    // 
    // Bits[5:0], RW, default = 0x0
    //
    UINTX b1n0_txdll_rk0siggrp07picode : 6;
    //
    // Nibble 0 DQ rank 1 sigclk PI code
    // 
    // Bits[11:6], RW, default = 0x0
    //
    UINTX b1n0_txdll_rk1siggrp07picode : 6;
    //
    // Nibble 0 DQ rank 2 sigclk PI code
    // 
    // Bits[17:12], RW, default = 0x0
    //
    UINTX b1n0_txdll_rk2siggrp07picode : 6;
    //
    // Nibble 0 DQ rank 3 sigclk PI code
    // 
    // Bits[23:18], RW, default = 0x0
    //
    UINTX b1n0_txdll_rk3siggrp07picode : 6;
    //
    // Reserved
    // 
    // Bits[31:24], RO, default = 0x0
    //
    UINTX reserved : 8;
  } Bits;
  UINTX Data;
} DQSIGCTL2_B1N0_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define DQSIGCTL2_B1N1_DDRDQ_PHY_REG                       0x00000418
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Nibble 1 DQ rank 0 sigclk PI code
    // 
    // Bits[5:0], RW, default = 0x0
    //
    UINTX b1n1_txdll_rk0siggrp10picode : 6;
    //
    // Nibble 1 DQ rank 1 sigclk PI code
    // 
    // Bits[11:6], RW, default = 0x0
    //
    UINTX b1n1_txdll_rk1siggrp10picode : 6;
    //
    // Nibble 1 DQ rank 2 sigclk PI code
    // 
    // Bits[17:12], RW, default = 0x0
    //
    UINTX b1n1_txdll_rk2siggrp10picode : 6;
    //
    // Nibble 1 DQ rank 3 sigclk PI code
    // 
    // Bits[23:18], RW, default = 0x0
    //
    UINTX b1n1_txdll_rk3siggrp10picode : 6;
    //
    // Reserved
    // 
    // Bits[31:24], RO, default = 0x0
    //
    UINTX reserved : 8;
  } Bits;
  UINTX Data;
} DQSIGCTL2_B1N1_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define DQSSIGCTL0_B1N0_DDRDQ_PHY_REG                      0x0000041C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // DQS rank 0 signal clock deadband select. 00: No Deadband Zone[br]01: No Deadband
    // Zone 270 pathsel[br]10: Deadband 90 degree path sel[br]11: Deadband 180 degree
    // path sel. 
    // 
    // Bits[1:0], RW, default = 0x0
    //
    UINTX b1n0_rk0dqssigdbsel : 2;
    //
    // DQS rank 1 signal clock deadband select. 00: No Deadband Zone[br]01: No Deadband
    // Zone 270 pathsel[br]10: Deadband 90 degree path sel[br]11: Deadband 180 degree
    // path sel. 
    // 
    // Bits[3:2], RW, default = 0x0
    //
    UINTX b1n0_rk1dqssigdbsel : 2;
    //
    // DQS rank 2 signal clock deadband select. 00: No Deadband Zone[br]01: No Deadband
    // Zone 270 pathsel[br]10: Deadband 90 degree path sel[br]11: Deadband 180 degree
    // path sel. 
    // 
    // Bits[5:4], RW, default = 0x0
    //
    UINTX b1n0_rk2dqssigdbsel : 2;
    //
    // DQS rank 3 signal clock deadband select. 00: No Deadband Zone[br]01: No Deadband
    // Zone 270 pathsel[br]10: Deadband 90 degree path sel[br]11: Deadband 180 degree
    // path sel. 
    // 
    // Bits[7:6], RW, default = 0x0
    //
    UINTX b1n0_rk3dqssigdbsel : 2;
    //
    // DQS rank 0 signal clock read pointer offset
    // 
    // Bits[11:8], RW, default = 0x0
    //
    UINTX b1n0_rk0dqssigrdptroffset : 4;
    //
    // DQS rank 1 signal clock read pointer offset
    // 
    // Bits[15:12], RW, default = 0x0
    //
    UINTX b1n0_rk1dqssigrdptroffset : 4;
    //
    // DQS rank 2 signal clock read pointer offset
    // 
    // Bits[19:16], RW, default = 0x0
    //
    UINTX b1n0_rk2dqssigrdptroffset : 4;
    //
    // DQS rank 3 signal clock read pointer offset
    // 
    // Bits[23:20], RW, default = 0x0
    //
    UINTX b1n0_rk3dqssigrdptroffset : 4;
    //
    // Reserved
    // 
    // Bits[31:24], RO, default = 0x0
    //
    UINTX reserved : 8;
  } Bits;
  UINTX Data;
} DQSSIGCTL0_B1N0_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define DQSSIGCTL0_B1N1_DDRDQ_PHY_REG                      0x00000420
#ifndef ASM_INC
typedef union {
  struct {
    //
    // DQS rank 0 signal clock deadband select. 00: No Deadband Zone[br]01: No Deadband
    // Zone 270 pathsel[br]10: Deadband 90 degree path sel[br]11: Deadband 180 degree
    // path sel. 
    // 
    // Bits[1:0], RW, default = 0x0
    //
    UINTX b1n1_rk0dqssigdbsel : 2;
    //
    // DQS rank 1 signal clock deadband select. 00: No Deadband Zone[br]01: No Deadband
    // Zone 270 pathsel[br]10: Deadband 90 degree path sel[br]11: Deadband 180 degree
    // path sel. 
    // 
    // Bits[3:2], RW, default = 0x0
    //
    UINTX b1n1_rk1dqssigdbsel : 2;
    //
    // DQS rank 2 signal clock deadband select. 00: No Deadband Zone[br]01: No Deadband
    // Zone 270 pathsel[br]10: Deadband 90 degree path sel[br]11: Deadband 180 degree
    // path sel. 
    // 
    // Bits[5:4], RW, default = 0x0
    //
    UINTX b1n1_rk2dqssigdbsel : 2;
    //
    // DQS rank 3 signal clock deadband select. 00: No Deadband Zone[br]01: No Deadband
    // Zone 270 pathsel[br]10: Deadband 90 degree path sel[br]11: Deadband 180 degree
    // path sel. 
    // 
    // Bits[7:6], RW, default = 0x0
    //
    UINTX b1n1_rk3dqssigdbsel : 2;
    //
    // DQS rank 0 signal clock read pointer offset
    // 
    // Bits[11:8], RW, default = 0x0
    //
    UINTX b1n1_rk0dqssigrdptroffset : 4;
    //
    // DQS rank 1 signal clock read pointer offset
    // 
    // Bits[15:12], RW, default = 0x0
    //
    UINTX b1n1_rk1dqssigrdptroffset : 4;
    //
    // DQS rank 2 signal clock read pointer offset
    // 
    // Bits[19:16], RW, default = 0x0
    //
    UINTX b1n1_rk2dqssigrdptroffset : 4;
    //
    // DQS rank 3 signal clock read pointer offset
    // 
    // Bits[23:20], RW, default = 0x0
    //
    UINTX b1n1_rk3dqssigrdptroffset : 4;
    //
    // Reserved
    // 
    // Bits[31:24], RO, default = 0x0
    //
    UINTX reserved : 8;
  } Bits;
  UINTX Data;
} DQSSIGCTL0_B1N1_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define DQSSIGCTL1_B1N0_DDRDQ_PHY_REG                      0x00000424
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Nibble 0 DQS rank 0 sigclk PI code
    // 
    // Bits[5:0], RW, default = 0x0
    //
    UINTX b1n0_txdll_rk0siggrp06picode : 6;
    //
    // Nibble 0 DQS rank 1 sigclk PI code
    // 
    // Bits[11:6], RW, default = 0x0
    //
    UINTX b1n0_txdll_rk1siggrp06picode : 6;
    //
    // Nibble 0 DQS rank 2 sigclk PI code
    // 
    // Bits[17:12], RW, default = 0x0
    //
    UINTX b1n0_txdll_rk2siggrp06picode : 6;
    //
    // Nibble 0 DQS rank 3 sigclk PI code
    // 
    // Bits[23:18], RW, default = 0x0
    //
    UINTX b1n0_txdll_rk3siggrp06picode : 6;
    //
    // Reserved
    // 
    // Bits[31:24], RO, default = 0x0
    //
    UINTX reserved : 8;
  } Bits;
  UINTX Data;
} DQSSIGCTL1_B1N0_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define DQSSIGCTL1_B1N1_DDRDQ_PHY_REG                      0x00000428
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Nibble 1 DQS rank 0 sigclk PI code
    // 
    // Bits[5:0], RW, default = 0x0
    //
    UINTX b1n1_txdll_rk0siggrp09picode : 6;
    //
    // Nibble 1 DQS rank 1 sigclk PI code
    // 
    // Bits[11:6], RW, default = 0x0
    //
    UINTX b1n1_txdll_rk1siggrp09picode : 6;
    //
    // Nibble 1 DQS rank 2 sigclk PI code
    // 
    // Bits[17:12], RW, default = 0x0
    //
    UINTX b1n1_txdll_rk2siggrp09picode : 6;
    //
    // Nibble 1 DQS rank 3 sigclk PI code
    // 
    // Bits[23:18], RW, default = 0x0
    //
    UINTX b1n1_txdll_rk3siggrp09picode : 6;
    //
    // Reserved
    // 
    // Bits[31:24], RO, default = 0x0
    //
    UINTX reserved : 8;
  } Bits;
  UINTX Data;
} DQSSIGCTL1_B1N1_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define RCVENSIGCTL0_B1N0_DDRDQ_PHY_REG                    0x0000042C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Receive Enable rank 0 signal clock deadband select. 00: No Deadband Zone[br]01:
    // No Deadband Zone 270 pathsel[br]10: Deadband 90 degree path sel[br]11: Deadband
    // 180 degree path sel. 
    // 
    // Bits[1:0], RW, default = 0x0
    //
    UINTX b1n0_rk0rcvensigdbsel : 2;
    //
    // Receive Enable rank 1 signal clock deadband select. 00: No Deadband Zone[br]01:
    // No Deadband Zone 270 pathsel[br]10: Deadband 90 degree path sel[br]11: Deadband
    // 180 degree path sel. 
    // 
    // Bits[3:2], RW, default = 0x0
    //
    UINTX b1n0_rk1rcvensigdbsel : 2;
    //
    // Receive Enable rank 2 signal clock deadband select. 00: No Deadband Zone[br]01:
    // No Deadband Zone 270 pathsel[br]10: Deadband 90 degree path sel[br]11: Deadband
    // 180 degree path sel. 
    // 
    // Bits[5:4], RW, default = 0x0
    //
    UINTX b1n0_rk2rcvensigdbsel : 2;
    //
    // Receive Enable rank 3 signal clock deadband select. 00: No Deadband Zone[br]01:
    // No Deadband Zone 270 pathsel[br]10: Deadband 90 degree path sel[br]11: Deadband
    // 180 degree path sel. 
    // 
    // Bits[7:6], RW, default = 0x0
    //
    UINTX b1n0_rk3rcvensigdbsel : 2;
    //
    // Receive Enable rank 0 signal clock read pointer offset
    // 
    // Bits[11:8], RW, default = 0x0
    //
    UINTX b1n0_rk0rcvensigrdptroffset : 4;
    //
    // Receive Enable rank 1 signal clock read pointer offset
    // 
    // Bits[15:12], RW, default = 0x0
    //
    UINTX b1n0_rk1rcvensigrdptroffset : 4;
    //
    // Receive Enable rank 2 signal clock read pointer offset
    // 
    // Bits[19:16], RW, default = 0x0
    //
    UINTX b1n0_rk2rcvensigrdptroffset : 4;
    //
    // Receive Enable rank 3 signal clock read pointer offset
    // 
    // Bits[23:20], RW, default = 0x0
    //
    UINTX b1n0_rk3rcvensigrdptroffset : 4;
    //
    // Reserved
    // 
    // Bits[31:24], RO, default = 0x0
    //
    UINTX reserved : 8;
  } Bits;
  UINTX Data;
} RCVENSIGCTL0_B1N0_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define RCVENSIGCTL0_B1N1_DDRDQ_PHY_REG                    0x00000430
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Receive Enable rank 0 signal clock deadband select. 00: No Deadband Zone[br]01:
    // No Deadband Zone 270 pathsel[br]10: Deadband 90 degree path sel[br]11: Deadband
    // 180 degree path sel. 
    // 
    // Bits[1:0], RW, default = 0x0
    //
    UINTX b1n1_rk0rcvensigdbsel : 2;
    //
    // Receive Enable rank 1 signal clock deadband select. 00: No Deadband Zone[br]01:
    // No Deadband Zone 270 pathsel[br]10: Deadband 90 degree path sel[br]11: Deadband
    // 180 degree path sel. 
    // 
    // Bits[3:2], RW, default = 0x0
    //
    UINTX b1n1_rk1rcvensigdbsel : 2;
    //
    // Receive Enable rank 2 signal clock deadband select. 00: No Deadband Zone[br]01:
    // No Deadband Zone 270 pathsel[br]10: Deadband 90 degree path sel[br]11: Deadband
    // 180 degree path sel. 
    // 
    // Bits[5:4], RW, default = 0x0
    //
    UINTX b1n1_rk2rcvensigdbsel : 2;
    //
    // Receive Enable rank 3 signal clock deadband select. 00: No Deadband Zone[br]01:
    // No Deadband Zone 270 pathsel[br]10: Deadband 90 degree path sel[br]11: Deadband
    // 180 degree path sel. 
    // 
    // Bits[7:6], RW, default = 0x0
    //
    UINTX b1n1_rk3rcvensigdbsel : 2;
    //
    // Receive Enable rank 0 signal clock read pointer offset
    // 
    // Bits[11:8], RW, default = 0x0
    //
    UINTX b1n1_rk0rcvensigrdptroffset : 4;
    //
    // Receive Enable rank 1 signal clock read pointer offset
    // 
    // Bits[15:12], RW, default = 0x0
    //
    UINTX b1n1_rk1rcvensigrdptroffset : 4;
    //
    // Receive Enable rank 2 signal clock read pointer offset
    // 
    // Bits[19:16], RW, default = 0x0
    //
    UINTX b1n1_rk2rcvensigrdptroffset : 4;
    //
    // Receive Enable rank 3 signal clock read pointer offset
    // 
    // Bits[23:20], RW, default = 0x0
    //
    UINTX b1n1_rk3rcvensigrdptroffset : 4;
    //
    // Reserved
    // 
    // Bits[31:24], RO, default = 0x0
    //
    UINTX reserved : 8;
  } Bits;
  UINTX Data;
} RCVENSIGCTL0_B1N1_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define RCVENSIGCTL1_B1N0_DDRDQ_PHY_REG                    0x00000434
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Nibble0 Receive Enable rank 1 sigclk PI code
    // 
    // Bits[5:0], RW, default = 0x0
    //
    UINTX b1n0_txdll_rk0siggrp08picode : 6;
    //
    // Nibble0 Receive Enable rank 1 sigclk PI code
    // 
    // Bits[11:6], RW, default = 0x0
    //
    UINTX b1n0_txdll_rk1siggrp08picode : 6;
    //
    // Nibble0 Receive Enable rank 1 sigclk PI code
    // 
    // Bits[17:12], RW, default = 0x0
    //
    UINTX b1n0_txdll_rk2siggrp08picode : 6;
    //
    // Nibble0 Receive Enable rank 1 sigclk PI code
    // 
    // Bits[23:18], RW, default = 0x0
    //
    UINTX b1n0_txdll_rk3siggrp08picode : 6;
    //
    // Reserved
    // 
    // Bits[31:24], RO, default = 0x0
    //
    UINTX reserved : 8;
  } Bits;
  UINTX Data;
} RCVENSIGCTL1_B1N0_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define RCVENSIGCTL1_B1N1_DDRDQ_PHY_REG                    0x00000438
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Nibble1 Receive Enable rank 1 sigclk PI code
    // 
    // Bits[5:0], RW, default = 0x0
    //
    UINTX b1n1_txdll_rk0siggrp11picode : 6;
    //
    // Nibble1 Receive Enable rank 1 sigclk PI code
    // 
    // Bits[11:6], RW, default = 0x0
    //
    UINTX b1n1_txdll_rk1siggrp11picode : 6;
    //
    // Nibble1 Receive Enable rank 1 sigclk PI code
    // 
    // Bits[17:12], RW, default = 0x0
    //
    UINTX b1n1_txdll_rk2siggrp11picode : 6;
    //
    // Nibble1 Receive Enable rank 1 sigclk PI code
    // 
    // Bits[23:18], RW, default = 0x0
    //
    UINTX b1n1_txdll_rk3siggrp11picode : 6;
    //
    // Reserved
    // 
    // Bits[31:24], RO, default = 0x0
    //
    UINTX reserved : 8;
  } Bits;
  UINTX Data;
} RCVENSIGCTL1_B1N1_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define DQSRXDLL_B1N0_DDRDQ_PHY_REG                        0x0000043C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Nibble 0 DQS rank 1 RX slave delay line PI code. This is used to centre the DQS
    // in the DQ eye 
    // 
    // Bits[6:0], RW, default = 0x0
    //
    UINTX b1n0_rxdll_rk0dqspicode : 7;
    //
    // Nibble 0 DQS rank 1 RX slave delay line PI code. This is used to centre the DQS
    // in the DQ eye 
    // 
    // Bits[13:7], RW, default = 0x0
    //
    UINTX b1n0_rxdll_rk1dqspicode : 7;
    //
    // Nibble 0 DQS rank 1 RX slave delay line PI code. This is used to centre the DQS
    // in the DQ eye 
    // 
    // Bits[20:14], RW, default = 0x0
    //
    UINTX b1n0_rxdll_rk2dqspicode : 7;
    //
    // Nibble 0 DQS rank 1 RX slave delay line PI code. This is used to centre the DQS
    // in the DQ eye 
    // 
    // Bits[27:21], RW, default = 0x0
    //
    UINTX b1n0_rxdll_rk3dqspicode : 7;
    //
    // Reserved
    // 
    // Bits[31:28], RO, default = 0x0
    //
    UINTX reserved : 4;
  } Bits;
  UINTX Data;
} DQSRXDLL_B1N0_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define DQSRXDLL_B1N1_DDRDQ_PHY_REG                        0x00000440
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Nibble 1 DQS rank 1 RX slave delay line PI code. This is used to centre the DQS
    // in the DQ eye 
    // 
    // Bits[6:0], RW, default = 0x0
    //
    UINTX b1n1_rxdll_rk0dqspicode : 7;
    //
    // Nibble 1 DQS rank 1 RX slave delay line PI code. This is used to centre the DQS
    // in the DQ eye 
    // 
    // Bits[13:7], RW, default = 0x0
    //
    UINTX b1n1_rxdll_rk1dqspicode : 7;
    //
    // Nibble 1 DQS rank 1 RX slave delay line PI code. This is used to centre the DQS
    // in the DQ eye 
    // 
    // Bits[20:14], RW, default = 0x0
    //
    UINTX b1n1_rxdll_rk2dqspicode : 7;
    //
    // Nibble 1 DQS rank 1 RX slave delay line PI code. This is used to centre the DQS
    // in the DQ eye 
    // 
    // Bits[27:21], RW, default = 0x0
    //
    UINTX b1n1_rxdll_rk3dqspicode : 7;
    //
    // Reserved
    // 
    // Bits[31:28], RO, default = 0x0
    //
    UINTX reserved : 4;
  } Bits;
  UINTX Data;
} DQSRXDLL_B1N1_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define DQSBRXDLL_B1N0_DDRDQ_PHY_REG                       0x00000444
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Nibble 0 DQSB rank 1 RX slave delay line PI code. This is used to centre the DQSB
    // in the DQ eye 
    // 
    // Bits[6:0], RW, default = 0x0
    //
    UINTX b1n0_rxdll_rk0dqsbpicode : 7;
    //
    // Nibble 0 DQSB rank 1 RX slave delay line PI code. This is used to centre the DQSB
    // in the DQ eye 
    // 
    // Bits[13:7], RW, default = 0x0
    //
    UINTX b1n0_rxdll_rk1dqsbpicode : 7;
    //
    // Nibble 0 DQSB rank 1 RX slave delay line PI code. This is used to centre the DQSB
    // in the DQ eye 
    // 
    // Bits[20:14], RW, default = 0x0
    //
    UINTX b1n0_rxdll_rk2dqsbpicode : 7;
    //
    // Nibble 0 DQSB rank 1 RX slave delay line PI code. This is used to centre the DQSB
    // in the DQ eye 
    // 
    // Bits[27:21], RW, default = 0x0
    //
    UINTX b1n0_rxdll_rk3dqsbpicode : 7;
    //
    // Reserved
    // 
    // Bits[31:28], RO, default = 0x0
    //
    UINTX reserved : 4;
  } Bits;
  UINTX Data;
} DQSBRXDLL_B1N0_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define DQSBRXDLL_B1N1_DDRDQ_PHY_REG                       0x00000448
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Nibble 1 DQSB rank 1 RX slave delay line PI code. This is used to centre the DQSB
    // in the DQ eye 
    // 
    // Bits[6:0], RW, default = 0x0
    //
    UINTX b1n1_rxdll_rk0dqsbpicode : 7;
    //
    // Nibble 1 DQSB rank 1 RX slave delay line PI code. This is used to centre the DQSB
    // in the DQ eye 
    // 
    // Bits[13:7], RW, default = 0x0
    //
    UINTX b1n1_rxdll_rk1dqsbpicode : 7;
    //
    // Nibble 1 DQSB rank 1 RX slave delay line PI code. This is used to centre the DQSB
    // in the DQ eye 
    // 
    // Bits[20:14], RW, default = 0x0
    //
    UINTX b1n1_rxdll_rk2dqsbpicode : 7;
    //
    // Nibble 1 DQSB rank 1 RX slave delay line PI code. This is used to centre the DQSB
    // in the DQ eye 
    // 
    // Bits[27:21], RW, default = 0x0
    //
    UINTX b1n1_rxdll_rk3dqsbpicode : 7;
    //
    // Reserved
    // 
    // Bits[31:28], RO, default = 0x0
    //
    UINTX reserved : 4;
  } Bits;
  UINTX Data;
} DQSBRXDLL_B1N1_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define CLKGATE0_BL1_DDRDQ_PHY_REG                         0x0000044C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Reserved
    // 
    // Bits[8:0], RO, default = 0x0
    //
    UINTX reserved : 9;
    //
    // Dynamic spidclk clock enable for common  (to enable gspidclk)
    // 
    // Bits[9:9], RW, default = 0x0
    //
    UINTX b1_dynspidclken : 1;
    //
    // Dynamic ref1xclk clock enable for common (to enable gref1xclk)
    // 
    // Bits[10:10], RW, default = 0x0
    //
    UINTX b1_dynref1xclken : 1;
    //
    // Dynamic ref2xclk clock enable for common (to enable gref2xclk)
    // 
    // Bits[11:11], RW, default = 0x0
    //
    UINTX b1_dynref2xclken : 1;
    //
    // Dynamic sigclk group enable for commom   (to enable ref2xclk180siggrpen/ref2xclk270siggrpen/ref2xclk90siggrpen)
    // 
    // Bits[12:12], RW, default = 0x0
    //
    UINTX b1_dynsiggrpen : 1;
    //
    // Dynamic spidclk clock enable for write command  (to enable gspidwrclk)
    // 
    // Bits[13:13], RW, default = 0x0
    //
    UINTX b1_dynwritespidclken : 1;
    //
    // Dynamic ref1xclk clock enable for write command (to enable grefwr1xclk)
    // 
    // Bits[14:14], RW, default = 0x0
    //
    UINTX b1_dynwriteref1xclken : 1;
    //
    // Dynamic ref2xclk clock enable for write command (to enable grefwr2xclk)
    // 
    // Bits[15:15], RW, default = 0x0
    //
    UINTX b1_dynwriteref2xclken : 1;
    //
    // Dynamic sigclk group enable for write command   (to enable dqsigclk/dqsigclk)
    // 
    // Bits[16:16], RW, default = 0x0
    //
    UINTX b1_dynwritesiggrpen : 1;
    //
    // Dynamic spidclk clock enable for read command  (to enable gspidrdclk)
    // 
    // Bits[17:17], RW, default = 0x0
    //
    UINTX b1_dynreadspidclken : 1;
    //
    // Dynamic ref1xclk clock enable for read command (to enable grefrd1xclk)
    // 
    // Bits[18:18], RW, default = 0x0
    //
    UINTX b1_dynreadref1xclken : 1;
    //
    // Dynamic ref2xclk clock enable for read command (to enable grefrd2xclk)
    // 
    // Bits[19:19], RW, default = 0x0
    //
    UINTX b1_dynreadref2xclken : 1;
    //
    // Dynamic sigclk group enable for read command   (to enable rcvensigclk)
    // 
    // Bits[20:20], RW, default = 0x0
    //
    UINTX b1_dynreadsiggrpen : 1;
    //
    // Reserved
    // 
    // Bits[26:21], RO, default = 0x0
    //
    UINTX reserved_1 : 6;
    //
    // Reserved
    // 
    // Bits[31:27], RO, default = 0x0
    //
    UINTX reserved_2 : 5;
  } Bits;
  UINTX Data;
} CLKGATE0_BL1_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define CLKGATE1_BL1_DDRDQ_PHY_REG                         0x00000450
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Clock Gating register: IDLE timer counter max value for clock gating on Tx/RX
    // . Counter timeout based on last WRCMD/RDCMD received. 6 bits are good enough since
    // it increments in spidclk. 
    // 
    // Bits[5:0], RW, default = 0x0
    //
    UINTX b1_clkgate_maxcntr : 6;
    //
    // Clock Gating register: IDLE timer counter max value for clock gating on TX . Counter
    // timeout based on last WRCMD/RDCMD received. 6 bits are good enough since it increments
    // in spidclk. 
    // 
    // Bits[11:6], RW, default = 0x0
    //
    UINTX b1_writeclkgate_maxcntr : 6;
    //
    // After wrcmd received, enable drven after scr_write_startdrv clocks.
    // 
    // Bits[14:12], RW, default = 0x0
    //
    UINTX b1_write_startdrv : 3;
    //
    // Stop the drven scr_write_stopdrv clocks before clock gated.
    // 
    // Bits[17:15], RW, default = 0x0
    //
    UINTX b1_write_stopdrv : 3;
    //
    // Clock Gating register: IDLE timer counter max value for clock gating on RX . Counter
    // timeout based on last WRCMD/RDCMD received. 6 bits are good enough since it increments
    // in spidclk. 
    // 
    // Bits[23:18], RW, default = 0x0
    //
    UINTX b1_readclkgate_maxcntr : 6;
    //
    // After rdcmd received, enable rden after scr_read_startrden clocks.
    // 
    // Bits[26:24], RW, default = 0x0
    //
    UINTX b1_read_startrden : 3;
    //
    // Stop the rden scr_read_stoprden  clocks before clock gated.
    // 
    // Bits[29:27], RW, default = 0x0
    //
    UINTX b1_read_stoprden : 3;
    //
    // Reserved
    // 
    // Bits[31:30], RO, default = 0x0
    //
    UINTX reserved : 2;
  } Bits;
  UINTX Data;
} CLKGATE1_BL1_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define WRLVL_BL1_DDRDQ_PHY_REG                            0x00000454
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write leveling RX data
    // 
    // Bits[3:0], RO/V, default = 0x0
    //
    UINTX b1n0_wrlvl_sample : 4;
    //
    // Write leveling RX data - ANDed together
    // 
    // Bits[4:4], RO/V, default = 0x0
    //
    UINTX b1n0_wrlvl_and_sample : 1;
    //
    // Write leveling RX data - ORed together
    // 
    // Bits[5:5], RO/V, default = 0x0
    //
    UINTX b1n0_wrlvl_or_sample : 1;
    //
    // Write leveling RX data
    // 
    // Bits[9:6], RO/V, default = 0x0
    //
    UINTX b1n1_wrlvl_sample : 4;
    //
    // Write leveling RX data - ANDed together
    // 
    // Bits[10:10], RO/V, default = 0x0
    //
    UINTX b1n1_wrlvl_and_sample : 1;
    //
    // Write leveling RX data - ORed together
    // 
    // Bits[11:11], RO/V, default = 0x0
    //
    UINTX b1n1_wrlvl_or_sample : 1;
    //
    // Reserved
    // 
    // Bits[31:12], RO, default = 0x0
    //
    UINTX reserved : 20;
  } Bits;
  UINTX Data;
} WRLVL_BL1_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define RCVENMARG_BL1_DDRDQ_PHY_REG                        0x00000458
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Receive enable margining data
    // 
    // Bits[0:0], RO/V, default = 0x0
    //
    UINTX b1n0_rcven_margin : 1;
    //
    // Receive enable margining data
    // 
    // Bits[1:1], RO/V, default = 0x0
    //
    UINTX b1n1_rcven_margin : 1;
    //
    // Reserved
    // 
    // Bits[31:2], RO, default = 0x0
    //
    UINTX reserved : 30;
  } Bits;
  UINTX Data;
} RCVENMARG_BL1_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define MRGMODE_BL1_DDRDQ_PHY_REG                          0x000004B0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // DFX margin mode TX fall data phase 0
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINTX b1_dfxmrgtxd_fall_ph0 : 1;
    //
    // DFX margin mode TX fall data phase 1
    // 
    // Bits[1:1], RW, default = 0x0
    //
    UINTX b1_dfxmrgtxd_fall_ph1 : 1;
    //
    // DFX margin mode TX rise data phase 0
    // 
    // Bits[2:2], RW, default = 0x0
    //
    UINTX b1_dfxmrgtxd_rise_ph0 : 1;
    //
    // DFX margin mode TX rise data phase 1
    // 
    // Bits[3:3], RW, default = 0x0
    //
    UINTX b1_dfxmrgtxd_rise_ph1 : 1;
    //
    // DFX margin mode RX compare values
    // 
    // Bits[11:4], RW, default = 0x0
    //
    UINTX b1_dfxmrgtxd_cmp : 8;
    //
    // DFX margin mode TX override enable
    // 
    // Bits[12:12], RW, default = 0x0
    //
    UINTX b1_dfxmrgtx_ovren : 1;
    //
    // DFX margin mode TX write enable
    // 
    // Bits[13:13], RW, default = 0x0
    //
    UINTX b1_dfxmrgtxwren : 1;
    //
    // Reserved
    // 
    // Bits[31:14], RO, default = 0x0
    //
    UINTX reserved : 18;
  } Bits;
  UINTX Data;
} MRGMODE_BL1_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define MRGMODE2_BL1_DDRDQ_PHY_REG                         0x000004B4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // DFX margin mode TX fall data phase 0 strobe
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINTX b1_dfxmrgtxdqsfall : 1;
    //
    // DFX margin mode TX rise data phase 1 strobe
    // 
    // Bits[1:1], RW, default = 0x0
    //
    UINTX b1_dfxmrgtxdqsrise : 1;
    //
    // Reserved
    // 
    // Bits[31:2], RO, default = 0x0
    //
    UINTX reserved : 30;
  } Bits;
  UINTX Data;
} MRGMODE2_BL1_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define DATLVL_BL1_DDRDQ_PHY_REG                           0x000004E0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Binary Vmode EQ (Deemphasis) coefficient.These bits will be set based on SIE input
    // to choose the Eq coef. value . Each bit represents each of the static legs. [br][2:0]
    // [br]------------------[br]000      TBD  [br]001      TBD[br]010      TBD[br]011
    //      TBD[br]100      TBD[br]101      TBD[br]110      TBD[br]111      TBD 
    // 
    // Bits[2:0], RW, default = 0x0
    //
    UINTX datlvl_b1_eqcoeff : 3;
    //
    // Tap select for Imode data.[br]0 : After the TCO delay cell(after first segment)
    // [br]1: after first delay cell(after second segment) 
    // 
    // Bits[3:3], RW, default = 0x1
    //
    UINTX datlvl_b1_imodedatadlysel : 1;
    //
    // This signal is purposed turn-on weak PU termination during Idle mode (drvenb=odtenb=iobufrstb=1).
    // Active low. It is recommended to enable it for DDR4 only due to PU termination.
    // 
    // Bits[4:4], RW, default = 0x0
    //
    UINTX datlvl_b1_idlemodepuen : 1;
    //
    // DQ Swing boost enable -  Active high.
    // 
    // Bits[8:5], RW, default = 0x0
    //
    UINTX datlvl_b1n0_dqswingboosten : 4;
    //
    // DQS Swing boost enable -  Active high.
    // 
    // Bits[9:9], RW, default = 0x0
    //
    UINTX datlvl_b1n0_dqsswingboosten : 1;
    //
    // DQ Swing boost enable -  Active high.
    // 
    // Bits[13:10], RW, default = 0x0
    //
    UINTX datlvl_b1n1_dqswingboosten : 4;
    //
    // DQS Swing boost enable -  Active high.
    // 
    // Bits[14:14], RW, default = 0x0
    //
    UINTX datlvl_b1n1_dqsswingboosten : 1;
    //
    // Reserved
    // 
    // Bits[31:15], RO, default = 0x0
    //
    UINTX reserved : 17;
  } Bits;
  UINTX Data;
} DATLVL_BL1_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define DQSTX_BL1_DDRDQ_PHY_REG                            0x000004E4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Fall TCO c73ddr402_COMP code
    // 
    // Bits[5:0], RW, default = 0x3F
    //
    UINTX dqstx_b1_tcocompfall : 6;
    //
    // Rise TCO c73ddr402_COMP code
    // 
    // Bits[11:6], RW, default = 0x3F
    //
    UINTX dqstx_b1_tcocomprise : 6;
    //
    // Reserved
    // 
    // Bits[31:12], RO, default = 0x0
    //
    UINTX reserved : 20;
  } Bits;
  UINTX Data;
} DQSTX_BL1_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define DXTX_BL1_2_DDRDQ_PHY_REG                           0x000004E8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // reserved
    // 
    // Bits[2:0], RW, default = 0x7
    //
    UINTX dxtx_b1r0_drvsegen_predfx : 3;
    //
    // reserved
    // 
    // Bits[5:3], RW, default = 0x7
    //
    UINTX dxtx_b1r1_drvsegen_predfx : 3;
    //
    // Reserved
    // 
    // Bits[31:6], RO, default = 0x0
    //
    UINTX reserved : 26;
  } Bits;
  UINTX Data;
} DXTX_BL1_2_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define DXTX_BL1_DDRDQ_PHY_REG                             0x000004EC
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Stretches falling edge of Buffer enable pulse to support Early DQ mode.  [br]00=default
    // pulse width[br] 01=minimum stretch on width[br]10=intermediate stretch on pulse[br]11=maximum
    // stretch on pulse. 
    // 
    // Bits[1:0], RW, default = 0x2
    //
    UINTX dxtx_b1_drvenstretch : 2;
    //
    // Bias control for Swing Boost Imode Buffer (00=1kohm (default), 01=0.5kohm, 10=0.25kohm,
    // 11=0.1kohm 
    // 
    // Bits[3:2], RW, default = 0x0
    //
    UINTX dqtx_b1_swingboostbiasctrl : 2;
    //
    // Binary Imode Coefficients, and will be set based on SIE input.[br]Coeff[3:0] 
    // %mV[br]------------------[br]0000        TBD  [br]0001        [br]0010       
    //  [br]  *  [br]  * [br]  *[br]1111       TBD 
    // 
    // Bits[7:4], RW, default = 0x0
    //
    UINTX dxtx_b1_imodecoeff : 4;
    //
    // Swing boost segment enable, support DFX Per leg test feature
    // 
    // Bits[11:8], RW, default = 0xF
    //
    UINTX dxtx_b1_swingboostsegen : 4;
    //
    // Fall TCO c73ddr402_COMP code
    // 
    // Bits[17:12], RW, default = 0x3F
    //
    UINTX dqtx_b1_tcocompfall : 6;
    //
    // Rise TCO c73ddr402_COMP code
    // 
    // Bits[23:18], RW, default = 0x3F
    //
    UINTX dqtx_b1_tcocomprise : 6;
    //
    // Transmitter segment enable. Only used to enable DFX Per Leg checks.
    // 
    // Bits[26:24], RW, default = 0x7
    //
    UINTX dqtx_b1_drvsegen : 3;
    //
    // delay cell static leg enable;support dfx per leg testing of delay cells in predriver
    // logic/delay c73ddr402_comp. 1: enabled (default) 0: disabled 
    // 
    // Bits[27:27], RW, default = 0x1
    //
    UINTX dxtx_b1_dlycellstaticlegen : 1;
    //
    // dfx legtest enable pin. Allows for independent control of the lower 4 legs of
    // the deley element which are controlled by the decoder. 1: enabled       0 : disbaled
    // (default) 
    // 
    // Bits[28:28], RW, default = 0x0
    //
    UINTX dx_b1_pbddfxtesten : 1;
    //
    // Reserved
    // 
    // Bits[31:29], RO, default = 0x0
    //
    UINTX reserved : 3;
  } Bits;
  UINTX Data;
} DXTX_BL1_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define DQRX_BL1_DDRDQ_PHY_REG                             0x000004F0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Enable offset cancellation mode (0= enable, 1 = disable (default)), share it with
    // tco delay cell 
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINTX dqrx_b1_ampoffseten : 1;
    //
    // Bias control for CTLE Amp (00=1kohm (default), 01=0.5kohm, 10=0.25kohm, 11=0.1kohm
    // 
    // Bits[3:1], RW, default = 0x0
    //
    UINTX rxbias_b1_ctlebiasctrl : 3;
    //
    // rxbiasovrval config. If rxbiasovren =1, rxbias = rxbiasovrval
    // 
    // Bits[4:4], RW, default = 0x0
    //
    UINTX rxbias_b1_biasovrval : 1;
    //
    // Override enable function: 0: rxbias is the same as diffampen function, 1: rxbias
    // is equal rxbiasovrval config 
    // 
    // Bits[5:5], RW, default = 0x0
    //
    UINTX rxbias_b1_biasovren : 1;
    //
    // CTLE enable
    // 
    // Bits[6:6], RW, default = 0x1
    //
    UINTX dqrx_b1_ctleen : 1;
    //
    // cap tuning, 00 = 0.5pF, 01 = 1pF, 10 = 1.5pF, 11 = 2pF
    // 
    // Bits[8:7], RW, default = 0x1
    //
    UINTX dqrx_b1_ctlecap : 2;
    //
    // resistor tuning ,00 = 0.5kOhm, 01 = 1kOhm, 10 = 1.5kOhm, 11 =2kOhm
    // 
    // Bits[10:9], RW, default = 0x0
    //
    UINTX dqrx_b1_ctleres : 2;
    //
    // Reserved
    // 
    // Bits[31:11], RO, default = 0x0
    //
    UINTX reserved : 21;
  } Bits;
  UINTX Data;
} DQRX_BL1_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define DQRX_B1N0_DDRDQ_PHY_REG                            0x000004F4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Tuning bits for offset cancellation
    // 
    // Bits[3:0], RW, default = 0x0
    //
    UINTX dqrx_b1n0dq0_ampoffset : 4;
    //
    // Tuning bits for offset cancellation
    // 
    // Bits[7:4], RW, default = 0x0
    //
    UINTX dqrx_b1n0dq1_ampoffset : 4;
    //
    // Tuning bits for offset cancellation
    // 
    // Bits[11:8], RW, default = 0x0
    //
    UINTX dqrx_b1n0dq2_ampoffset : 4;
    //
    // Tuning bits for offset cancellation
    // 
    // Bits[15:12], RW, default = 0x0
    //
    UINTX dqrx_b1n0dq3_ampoffset : 4;
    //
    // Reserved
    // 
    // Bits[31:16], RO, default = 0x0
    //
    UINTX reserved : 16;
  } Bits;
  UINTX Data;
} DQRX_B1N0_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define DQRX_B1N1_DDRDQ_PHY_REG                            0x000004F8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Tuning bits for offset cancellation
    // 
    // Bits[3:0], RW, default = 0x0
    //
    UINTX dqrx_b1n1dq0_ampoffset : 4;
    //
    // Tuning bits for offset cancellation
    // 
    // Bits[7:4], RW, default = 0x0
    //
    UINTX dqrx_b1n1dq1_ampoffset : 4;
    //
    // Tuning bits for offset cancellation
    // 
    // Bits[11:8], RW, default = 0x0
    //
    UINTX dqrx_b1n1dq2_ampoffset : 4;
    //
    // Tuning bits for offset cancellation
    // 
    // Bits[15:12], RW, default = 0x0
    //
    UINTX dqrx_b1n1dq3_ampoffset : 4;
    //
    // Reserved
    // 
    // Bits[31:16], RO, default = 0x0
    //
    UINTX reserved : 16;
  } Bits;
  UINTX Data;
} DQRX_B1N1_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define DQSRX_BL1_DDRDQ_PHY_REG                            0x000004FC
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Enable offset cancellation mode (0= enable, 1 = disable (default)), share it with
    // tco delay cell 
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINTX dqsrx_b1_ampoffseten : 1;
    //
    // CTLE enable
    // 
    // Bits[1:1], RW, default = 0x1
    //
    UINTX dqsrx_b1_ctleen : 1;
    //
    // This is the dqs counter reset signal. 0 = reset. Combined with PM control
    // 
    // Bits[2:2], RW, default = 0x0
    //
    UINTX dqsrx_b1_dqscountrstb : 1;
    //
    // Tuning bits for offset cancellation
    // 
    // Bits[6:3], RW, default = 0x0
    //
    UINTX dqsrx_b1n0_ampoffset : 4;
    //
    // Tuning bits for offset cancellation
    // 
    // Bits[10:7], RW, default = 0x0
    //
    UINTX dqsrx_b1n1_ampoffset : 4;
    //
    // cap tuning, 00 = 0.5pF, 01 = 1pF, 10 = 1.5pF, 11 = 2pF
    // 
    // Bits[12:11], RW, default = 0x1
    //
    UINTX dqsrx_b1_ctlecap : 2;
    //
    // resistor tuning ,00 = 0.5kOhm, 01 = 1kOhm, 10 = 1.5kOhm, 11 =2kOhm
    // 
    // Bits[14:13], RW, default = 0x0
    //
    UINTX dqsrx_b1_ctleres : 2;
    //
    // Dfx Rx enable for the Dqs/dqsb
    // 
    // Bits[15:15], RW, default = 0x0
    //
    UINTX dqsdfxrx_b1n0_dfxrxen : 1;
    //
    // Dfx Rx enable for the Dqs/dqsb
    // 
    // Bits[16:16], RW, default = 0x0
    //
    UINTX dqsdfxrx_b1n1_dfxrxen : 1;
    //
    // masking out the first dqs negedge during rcven handling in ddr4 (0-ddr4;1-ddr3l)
    // 
    // Bits[17:17], RW, default = 0x0
    //
    UINTX dqsrx_b1_dqsnegedgemask : 1;
    //
    // Reserved
    // 
    // Bits[31:18], RO, default = 0x0
    //
    UINTX reserved : 14;
  } Bits;
  UINTX Data;
} DQSRX_BL1_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define DQTXPBD0_B1N0_DDRDQ_PHY_REG                        0x00000500
#ifndef ASM_INC
typedef union {
  struct {
    //
    // DQ TX rank 0 bit 0 fine bit setting for tx per bit deskew
    // 
    // Bits[3:0], RW, default = 0xF
    //
    UINTX dqtxpbd_b1n0dq0_rk0fine : 4;
    //
    // DQ TX rank 0 bit 0 coarse bit setting for tx per bit deskew
    // 
    // Bits[9:4], RW, default = 0x3D
    //
    UINTX dqtxpbd_b1n0dq0_rk0coarse : 6;
    //
    // DQ TX rank 1 bit 0 fine bit setting for tx per bit deskew
    // 
    // Bits[13:10], RW, default = 0xF
    //
    UINTX dqtxpbd_b1n0dq0_rk1fine : 4;
    //
    // DQ TX rank 1 bit 0 coarse bit setting for tx per bit deskew
    // 
    // Bits[19:14], RW, default = 0x3D
    //
    UINTX dqtxpbd_b1n0dq0_rk1coarse : 6;
    //
    // per bit deskew enable . 1:enabled (default) 0:disabled
    // 
    // Bits[20:20], RW, default = 0x1
    //
    UINTX dqtxpbd_b1_en : 1;
    //
    // per bit deskew delay cell static leg enable;support dfx per leg testing of delay
    // cells in tx pbd. 1: enabled (default) 0: disabled 
    // 
    // Bits[21:21], RW, default = 0x1
    //
    UINTX dqtxpbd_b1_staticlegen : 1;
    //
    // Reserved
    // 
    // Bits[31:22], RO, default = 0x0
    //
    UINTX reserved : 10;
  } Bits;
  UINTX Data;
} DQTXPBD0_B1N0_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define DQTXPBD1_B1N0_DDRDQ_PHY_REG                        0x00000504
#ifndef ASM_INC
typedef union {
  struct {
    //
    // DQ TX rank 2 bit 0 fine bit setting for tx per bit deskew
    // 
    // Bits[3:0], RW, default = 0xF
    //
    UINTX dqtxpbd_b1n0dq0_rk2fine : 4;
    //
    // DQ TX rank 2 bit 0 coarse bit setting for tx per bit deskew
    // 
    // Bits[9:4], RW, default = 0x3D
    //
    UINTX dqtxpbd_b1n0dq0_rk2coarse : 6;
    //
    // DQ TX rank 3 bit 0 fine bit setting for tx per bit deskew
    // 
    // Bits[13:10], RW, default = 0xF
    //
    UINTX dqtxpbd_b1n0dq0_rk3fine : 4;
    //
    // DQ TX rank 3 bit 0 coarse bit setting for tx per bit deskew
    // 
    // Bits[19:14], RW, default = 0x3D
    //
    UINTX dqtxpbd_b1n0dq0_rk3coarse : 6;
    //
    // Reserved
    // 
    // Bits[31:20], RO, default = 0x0
    //
    UINTX reserved : 12;
  } Bits;
  UINTX Data;
} DQTXPBD1_B1N0_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define DQTXPBD2_B1N0_DDRDQ_PHY_REG                        0x00000508
#ifndef ASM_INC
typedef union {
  struct {
    //
    // DQ TX rank 0 bit 1 fine bit setting for tx per bit deskew
    // 
    // Bits[3:0], RW, default = 0xF
    //
    UINTX dqtxpbd_b1n0dq1_rk0fine : 4;
    //
    // DQ TX rank 0 bit 1 coarse bit setting for tx per bit deskew
    // 
    // Bits[9:4], RW, default = 0x3D
    //
    UINTX dqtxpbd_b1n0dq1_rk0coarse : 6;
    //
    // DQ TX rank 1 bit 1 fine bit setting for tx per bit deskew
    // 
    // Bits[13:10], RW, default = 0xF
    //
    UINTX dqtxpbd_b1n0dq1_rk1fine : 4;
    //
    // DQ TX rank 1 bit 1 coarse bit setting for tx per bit deskew
    // 
    // Bits[19:14], RW, default = 0x3D
    //
    UINTX dqtxpbd_b1n0dq1_rk1coarse : 6;
    //
    // Reserved
    // 
    // Bits[31:20], RO, default = 0x0
    //
    UINTX reserved : 12;
  } Bits;
  UINTX Data;
} DQTXPBD2_B1N0_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define DQTXPBD3_B1N0_DDRDQ_PHY_REG                        0x0000050C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // DQ TX rank 2 bit 1 fine bit setting for tx per bit deskew
    // 
    // Bits[3:0], RW, default = 0xF
    //
    UINTX dqtxpbd_b1n0dq1_rk2fine : 4;
    //
    // DQ TX rank 2 bit 1 coarse bit setting for tx per bit deskew
    // 
    // Bits[9:4], RW, default = 0x3D
    //
    UINTX dqtxpbd_b1n0dq1_rk2coarse : 6;
    //
    // DQ TX rank 3 bit 1 fine bit setting for tx per bit deskew
    // 
    // Bits[13:10], RW, default = 0xF
    //
    UINTX dqtxpbd_b1n0dq1_rk3fine : 4;
    //
    // DQ TX rank 3 bit 1 coarse bit setting for tx per bit deskew
    // 
    // Bits[19:14], RW, default = 0x3D
    //
    UINTX dqtxpbd_b1n0dq1_rk3coarse : 6;
    //
    // Reserved
    // 
    // Bits[31:20], RO, default = 0x0
    //
    UINTX reserved : 12;
  } Bits;
  UINTX Data;
} DQTXPBD3_B1N0_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define DQTXPBD4_B1N0_DDRDQ_PHY_REG                        0x00000510
#ifndef ASM_INC
typedef union {
  struct {
    //
    // DQ TX rank 0 bit 2 fine bit setting for tx per bit deskew
    // 
    // Bits[3:0], RW, default = 0xF
    //
    UINTX dqtxpbd_b1n0dq2_rk0fine : 4;
    //
    // DQ TX rank 0 bit 2 coarse bit setting for tx per bit deskew
    // 
    // Bits[9:4], RW, default = 0x3D
    //
    UINTX dqtxpbd_b1n0dq2_rk0coarse : 6;
    //
    // DQ TX rank 1 bit 2 fine bit setting for tx per bit deskew
    // 
    // Bits[13:10], RW, default = 0xF
    //
    UINTX dqtxpbd_b1n0dq2_rk1fine : 4;
    //
    // DQ TX rank 1 bit 2 coarse bit setting for tx per bit deskew
    // 
    // Bits[19:14], RW, default = 0x3D
    //
    UINTX dqtxpbd_b1n0dq2_rk1coarse : 6;
    //
    // Reserved
    // 
    // Bits[31:20], RO, default = 0x0
    //
    UINTX reserved : 12;
  } Bits;
  UINTX Data;
} DQTXPBD4_B1N0_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define DQTXPBD5_B1N0_DDRDQ_PHY_REG                        0x00000514
#ifndef ASM_INC
typedef union {
  struct {
    //
    // DQ TX rank 2 bit 2 fine bit setting for tx per bit deskew
    // 
    // Bits[3:0], RW, default = 0xF
    //
    UINTX dqtxpbd_b1n0dq2_rk2fine : 4;
    //
    // DQ TX rank 2 bit 2 coarse bit setting for tx per bit deskew
    // 
    // Bits[9:4], RW, default = 0x3D
    //
    UINTX dqtxpbd_b1n0dq2_rk2coarse : 6;
    //
    // DQ TX rank 3 bit 2 fine bit setting for tx per bit deskew
    // 
    // Bits[13:10], RW, default = 0xF
    //
    UINTX dqtxpbd_b1n0dq2_rk3fine : 4;
    //
    // DQ TX rank 3 bit 2 coarse bit setting for tx per bit deskew
    // 
    // Bits[19:14], RW, default = 0x3D
    //
    UINTX dqtxpbd_b1n0dq2_rk3coarse : 6;
    //
    // Reserved
    // 
    // Bits[31:20], RO, default = 0x0
    //
    UINTX reserved : 12;
  } Bits;
  UINTX Data;
} DQTXPBD5_B1N0_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define DQTXPBD6_B1N0_DDRDQ_PHY_REG                        0x00000518
#ifndef ASM_INC
typedef union {
  struct {
    //
    // DQ TX rank 0 bit 3 fine bit setting for tx per bit deskew
    // 
    // Bits[3:0], RW, default = 0xF
    //
    UINTX dqtxpbd_b1n0dq3_rk0fine : 4;
    //
    // DQ TX rank 0 bit 3 coarse bit setting for tx per bit deskew
    // 
    // Bits[9:4], RW, default = 0x3D
    //
    UINTX dqtxpbd_b1n0dq3_rk0coarse : 6;
    //
    // DQ TX rank 1 bit 3 fine bit setting for tx per bit deskew
    // 
    // Bits[13:10], RW, default = 0xF
    //
    UINTX dqtxpbd_b1n0dq3_rk1fine : 4;
    //
    // DQ TX rank 1 bit 3 coarse bit setting for tx per bit deskew
    // 
    // Bits[19:14], RW, default = 0x3D
    //
    UINTX dqtxpbd_b1n0dq3_rk1coarse : 6;
    //
    // Reserved
    // 
    // Bits[31:20], RO, default = 0x0
    //
    UINTX reserved : 12;
  } Bits;
  UINTX Data;
} DQTXPBD6_B1N0_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define DQTXPBD7_B1N0_DDRDQ_PHY_REG                        0x0000051C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // DQ TX rank 2 bit 3 fine bit setting for tx per bit deskew
    // 
    // Bits[3:0], RW, default = 0xF
    //
    UINTX dqtxpbd_b1n0dq3_rk2fine : 4;
    //
    // DQ TX rank 2 bit 3 coarse bit setting for tx per bit deskew
    // 
    // Bits[9:4], RW, default = 0x3D
    //
    UINTX dqtxpbd_b1n0dq3_rk2coarse : 6;
    //
    // DQ TX rank 3 bit 3 fine bit setting for tx per bit deskew
    // 
    // Bits[13:10], RW, default = 0xF
    //
    UINTX dqtxpbd_b1n0dq3_rk3fine : 4;
    //
    // DQ TX rank 3 bit 3 coarse bit setting for tx per bit deskew
    // 
    // Bits[19:14], RW, default = 0x3D
    //
    UINTX dqtxpbd_b1n0dq3_rk3coarse : 6;
    //
    // Reserved
    // 
    // Bits[31:20], RO, default = 0x0
    //
    UINTX reserved : 12;
  } Bits;
  UINTX Data;
} DQTXPBD7_B1N0_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define DQTXPBD0_B1N1_DDRDQ_PHY_REG                        0x00000520
#ifndef ASM_INC
typedef union {
  struct {
    //
    // DQ TX rank 0 bit 0 fine bit setting for tx per bit deskew
    // 
    // Bits[3:0], RW, default = 0xF
    //
    UINTX dqtxpbd_b1n1dq0_rk0fine : 4;
    //
    // DQ TX rank 0 bit 0 coarse bit setting for tx per bit deskew
    // 
    // Bits[9:4], RW, default = 0x3D
    //
    UINTX dqtxpbd_b1n1dq0_rk0coarse : 6;
    //
    // DQ TX rank 1 bit 0 fine bit setting for tx per bit deskew
    // 
    // Bits[13:10], RW, default = 0xF
    //
    UINTX dqtxpbd_b1n1dq0_rk1fine : 4;
    //
    // DQ TX rank 1 bit 0 coarse bit setting for tx per bit deskew
    // 
    // Bits[19:14], RW, default = 0x3D
    //
    UINTX dqtxpbd_b1n1dq0_rk1coarse : 6;
    //
    // Reserved
    // 
    // Bits[31:20], RO, default = 0x0
    //
    UINTX reserved : 12;
  } Bits;
  UINTX Data;
} DQTXPBD0_B1N1_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define DQTXPBD1_B1N1_DDRDQ_PHY_REG                        0x00000524
#ifndef ASM_INC
typedef union {
  struct {
    //
    // DQ TX rank 2 bit 0 fine bit setting for tx per bit deskew
    // 
    // Bits[3:0], RW, default = 0xF
    //
    UINTX dqtxpbd_b1n1dq0_rk2fine : 4;
    //
    // DQ TX rank 2 bit 0 coarse bit setting for tx per bit deskew
    // 
    // Bits[9:4], RW, default = 0x3D
    //
    UINTX dqtxpbd_b1n1dq0_rk2coarse : 6;
    //
    // DQ TX rank 3 bit 0 fine bit setting for tx per bit deskew
    // 
    // Bits[13:10], RW, default = 0xF
    //
    UINTX dqtxpbd_b1n1dq0_rk3fine : 4;
    //
    // DQ TX rank 3 bit 0 coarse bit setting for tx per bit deskew
    // 
    // Bits[19:14], RW, default = 0x3D
    //
    UINTX dqtxpbd_b1n1dq0_rk3coarse : 6;
    //
    // Reserved
    // 
    // Bits[31:20], RO, default = 0x0
    //
    UINTX reserved : 12;
  } Bits;
  UINTX Data;
} DQTXPBD1_B1N1_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define DQTXPBD2_B1N1_DDRDQ_PHY_REG                        0x00000528
#ifndef ASM_INC
typedef union {
  struct {
    //
    // DQ TX rank 0 bit 1 fine bit setting for tx per bit deskew
    // 
    // Bits[3:0], RW, default = 0xF
    //
    UINTX dqtxpbd_b1n1dq1_rk0fine : 4;
    //
    // DQ TX rank 0 bit 1 coarse bit setting for tx per bit deskew
    // 
    // Bits[9:4], RW, default = 0x3D
    //
    UINTX dqtxpbd_b1n1dq1_rk0coarse : 6;
    //
    // DQ TX rank 1 bit 1 fine bit setting for tx per bit deskew
    // 
    // Bits[13:10], RW, default = 0xF
    //
    UINTX dqtxpbd_b1n1dq1_rk1fine : 4;
    //
    // DQ TX rank 1 bit 1 coarse bit setting for tx per bit deskew
    // 
    // Bits[19:14], RW, default = 0x3D
    //
    UINTX dqtxpbd_b1n1dq1_rk1coarse : 6;
    //
    // Reserved
    // 
    // Bits[31:20], RO, default = 0x0
    //
    UINTX reserved : 12;
  } Bits;
  UINTX Data;
} DQTXPBD2_B1N1_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define DQTXPBD3_B1N1_DDRDQ_PHY_REG                        0x0000052C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // DQ TX rank 2 bit 1 fine bit setting for tx per bit deskew
    // 
    // Bits[3:0], RW, default = 0xF
    //
    UINTX dqtxpbd_b1n1dq1_rk2fine : 4;
    //
    // DQ TX rank 2 bit 1 coarse bit setting for tx per bit deskew
    // 
    // Bits[9:4], RW, default = 0x3D
    //
    UINTX dqtxpbd_b1n1dq1_rk2coarse : 6;
    //
    // DQ TX rank 3 bit 1 fine bit setting for tx per bit deskew
    // 
    // Bits[13:10], RW, default = 0xF
    //
    UINTX dqtxpbd_b1n1dq1_rk3fine : 4;
    //
    // DQ TX rank 3 bit 1 coarse bit setting for tx per bit deskew
    // 
    // Bits[19:14], RW, default = 0x3D
    //
    UINTX dqtxpbd_b1n1dq1_rk3coarse : 6;
    //
    // Reserved
    // 
    // Bits[31:20], RO, default = 0x0
    //
    UINTX reserved : 12;
  } Bits;
  UINTX Data;
} DQTXPBD3_B1N1_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define DQTXPBD4_B1N1_DDRDQ_PHY_REG                        0x00000530
#ifndef ASM_INC
typedef union {
  struct {
    //
    // DQ TX rank 0 bit 2 fine bit setting for tx per bit deskew
    // 
    // Bits[3:0], RW, default = 0xF
    //
    UINTX dqtxpbd_b1n1dq2_rk0fine : 4;
    //
    // DQ TX rank 0 bit 2 coarse bit setting for tx per bit deskew
    // 
    // Bits[9:4], RW, default = 0x3D
    //
    UINTX dqtxpbd_b1n1dq2_rk0coarse : 6;
    //
    // DQ TX rank 1 bit 2 fine bit setting for tx per bit deskew
    // 
    // Bits[13:10], RW, default = 0xF
    //
    UINTX dqtxpbd_b1n1dq2_rk1fine : 4;
    //
    // DQ TX rank 1 bit 2 coarse bit setting for tx per bit deskew
    // 
    // Bits[19:14], RW, default = 0x3D
    //
    UINTX dqtxpbd_b1n1dq2_rk1coarse : 6;
    //
    // Reserved
    // 
    // Bits[31:20], RO, default = 0x0
    //
    UINTX reserved : 12;
  } Bits;
  UINTX Data;
} DQTXPBD4_B1N1_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define DQTXPBD5_B1N1_DDRDQ_PHY_REG                        0x00000534
#ifndef ASM_INC
typedef union {
  struct {
    //
    // DQ TX rank 2 bit 2 fine bit setting for tx per bit deskew
    // 
    // Bits[3:0], RW, default = 0xF
    //
    UINTX dqtxpbd_b1n1dq2_rk2fine : 4;
    //
    // DQ TX rank 2 bit 2 coarse bit setting for tx per bit deskew
    // 
    // Bits[9:4], RW, default = 0x3D
    //
    UINTX dqtxpbd_b1n1dq2_rk2coarse : 6;
    //
    // DQ TX rank 3 bit 2 fine bit setting for tx per bit deskew
    // 
    // Bits[13:10], RW, default = 0xF
    //
    UINTX dqtxpbd_b1n1dq2_rk3fine : 4;
    //
    // DQ TX rank 3 bit 2 coarse bit setting for tx per bit deskew
    // 
    // Bits[19:14], RW, default = 0x3D
    //
    UINTX dqtxpbd_b1n1dq2_rk3coarse : 6;
    //
    // Reserved
    // 
    // Bits[31:20], RO, default = 0x0
    //
    UINTX reserved : 12;
  } Bits;
  UINTX Data;
} DQTXPBD5_B1N1_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define DQTXPBD6_B1N1_DDRDQ_PHY_REG                        0x00000538
#ifndef ASM_INC
typedef union {
  struct {
    //
    // DQ TX rank 0 bit 3 fine bit setting for tx per bit deskew
    // 
    // Bits[3:0], RW, default = 0xF
    //
    UINTX dqtxpbd_b1n1dq3_rk0fine : 4;
    //
    // DQ TX rank 0 bit 3 coarse bit setting for tx per bit deskew
    // 
    // Bits[9:4], RW, default = 0x3D
    //
    UINTX dqtxpbd_b1n1dq3_rk0coarse : 6;
    //
    // DQ TX rank 1 bit 3 fine bit setting for tx per bit deskew
    // 
    // Bits[13:10], RW, default = 0xF
    //
    UINTX dqtxpbd_b1n1dq3_rk1fine : 4;
    //
    // DQ TX rank 1 bit 3 coarse bit setting for tx per bit deskew
    // 
    // Bits[19:14], RW, default = 0x3D
    //
    UINTX dqtxpbd_b1n1dq3_rk1coarse : 6;
    //
    // Reserved
    // 
    // Bits[31:20], RO, default = 0x0
    //
    UINTX reserved : 12;
  } Bits;
  UINTX Data;
} DQTXPBD6_B1N1_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define DQTXPBD7_B1N1_DDRDQ_PHY_REG                        0x0000053C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // DQ TX rank 2 bit 3 fine bit setting for tx per bit deskew
    // 
    // Bits[3:0], RW, default = 0xF
    //
    UINTX dqtxpbd_b1n1dq3_rk2fine : 4;
    //
    // DQ TX rank 2 bit 3 coarse bit setting for tx per bit deskew
    // 
    // Bits[9:4], RW, default = 0x3D
    //
    UINTX dqtxpbd_b1n1dq3_rk2coarse : 6;
    //
    // DQ TX rank 3 bit 3 fine bit setting for tx per bit deskew
    // 
    // Bits[13:10], RW, default = 0xF
    //
    UINTX dqtxpbd_b1n1dq3_rk3fine : 4;
    //
    // DQ TX rank 3 bit 3 coarse bit setting for tx per bit deskew
    // 
    // Bits[19:14], RW, default = 0x3D
    //
    UINTX dqtxpbd_b1n1dq3_rk3coarse : 6;
    //
    // Reserved
    // 
    // Bits[31:20], RO, default = 0x0
    //
    UINTX reserved : 12;
  } Bits;
  UINTX Data;
} DQTXPBD7_B1N1_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define DQSTXPBD0_B1N0_DDRDQ_PHY_REG                       0x00000540
#ifndef ASM_INC
typedef union {
  struct {
    //
    // DQS rank 0 fine bit setting for tx per bit deskew
    // 
    // Bits[3:0], RW, default = 0xF
    //
    UINTX dqstxpbd_b1n0_rk0fine : 4;
    //
    // DQS rank 0 coarse bit setting for tx per bit deskew
    // 
    // Bits[9:4], RW, default = 0x3D
    //
    UINTX dqstxpbd_b1n0_rk0coarse : 6;
    //
    // DQS rank 1 fine bit setting for tx per bit deskew
    // 
    // Bits[13:10], RW, default = 0xF
    //
    UINTX dqstxpbd_b1n0_rk1fine : 4;
    //
    // DQS rank 1 coarse bit setting for tx per bit deskew
    // 
    // Bits[19:14], RW, default = 0x3D
    //
    UINTX dqstxpbd_b1n0_rk1coarse : 6;
    //
    // per bit deskew enable . 1:enabled (default) 0:disabled
    // 
    // Bits[20:20], RW, default = 0x1
    //
    UINTX dqstxpbd_b1_en : 1;
    //
    // per bit deskew delay cell static leg enable;support dfx per leg testing of delay
    // cells in tx pbd. 1: enabled (default) 0: disabled 
    // 
    // Bits[21:21], RW, default = 0x1
    //
    UINTX dqstxpbd_b1_staticlegen : 1;
    //
    // Reserved
    // 
    // Bits[31:22], RO, default = 0x0
    //
    UINTX reserved : 10;
  } Bits;
  UINTX Data;
} DQSTXPBD0_B1N0_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define DQSTXPBD1_B1N0_DDRDQ_PHY_REG                       0x00000544
#ifndef ASM_INC
typedef union {
  struct {
    //
    // DQS rank 2 fine bit setting for tx per bit deskew
    // 
    // Bits[3:0], RW, default = 0xF
    //
    UINTX dqstxpbd_b1n0_rk2fine : 4;
    //
    // DQS rank 2 coarse bit setting for tx per bit deskew
    // 
    // Bits[9:4], RW, default = 0x3D
    //
    UINTX dqstxpbd_b1n0_rk2coarse : 6;
    //
    // DQS rank 3 fine bit setting for tx per bit deskew
    // 
    // Bits[13:10], RW, default = 0xF
    //
    UINTX dqstxpbd_b1n0_rk3fine : 4;
    //
    // DQS rank 3 coarse bit setting for tx per bit deskew
    // 
    // Bits[19:14], RW, default = 0x3D
    //
    UINTX dqstxpbd_b1n0_rk3coarse : 6;
    //
    // Reserved
    // 
    // Bits[31:20], RO, default = 0x0
    //
    UINTX reserved : 12;
  } Bits;
  UINTX Data;
} DQSTXPBD1_B1N0_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define DQSTXPBD0_B1N1_DDRDQ_PHY_REG                       0x00000548
#ifndef ASM_INC
typedef union {
  struct {
    //
    // DQS rank 0 fine bit setting for tx per bit deskew
    // 
    // Bits[3:0], RW, default = 0xF
    //
    UINTX dqstxpbd_b1n1_rk0fine : 4;
    //
    // DQS rank 0 coarse bit setting for tx per bit deskew
    // 
    // Bits[9:4], RW, default = 0x3D
    //
    UINTX dqstxpbd_b1n1_rk0coarse : 6;
    //
    // DQS rank 1 fine bit setting for tx per bit deskew
    // 
    // Bits[13:10], RW, default = 0xF
    //
    UINTX dqstxpbd_b1n1_rk1fine : 4;
    //
    // DQS rank 1 coarse bit setting for tx per bit deskew
    // 
    // Bits[19:14], RW, default = 0x3D
    //
    UINTX dqstxpbd_b1n1_rk1coarse : 6;
    //
    // Reserved
    // 
    // Bits[31:20], RO, default = 0x0
    //
    UINTX reserved : 12;
  } Bits;
  UINTX Data;
} DQSTXPBD0_B1N1_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define DQSTXPBD1_B1N1_DDRDQ_PHY_REG                       0x0000054C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // DQS rank 2 fine bit setting for tx per bit deskew
    // 
    // Bits[3:0], RW, default = 0xF
    //
    UINTX dqstxpbd_b1n1_rk2fine : 4;
    //
    // DQS rank 2 coarse bit setting for tx per bit deskew
    // 
    // Bits[9:4], RW, default = 0x3D
    //
    UINTX dqstxpbd_b1n1_rk2coarse : 6;
    //
    // DQS rank 3 fine bit setting for tx per bit deskew
    // 
    // Bits[13:10], RW, default = 0xF
    //
    UINTX dqstxpbd_b1n1_rk3fine : 4;
    //
    // DQS rank 3 coarse bit setting for tx per bit deskew
    // 
    // Bits[19:14], RW, default = 0x3D
    //
    UINTX dqstxpbd_b1n1_rk3coarse : 6;
    //
    // Reserved
    // 
    // Bits[31:20], RO, default = 0x0
    //
    UINTX reserved : 12;
  } Bits;
  UINTX Data;
} DQSTXPBD1_B1N1_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define DQRXPBD0_B1N0_DDRDQ_PHY_REG                        0x00000550
#ifndef ASM_INC
typedef union {
  struct {
    //
    // DQ RX rank 0 bit 0 fine bit setting for rx per bit deskew
    // 
    // Bits[3:0], RW, default = 0xF
    //
    UINTX dqrxpbd_b1n0dq0_rk0fine : 4;
    //
    // DQ RX rank 0 bit 0 coarse bit setting for rx per bit deskew
    // 
    // Bits[9:4], RW, default = 0x3D
    //
    UINTX dqrxpbd_b1n0dq0_rk0coarse : 6;
    //
    // DQ RX rank 1 bit 0 fine bit setting for rx per bit deskew
    // 
    // Bits[13:10], RW, default = 0xF
    //
    UINTX dqrxpbd_b1n0dq0_rk1fine : 4;
    //
    // DQ RX rank 1 bit 0 coarse bit setting for rx per bit deskew
    // 
    // Bits[19:14], RW, default = 0x3D
    //
    UINTX dqrxpbd_b1n0dq0_rk1coarse : 6;
    //
    // per bit deskew enable . 1:enabled (default) 0:disabled
    // 
    // Bits[20:20], RW, default = 0x1
    //
    UINTX dqrxpbd_b1_en : 1;
    //
    // per bit deskew delay cell static leg enable;support dfx per leg testing of delay
    // cells in rx pbd. 1: enabled (default) 0: disabled 
    // 
    // Bits[21:21], RW, default = 0x1
    //
    UINTX dqrxpbd_b1_staticlegen : 1;
    //
    // Reserved
    // 
    // Bits[31:22], RO, default = 0x0
    //
    UINTX reserved : 10;
  } Bits;
  UINTX Data;
} DQRXPBD0_B1N0_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define DQRXPBD1_B1N0_DDRDQ_PHY_REG                        0x00000554
#ifndef ASM_INC
typedef union {
  struct {
    //
    // DQ RX rank 2 bit 0 fine bit setting for rx per bit deskew
    // 
    // Bits[3:0], RW, default = 0xF
    //
    UINTX dqrxpbd_b1n0dq0_rk2fine : 4;
    //
    // DQ RX rank 2 bit 0 coarse bit setting for rx per bit deskew
    // 
    // Bits[9:4], RW, default = 0x3D
    //
    UINTX dqrxpbd_b1n0dq0_rk2coarse : 6;
    //
    // DQ RX rank 3 bit 0 fine bit setting for rx per bit deskew
    // 
    // Bits[13:10], RW, default = 0xF
    //
    UINTX dqrxpbd_b1n0dq0_rk3fine : 4;
    //
    // DQ RX rank 3 bit 0 coarse bit setting for rx per bit deskew
    // 
    // Bits[19:14], RW, default = 0x3D
    //
    UINTX dqrxpbd_b1n0dq0_rk3coarse : 6;
    //
    // Reserved
    // 
    // Bits[31:20], RO, default = 0x0
    //
    UINTX reserved : 12;
  } Bits;
  UINTX Data;
} DQRXPBD1_B1N0_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define DQRXPBD2_B1N0_DDRDQ_PHY_REG                        0x00000558
#ifndef ASM_INC
typedef union {
  struct {
    //
    // DQ RX rank 0 bit 1 fine bit setting for rx per bit deskew
    // 
    // Bits[3:0], RW, default = 0xF
    //
    UINTX dqrxpbd_b1n0dq1_rk0fine : 4;
    //
    // DQ RX rank 0 bit 1 coarse bit setting for rx per bit deskew
    // 
    // Bits[9:4], RW, default = 0x3D
    //
    UINTX dqrxpbd_b1n0dq1_rk0coarse : 6;
    //
    // DQ RX rank 1 bit 1 fine bit setting for rx per bit deskew
    // 
    // Bits[13:10], RW, default = 0xF
    //
    UINTX dqrxpbd_b1n0dq1_rk1fine : 4;
    //
    // DQ RX rank 1 bit 1 coarse bit setting for rx per bit deskew
    // 
    // Bits[19:14], RW, default = 0x3D
    //
    UINTX dqrxpbd_b1n0dq1_rk1coarse : 6;
    //
    // Reserved
    // 
    // Bits[31:20], RO, default = 0x0
    //
    UINTX reserved : 12;
  } Bits;
  UINTX Data;
} DQRXPBD2_B1N0_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define DQRXPBD3_B1N0_DDRDQ_PHY_REG                        0x0000055C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // DQ RX rank 2 bit 1 fine bit setting for rx per bit deskew
    // 
    // Bits[3:0], RW, default = 0xF
    //
    UINTX dqrxpbd_b1n0dq1_rk2fine : 4;
    //
    // DQ RX rank 2 bit 1 coarse bit setting for rx per bit deskew
    // 
    // Bits[9:4], RW, default = 0x3D
    //
    UINTX dqrxpbd_b1n0dq1_rk2coarse : 6;
    //
    // DQ RX rank 3 bit 1 fine bit setting for rx per bit deskew
    // 
    // Bits[13:10], RW, default = 0xF
    //
    UINTX dqrxpbd_b1n0dq1_rk3fine : 4;
    //
    // DQ RX rank 3 bit 1 coarse bit setting for rx per bit deskew
    // 
    // Bits[19:14], RW, default = 0x3D
    //
    UINTX dqrxpbd_b1n0dq1_rk3coarse : 6;
    //
    // Reserved
    // 
    // Bits[31:20], RO, default = 0x0
    //
    UINTX reserved : 12;
  } Bits;
  UINTX Data;
} DQRXPBD3_B1N0_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define DQRXPBD4_B1N0_DDRDQ_PHY_REG                        0x00000560
#ifndef ASM_INC
typedef union {
  struct {
    //
    // DQ RX rank 0 bit 2 fine bit setting for rx per bit deskew
    // 
    // Bits[3:0], RW, default = 0xF
    //
    UINTX dqrxpbd_b1n0dq2_rk0fine : 4;
    //
    // DQ RX rank 0 bit 2 coarse bit setting for rx per bit deskew
    // 
    // Bits[9:4], RW, default = 0x3D
    //
    UINTX dqrxpbd_b1n0dq2_rk0coarse : 6;
    //
    // DQ RX rank 1 bit 2 fine bit setting for rx per bit deskew
    // 
    // Bits[13:10], RW, default = 0xF
    //
    UINTX dqrxpbd_b1n0dq2_rk1fine : 4;
    //
    // DQ RX rank 1 bit 2 coarse bit setting for rx per bit deskew
    // 
    // Bits[19:14], RW, default = 0x3D
    //
    UINTX dqrxpbd_b1n0dq2_rk1coarse : 6;
    //
    // Reserved
    // 
    // Bits[31:20], RO, default = 0x0
    //
    UINTX reserved : 12;
  } Bits;
  UINTX Data;
} DQRXPBD4_B1N0_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define DQRXPBD5_B1N0_DDRDQ_PHY_REG                        0x00000564
#ifndef ASM_INC
typedef union {
  struct {
    //
    // DQ RX rank 2 bit 2 fine bit setting for rx per bit deskew
    // 
    // Bits[3:0], RW, default = 0xF
    //
    UINTX dqrxpbd_b1n0dq2_rk2fine : 4;
    //
    // DQ RX rank 2 bit 2 coarse bit setting for rx per bit deskew
    // 
    // Bits[9:4], RW, default = 0x3D
    //
    UINTX dqrxpbd_b1n0dq2_rk2coarse : 6;
    //
    // DQ RX rank 3 bit 2 fine bit setting for rx per bit deskew
    // 
    // Bits[13:10], RW, default = 0xF
    //
    UINTX dqrxpbd_b1n0dq2_rk3fine : 4;
    //
    // DQ RX rank 3 bit 2 coarse bit setting for rx per bit deskew
    // 
    // Bits[19:14], RW, default = 0x3D
    //
    UINTX dqrxpbd_b1n0dq2_rk3coarse : 6;
    //
    // Reserved
    // 
    // Bits[31:20], RO, default = 0x0
    //
    UINTX reserved : 12;
  } Bits;
  UINTX Data;
} DQRXPBD5_B1N0_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define DQRXPBD6_B1N0_DDRDQ_PHY_REG                        0x00000568
#ifndef ASM_INC
typedef union {
  struct {
    //
    // DQ RX rank 0 bit 3 fine bit setting for rx per bit deskew
    // 
    // Bits[3:0], RW, default = 0xF
    //
    UINTX dqrxpbd_b1n0dq3_rk0fine : 4;
    //
    // DQ RX rank 0 bit 3 coarse bit setting for rx per bit deskew
    // 
    // Bits[9:4], RW, default = 0x3D
    //
    UINTX dqrxpbd_b1n0dq3_rk0coarse : 6;
    //
    // DQ RX rank 1 bit 3 fine bit setting for rx per bit deskew
    // 
    // Bits[13:10], RW, default = 0xF
    //
    UINTX dqrxpbd_b1n0dq3_rk1fine : 4;
    //
    // DQ RX rank 1 bit 3 coarse bit setting for rx per bit deskew
    // 
    // Bits[19:14], RW, default = 0x3D
    //
    UINTX dqrxpbd_b1n0dq3_rk1coarse : 6;
    //
    // Reserved
    // 
    // Bits[31:20], RO, default = 0x0
    //
    UINTX reserved : 12;
  } Bits;
  UINTX Data;
} DQRXPBD6_B1N0_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define DQRXPBD7_B1N0_DDRDQ_PHY_REG                        0x0000056C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // DQ RX rank 2 bit 3 fine bit setting for rx per bit deskew
    // 
    // Bits[3:0], RW, default = 0xF
    //
    UINTX dqrxpbd_b1n0dq3_rk2fine : 4;
    //
    // DQ RX rank 2 bit 3 coarse bit setting for rx per bit deskew
    // 
    // Bits[9:4], RW, default = 0x3D
    //
    UINTX dqrxpbd_b1n0dq3_rk2coarse : 6;
    //
    // DQ RX rank 3 bit 3 fine bit setting for rx per bit deskew
    // 
    // Bits[13:10], RW, default = 0xF
    //
    UINTX dqrxpbd_b1n0dq3_rk3fine : 4;
    //
    // DQ RX rank 3 bit 3 coarse bit setting for rx per bit deskew
    // 
    // Bits[19:14], RW, default = 0x3D
    //
    UINTX dqrxpbd_b1n0dq3_rk3coarse : 6;
    //
    // Reserved
    // 
    // Bits[31:20], RO, default = 0x0
    //
    UINTX reserved : 12;
  } Bits;
  UINTX Data;
} DQRXPBD7_B1N0_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define DQRXPBD0_B1N1_DDRDQ_PHY_REG                        0x00000570
#ifndef ASM_INC
typedef union {
  struct {
    //
    // DQ RX rank 0 bit 0 fine bit setting for rx per bit deskew
    // 
    // Bits[3:0], RW, default = 0xF
    //
    UINTX dqrxpbd_b1n1dq0_rk0fine : 4;
    //
    // DQ RX rank 0 bit 0 coarse bit setting for rx per bit deskew
    // 
    // Bits[9:4], RW, default = 0x3D
    //
    UINTX dqrxpbd_b1n1dq0_rk0coarse : 6;
    //
    // DQ RX rank 1 bit 0 fine bit setting for rx per bit deskew
    // 
    // Bits[13:10], RW, default = 0xF
    //
    UINTX dqrxpbd_b1n1dq0_rk1fine : 4;
    //
    // DQ RX rank 1 bit 0 coarse bit setting for rx per bit deskew
    // 
    // Bits[19:14], RW, default = 0x3D
    //
    UINTX dqrxpbd_b1n1dq0_rk1coarse : 6;
    //
    // Reserved
    // 
    // Bits[31:20], RO, default = 0x0
    //
    UINTX reserved : 12;
  } Bits;
  UINTX Data;
} DQRXPBD0_B1N1_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define DQRXPBD1_B1N1_DDRDQ_PHY_REG                        0x00000574
#ifndef ASM_INC
typedef union {
  struct {
    //
    // DQ RX rank 2 bit 0 fine bit setting for rx per bit deskew
    // 
    // Bits[3:0], RW, default = 0xF
    //
    UINTX dqrxpbd_b1n1dq0_rk2fine : 4;
    //
    // DQ RX rank 2 bit 0 coarse bit setting for rx per bit deskew
    // 
    // Bits[9:4], RW, default = 0x3D
    //
    UINTX dqrxpbd_b1n1dq0_rk2coarse : 6;
    //
    // DQ RX rank 3 bit 0 fine bit setting for rx per bit deskew
    // 
    // Bits[13:10], RW, default = 0xF
    //
    UINTX dqrxpbd_b1n1dq0_rk3fine : 4;
    //
    // DQ RX rank 3 bit 0 coarse bit setting for rx per bit deskew
    // 
    // Bits[19:14], RW, default = 0x3D
    //
    UINTX dqrxpbd_b1n1dq0_rk3coarse : 6;
    //
    // Reserved
    // 
    // Bits[31:20], RO, default = 0x0
    //
    UINTX reserved : 12;
  } Bits;
  UINTX Data;
} DQRXPBD1_B1N1_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define DQRXPBD2_B1N1_DDRDQ_PHY_REG                        0x00000578
#ifndef ASM_INC
typedef union {
  struct {
    //
    // DQ RX rank 0 bit 1 fine bit setting for rx per bit deskew
    // 
    // Bits[3:0], RW, default = 0xF
    //
    UINTX dqrxpbd_b1n1dq1_rk0fine : 4;
    //
    // DQ RX rank 0 bit 1 coarse bit setting for rx per bit deskew
    // 
    // Bits[9:4], RW, default = 0x3D
    //
    UINTX dqrxpbd_b1n1dq1_rk0coarse : 6;
    //
    // DQ RX rank 1 bit 1 fine bit setting for rx per bit deskew
    // 
    // Bits[13:10], RW, default = 0xF
    //
    UINTX dqrxpbd_b1n1dq1_rk1fine : 4;
    //
    // DQ RX rank 1 bit 1 coarse bit setting for rx per bit deskew
    // 
    // Bits[19:14], RW, default = 0x3D
    //
    UINTX dqrxpbd_b1n1dq1_rk1coarse : 6;
    //
    // Reserved
    // 
    // Bits[31:20], RO, default = 0x0
    //
    UINTX reserved : 12;
  } Bits;
  UINTX Data;
} DQRXPBD2_B1N1_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define DQRXPBD3_B1N1_DDRDQ_PHY_REG                        0x0000057C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // DQ RX rank 2 bit 1 fine bit setting for rx per bit deskew
    // 
    // Bits[3:0], RW, default = 0xF
    //
    UINTX dqrxpbd_b1n1dq1_rk2fine : 4;
    //
    // DQ RX rank 2 bit 1 coarse bit setting for rx per bit deskew
    // 
    // Bits[9:4], RW, default = 0x3D
    //
    UINTX dqrxpbd_b1n1dq1_rk2coarse : 6;
    //
    // DQ RX rank 3 bit 1 fine bit setting for rx per bit deskew
    // 
    // Bits[13:10], RW, default = 0xF
    //
    UINTX dqrxpbd_b1n1dq1_rk3fine : 4;
    //
    // DQ RX rank 3 bit 1 coarse bit setting for rx per bit deskew
    // 
    // Bits[19:14], RW, default = 0x3D
    //
    UINTX dqrxpbd_b1n1dq1_rk3coarse : 6;
    //
    // Reserved
    // 
    // Bits[31:20], RO, default = 0x0
    //
    UINTX reserved : 12;
  } Bits;
  UINTX Data;
} DQRXPBD3_B1N1_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define DQRXPBD4_B1N1_DDRDQ_PHY_REG                        0x00000580
#ifndef ASM_INC
typedef union {
  struct {
    //
    // DQ RX rank 0 bit 2 fine bit setting for rx per bit deskew
    // 
    // Bits[3:0], RW, default = 0xF
    //
    UINTX dqrxpbd_b1n1dq2_rk0fine : 4;
    //
    // DQ RX rank 0 bit 2 coarse bit setting for rx per bit deskew
    // 
    // Bits[9:4], RW, default = 0x3D
    //
    UINTX dqrxpbd_b1n1dq2_rk0coarse : 6;
    //
    // DQ RX rank 1 bit 2 fine bit setting for rx per bit deskew
    // 
    // Bits[13:10], RW, default = 0xF
    //
    UINTX dqrxpbd_b1n1dq2_rk1fine : 4;
    //
    // DQ RX rank 1 bit 2 coarse bit setting for rx per bit deskew
    // 
    // Bits[19:14], RW, default = 0x3D
    //
    UINTX dqrxpbd_b1n1dq2_rk1coarse : 6;
    //
    // Reserved
    // 
    // Bits[31:20], RO, default = 0x0
    //
    UINTX reserved : 12;
  } Bits;
  UINTX Data;
} DQRXPBD4_B1N1_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define DQRXPBD5_B1N1_DDRDQ_PHY_REG                        0x00000584
#ifndef ASM_INC
typedef union {
  struct {
    //
    // DQ RX rank 2 bit 2 fine bit setting for rx per bit deskew
    // 
    // Bits[3:0], RW, default = 0xF
    //
    UINTX dqrxpbd_b1n1dq2_rk2fine : 4;
    //
    // DQ RX rank 2 bit 2 coarse bit setting for rx per bit deskew
    // 
    // Bits[9:4], RW, default = 0x3D
    //
    UINTX dqrxpbd_b1n1dq2_rk2coarse : 6;
    //
    // DQ RX rank 3 bit 2 fine bit setting for rx per bit deskew
    // 
    // Bits[13:10], RW, default = 0xF
    //
    UINTX dqrxpbd_b1n1dq2_rk3fine : 4;
    //
    // DQ RX rank 3 bit 2 coarse bit setting for rx per bit deskew
    // 
    // Bits[19:14], RW, default = 0x3D
    //
    UINTX dqrxpbd_b1n1dq2_rk3coarse : 6;
    //
    // Reserved
    // 
    // Bits[31:20], RO, default = 0x0
    //
    UINTX reserved : 12;
  } Bits;
  UINTX Data;
} DQRXPBD5_B1N1_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define DQRXPBD6_B1N1_DDRDQ_PHY_REG                        0x00000588
#ifndef ASM_INC
typedef union {
  struct {
    //
    // DQ RX rank 0 bit 3 fine bit setting for rx per bit deskew
    // 
    // Bits[3:0], RW, default = 0xF
    //
    UINTX dqrxpbd_b1n1dq3_rk0fine : 4;
    //
    // DQ RX rank 0 bit 3 coarse bit setting for rx per bit deskew
    // 
    // Bits[9:4], RW, default = 0x3D
    //
    UINTX dqrxpbd_b1n1dq3_rk0coarse : 6;
    //
    // DQ RX rank 1 bit 3 fine bit setting for rx per bit deskew
    // 
    // Bits[13:10], RW, default = 0xF
    //
    UINTX dqrxpbd_b1n1dq3_rk1fine : 4;
    //
    // DQ RX rank 1 bit 3 coarse bit setting for rx per bit deskew
    // 
    // Bits[19:14], RW, default = 0x3D
    //
    UINTX dqrxpbd_b1n1dq3_rk1coarse : 6;
    //
    // Reserved
    // 
    // Bits[31:20], RO, default = 0x0
    //
    UINTX reserved : 12;
  } Bits;
  UINTX Data;
} DQRXPBD6_B1N1_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define DQRXPBD7_B1N1_DDRDQ_PHY_REG                        0x0000058C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // DQ RX rank 2 bit 3 fine bit setting for rx per bit deskew
    // 
    // Bits[3:0], RW, default = 0xF
    //
    UINTX dqrxpbd_b1n1dq3_rk2fine : 4;
    //
    // DQ RX rank 2 bit 3 coarse bit setting for rx per bit deskew
    // 
    // Bits[9:4], RW, default = 0x3D
    //
    UINTX dqrxpbd_b1n1dq3_rk2coarse : 6;
    //
    // DQ RX rank 3 bit 3 fine bit setting for rx per bit deskew
    // 
    // Bits[13:10], RW, default = 0xF
    //
    UINTX dqrxpbd_b1n1dq3_rk3fine : 4;
    //
    // DQ RX rank 3 bit 3 coarse bit setting for rx per bit deskew
    // 
    // Bits[19:14], RW, default = 0x3D
    //
    UINTX dqrxpbd_b1n1dq3_rk3coarse : 6;
    //
    // Reserved
    // 
    // Bits[31:20], RO, default = 0x0
    //
    UINTX reserved : 12;
  } Bits;
  UINTX Data;
} DQRXPBD7_B1N1_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define DQSRXPBD0_B1N0_DDRDQ_PHY_REG                       0x00000590
#ifndef ASM_INC
typedef union {
  struct {
    //
    // DQS RX rank 0 fine bit setting for rx per bit deskew
    // 
    // Bits[3:0], RW, default = 0xF
    //
    UINTX dqsrxpbd_b1n0_rk0fine : 4;
    //
    // DQS RX rank 0 coarse bit setting for rx per bit deskew
    // 
    // Bits[9:4], RW, default = 0x3D
    //
    UINTX dqsrxpbd_b1n0_rk0coarse : 6;
    //
    // DQS RX rank 1 fine bit setting for rx per bit deskew
    // 
    // Bits[13:10], RW, default = 0xF
    //
    UINTX dqsrxpbd_b1n0_rk1fine : 4;
    //
    // DQS RX rank 1 coarse bit setting for rx per bit deskew
    // 
    // Bits[19:14], RW, default = 0x3D
    //
    UINTX dqsrxpbd_b1n0_rk1coarse : 6;
    //
    // DQS per bit deskew enable . 1:enabled (default) 0:disabled
    // 
    // Bits[20:20], RW, default = 0x1
    //
    UINTX dqsrxpbd_b1_en : 1;
    //
    // DQS per bit deskew delay cell static leg enable;support dfx per leg testing of
    // delay cells in rx pbd. 1: enabled (default) 0: disabled 
    // 
    // Bits[21:21], RW, default = 0x1
    //
    UINTX dqsrxpbd_b1_staticlegen : 1;
    //
    // Reserved
    // 
    // Bits[31:22], RO, default = 0x0
    //
    UINTX reserved : 10;
  } Bits;
  UINTX Data;
} DQSRXPBD0_B1N0_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define DQSRXPBD1_B1N0_DDRDQ_PHY_REG                       0x00000594
#ifndef ASM_INC
typedef union {
  struct {
    //
    // DQS RX rank 0 fine bit setting for rx per bit deskew
    // 
    // Bits[3:0], RW, default = 0xF
    //
    UINTX dqsrxpbd_b1n0_rk2fine : 4;
    //
    // DQS RX rank 0 coarse bit setting for rx per bit deskew
    // 
    // Bits[9:4], RW, default = 0x3D
    //
    UINTX dqsrxpbd_b1n0_rk2coarse : 6;
    //
    // DQS RX rank 1 fine bit setting for rx per bit deskew
    // 
    // Bits[13:10], RW, default = 0xF
    //
    UINTX dqsrxpbd_b1n0_rk3fine : 4;
    //
    // DQS RX rank 1 coarse bit setting for rx per bit deskew
    // 
    // Bits[19:14], RW, default = 0x3D
    //
    UINTX dqsrxpbd_b1n0_rk3coarse : 6;
    //
    // Reserved
    // 
    // Bits[31:20], RO, default = 0x0
    //
    UINTX reserved : 12;
  } Bits;
  UINTX Data;
} DQSRXPBD1_B1N0_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define DQSRXPBD0_B1N1_DDRDQ_PHY_REG                       0x00000598
#ifndef ASM_INC
typedef union {
  struct {
    //
    // DQS RX rank 0 fine bit setting for rx per bit deskew
    // 
    // Bits[3:0], RW, default = 0xF
    //
    UINTX dqsrxpbd_b1n1_rk0fine : 4;
    //
    // DQS RX rank 0 coarse bit setting for rx per bit deskew
    // 
    // Bits[9:4], RW, default = 0x3D
    //
    UINTX dqsrxpbd_b1n1_rk0coarse : 6;
    //
    // DQS RX rank 1 fine bit setting for rx per bit deskew
    // 
    // Bits[13:10], RW, default = 0xF
    //
    UINTX dqsrxpbd_b1n1_rk1fine : 4;
    //
    // DQS RX rank 1 coarse bit setting for rx per bit deskew
    // 
    // Bits[19:14], RW, default = 0x3D
    //
    UINTX dqsrxpbd_b1n1_rk1coarse : 6;
    //
    // Reserved
    // 
    // Bits[31:20], RO, default = 0x0
    //
    UINTX reserved : 12;
  } Bits;
  UINTX Data;
} DQSRXPBD0_B1N1_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define DQSRXPBD1_B1N1_DDRDQ_PHY_REG                       0x0000059C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // DQS RX rank 0 fine bit setting for rx per bit deskew
    // 
    // Bits[3:0], RW, default = 0xF
    //
    UINTX dqsrxpbd_b1n1_rk2fine : 4;
    //
    // DQS RX rank 0 coarse bit setting for rx per bit deskew
    // 
    // Bits[9:4], RW, default = 0x3D
    //
    UINTX dqsrxpbd_b1n1_rk2coarse : 6;
    //
    // DQS RX rank 1 fine bit setting for rx per bit deskew
    // 
    // Bits[13:10], RW, default = 0xF
    //
    UINTX dqsrxpbd_b1n1_rk3fine : 4;
    //
    // DQS RX rank 1 coarse bit setting for rx per bit deskew
    // 
    // Bits[19:14], RW, default = 0x3D
    //
    UINTX dqsrxpbd_b1n1_rk3coarse : 6;
    //
    // Reserved
    // 
    // Bits[31:20], RO, default = 0x0
    //
    UINTX reserved : 12;
  } Bits;
  UINTX Data;
} DQSRXPBD1_B1N1_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define RXDLLCFG_B1N0_DDRDQ_PHY_REG                        0x000005A0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Slave Delay line enable signal. 1= power up DL, 0= power down DL
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINTX rxdll_b1n0_dqssdllen : 1;
    //
    // Enable DQS PI block. 1= enable DQS PI block, 0=disable DQS PI block
    // 
    // Bits[1:1], RW, default = 0x0
    //
    UINTX rxdll_b1n0_dqspien : 1;
    //
    // DQS PI output gate enable. 1= gate DQS output off, 0= DQS output not gated
    // 
    // Bits[2:2], RW, default = 0x0
    //
    UINTX rxdll_b1n0_dqspiouten : 1;
    //
    // Enable DQSB PI block. 1= enable DQSB PI block, 0=disable DQSB PI block
    // 
    // Bits[3:3], RW, default = 0x0
    //
    UINTX rxdll_b1n0_dqsbpien : 1;
    //
    // DQSB PI output gate enable. 1= gate DQBS output off, 0= DQSB output not gated
    // 
    // Bits[4:4], RW, default = 0x0
    //
    UINTX rxdll_b1n0_dqsbpiouten : 1;
    //
    // Bypass Delay line and PI block for both DQS and DQSB output and route delay line
    // input to both DQS and DQSB outputs 
    // 
    // Bits[5:5], RW, default = 0x0
    //
    UINTX rxdll_b1n0_dqsbypassen : 1;
    //
    // 2x clk enable for DFX mode. This muxes a 2x clk to the rxdqssdl block input for
    // DFX 
    // 
    // Bits[6:6], RW, default = 0x0
    //
    UINTX rxdll_b1n0_2xdfxen : 1;
    //
    // Reserved
    // 
    // Bits[31:7], RO, default = 0x0
    //
    UINTX reserved : 25;
  } Bits;
  UINTX Data;
} RXDLLCFG_B1N0_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define RXDLLCFG_B1N1_DDRDQ_PHY_REG                        0x000005A4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Slave Delay line enable signal. 1= power up DL, 0= power down DL
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINTX rxdll_b1n1_dqssdllen : 1;
    //
    // Enable DQS PI block. 1= enable DQS PI block, 0=disable DQS PI block
    // 
    // Bits[1:1], RW, default = 0x0
    //
    UINTX rxdll_b1n1_dqspien : 1;
    //
    // DQS PI output gate enable. 1= gate DQS output off, 0= DQS output not gated
    // 
    // Bits[2:2], RW, default = 0x0
    //
    UINTX rxdll_b1n1_dqspiouten : 1;
    //
    // Enable DQSB PI block. 1= enable DQSB PI block, 0=disable DQSB PI block
    // 
    // Bits[3:3], RW, default = 0x0
    //
    UINTX rxdll_b1n1_dqsbpien : 1;
    //
    // DQSB PI output gate enable. 1= gate DQBS output off, 0= DQSB output not gated
    // 
    // Bits[4:4], RW, default = 0x0
    //
    UINTX rxdll_b1n1_dqsbpiouten : 1;
    //
    // Bypass Delay line and PI block for both DQS and DQSB output and route delay line
    // input to both DQS and DQSB outputs 
    // 
    // Bits[5:5], RW, default = 0x0
    //
    UINTX rxdll_b1n1_dqsbypassen : 1;
    //
    // 2x clk enable for DFX mode. This muxes a 2x clk to the rxdqssdl block input for
    // DFX 
    // 
    // Bits[6:6], RW, default = 0x0
    //
    UINTX rxdll_b1n1_2xdfxen : 1;
    //
    // Reserved
    // 
    // Bits[31:7], RO, default = 0x0
    //
    UINTX reserved : 25;
  } Bits;
  UINTX Data;
} RXDLLCFG_B1N1_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define OBSCFG_BL1_DDRDQ_PHY_REG                           0x000005A8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // ANA Buf mux select 0
    // 
    // Bits[1:0], RW, default = 0x0
    //
    UINTX dqbuf_b1_anaobs0sel : 2;
    //
    // ANA Buf mux select 1
    // 
    // Bits[3:2], RW, default = 0x0
    //
    UINTX dqbuf_b1_anaobs1sel : 2;
    //
    // DIG Buf mux select 0
    // 
    // Bits[7:4], RW, default = 0x0
    //
    UINTX dqbuf_b1_digobs0sel : 4;
    //
    // DIG Buf mux select 1
    // 
    // Bits[11:8], RW, default = 0x0
    //
    UINTX dqbuf_b1_digobs1sel : 4;
    //
    // ANA Buf mux select 0
    // 
    // Bits[13:12], RW, default = 0x0
    //
    UINTX dqsbuf_b1_anaobs0sel : 2;
    //
    // ANA Buf mux select 1
    // 
    // Bits[15:14], RW, default = 0x0
    //
    UINTX dqsbuf_b1_anaobs1sel : 2;
    //
    // DIG Buf mux select 0
    // 
    // Bits[19:16], RW, default = 0x0
    //
    UINTX dqsbuf_b1_digobs0sel : 4;
    //
    // DIG Buf mux select 1
    // 
    // Bits[23:20], RW, default = 0x0
    //
    UINTX dqsbuf_b1_digobs1sel : 4;
    //
    // Digital obs select lines for obs port 0
    // 
    // Bits[25:24], RW, default = 0x0
    //
    UINTX rxdll_b1n0_digobs0sel : 2;
    //
    // Digital obs select lines for obs port 1
    // 
    // Bits[27:26], RW, default = 0x0
    //
    UINTX rxdll_b1n0_digobs1sel : 2;
    //
    // Digital obs select lines for obs port 0
    // 
    // Bits[29:28], RW, default = 0x0
    //
    UINTX rxdll_b1n1_digobs0sel : 2;
    //
    // Digital obs select lines for obs port 1
    // 
    // Bits[31:30], RW, default = 0x0
    //
    UINTX rxdll_b1n1_digobs1sel : 2;
  } Bits;
  UINTX Data;
} OBSCFG_BL1_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define RXDQMINDLY_BL1_DDRDQ_PHY_REG                       0x000005AC
#ifndef ASM_INC
typedef union {
  struct {
    //
    // RXDQMINDLY PI output gate enable. 1= gate RXDQMINDLY output off, 0= RXDQMINDLY
    // output not gated 
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINTX rxdqmindly_b1_dqpiouten : 1;
    //
    // Enable RXDQMINDLY PI block. 1= enable RXDQMINDLY PI block, 0=disable RXDQMINDLY
    // PI block 
    // 
    // Bits[1:1], RW, default = 0x0
    //
    UINTX rxdqmindly_b1_dqdllpien : 1;
    //
    // Bypass Delay line and PI block for RXDQMINDLY output and route delay line input
    // to RXDQMINDLY output 
    // 
    // Bits[2:2], RW, default = 0x0
    //
    UINTX rxdqmindly_b1_dqbypassen : 1;
    //
    // Digital obs select lines for RXDQMINDLY obs port 1
    // 
    // Bits[4:3], RW, default = 0x0
    //
    UINTX rxdqmindly_b1_digobs1sel : 2;
    //
    // Digital obs select lines for RXDQMINDLY obs port 0
    // 
    // Bits[6:5], RW, default = 0x0
    //
    UINTX rxdqmindly_b1_digobs0sel : 2;
    //
    // Reserved
    // 
    // Bits[31:7], RO, default = 0x0
    //
    UINTX reserved : 25;
  } Bits;
  UINTX Data;
} RXDQMINDLY_BL1_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define RXVREFCFG_BL1_DDRDQ_PHY_REG                        0x000005B0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Enable VREF
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINTX rxvref_b1_vrefen : 1;
    //
    // VREF Code
    // 
    // Bits[6:1], RW, default = 0x20
    //
    UINTX rxvref_b1_vrefctrl : 6;
    //
    // Range select to pick between DDR3 and DDR4. [br]0 - DDR3 (Default)  [br]1- DDR4
    // 
    // Bits[7:7], RW, default = 0x0
    //
    UINTX rxvref_b1_vrefrangesel : 1;
    //
    // Reserved
    // 
    // Bits[31:8], RO, default = 0x0
    //
    UINTX reserved : 24;
  } Bits;
  UINTX Data;
} RXVREFCFG_BL1_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define COMPSTATIC_BL1_DDRDQ_PHY_REG                       0x000005B4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Pull-down RCOMP code for driver static leg for DQ buffers
    // 
    // Bits[2:0], RW, default = 0x7
    //
    UINTX comp_b1_dqpdndrvstatic : 3;
    //
    // Pull-down RCOMP code for ODT static leg. [br]3'b010 : DDR3L[br]3'b010 : DDR4 weak[br]3'b111
    // : DDR4 strong 
    // 
    // Bits[5:3], RW, default = 0x7
    //
    UINTX comp_b1_dqpdnodtstatic : 3;
    //
    // Pull-up RCOMP code for driver static leg for DQ buffers
    // 
    // Bits[8:6], RW, default = 0x7
    //
    UINTX comp_b1_dqpupdrvstatic : 3;
    //
    // Pull-up RCOMP code for ODT static leg. [br]3'b010 : DDR3L[br]3'b010 : DDR4 weak[br]3'b111
    // : DDR4 strong 
    // 
    // Bits[11:9], RW, default = 0x7
    //
    UINTX comp_b1_dqpupodtstatic : 3;
    //
    // Pull-down RCOMP code for driver static leg for DQ buffers
    // 
    // Bits[14:12], RW, default = 0x7
    //
    UINTX comp_b1_dqspdndrvstatic : 3;
    //
    // Pull-down RCOMP code for ODT static leg. [br]3'b010 : DDR3L[br]3'b010 : DDR4 weak[br]3'b111
    // : DDR4 strong 
    // 
    // Bits[17:15], RW, default = 0x7
    //
    UINTX comp_b1_dqspdnodtstatic : 3;
    //
    // Pull-up RCOMP code for driver static leg for DQ buffers
    // 
    // Bits[20:18], RW, default = 0x7
    //
    UINTX comp_b1_dqspupdrvstatic : 3;
    //
    // Pull-up RCOMP code for ODT static leg. [br]3'b010 : DDR3L[br]3'b010 : DDR4 weak[br]3'b111
    // : DDR4 strong 
    // 
    // Bits[23:21], RW, default = 0x7
    //
    UINTX comp_b1_dqspupodtstatic : 3;
    //
    // Reserved
    // 
    // Bits[31:24], RO, default = 0x0
    //
    UINTX reserved : 8;
  } Bits;
  UINTX Data;
} COMPSTATIC_BL1_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define DQ_LRCOMP_CFG1_DDRDQ_PHY_REG                       0x000005E0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Delay after enabling Rcomp before starting measurement timer
    // 
    // Bits[7:0], RW, default = 0xE
    //
    UINTX reserved : 8;
    //
    // Number of binary search steps
    // 
    // Bits[11:8], RW, default = 0xA
    //
    UINTX reserved_1 : 4;
    //
    // Initial step value for Rcomp binary search
    // 
    // Bits[18:12], RW, default = 0x20
    //
    UINTX lrcomp_initstep : 7;
    //
    // Initial value for Rcomp binary search
    // 
    // Bits[25:19], RW, default = 0x0
    //
    UINTX reserved_2 : 7;
    //
    // Number of times to repeat and average the Rcomp compensation
    // 
    // Bits[30:26], RW, default = 0x1
    //
    UINTX reserved_3 : 5;
    //
    // Reserved bits
    // 
    // Bits[31:31], RO, default = 0x0
    //
    UINTX reserved_4 : 1;
  } Bits;
  UINTX Data;
} DQ_LRCOMP_CFG1_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define DQ_LRCOMP_CFG2_DDRDQ_PHY_REG                       0x000005E4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // indicates the division ratio of the c73ddr402_comp clock w.r.t spid clk
    // 
    // Bits[1:0], RW, default = 0x1
    //
    UINTX reserved : 2;
    //
    // set it to '1' to select the membus form gcomp, '0' to select it from previous
    // module. 
    // 
    // Bits[2:2], RW, default = 0x0
    //
    UINTX reserved_1 : 1;
    //
    // Rcomp sample time 3
    // 
    // Bits[10:3], RW, default = 0xE
    //
    UINTX reserved_2 : 8;
    //
    // Rcomp sample time 2
    // 
    // Bits[18:11], RW, default = 0xE
    //
    UINTX reserved_3 : 8;
    //
    // Rcomp sample time 1
    // 
    // Bits[26:19], RW, default = 0xE
    //
    UINTX reserved_4 : 8;
    //
    // Reserved bits
    // 
    // Bits[31:27], RO, default = 0x0
    //
    UINTX reserved_5 : 5;
  } Bits;
  UINTX Data;
} DQ_LRCOMP_CFG2_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define DQ_LRCOMP_OVR0_DDRDQ_PHY_REG                       0x000005E8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // not used
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINTX reserved : 1;
    //
    // not used
    // 
    // Bits[7:1], RW, default = 0x0
    //
    UINTX reserved_1 : 7;
    //
    // Pull down override enable
    // 
    // Bits[11:8], RW, default = 0x0
    //
    UINTX reserved_2 : 4;
    //
    // Pull up override enable
    // 
    // Bits[15:12], RW, default = 0x0
    //
    UINTX reserved_3 : 4;
    //
    // override enable for override for pull down live rcomp code going to AFE
    // 
    // Bits[16:16], RW, default = 0x0
    //
    UINTX reserved_4 : 1;
    //
    // override for pull down live rcomp code going to AFE
    // 
    // Bits[23:17], RW, default = 0x1
    //
    UINTX reserved_5 : 7;
    //
    // Reserved bits
    // 
    // Bits[31:24], RO, default = 0x0
    //
    UINTX reserved_6 : 8;
  } Bits;
  UINTX Data;
} DQ_LRCOMP_OVR0_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define DQ_LRCOMP_CTL0_DDRDQ_PHY_REG                       0x000005EC
#ifndef ASM_INC
typedef union {
  struct {
    //
    // config contorl for disabling rcomp code per group.
    // 
    // Bits[3:0], RW, default = 0x0
    //
    UINTX reserved : 4;
    //
    // enable for config concifg control for updating rcomp codes.
    // 
    // Bits[4:4], RW, default = 0x0
    //
    UINTX reserved_1 : 1;
    //
    // config control for updating rcomp codes.
    // 
    // Bits[5:5], RW, default = 0x0
    //
    UINTX reserved_2 : 1;
    //
    // not used.
    // 
    // Bits[11:6], RW, default = 0x0
    //
    UINTX reserved_3 : 6;
    //
    // static leg signal for PD c73ddr402_comp buffer.
    // 
    // Bits[12:12], RW, default = 0x1
    //
    UINTX reserved_4 : 1;
    //
    // static live signal for PD c73ddr402_comp buffer.
    // 
    // Bits[13:13], RW, default = 0x1
    //
    UINTX reserved_5 : 1;
    //
    // selects the bus_quiet_time_gnt signal for lcomp buffer.
    // 
    // Bits[15:14], RW, default = 0x1
    //
    UINTX reserved_6 : 2;
    //
    // Reserved bits
    // 
    // Bits[31:16], RO, default = 0x0
    //
    UINTX reserved_7 : 16;
  } Bits;
  UINTX Data;
} DQ_LRCOMP_CTL0_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define DQ_LRCOMP_CTL1_DDRDQ_PHY_REG                       0x000005F0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // enable indirect update, when '1', it enables indirect update for respective group,
    // when '0', it disables indirect update for that group. 
    // 
    // Bits[3:0], RW, default = 0x0
    //
    UINTX reserved : 4;
    //
    // tells the rcomp which groups are valid.
    // 
    // Bits[11:4], RW, default = 0xF
    //
    UINTX reserved_1 : 8;
    //
    // tells the rcomp to copy the adjecent code instead of evaluating it
    // 
    // Bits[19:12], RW, default = 0x0
    //
    UINTX reserved_2 : 8;
    //
    // Reserved bits
    // 
    // Bits[31:20], RO, default = 0x0
    //
    UINTX reserved_3 : 12;
  } Bits;
  UINTX Data;
} DQ_LRCOMP_CTL1_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define DQ_LRCOMP_RSTCTL_DDRDQ_PHY_REG                     0x000005F4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // active low reset for lcomp.
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINTX reserved : 1;
    //
    // Reserved bits
    // 
    // Bits[31:1], RO, default = 0x0
    //
    UINTX reserved_1 : 31;
  } Bits;
  UINTX Data;
} DQ_LRCOMP_RSTCTL_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define DQ_TXDLYCOMP_CLKGATE_DDRDQ_PHY_REG                 0x000005F8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Clock gating control for txdlycomp
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINTX reserved : 1;
    //
    // Clock gating control for rcomp.
    // 
    // Bits[1:1], RW, default = 0x0
    //
    UINTX reserved_1 : 1;
    //
    // Reserved bits
    // 
    // Bits[31:2], RO, default = 0x0
    //
    UINTX reserved_2 : 30;
  } Bits;
  UINTX Data;
} DQ_TXDLYCOMP_CLKGATE_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define DQ_TXDLYCOMP_INIT_DDRDQ_PHY_REG                    0x000005FC
#ifndef ASM_INC
typedef union {
  struct {
    //
    // enable initial txdlycomp
    // 
    // Bits[0:0], RW/1S/V, default = 0x0
    //
    UINTX reserved : 1;
    //
    // Reserved bits
    // 
    // Bits[31:1], RO, default = 0x0
    //
    UINTX reserved_1 : 31;
  } Bits;
  UINTX Data;
} DQ_TXDLYCOMP_INIT_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define DQ_LRCOMP_DEBUG_DDRDQ_PHY_REG                      0x00000600
#ifndef ASM_INC
typedef union {
  struct {
    //
    // debug ctrl bits.
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINTX reserved : 1;
    //
    // debug ctrl bits.
    // 
    // Bits[1:1], RW, default = 0x0
    //
    UINTX reserved_1 : 1;
    //
    // spare bits
    // 
    // Bits[17:2], RW, default = 0x0
    //
    UINTX reserved_2 : 16;
    //
    // Reserved bits
    // 
    // Bits[31:18], RO, default = 0x0
    //
    UINTX reserved_3 : 14;
  } Bits;
  UINTX Data;
} DQ_LRCOMP_DEBUG_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define DQ_LRCOMP_OVR1_DDRDQ_PHY_REG                       0x00000604
#ifndef ASM_INC
typedef union {
  struct {
    //
    // grp1 pull down override code
    // 
    // Bits[6:0], RW, default = 0x0
    //
    UINTX reserved : 7;
    //
    // grp1 pull up override code
    // 
    // Bits[13:7], RW, default = 0x0
    //
    UINTX reserved_1 : 7;
    //
    // grp0 pull down override code
    // 
    // Bits[20:14], RW, default = 0x0
    //
    UINTX reserved_2 : 7;
    //
    // grp0 pull up override code
    // 
    // Bits[27:21], RW, default = 0x0
    //
    UINTX reserved_3 : 7;
    //
    // Reserved bits
    // 
    // Bits[31:28], RO, default = 0x0
    //
    UINTX reserved_4 : 4;
  } Bits;
  UINTX Data;
} DQ_LRCOMP_OVR1_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define DQ_LRCOMP_OVR2_DDRDQ_PHY_REG                       0x00000608
#ifndef ASM_INC
typedef union {
  struct {
    //
    // grp3 pull down override code
    // 
    // Bits[6:0], RW, default = 0x0
    //
    UINTX reserved : 7;
    //
    // grp3 pull up override code
    // 
    // Bits[13:7], RW, default = 0x0
    //
    UINTX reserved_1 : 7;
    //
    // grp2 pull down override code
    // 
    // Bits[20:14], RW, default = 0x0
    //
    UINTX reserved_2 : 7;
    //
    // grp2 pull up override code
    // 
    // Bits[27:21], RW, default = 0x0
    //
    UINTX reserved_3 : 7;
    //
    // Reserved bits
    // 
    // Bits[31:28], RO, default = 0x0
    //
    UINTX reserved_4 : 4;
  } Bits;
  UINTX Data;
} DQ_LRCOMP_OVR2_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define DQ_TXDLYCOMP_0_DDRDQ_PHY_REG                       0x0000060C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // TBD
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINTX reserved : 1;
    //
    // continuous enable mode for txdlycomp
    // 
    // Bits[1:1], RW, default = 0x0
    //
    UINTX reserved_1 : 1;
    //
    // TBD
    // 
    // Bits[2:2], RW/1C/V, default = 0x0
    //
    UINTX reserved_2 : 1;
    //
    // config value for grp0 fine code.
    // 
    // Bits[10:3], RW, default = 0x0
    //
    UINTX reserved_3 : 8;
    //
    // config value for grp0 coarse code.
    // 
    // Bits[18:11], RW, default = 0x0
    //
    UINTX reserved_4 : 8;
    //
    // bits for override control of grp0 code
    // 
    // Bits[19:19], RW, default = 0x0
    //
    UINTX reserved_5 : 1;
    //
    // bits to disable for group0 code update.
    // 
    // Bits[20:20], RW, default = 0x0
    //
    UINTX reserved_6 : 1;
    //
    // select the delay tap node in AFE for group0
    // 
    // Bits[25:21], RW, default = 0x2
    //
    UINTX reserved_7 : 5;
    //
    // enable for config update contorl for txdlycomp code.
    // 
    // Bits[26:26], RW, default = 0x0
    //
    UINTX reserved_8 : 1;
    //
    // config update contorl for txdlyocmp code
    // 
    // Bits[27:27], RW, default = 0x0
    //
    UINTX reserved_9 : 1;
    //
    // Reserved bits
    // 
    // Bits[31:28], RO, default = 0x0
    //
    UINTX reserved_10 : 4;
  } Bits;
  UINTX Data;
} DQ_TXDLYCOMP_0_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define DQ_TXDLYCOMP_1_DDRDQ_PHY_REG                       0x00000610
#ifndef ASM_INC
typedef union {
  struct {
    //
    // config value for grp1 fine code.
    // 
    // Bits[7:0], RW, default = 0x0
    //
    UINTX reserved : 8;
    //
    // config value for grp1 coarse code.
    // 
    // Bits[15:8], RW, default = 0x0
    //
    UINTX reserved_1 : 8;
    //
    // bits for override control of grp1 code
    // 
    // Bits[16:16], RW, default = 0x0
    //
    UINTX reserved_2 : 1;
    //
    // bits to disable for group1 code update.
    // 
    // Bits[17:17], RW, default = 0x0
    //
    UINTX reserved_3 : 1;
    //
    // select the delay tap node in AFE for group1
    // 
    // Bits[22:18], RW, default = 0x2
    //
    UINTX reserved_4 : 5;
    //
    // Reserved bits
    // 
    // Bits[31:23], RO, default = 0x0
    //
    UINTX reserved_5 : 9;
  } Bits;
  UINTX Data;
} DQ_TXDLYCOMP_1_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define DQ_TXDLYCOMPOVR_DDRDQ_PHY_REG                      0x00000614
#ifndef ASM_INC
typedef union {
  struct {
    //
    // TX Delay c73ddr402_comp MAX value of fine code.
    // 
    // Bits[3:0], RW, default = 0x8
    //
    UINTX reserved : 4;
    //
    // TX Delay c73ddr402_comp MAX value of coarse code.
    // 
    // Bits[7:4], RW, default = 0x7
    //
    UINTX reserved_1 : 4;
    //
    // Enable for TX Delay ocmp live code override value.
    // 
    // Bits[8:8], RW, default = 0x0
    //
    UINTX reserved_2 : 1;
    //
    // TX Delay c73ddr402_comp live code override value
    // 
    // Bits[16:9], RW, default = 0x0
    //
    UINTX reserved_3 : 8;
    //
    // Reserved bits
    // 
    // Bits[31:17], RO, default = 0x0
    //
    UINTX reserved_4 : 15;
  } Bits;
  UINTX Data;
} DQ_TXDLYCOMPOVR_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define DQ_LRCOMP_CODES_0_DDRDQ_PHY_REG                    0x00000618
#ifndef ASM_INC
typedef union {
  struct {
    //
    // reserved
    // 
    // Bits[7:0], RO/V, default = 0x8
    //
    UINTX reserved : 8;
    //
    // reserved
    // 
    // Bits[15:8], RO/V, default = 0x7
    //
    UINTX reserved_1 : 8;
    //
    // reserved
    // 
    // Bits[23:16], RO/V, default = 0x0
    //
    UINTX reserved_2 : 8;
    //
    // reserved
    // 
    // Bits[31:24], RO/V, default = 0x0
    //
    UINTX reserved_3 : 8;
  } Bits;
  UINTX Data;
} DQ_LRCOMP_CODES_0_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define DQ_LRCOMP_CODES_1_DDRDQ_PHY_REG                    0x0000061C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // reserved
    // 
    // Bits[7:0], RO/V, default = 0x8
    //
    UINTX reserved : 8;
    //
    // reserved
    // 
    // Bits[15:8], RO/V, default = 0x7
    //
    UINTX reserved_1 : 8;
    //
    // reserved
    // 
    // Bits[23:16], RO/V, default = 0x0
    //
    UINTX reserved_2 : 8;
    //
    // reserved
    // 
    // Bits[31:24], RO/V, default = 0x0
    //
    UINTX reserved_3 : 8;
  } Bits;
  UINTX Data;
} DQ_LRCOMP_CODES_1_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define DQ_LTXDLYCOMP_CODES_0_DDRDQ_PHY_REG                0x00000620
#ifndef ASM_INC
typedef union {
  struct {
    //
    // reserved
    // 
    // Bits[7:0], RO/V, default = 0x8
    //
    UINTX reserved : 8;
    //
    // reserved
    // 
    // Bits[15:8], RO/V, default = 0x7
    //
    UINTX reserved_1 : 8;
    //
    // reserved
    // 
    // Bits[23:16], RO/V, default = 0x0
    //
    UINTX reserved_2 : 8;
    //
    // reserved
    // 
    // Bits[31:24], RO/V, default = 0x0
    //
    UINTX reserved_3 : 8;
  } Bits;
  UINTX Data;
} DQ_LTXDLYCOMP_CODES_0_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define DQ_LRCOMP_CTL2_DDRDQ_PHY_REG                       0x00000624
#ifndef ASM_INC
typedef union {
  struct {
    //
    // For future designs, where there might be a need to generate a stage3 enable for
    // AFE. It needs to be '1' otherwise. 
    // 
    // Bits[3:0], RW, default = 0x1
    //
    UINTX reserved : 4;
    //
    // For future designs, where there might be a need to generate a stage3 enable for
    // AFE. It needs to be '1' otherwise. 
    // 
    // Bits[7:4], RW, default = 0x1
    //
    UINTX reserved_1 : 4;
    //
    // For future designs, where there might be a need to generate a stage3 enable for
    // AFE. It needs to be '1' otherwise. 
    // 
    // Bits[11:8], RW, default = 0x1
    //
    UINTX reserved_2 : 4;
    //
    // the number of cycles after lcomp receives the bus_quiet_time_gnt signal, and before
    // it takes any action. This allows the phy to finish off any running read/write
    // cycles 
    // 
    // Bits[18:12], RW, default = 0x1
    //
    UINTX reserved_3 : 7;
    //
    // Reserved bits
    // 
    // Bits[31:19], RO, default = 0x0
    //
    UINTX reserved_4 : 13;
  } Bits;
  UINTX Data;
} DQ_LRCOMP_CTL2_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define DQ_LRCOMP_CTL3_DDRDQ_PHY_REG                       0x00000628
#ifndef ASM_INC
typedef union {
  struct {
    //
    // pull down verf ctrl voltage code for grp3
    // 
    // Bits[5:0], RW, default = 0x20
    //
    UINTX reserved : 6;
    //
    // pull down verf ctrl voltage code for grp2
    // 
    // Bits[11:6], RW, default = 0x20
    //
    UINTX reserved_1 : 6;
    //
    // pull down verf ctrl voltage code for grp1
    // 
    // Bits[17:12], RW, default = 0x20
    //
    UINTX reserved_2 : 6;
    //
    // pull down verf ctrl voltage code for grp0
    // 
    // Bits[23:18], RW, default = 0x20
    //
    UINTX reserved_3 : 6;
    //
    // Masking bit for indirect update for (stg3) stage 3 latches in AFE. Should be always
    // '1' in DNV. 
    // 
    // Bits[24:24], RW, default = 0x1
    //
    UINTX reserved_4 : 1;
    //
    // Reserved bits
    // 
    // Bits[31:25], RO, default = 0x0
    //
    UINTX reserved_5 : 7;
  } Bits;
  UINTX Data;
} DQ_LRCOMP_CTL3_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define DQ_LRCOMP_CTL4_DDRDQ_PHY_REG                       0x0000062C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Length of update pulse = lrcomp_update_len+1 comp_clk cycles
    // 
    // Bits[3:0], RW, default = 0x0
    //
    UINTX reserved : 4;
    //
    // Width of CLK rcomp stage 2 latch enable = lrcomp_clk_stg2_width + 1 comp_clk cycles
    // 
    // Bits[7:4], RW, default = 0x0
    //
    UINTX reserved_1 : 4;
    //
    // Reserved bits
    // 
    // Bits[31:8], RO, default = 0x0
    //
    UINTX reserved_2 : 24;
  } Bits;
  UINTX Data;
} DQ_LRCOMP_CTL4_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define DQ_LRCOMP_CTL5_DDRDQ_PHY_REG                       0x00000630
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Rcomp max value of code. The live code wont go beyond this. If the c73ddr402_comp
    // sm gives a value greater than this, it will be capped to this value. 
    // 
    // Bits[6:0], RW, default = 0x3F
    //
    UINTX reserved : 7;
    //
    // Not used. Reserved for future usage of LCOMP channel enable
    // 
    // Bits[8:7], RW, default = 0x3
    //
    UINTX reserved_1 : 2;
    //
    // Reserved bits
    // 
    // Bits[31:9], RO, default = 0x0
    //
    UINTX reserved_2 : 23;
  } Bits;
  UINTX Data;
} DQ_LRCOMP_CTL5_DDRDQ_PHY_STRUCT;
#endif // ASM_INC

#define DQ_TXDLYCOMP_2_DDRDQ_PHY_REG                       0x00000634
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Delay after sending timing reference pulse before sampling updn
    // 
    // Bits[7:0], RW, default = 0x0
    //
    UINTX reserved : 8;
    //
    // Delay before sending timing reference pulse
    // 
    // Bits[11:8], RW, default = 0x0
    //
    UINTX reserved_1 : 4;
    //
    // cadence continuous enable mode for txdlycomp
    // 
    // Bits[12:12], RW, default = 0x0
    //
    UINTX reserved_2 : 1;
    //
    // Reserved bits
    // 
    // Bits[31:13], RO, default = 0x0
    //
    UINTX reserved_3 : 19;
  } Bits;
  UINTX Data;
} DQ_TXDLYCOMP_2_DDRDQ_PHY_STRUCT;
#endif // ASM_INC


#endif // _DDRDQ_PHY_H_
