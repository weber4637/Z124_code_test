/** @file
  File name:    DUNIT_COMMON.h
  Input File:   DNV_MRC.xlsx

  THIS FILE IS AUTO-GENERATED BY THE MSP TOOL. DO NOT CHANGE THIS CODE.

  If edits are needed in this file, they must be done via the MSP tool.

  If there is additional project-specific data required by the MSP, it
  can be placed in DUNIT_COMMON.h, which is used for non-tool-generated
  data

  Includes register defines specific to a project.

  Copyright (c) 2005-2018 Intel Corporation. All rights reserved
  This software and associated documentation (if any) is furnished
  under a license and may only be used or copied in accordance
  with the terms of the license. Except as permitted by such
  license, no part of this software or documentation may be
  reproduced, stored in a retrieval system, or transmitted in any
  form or by any means without the express written consent of
  Intel Corporation.
**/
#ifndef _DUNIT_COMMON_H_
#define _DUNIT_COMMON_H_

#include "DataTypes.h"

#if USE_64_BIT_VARIABLES
#define UINTX UINT64
#else
#define UINTX UINT32
#endif

#define MRC_FLOW_SSKPD0_DUNIT_COMMON_REG                   0x00000120
#ifndef ASM_INC
typedef union {
  struct {
    //
    // SSKPD0
    // 
    // Bits[2:0], RW, default = 0x0
    //
    UINTX mrcflowstatus : 3;
    //
    // SSKPD0
    // 
    // Bits[3:3], RW, default = 0x0
    //
    UINTX reserved0 : 1;
    //
    // SSKPD0
    // 
    // Bits[6:4], RW, default = 0x0
    //
    UINTX mrcspdfrequency : 3;
    //
    // SSKPD0
    // 
    // Bits[7:7], RW, default = 0x0
    //
    UINTX mrcspdreset : 1;
    //
    // SSKPD0
    // 
    // Bits[10:8], RW, default = 0x0
    //
    UINTX mrcvoltage : 3;
    //
    // SSKPD0
    // 
    // Bits[11:11], RW, default = 0x0
    //
    UINTX reserved1 : 1;
    //
    // SSKPD0
    // 
    // Bits[19:12], RW, default = 0x0
    //
    UINTX mrcfinevoltage : 8;
    //
    // SSKPD0
    // 
    // Bits[21:20], RW, default = 0x0
    //
    UINTX mrcchannel : 2;
    //
    // SSKPD0
    // 
    // Bits[31:22], RW, default = 0x0
    //
    UINTX reserved2 : 10;
  } Bits;
  UINTX Data;
} MRC_FLOW_SSKPD0_DUNIT_COMMON_STRUCT;
#endif // ASM_INC

#define DSCH_DATA_DUNIT_COMMON_REG                         0x00000000
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Data31_0
    // 
    // Bits[31:0], RW, default = 0x0
    //
    UINTX data : 32;
  } Bits;
  UINTX Data;
} DSCH_DATA_DUNIT_COMMON_STRUCT;
#endif // ASM_INC

#define DZQPARAM_DATA_DUNIT_COMMON_REG                     0x00000004
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Data31_0
    // 
    // Bits[31:0], RW, default = 0x0
    //
    UINTX data : 32;
  } Bits;
  UINTX Data;
} DZQPARAM_DATA_DUNIT_COMMON_STRUCT;
#endif // ASM_INC

#define DPMC_DATA_DUNIT_COMMON_REG                         0x0000000C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Data31_0
    // 
    // Bits[31:0], RW, default = 0x0
    //
    UINTX data : 32;
  } Bits;
  UINTX Data;
} DPMC_DATA_DUNIT_COMMON_STRUCT;
#endif // ASM_INC

#define DRFC2_DATA_DUNIT_COMMON_REG                        0x00000018
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Data31_0
    // 
    // Bits[31:0], RW, default = 0x0
    //
    UINTX data : 32;
  } Bits;
  UINTX Data;
} DRFC2_DATA_DUNIT_COMMON_STRUCT;
#endif // ASM_INC

#define DRFC0_DATA_DUNIT_COMMON_REG                        0x00000010
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Data31_0
    // 
    // Bits[31:0], RW, default = 0x0
    //
    UINTX data : 32;
  } Bits;
  UINTX Data;
} DRFC0_DATA_DUNIT_COMMON_STRUCT;
#endif // ASM_INC

#define SBONUS_MISC_B0_DUNIT_COMMON_REG                    0x00000034
#ifndef ASM_INC
typedef union {
  struct {
    //
    // DDRIO_RST_BLOCK when set to 1 will block warm reset from being sent to the DDRIO
    // HIP 
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINTX ddrio_rst_block : 1;
    //
    // ECO (Bonus) Regsiter cleared only by cold reset (sticky).
    // 
    // Bits[31:1], RW, default = 0x0
    //
    UINTX eco : 31;
  } Bits;
  UINTX Data;
} SBONUS_MISC_B0_DUNIT_COMMON_STRUCT;
#endif // ASM_INC

#define DSCH_DUNIT_COMMON_REG                              0x00000000
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Channel 0 Enable: 0 = Disabled, 1= Enabled.
    // 
    // Bits[0:0], RW/V/P, default = 0x0
    //
    UINTX ch0en : 1;
    //
    // Channel 1 Enable: 0 = Disabled, 1= Enabled.
    // 
    // Bits[1:1], RW/V/P, default = 0x0
    //
    UINTX ch1en : 1;
    //
    // DRAM Technology Selection: 0 = DDR3, 1 = DDR4
    // 
    // Bits[2:2], RW/V/P, default = 0x0
    //
    UINTX ddr4en : 1;
    //
    // After Cold Reset, BIOS should set this bit to 1 before sending the WAKE message
    // to the Dunit. 
    // [br] For Standby Exit, or any other mode in which the DRAM is in SR, this bit
    // must be set to 0. 
    // 
    // Bits[3:3], RW/P, default = 0x0
    //
    UINTX coldwake : 1;
    //
    // Disable New Request Bypass:
    // [br] 0: Enable a new request from PMI to get processed immediately without having
    // to first enter the IPreq queue. This is allowed only when the IPreq queue is empty.
    // [br] 1: Disable new request from getting processed directly. All new requests
    // from PMI has to enter the IPreq queue first before they get processed. New requests
    // are not allowed to bypass the IPreq queue. 
    // 
    // Bits[4:4], RW/P, default = 0x0
    //
    UINTX newbypdis : 1;
    //
    // DRAM Channel Width Selection: 0 = 64 bit, 1 = 32 bit.
    // 
    // Bits[5:5], RW/P, default = 0x0
    //
    UINTX channel_width_32 : 1;
    //
    // Reserved
    // 
    // Bits[6:6], RSV, default = 0x0
    //
    UINTX rsvd_dsch_0 : 1;
    //
    // Disable Out-of-Order for both reads and writes
    // [br] 0: OOO enabled.
    // [br] 1: OOO disabled.
    // [br] Should be disabled during init/training and can be enabled for functional
    // mode. 
    // 
    // Bits[7:7], RW/P, default = 0x0
    //
    UINTX ooodis : 1;
    //
    // Reserved
    // 
    // Bits[18:8], RSV, default = 0x0
    //
    UINTX rsvd_dsch_1 : 11;
    //
    // Dunit Initialization Complete:
    // [br] Indicates that initialization of the Dunit has completed. Memory accesses
    // are permitted and maintenance operation begins. 
    // Until this bit is set to a 1, the memory controller will not issue refreshes,
    // initiate autopage closes, allow dynamic SR entry or CAP error detection. 
    // [br] Note: Set this bit to 1 only when all other Dunit registers has been configured.
    // Usually set at the last configuration step. 
    // 
    // Bits[19:19], RW, default = 0x0
    //
    UINTX ic : 1;
    //
    // Reserved
    // 
    // Bits[31:20], RSV, default = 0x0
    //
    UINTX rsvd_dsch_2 : 12;
  } Bits;
  UINTX Data;
} DSCH_DUNIT_COMMON_STRUCT;
#endif // ASM_INC

#define DZQPARAM_DUNIT_COMMON_REG                          0x00000004
#ifndef ASM_INC
typedef union {
  struct {
    //
    // ZQ Calibration Short Interval:
    // [br] ZQCS commands will be sent to each enabled rank at 1/8th of the interval
    // value programmed in this field.  ZQCINT may be changed on-the-fly.  This field
    // is in 8192 DRAM clocks. 
    // [br] 0: Disabled.  Typical value is 128ms.
    // [br] 1562: DDR3 1600: 128ms
    // [br] 1822: DDR3 1867: 128ms
    // [br] 2083: DDR4 2133: 128ms
    // [br] 2343: DDR4 2400: 128ms
    // [br] 2604: DDR4 2667: 128ms
    // 
    // Bits[10:0], RW/P, default = 0x61A
    //
    UINTX zqcint : 11;
    //
    // ZQCS to Any DRAM Command Delay:
    // [br] Specifies the delay between the DRAM ZQ Calibration Short (ZQCS) command
    // and any DRAM command. 
    // [br] JEDEC defines for DDR3 tZQCS = Max(64nCK, 80ns).
    // [br] For DDR4, this is 128 DRAM Clocks
    // [br] tZQCS = tZQCS register field
    // [br] 64 DDR3 1600
    // [br] 75: DDR3 1867
    // [br] 128: DDR4 1600, DDR4 1867, DDR4 2133, DDR4 2400, DDR4 2667
    // [br] All other values are reserved.
    // 
    // Bits[19:11], RW/P, default = 0x0
    //
    UINTX tzqcs : 9;
    //
    // ZQCL to Any DRAM Command Delay:
    // [br] Specifies the delay between the DRAM ZQ Calibration Long (ZQCL) command and
    // any DRAM command during normal operation. 
    // [br] JEDEC defines tZQoper = Max(256nCK, 320ns).
    // [br] For DDR4: 512 Clocks
    // [br] Set ZQCL = tZQCL field
    // [br] 100H: 256 DRAM Clock DDR3 1600
    // [br] 12BH: 299 DRAM Clocks DDR3 1867
    // [br] 200H: 512 DRAM Clocks DDR4
    // 
    // Bits[30:20], RW/P, default = 0x0
    //
    UINTX tzqcl : 11;
    //
    // Reserved
    // 
    // Bits[31:31], RSV, default = 0x0
    //
    UINTX rsvd_dzqparam_0 : 1;
  } Bits;
  UINTX Data;
} DZQPARAM_DUNIT_COMMON_STRUCT;
#endif // ASM_INC

#define DXS_PARAM_DUNIT_COMMON_REG                         0x00000008
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Delay between SRX to Any DRAM Command not Requiring DLL Lock:
    // [br] Specifies the delay between the DRAM Self Refresh Exit (SRX) command and
    // any DRAM command not requiring DLL lock. For example, ZQCL can be issued after
    // tXS delay. 
    // [br] JEDEC defines tXS = Max(5nCK, tRFCmin + 10ns), which ranges from 264 to 480
    // DRAM Clocks depending on the density of the DRAM device. tRFC varies from 160ns
    // to 350ns for 2Gb to 8 Gb devices. 
    // [br] Set to tRFCmin + 10 ns.
    // 
    // Bits[11:0], RW/P, default = 0x0
    //
    UINTX txs : 12;
    //
    // Delay between SRX to Any DRAM Command Requiring DLL Lock:
    // [br] For tZQCL handling, set tXSDLL to a max (tZQCL + tXS + state machine transition
    // overhead, tXSDLL). 
    // [br] Specifies the delay between the DRAM Self Refresh Exit (SRX) command and
    // any DRAM command requiring DLL lock. 
    // [br] JEDEC defines tXSDLL = tDLLKmin = 512 DRAM Clocks for DDR3.
    // [br] DDR4 tDLLK is a range from 597 to 768 Clocks
    // [br] 512 : DDR3 1600/1867
    // [br] 597 : DDR4 1600/1867
    // [br] 768 : DDR4 2133/2667
    // [br] All other encodings reserved
    // 
    // Bits[23:12], RW/P, default = 0x0
    //
    UINTX txsdll : 12;
    //
    // ZQ Calibration Long during SR Exit Control:
    // [br] 0: ZQCL commands are sent in parallel to all ranks during after every Self
    // Refresh exit. (Normal Mode) 
    // [br] 1: ZQCL commands are sent in serial to each rank during after every Self
    // Refresh exit. (Not Used) 
    // [br] 2: No ZQCL commands are sent after each Self Refresh exit. (For debug only)
    // 
    // Bits[25:24], RW/P, default = 0x0
    //
    UINTX srxzqcl : 2;
    //
    // SRE to Power Management Message Delay:
    // [br] Specifies the delay between the DRAM Self Refresh Entry (SRE) command and
    // the issuing of the Power Management message from the Dunit to the DDRIO PHY. 
    // [br] This should be set to be at least maximum (tCKSRE, tCKESR). tCKESR is the
    // minimum duration that the DIMM has to be in self-refresh. It is typically lower
    // than tCKSRE. 
    // [br] 0h:  0 CK
    // [br] 1h:  2 CK
    // [br] 2h:  4 CK
    // [br] 3h:  6 CK
    // [br] 4h:  8 CK  DDR4 1600, DDR3 1600
    // [br] 5h: 10 CK  DDR4 1867, DDR3 1867
    // [br] 6h: 12 CK  DDR4 2133, DDR4 2400
    // [br] 7h: 14 CK  DDR4 2667
    // [br] 8h-3f: Reserved for future expansion.
    // 
    // Bits[31:26], RW/P, default = 0x3
    //
    UINTX pmedly : 6;
  } Bits;
  UINTX Data;
} DXS_PARAM_DUNIT_COMMON_STRUCT;
#endif // ASM_INC

#define DPMC_DUNIT_COMMON_REG                              0x0000000C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Reserved
    // 
    // Bits[15:0], RSV, default = 0x0
    //
    UINTX rsvd_dpmc_0 : 16;
    //
    // Page Close Timeout Period.
    // [br] Specifies the time from the last access of a DRAM page until that page is
    // scheduled to close (by sending a Precharge command to DRAM). This is implemented
    // with a sliding widow, which results in a range rather than a exact time that a
    // page will be closed. 
    // [br] 0:  Disable page close timer
    // [br] 1:  Immediately after last access, schedule page to close
    // [br] 2:       30-60 ns after last access, schedule page to close
    // [br] 3:     60-120 ns after last access, schedule page to close
    // [br] 4:   120-240 ns after last access, schedule page to close
    // [br] 5:   240-480 ns after last access, schedule page to close
    // [br] 6:   480-960 ns after last access, schedule page to close
    // [br] 7:          1-2 s after last access, schedule page to close
    // 
    // Bits[18:16], RW/P, default = 0x0
    //
    UINTX pclsto : 3;
    //
    // Wake Allowed to Close Page:
    // [br] Setting 1 in this field indicates that the Dunit is allowed to wake the DRAM
    // devices out of Power Down mode for individual page closes due to page timer expiration.
    // Trades performance for power consumption. 
    // [br] Note this bit applies only to cases where at least one other bank in the
    // same rank is open but not yet timed-out to be closed. 
    // [br] If all banks in the rank timed-out, a PDX command will be sent regardless
    // of this bit. 
    // [br] This bit must be set to 0 during DRAM init and DDRIO training.
    // 
    // Bits[19:19], RW/P, default = 0x0
    //
    UINTX pclswkok : 1;
    //
    // Power Down Enable:
    // [br] 0x: The Dunit constantly drives the CKE pins high to keep the DRAM devices
    // from entering Power Down mode. This mode is used only for training. 
    // [br] 10: The Dunit dynamically controls the CKE pins to place the DRAM devices
    // in Power Down mode and bring them out of Power Down mode.  Power down is only
    // entered when the there are no visible requests targetting the specific rank and
    // the PWDDLY value has been satisfied. 
    // [br] 11: The Dunit dynamically controls the CKE pins to place the DRAM devices
    // in Power Down mode and bring them out of Power Down mode.  Power down is only
    // entered when the there are no visible requests targetting the specific rank and
    // the PWDDLY value has been satisfied and the PMI status is 0 (low power mode).
    // 
    // Bits[21:20], RW/P, default = 0x0
    //
    UINTX pwrdnen : 2;
    //
    // Close All Pages before entering Power-Down:
    // [br] When set to 1, the Dunit will issue a Precharge All to close all pages within
    // a rank before powering down that rank. 
    // 
    // Bits[22:22], RW/P, default = 0x0
    //
    UINTX preapwden : 1;
    //
    // Reserved
    // 
    // Bits[23:23], RSV, default = 0x0
    //
    UINTX rsvd_dpmc_1 : 1;
    //
    // Read/Write Command to Power-Down Delay:
    // [br] This is a non-JEDEC timing parameter used to delay power-down entry to improve
    // performance. 
    // [br] Delay = PWDDLY x 4 DRAM Clocks
    // 
    // Bits[27:24], RW/P, default = 0x6
    //
    UINTX pwddly : 4;
    //
    // Command/Address Tristate:
    // [br] 00 - The DRAM Cmd/Addr pins are never tristated.
    // [br] 01 - The DRAM Cmd/Addr pins are tristated only when all enabled CKE pins
    // are low. 
    // [br] 10 - The DRAM Cmd/Addr pins are tristated when not driving a valid command.
    // [br] 11 - The DRAM Cmd/Addr pins are tristated when not driving a valid command
    // but may not be tristated for less than 2 DRAM clocks. This mode is only valid
    // when tCMD=0 (1N mode) or tCMD=1 (2N mode). 
    // 
    // Bits[29:28], RW/P, default = 0x1
    //
    UINTX cmdtrist : 2;
    //
    // Chip Select Tristate:
    // [br] 0 - The DRAM CS# pins associated with the enabled ranks are never tristated.
    // [br] 1 - The DRAM CS# pins associated with the enabled ranks are tristated during
    // self-refresh. 
    // [br] The DRAM CS# pins associated with the disabled ranks are  always tristated.
    // 
    // Bits[30:30], RW/P, default = 0x1
    //
    UINTX cstrist : 1;
    //
    // Dunit Clock Gating Disable:
    // [br] Setting this bit to 0 allows the majority of the Dunit clocks to be gated
    // off when there is no activity in order to save power. When set to 1, Dunit clock-gating
    // is disabled.  0 - Enable.  1 - Disable. (Note: This is a defeature bit and should
    // be set to 0 for normal operation.) Pcode will need to set this bit to 1 in the
    // warm reset flow before issuing a SUSPEND to the Dunit. MRC or Pcode will need
    // to clear this bit again after the reset. 
    // 
    // Bits[31:31], RW/P, default = 0x1
    //
    UINTX clkgtdis : 1;
  } Bits;
  UINTX Data;
} DPMC_DUNIT_COMMON_STRUCT;
#endif // ASM_INC

#define DRFC0_DUNIT_COMMON_REG                             0x00000010
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Refresh Low Watermark:
    // [br] When the Refresh counter (per rank) is greater than this value, the Dunit
    // will send a REF command to the rank only if there's no pending request to the
    // same rank and the PMI Status is 0. 
    // [br] 0100 - Allow pulling-in 2 REF commands.
    // [br] 0101 - Allow pulling-in 1 REF command.
    // [br] 0110 - Issue 1 REF command every tREFI.
    // [br] 0111 - Postpone 2 REF commands.
    // [br] 1000 - Postpone 3 REF commands.
    // [br] 1001 - Postpone 4 REF commands.
    // [br] 1010 - Postpone 5 REF commands.
    // [br] 1011 - Postpone 6 REF commands.
    // [br] 1100 - Postpone 7 REF commands.
    // [br] 1101 - Postpone 8 REF commands.
    // [br] Others - Reserved
    // 
    // Bits[3:0], RW/P, default = 0x7
    //
    UINTX refwmlo : 4;
    //
    // Refresh High Watermark:
    // [br] When the Refresh counter (per rank) is greater than this value, the Dunit
    // will send a REF command to the rank regardless if there's pending request to the
    // same rank, but only if the PMI Status is 0. 
    // [br] 0110 - Issue 1 REF command every tREFI.
    // [br] 0111 - Postpone 2 REF commands.
    // [br] 1000 - Postpone 3 REF commands.
    // [br] 1001 - Postpone 4 REF commands.
    // [br] 1010 - Postpone 5 REF commands.
    // [br] 1011 - Postpone 6 REF commands.
    // [br] 1100 - Postpone 7 REF commands.
    // [br] 1101 - Postpone 8 REF commands.
    // [br] Others - Reserved
    // [br] (Note: REFWMHI must be greater than or equal to REFWMLO.)
    // 
    // Bits[7:4], RW/P, default = 0xA
    //
    UINTX refwmhi : 4;
    //
    // Refresh Panic Watermark:
    // [br] When the Refresh counter (per rank) is greater than this value, the Dunit
    // will send a REF command to the rank regardless of PMI Status and pending requests.
    // [br] 0110 - Issue 1 REF command every tREFI.
    // [br] 0111 - Postpone 2 REF commands.
    // [br] 1000 - Postpone 3 REF commands.
    // [br] 1001 - Postpone 4 REF commands.
    // [br] 1010 - Postpone 5 REF commands.
    // [br] 1011 - Postpone 6 REF commands.
    // [br] 1100 - Postpone 7 REF commands.
    // [br] 1101 - Postpone 8 REF commands.
    // [br] Others - Reserved
    // [br] (Note: REFWMPNC must be greater than or equal to REFWMHI.)
    // 
    // Bits[11:8], RW/P, default = 0xC
    //
    UINTX refwmpnc : 4;
    //
    // Refresh Rate:
    // [br] When ENREFRATE=0, this field is not used.
    // [br] When ENREFRATE=1, then any two refresh commands, regardless of channel, will
    // be separated by at least 2*(REFRATE+1) DRAM clock cycles. 
    // [br] Maximum Rate =     2 DRAM clock cycles (REFRATE=0)
    // [br] Minimum Rate  = 128 DRAM clock cycles (REFRATE=3Fh)
    // 
    // Bits[17:12], RW/P, default = 0x0
    //
    UINTX refrate : 6;
    //
    // Enable Refresh Limit Feature:
    // [br] 0: Disabled: There is no refresh rate limit; Refresh can be issued to different
    // ranks every other DRAM clock cycle, both channels operating independently. 
    // [br] 1: Enabled: Refresh to any rank, regardless of channel, will be separated
    // by at least the number of clocks specified by REFRATE (above). 
    // 
    // Bits[18:18], RW/P, default = 0x0
    //
    UINTX enrfrate : 1;
    //
    // Enable Self-Refresh Rate Limit Feature:
    // [br] 0: Disabled: There is no self-refresh rate limit; SR entry for each rank
    // will occur in back-to-back cycles, simulataneously on both channels. 
    // [br] 1: Enabled: SR (entry) to any rank, regardless of channel, will be separated
    // by at least the number of clocks specified by REFRATE (above). 
    // 
    // Bits[19:19], RW/P, default = 0x0
    //
    UINTX ensrrate : 1;
    //
    // Reserved
    // 
    // Bits[31:20], RSV, default = 0x0
    //
    UINTX rsvd_drfc0_0 : 12;
  } Bits;
  UINTX Data;
} DRFC0_DUNIT_COMMON_STRUCT;
#endif // ASM_INC

#define DRFC1_DUNIT_COMMON_REG                             0x00000014
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Refresh Slot for Channel 0 Rank 0
    // 
    // Bits[2:0], RW/P, default = 0x0
    //
    UINTX refslot00 : 3;
    //
    // Reserved
    // 
    // Bits[3:3], RSV, default = 0x0
    //
    UINTX rsvd_drfc1_0 : 1;
    //
    // Refresh Slot for Channel 0 Rank 1
    // 
    // Bits[6:4], RW/P, default = 0x4
    //
    UINTX refslot01 : 3;
    //
    // Reserved
    // 
    // Bits[7:7], RSV, default = 0x0
    //
    UINTX rsvd_drfc1_1 : 1;
    //
    // Refresh Slot for Channel 0 Rank 2
    // 
    // Bits[10:8], RW/P, default = 0x2
    //
    UINTX refslot02 : 3;
    //
    // Reserved
    // 
    // Bits[11:11], RSV, default = 0x0
    //
    UINTX rsvd_drfc1_2 : 1;
    //
    // Refresh Slot for Channel 0 Rank 3
    // 
    // Bits[14:12], RW/P, default = 0x6
    //
    UINTX refslot03 : 3;
    //
    // Reserved
    // 
    // Bits[15:15], RSV, default = 0x0
    //
    UINTX rsvd_drfc1_3 : 1;
    //
    // Refresh Slot for Channel 1 Rank 0
    // 
    // Bits[18:16], RW/P, default = 0x1
    //
    UINTX refslot10 : 3;
    //
    // Reserved
    // 
    // Bits[19:19], RSV, default = 0x0
    //
    UINTX rsvd_drfc1_4 : 1;
    //
    // Refresh Slot for Channel 1 Rank 1
    // 
    // Bits[22:20], RW/P, default = 0x5
    //
    UINTX refslot11 : 3;
    //
    // Reserved
    // 
    // Bits[23:23], RSV, default = 0x0
    //
    UINTX rsvd_drfc1_5 : 1;
    //
    // Refresh Slot for Channel 1 Rank 2
    // 
    // Bits[26:24], RW/P, default = 0x3
    //
    UINTX refslot12 : 3;
    //
    // Reserved
    // 
    // Bits[27:27], RSV, default = 0x0
    //
    UINTX rsvd_drfc1_6 : 1;
    //
    // Refresh Slot for Channel 1 Rank 3
    // 
    // Bits[30:28], RW/P, default = 0x7
    //
    UINTX refslot13 : 3;
    //
    // Reserved
    // 
    // Bits[31:31], RSV, default = 0x0
    //
    UINTX rsvd_drfc1_7 : 1;
  } Bits;
  UINTX Data;
} DRFC1_DUNIT_COMMON_STRUCT;
#endif // ASM_INC

#define DRFC2_DUNIT_COMMON_REG                             0x00000018
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Refresh Period:
    // [br] Specifies the average time between sending REF commands to the DRAM. The
    // Dunit will ensure that this average time is met, but maintains some degree of
    // flexibility in the scheduling and issuing of the REF command to 
    // [br] increase overall performance.
    // [br] 0: Disable issuing the REF command.
    // [br] Value in DCLKs to specify the refresh rate.
    // [br] For 1x refresh rate
    // [br] DDR3L/DDR4 1600 : C30H
    // [br] DDR3L/DDR4 1867: E38H
    // [br] DDR4 2133: 1040H
    // [br] DDR4 2400: 1248H
    // [br] DDR4 2667: 1450H
    // [br] For 2x refresh rate: Half the above values.
    // [br] For 4x refresh rate: Quarter the above values.
    // 
    // Bits[16:0], RW/P, default = 0x1860
    //
    UINTX trefi : 17;
    //
    // Max Multiple-tREFI Interval:
    // [br] This is the maximum interval between two REF commands. JEDEC allows a maximum
    // of 9 x tREFI period before the memory controller has to issue a REF command to
    // DRAM. This parameter ensures the Dunit will always send at least 1 REF command
    // within 9 x tREFI to meet JEDEC spec requirement. When the 9 x tREFI counter (per
    // rank) is greater than this value, the Dunit will send a REF command to the rank
    // regardless of requestbd_Status and pending requests. Providing the capability
    // to do up to 33xtREFI, to support 4x refresh rate. 
    // [br] Max interval between two refresh commands is (REFCNTMAX+6)*tREFI
    // 
    // Bits[21:17], RW/P, default = 0x1
    //
    UINTX refcntmax : 5;
    //
    // This bit indicates if the dimms are in normal temperature or extended temperature
    // mode. 
    // [br] 0: Normal temperature Mode. Dunit will use tREFI=DRFC2.tREFI
    // [br] 1: Extended temperature Mode. Dunit will use tREFI=DRFC2.tREFI/2
    // 
    // Bits[22:22], RW/P, default = 0x0
    //
    UINTX ref_temp_mode : 1;
    //
    // Reserved
    // 
    // Bits[27:23], RSV, default = 0x0
    //
    UINTX rsvd_drfc2_0 : 5;
    //
    // Timer 30ns Interval Value:
    // [br] Specifies the value to load into the 30ns timer that is used by refresh,
    // ZQCal and the page closer timers. 
    // [br] The legal encodings are:
    // [br] 5: 1600 MT/s
    // [br] 6: 1866 MT/s
    // [br] 7: 2133 MT/s (DDR4 only)
    // [br] 8: 2400 MT/s (DDR4 only)
    // [br] 8: 2667 MT/s (DDR4 only)
    // [br] All other encodings are reserved.
    // 
    // Bits[31:28], RW/P, default = 0x0
    //
    UINTX tmr30ns : 4;
  } Bits;
  UINTX Data;
} DRFC2_DUNIT_COMMON_STRUCT;
#endif // ASM_INC

#define DFUSESTAT_DUNIT_COMMON_REG                         0x0000001C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // ECC Disable  0 - ECC can be enabled/disabled thru Dunit config reg  1 - Disable
    // ECC 
    // 
    // Bits[0:0], RO/V, default = 0x0
    //
    UINTX dis_ecc : 1;
    //
    // Max Supported Memory Size Per Channel in GByte
    // [br] 0:   2GB
    // [br] 1:   4GB
    // [br] 2:   8GB
    // [br] 3: 16GB
    // [br] 4: 32GB
    // [br] 5: 64GB
    // [br] 6: Reserved
    // [br] 7: No Limitation
    // 
    // Bits[3:1], RO/V, default = 0x7
    //
    UINTX max_mem : 3;
    //
    // Max Supported DRAM Device Density
    // [br] 0:   2Gb
    // [br] 1:   4Gb
    // [br] 2:   8Gb
    // [br] 3: 16Gb
    // 
    // Bits[5:4], RO/V, default = 0x3
    //
    UINTX max_den : 2;
    //
    // 2nd DIMM Disabled
    // [br] 0: Both DIMMs can be enabled thru Dunit config reg
    // [br] 1: Only DIMM 0 can be enabled thru Dunit config reg. DIMM 1 is disabled.
    // 
    // Bits[6:6], RO/V, default = 0x0
    //
    UINTX dis_2dpc : 1;
    //
    // 2nd Rank Per DIMM Disabled
    // [br] 0: All ranks can be enabled thru Dunit config reg
    // [br] 1: Only ranks 0 and 2 can be enabled thru Dunit config reg. Ranks 1 and 3
    // are disabled. 
    // 
    // Bits[7:7], RO/V, default = 0x0
    //
    UINTX dis_dr : 1;
    //
    // DDR3 Operation Disabled
    // [br] 0: The Memory Controller can enabled for DDR3 mode.
    // [br] 1: The Memory Controller can only operate in DDR4 mode; DDR3 mode is disabled.
    // 
    // Bits[8:8], RO/V, default = 0x0
    //
    UINTX dis_ddr3 : 1;
    //
    // DDR4 Operation Disabled
    // [br] 0: The Memory Controller can enabled for DDR4 mode.
    // [br] 1: The Memory Controller can only operate in DDR3 mode; DDR4 mode is disabled.
    // 
    // Bits[9:9], RO/V, default = 0x0
    //
    UINTX dis_ddr4 : 1;
    //
    // x8 DRAM Device Width Disabled
    // [br] 0: x8 DRAM device can be enabled thru Dunit config reg
    // [br] 1: x8 DRAM device is not allowed
    // 
    // Bits[10:10], RO/V, default = 0x0
    //
    UINTX dis_x8 : 1;
    //
    // x4 DRAM Device Width Disabled
    // [br] 0: x16 DRAM device can be enabled thru Dunit config reg
    // [br] 1: x16 DRAM device is not allowed
    // 
    // Bits[11:11], RO/V, default = 0x0
    //
    UINTX dis_x4 : 1;
    //
    // 1N Command Timings Disabled
    // [br] 0: 1N, 2N & 3N can be enabled thru Dunit config reg
    // [br] 1: 1N is disabled. Only 2N & 3N can be enabled thru Dunit config reg
    // 
    // Bits[12:12], RO/V, default = 0x0
    //
    UINTX dis_1n : 1;
    //
    // DRAM Data Scrambling Disabled
    // [br] 0: DQ data scrambling can be enabled thru Dunit config reg
    // [br] 1: DQ data scrambling is disabled
    // 
    // Bits[13:13], RO/V, default = 0x0
    //
    UINTX dis_scrmbl : 1;
    //
    // Dual-channel Disabled
    // [br] 0: Both channels may be enabled via DSCH.CH0EN and DSCH.CH1EN
    // [br] 1: Only one channel may be enabled
    // 
    // Bits[14:14], RO/V, default = 0x0
    //
    UINTX single_channel : 1;
    //
    // Register file fusing
    // 
    // Bits[15:15], RO/V, default = 0x0
    //
    UINTX rf_fuse : 1;
    //
    // DDRIO trim fuses
    // 
    // Bits[18:16], RO/V, default = 0x0
    //
    UINTX iproctrim : 3;
    //
    // N/A
    // 
    // Bits[31:19], RO, default = 0x0
    //
    UINTX spares : 13;
  } Bits;
  UINTX Data;
} DFUSESTAT_DUNIT_COMMON_STRUCT;
#endif // ASM_INC

#define DBUSCTL_DUNIT_COMMON_REG                           0x00000020
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Idle Count: The number of idle cycles that must occur before the ISM transitions
    // to the IDLE state 
    // 
    // Bits[7:0], RW/P, default = 0x10
    //
    UINTX idlecnt : 8;
    //
    // IOSF sideband endpoint clock gating enable/disable:
    // [br] 0 - The sideband endpoint clock is not clock gated
    // [br] 1 - The sideband endpoint clock is gated when the ISM is in the IDLE state
    // 
    // Bits[8:8], RW/P, default = 0x1
    //
    UINTX clkgaten : 1;
    //
    // Reserved
    // 
    // Bits[31:9], RSV, default = 0x0
    //
    UINTX rsvd_dbusctl_0 : 23;
  } Bits;
  UINTX Data;
} DBUSCTL_DUNIT_COMMON_STRUCT;
#endif // ASM_INC

#define DCMD_DUNIT_COMMON_REG                              0x00000024
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Command Disable: Disable control for each of the 8 command encodings.  When set,
    // the selected command is not allowed to be issued by a DRAM Command Message. 
    // [br] CMDDIS[0]: MRS Command
    // [br] CMDDIS[1]: Refresh Command
    // [br] CMDDIS[2]: Pre-Charge Command
    // [br] CMDDIS[3]: Activate Command
    // [br] CMDDIS[4]: Write Command
    // [br] CMDDIS[5]: Read Command
    // [br] CMDDIS[6]: ZQ Calibration Command
    // [br] CMDDIS[7]: No Operation Command
    // 
    // Bits[7:0], RW/P, default = 0x0
    //
    UINTX cmddis : 8;
    //
    // Mode Register Disable: Disable control for each of the 8 mode register encodings.
    //  When set, the selected mode register (MRS Command) cannot be accessed. 
    // [br] MRDIS[x]: MRx; Disable access to Mode Register x
    // 
    // Bits[15:8], RW/P, default = 0x0
    //
    UINTX mrdis : 8;
    //
    // Reserved
    // 
    // Bits[31:16], RSV, default = 0x0
    //
    UINTX rsvd_dcmd : 16;
  } Bits;
  UINTX Data;
} DCMD_DUNIT_COMMON_STRUCT;
#endif // ASM_INC

#define BONUS_DUNIT_COMMON_REG                             0x00000030
#ifndef ASM_INC
typedef union {
  struct {
    //
    // ECO (Bonus) Regsiter cleared by warm or cold reset.
    // 
    // Bits[31:0], RW, default = 0x0
    //
    UINTX eco : 32;
  } Bits;
  UINTX Data;
} BONUS_DUNIT_COMMON_STRUCT;
#endif // ASM_INC

#define SBONUS_DUNIT_COMMON_REG                            0x00000034
#ifndef ASM_INC
typedef union {
  struct {
    //
    // ECO (Bonus) Regsiter cleared only by cold reset (sticky).
    // 
    // Bits[31:0], RW/P, default = 0x0
    //
    UINTX eco : 32;
  } Bits;
  UINTX Data;
} SBONUS_DUNIT_COMMON_STRUCT;
#endif // ASM_INC

#define MISC_CFG_DUNIT_COMMON_REG                          0x00000038
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Enable PMI address bit 5 on writes.  0 = zero out PMI bit 5 from Bunit on any
    // non-SBFT writes.  1 = use value of PMI address bit 5 from B unit for writes. 
    // 
    // Bits[0:0], RW/P, default = 0x0
    //
    UINTX en_pmi_wr_bit5 : 1;
    //
    // Disable PMI address bit 5 on reads.  0 = use value of PMI address bit 5 from B
    // unit for reads.  1 = zero out PMI bit 5 from Bunit on reads. 
    // 
    // Bits[1:1], RW/P, default = 0x0
    //
    UINTX dis_pmi_rd_bit5 : 1;
    //
    // When set, forces the synchronous clock request for Dclk to a 1.
    // 
    // Bits[2:2], RW/P, default = 0x0
    //
    UINTX dclk_always_on : 1;
    //
    // When set, forces the synchronous clock request for sideband clock to a 1.
    // 
    // Bits[3:3], RW/P, default = 0x0
    //
    UINTX sideclk_always_on : 1;
    //
    // Miscellanous Config Register.
    // 
    // Bits[31:4], RW/P, default = 0x0
    //
    UINTX misc_cfg : 28;
  } Bits;
  UINTX Data;
} MISC_CFG_DUNIT_COMMON_STRUCT;
#endif // ASM_INC

#define DMISC_STATUS_DUNIT_COMMON_REG                      0x0000003C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // DDRIO PHY Initialization Complete:
    // [br] Status indication that the DDRIO PHY initialization is complete (reflects
    // the status spid_init_complete signal) 
    // 
    // Bits[1:0], RO/V/P, default = 0x0
    //
    UINTX dioic : 2;
    //
    // DMSG Dunit Suspended.  Indicates the status of dmsg_dunit_suspended.
    // 
    // Bits[3:2], RO/V/P, default = 0x0
    //
    UINTX dmsg_suspended : 2;
    //
    // Reserved
    // 
    // Bits[31:4], RSV, default = 0x0
    //
    UINTX rsvd_dmisc_status_0 : 28;
  } Bits;
  UINTX Data;
} DMISC_STATUS_DUNIT_COMMON_STRUCT;
#endif // ASM_INC

#define MPRDATA0_DUNIT_COMMON_REG                          0x00000080
#ifndef ASM_INC
typedef union {
  struct {
    //
    // MPR data received for UI[7:0] DQ0
    // 
    // Bits[7:0], RO/V/P, default = 0x0
    //
    UINTX dq0 : 8;
    //
    // MPR data received for UI[7:0] DQ1
    // 
    // Bits[15:8], RO/V/P, default = 0x0
    //
    UINTX dq1 : 8;
    //
    // MPR data received for UI[7:0] DQ2
    // 
    // Bits[23:16], RO/V/P, default = 0x0
    //
    UINTX dq2 : 8;
    //
    // MPR data received for UI[7:0] DQ3
    // 
    // Bits[31:24], RO/V/P, default = 0x0
    //
    UINTX dq3 : 8;
  } Bits;
  UINTX Data;
} MPRDATA0_DUNIT_COMMON_STRUCT;
#endif // ASM_INC

#define MPRDATA1_DUNIT_COMMON_REG                          0x00000084
#ifndef ASM_INC
typedef union {
  struct {
    //
    // MPR data received for UI[7:0] DQ4
    // 
    // Bits[7:0], RO/V/P, default = 0x0
    //
    UINTX dq4 : 8;
    //
    // MPR data received for UI[7:0] DQ5
    // 
    // Bits[15:8], RO/V/P, default = 0x0
    //
    UINTX dq5 : 8;
    //
    // MPR data received for UI[7:0] DQ6
    // 
    // Bits[23:16], RO/V/P, default = 0x0
    //
    UINTX dq6 : 8;
    //
    // MPR data received for UI[7:0] DQ7
    // 
    // Bits[31:24], RO/V/P, default = 0x0
    //
    UINTX dq7 : 8;
  } Bits;
  UINTX Data;
} MPRDATA1_DUNIT_COMMON_STRUCT;
#endif // ASM_INC

#define MPRDATA2_DUNIT_COMMON_REG                          0x00000088
#ifndef ASM_INC
typedef union {
  struct {
    //
    // MPR data received for UI[7:0] DQ8
    // 
    // Bits[7:0], RO/V/P, default = 0x0
    //
    UINTX dq8 : 8;
    //
    // MPR data received for UI[7:0] DQ9
    // 
    // Bits[15:8], RO/V/P, default = 0x0
    //
    UINTX dq9 : 8;
    //
    // MPR data received for UI[7:0] DQ10
    // 
    // Bits[23:16], RO/V/P, default = 0x0
    //
    UINTX dq10 : 8;
    //
    // MPR data received for UI[7:0] DQ11
    // 
    // Bits[31:24], RO/V/P, default = 0x0
    //
    UINTX dq11 : 8;
  } Bits;
  UINTX Data;
} MPRDATA2_DUNIT_COMMON_STRUCT;
#endif // ASM_INC

#define MPRDATA3_DUNIT_COMMON_REG                          0x0000008C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // MPR data received for UI[7:0] DQ12
    // 
    // Bits[7:0], RO/V/P, default = 0x0
    //
    UINTX dq12 : 8;
    //
    // MPR data received for UI[7:0] DQ13
    // 
    // Bits[15:8], RO/V/P, default = 0x0
    //
    UINTX dq13 : 8;
    //
    // MPR data received for UI[7:0] DQ14
    // 
    // Bits[23:16], RO/V/P, default = 0x0
    //
    UINTX dq14 : 8;
    //
    // MPR data received for UI[7:0] DQ15
    // 
    // Bits[31:24], RO/V/P, default = 0x0
    //
    UINTX dq15 : 8;
  } Bits;
  UINTX Data;
} MPRDATA3_DUNIT_COMMON_STRUCT;
#endif // ASM_INC

#define MPRDATA4_DUNIT_COMMON_REG                          0x00000090
#ifndef ASM_INC
typedef union {
  struct {
    //
    // MPR data received for UI[7:0] DQ16
    // 
    // Bits[7:0], RO/V/P, default = 0x0
    //
    UINTX dq16 : 8;
    //
    // MPR data received for UI[7:0] DQ17
    // 
    // Bits[15:8], RO/V/P, default = 0x0
    //
    UINTX dq17 : 8;
    //
    // MPR data received for UI[7:0] DQ18
    // 
    // Bits[23:16], RO/V/P, default = 0x0
    //
    UINTX dq18 : 8;
    //
    // MPR data received for UI[7:0] DQ19
    // 
    // Bits[31:24], RO/V/P, default = 0x0
    //
    UINTX dq19 : 8;
  } Bits;
  UINTX Data;
} MPRDATA4_DUNIT_COMMON_STRUCT;
#endif // ASM_INC

#define MPRDATA5_DUNIT_COMMON_REG                          0x00000094
#ifndef ASM_INC
typedef union {
  struct {
    //
    // MPR data received for UI[7:0] DQ20
    // 
    // Bits[7:0], RO/V/P, default = 0x0
    //
    UINTX dq20 : 8;
    //
    // MPR data received for UI[7:0] DQ21
    // 
    // Bits[15:8], RO/V/P, default = 0x0
    //
    UINTX dq21 : 8;
    //
    // MPR data received for UI[7:0] DQ22
    // 
    // Bits[23:16], RO/V/P, default = 0x0
    //
    UINTX dq22 : 8;
    //
    // MPR data received for UI[7:0] DQ23
    // 
    // Bits[31:24], RO/V/P, default = 0x0
    //
    UINTX dq23 : 8;
  } Bits;
  UINTX Data;
} MPRDATA5_DUNIT_COMMON_STRUCT;
#endif // ASM_INC

#define MPRDATA6_DUNIT_COMMON_REG                          0x00000098
#ifndef ASM_INC
typedef union {
  struct {
    //
    // MPR data received for UI[7:0] DQ24
    // 
    // Bits[7:0], RO/V/P, default = 0x0
    //
    UINTX dq24 : 8;
    //
    // MPR data received for UI[7:0] DQ25
    // 
    // Bits[15:8], RO/V/P, default = 0x0
    //
    UINTX dq25 : 8;
    //
    // MPR data received for UI[7:0] DQ26
    // 
    // Bits[23:16], RO/V/P, default = 0x0
    //
    UINTX dq26 : 8;
    //
    // MPR data received for UI[7:0] DQ27
    // 
    // Bits[31:24], RO/V/P, default = 0x0
    //
    UINTX dq27 : 8;
  } Bits;
  UINTX Data;
} MPRDATA6_DUNIT_COMMON_STRUCT;
#endif // ASM_INC

#define MPRDATA7_DUNIT_COMMON_REG                          0x0000009C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // MPR data received for UI[7:0] DQ28
    // 
    // Bits[7:0], RO/V/P, default = 0x0
    //
    UINTX dq28 : 8;
    //
    // MPR data received for UI[7:0] DQ29
    // 
    // Bits[15:8], RO/V/P, default = 0x0
    //
    UINTX dq29 : 8;
    //
    // MPR data received for UI[7:0] DQ30
    // 
    // Bits[23:16], RO/V/P, default = 0x0
    //
    UINTX dq30 : 8;
    //
    // MPR data received for UI[7:0] DQ31
    // 
    // Bits[31:24], RO/V/P, default = 0x0
    //
    UINTX dq31 : 8;
  } Bits;
  UINTX Data;
} MPRDATA7_DUNIT_COMMON_STRUCT;
#endif // ASM_INC

#define MPRDATA8_DUNIT_COMMON_REG                          0x000000A0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // MPR data received for UI[7:0] DQ32
    // 
    // Bits[7:0], RO/V/P, default = 0x0
    //
    UINTX dq32 : 8;
    //
    // MPR data received for UI[7:0] DQ33
    // 
    // Bits[15:8], RO/V/P, default = 0x0
    //
    UINTX dq33 : 8;
    //
    // MPR data received for UI[7:0] DQ34
    // 
    // Bits[23:16], RO/V/P, default = 0x0
    //
    UINTX dq34 : 8;
    //
    // MPR data received for UI[7:0] DQ35
    // 
    // Bits[31:24], RO/V/P, default = 0x0
    //
    UINTX dq35 : 8;
  } Bits;
  UINTX Data;
} MPRDATA8_DUNIT_COMMON_STRUCT;
#endif // ASM_INC

#define MPRDATA9_DUNIT_COMMON_REG                          0x000000A4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // MPR data received for UI[7:0] DQ36
    // 
    // Bits[7:0], RO/V/P, default = 0x0
    //
    UINTX dq36 : 8;
    //
    // MPR data received for UI[7:0] DQ37
    // 
    // Bits[15:8], RO/V/P, default = 0x0
    //
    UINTX dq37 : 8;
    //
    // MPR data received for UI[7:0] DQ38
    // 
    // Bits[23:16], RO/V/P, default = 0x0
    //
    UINTX dq38 : 8;
    //
    // MPR data received for UI[7:0] DQ39
    // 
    // Bits[31:24], RO/V/P, default = 0x0
    //
    UINTX dq39 : 8;
  } Bits;
  UINTX Data;
} MPRDATA9_DUNIT_COMMON_STRUCT;
#endif // ASM_INC

#define MPRDATA10_DUNIT_COMMON_REG                         0x000000A8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // MPR data received for UI[7:0] DQ40
    // 
    // Bits[7:0], RO/V/P, default = 0x0
    //
    UINTX dq40 : 8;
    //
    // MPR data received for UI[7:0] DQ41
    // 
    // Bits[15:8], RO/V/P, default = 0x0
    //
    UINTX dq41 : 8;
    //
    // MPR data received for UI[7:0] DQ42
    // 
    // Bits[23:16], RO/V/P, default = 0x0
    //
    UINTX dq42 : 8;
    //
    // MPR data received for UI[7:0] DQ43
    // 
    // Bits[31:24], RO/V/P, default = 0x0
    //
    UINTX dq43 : 8;
  } Bits;
  UINTX Data;
} MPRDATA10_DUNIT_COMMON_STRUCT;
#endif // ASM_INC

#define MPRDATA11_DUNIT_COMMON_REG                         0x000000AC
#ifndef ASM_INC
typedef union {
  struct {
    //
    // MPR data received for UI[7:0] DQ44
    // 
    // Bits[7:0], RO/V/P, default = 0x0
    //
    UINTX dq44 : 8;
    //
    // MPR data received for UI[7:0] DQ45
    // 
    // Bits[15:8], RO/V/P, default = 0x0
    //
    UINTX dq45 : 8;
    //
    // MPR data received for UI[7:0] DQ46
    // 
    // Bits[23:16], RO/V/P, default = 0x0
    //
    UINTX dq46 : 8;
    //
    // MPR data received for UI[7:0] DQ47
    // 
    // Bits[31:24], RO/V/P, default = 0x0
    //
    UINTX dq47 : 8;
  } Bits;
  UINTX Data;
} MPRDATA11_DUNIT_COMMON_STRUCT;
#endif // ASM_INC

#define MPRDATA12_DUNIT_COMMON_REG                         0x000000B0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // MPR data received for UI[7:0] DQ48
    // 
    // Bits[7:0], RO/V/P, default = 0x0
    //
    UINTX dq48 : 8;
    //
    // MPR data received for UI[7:0] DQ49
    // 
    // Bits[15:8], RO/V/P, default = 0x0
    //
    UINTX dq49 : 8;
    //
    // MPR data received for UI[7:0] DQ50
    // 
    // Bits[23:16], RO/V/P, default = 0x0
    //
    UINTX dq50 : 8;
    //
    // MPR data received for UI[7:0] DQ51
    // 
    // Bits[31:24], RO/V/P, default = 0x0
    //
    UINTX dq51 : 8;
  } Bits;
  UINTX Data;
} MPRDATA12_DUNIT_COMMON_STRUCT;
#endif // ASM_INC

#define MPRDATA13_DUNIT_COMMON_REG                         0x000000B4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // MPR data received for UI[7:0] DQ52
    // 
    // Bits[7:0], RO/V/P, default = 0x0
    //
    UINTX dq52 : 8;
    //
    // MPR data received for UI[7:0] DQ53
    // 
    // Bits[15:8], RO/V/P, default = 0x0
    //
    UINTX dq53 : 8;
    //
    // MPR data received for UI[7:0] DQ54
    // 
    // Bits[23:16], RO/V/P, default = 0x0
    //
    UINTX dq54 : 8;
    //
    // MPR data received for UI[7:0] DQ55
    // 
    // Bits[31:24], RO/V/P, default = 0x0
    //
    UINTX dq55 : 8;
  } Bits;
  UINTX Data;
} MPRDATA13_DUNIT_COMMON_STRUCT;
#endif // ASM_INC

#define MPRDATA14_DUNIT_COMMON_REG                         0x000000B8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // MPR data received for UI[7:0] DQ56
    // 
    // Bits[7:0], RO/V/P, default = 0x0
    //
    UINTX dq56 : 8;
    //
    // MPR data received for UI[7:0] DQ57
    // 
    // Bits[15:8], RO/V/P, default = 0x0
    //
    UINTX dq57 : 8;
    //
    // MPR data received for UI[7:0] DQ58
    // 
    // Bits[23:16], RO/V/P, default = 0x0
    //
    UINTX dq58 : 8;
    //
    // MPR data received for UI[7:0] DQ59
    // 
    // Bits[31:24], RO/V/P, default = 0x0
    //
    UINTX dq59 : 8;
  } Bits;
  UINTX Data;
} MPRDATA14_DUNIT_COMMON_STRUCT;
#endif // ASM_INC

#define MPRDATA15_DUNIT_COMMON_REG                         0x000000BC
#ifndef ASM_INC
typedef union {
  struct {
    //
    // MPR data received for UI[7:0] DQ60
    // 
    // Bits[7:0], RO/V/P, default = 0x0
    //
    UINTX dq60 : 8;
    //
    // MPR data received for UI[7:0] DQ61
    // 
    // Bits[15:8], RO/V/P, default = 0x0
    //
    UINTX dq61 : 8;
    //
    // MPR data received for UI[7:0] DQ62
    // 
    // Bits[23:16], RO/V/P, default = 0x0
    //
    UINTX dq62 : 8;
    //
    // MPR data received for UI[7:0] DQ63
    // 
    // Bits[31:24], RO/V/P, default = 0x0
    //
    UINTX dq63 : 8;
  } Bits;
  UINTX Data;
} MPRDATA15_DUNIT_COMMON_STRUCT;
#endif // ASM_INC

#define MPRDATA16_DUNIT_COMMON_REG                         0x000000C0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // MPR data received for UI[7:0] DQ64
    // 
    // Bits[7:0], RO/V/P, default = 0x0
    //
    UINTX dq64 : 8;
    //
    // MPR data received for UI[7:0] DQ65
    // 
    // Bits[15:8], RO/V/P, default = 0x0
    //
    UINTX dq65 : 8;
    //
    // MPR data received for UI[7:0] DQ66
    // 
    // Bits[23:16], RO/V/P, default = 0x0
    //
    UINTX dq66 : 8;
    //
    // MPR data received for UI[7:0] DQ67
    // 
    // Bits[31:24], RO/V/P, default = 0x0
    //
    UINTX dq67 : 8;
  } Bits;
  UINTX Data;
} MPRDATA16_DUNIT_COMMON_STRUCT;
#endif // ASM_INC

#define MPRDATA17_DUNIT_COMMON_REG                         0x000000C4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // MPR data received for UI[7:0] DQ68
    // 
    // Bits[7:0], RO/V/P, default = 0x0
    //
    UINTX dq68 : 8;
    //
    // MPR data received for UI[7:0] DQ69
    // 
    // Bits[15:8], RO/V/P, default = 0x0
    //
    UINTX dq69 : 8;
    //
    // MPR data received for UI[7:0] DQ70
    // 
    // Bits[23:16], RO/V/P, default = 0x0
    //
    UINTX dq70 : 8;
    //
    // MPR data received for UI[7:0] DQ71
    // 
    // Bits[31:24], RO/V/P, default = 0x0
    //
    UINTX dq71 : 8;
  } Bits;
  UINTX Data;
} MPRDATA17_DUNIT_COMMON_STRUCT;
#endif // ASM_INC

#define SKPD0_DUNIT_COMMON_REG                             0x00000100
#ifndef ASM_INC
typedef union {
  struct {
    //
    // General Purpose Scratchpad. May be used for BIOS for data storage. Value is not
    // preserved in warm-reset. 
    // 
    // Bits[31:0], RW, default = 0x0
    //
    UINTX val : 32;
  } Bits;
  UINTX Data;
} SKPD0_DUNIT_COMMON_STRUCT;
#endif // ASM_INC

#define SKPD1_DUNIT_COMMON_REG                             0x00000104
#ifndef ASM_INC
typedef union {
  struct {
    //
    // General Purpose Scratchpad. May be used for BIOS for data storage. Value is not
    // preserved in warm-reset. 
    // 
    // Bits[31:0], RW, default = 0x0
    //
    UINTX val : 32;
  } Bits;
  UINTX Data;
} SKPD1_DUNIT_COMMON_STRUCT;
#endif // ASM_INC

#define SKPD2_DUNIT_COMMON_REG                             0x00000108
#ifndef ASM_INC
typedef union {
  struct {
    //
    // General Purpose Scratchpad. May be used for BIOS for data storage. Value is not
    // preserved in warm-reset. 
    // 
    // Bits[31:0], RW, default = 0x0
    //
    UINTX val : 32;
  } Bits;
  UINTX Data;
} SKPD2_DUNIT_COMMON_STRUCT;
#endif // ASM_INC

#define SKPD3_DUNIT_COMMON_REG                             0x0000010C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // General Purpose Scratchpad. May be used for BIOS for data storage. Value is not
    // preserved in warm-reset. 
    // 
    // Bits[31:0], RW, default = 0x0
    //
    UINTX val : 32;
  } Bits;
  UINTX Data;
} SKPD3_DUNIT_COMMON_STRUCT;
#endif // ASM_INC

#define SKPD4_DUNIT_COMMON_REG                             0x00000110
#ifndef ASM_INC
typedef union {
  struct {
    //
    // General Purpose Scratchpad. May be used for BIOS for data storage. Value is not
    // preserved in warm-reset. 
    // 
    // Bits[31:0], RW, default = 0x0
    //
    UINTX val : 32;
  } Bits;
  UINTX Data;
} SKPD4_DUNIT_COMMON_STRUCT;
#endif // ASM_INC

#define SKPD5_DUNIT_COMMON_REG                             0x00000114
#ifndef ASM_INC
typedef union {
  struct {
    //
    // General Purpose Scratchpad. May be used for BIOS for data storage. Value is not
    // preserved in warm-reset. 
    // 
    // Bits[31:0], RW, default = 0x0
    //
    UINTX val : 32;
  } Bits;
  UINTX Data;
} SKPD5_DUNIT_COMMON_STRUCT;
#endif // ASM_INC

#define SKPD6_DUNIT_COMMON_REG                             0x00000118
#ifndef ASM_INC
typedef union {
  struct {
    //
    // General Purpose Scratchpad. May be used for BIOS for data storage. Value is not
    // preserved in warm-reset. 
    // 
    // Bits[31:0], RW, default = 0x0
    //
    UINTX val : 32;
  } Bits;
  UINTX Data;
} SKPD6_DUNIT_COMMON_STRUCT;
#endif // ASM_INC

#define SKPD7_DUNIT_COMMON_REG                             0x0000011C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // General Purpose Scratchpad. May be used for BIOS for data storage. Value is not
    // preserved in warm-reset. 
    // 
    // Bits[31:0], RW, default = 0x0
    //
    UINTX val : 32;
  } Bits;
  UINTX Data;
} SKPD7_DUNIT_COMMON_STRUCT;
#endif // ASM_INC

#define SSKPD0_DUNIT_COMMON_REG                            0x00000120
#ifndef ASM_INC
typedef union {
  struct {
    //
    // General Purpose Scratchpad. May be used for BIOS for data storage. Value is preserved
    // in warm-reset. 
    // 
    // Bits[31:0], RW/P, default = 0x0
    //
    UINTX val : 32;
  } Bits;
  UINTX Data;
} SSKPD0_DUNIT_COMMON_STRUCT;
#endif // ASM_INC

#define SSKPD1_DUNIT_COMMON_REG                            0x00000124
#ifndef ASM_INC
typedef union {
  struct {
    //
    // General Purpose Scratchpad. May be used for BIOS for data storage. Value is preserved
    // in warm-reset. 
    // 
    // Bits[31:0], RW/P, default = 0x0
    //
    UINTX val : 32;
  } Bits;
  UINTX Data;
} SSKPD1_DUNIT_COMMON_STRUCT;
#endif // ASM_INC

#define SSKPD2_DUNIT_COMMON_REG                            0x00000128
#ifndef ASM_INC
typedef union {
  struct {
    //
    // General Purpose Scratchpad. May be used for BIOS for data storage. Value is preserved
    // in warm-reset. 
    // 
    // Bits[31:0], RW/P, default = 0x0
    //
    UINTX val : 32;
  } Bits;
  UINTX Data;
} SSKPD2_DUNIT_COMMON_STRUCT;
#endif // ASM_INC

#define SSKPD3_DUNIT_COMMON_REG                            0x0000012C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // General Purpose Scratchpad. May be used for BIOS for data storage. Value is preserved
    // in warm-reset. 
    // 
    // Bits[31:0], RW/P, default = 0x0
    //
    UINTX val : 32;
  } Bits;
  UINTX Data;
} SSKPD3_DUNIT_COMMON_STRUCT;
#endif // ASM_INC

#define SSKPD4_DUNIT_COMMON_REG                            0x00000130
#ifndef ASM_INC
typedef union {
  struct {
    //
    // General Purpose Scratchpad. May be used for BIOS for data storage. Value is preserved
    // in warm-reset. 
    // 
    // Bits[31:0], RW/P, default = 0x0
    //
    UINTX val : 32;
  } Bits;
  UINTX Data;
} SSKPD4_DUNIT_COMMON_STRUCT;
#endif // ASM_INC

#define SSKPD5_DUNIT_COMMON_REG                            0x00000134
#ifndef ASM_INC
typedef union {
  struct {
    //
    // General Purpose Scratchpad. May be used for BIOS for data storage. Value is preserved
    // in warm-reset. 
    // 
    // Bits[31:0], RW/P, default = 0x0
    //
    UINTX val : 32;
  } Bits;
  UINTX Data;
} SSKPD5_DUNIT_COMMON_STRUCT;
#endif // ASM_INC

#define SSKPD6_DUNIT_COMMON_REG                            0x00000138
#ifndef ASM_INC
typedef union {
  struct {
    //
    // General Purpose Scratchpad. May be used for BIOS for data storage. Value is preserved
    // in warm-reset. 
    // 
    // Bits[31:0], RW/P, default = 0x0
    //
    UINTX val : 32;
  } Bits;
  UINTX Data;
} SSKPD6_DUNIT_COMMON_STRUCT;
#endif // ASM_INC

#define SSKPD7_DUNIT_COMMON_REG                            0x0000013C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // General Purpose Scratchpad. May be used for BIOS for data storage. Value is preserved
    // in warm-reset. 
    // 
    // Bits[31:0], RW/P, default = 0x0
    //
    UINTX val : 32;
  } Bits;
  UINTX Data;
} SSKPD7_DUNIT_COMMON_STRUCT;
#endif // ASM_INC

#define SAI_GENERAL_CR_POLICY_DUNIT_COMMON_REG             0x00000140
#ifndef ASM_INC
typedef union {
  struct {
    //
    // N/A
    // 
    // Bits[63:0], RW/P, default = 0xC0001000200
    //
    UINTX val : 64;
  } Bits;
  UINTX Data;
} SAI_GENERAL_CR_POLICY_DUNIT_COMMON_STRUCT;
#endif // ASM_INC

#define SAI_GENERAL_RD_POLICY_DUNIT_COMMON_REG             0x00000148
#ifndef ASM_INC
typedef union {
  struct {
    //
    // N/A
    // 
    // Bits[63:0], RW/P, default = 0xFFFFFFFFFFFFFFFF
    //
    UINTX val : 64;
  } Bits;
  UINTX Data;
} SAI_GENERAL_RD_POLICY_DUNIT_COMMON_STRUCT;
#endif // ASM_INC

#define SAI_GENERAL_WR_POLICY_DUNIT_COMMON_REG             0x00000150
#ifndef ASM_INC
typedef union {
  struct {
    //
    // N/A
    // 
    // Bits[63:0], RW/P, default = 0xC0001000212
    //
    UINTX val : 64;
  } Bits;
  UINTX Data;
} SAI_GENERAL_WR_POLICY_DUNIT_COMMON_STRUCT;
#endif // ASM_INC

#define SAI_FUSE_CR_POLICY_DUNIT_COMMON_REG                0x00000158
#ifndef ASM_INC
typedef union {
  struct {
    //
    // N/A
    // 
    // Bits[63:0], RW/P, default = 0xC0001000200
    //
    UINTX val : 64;
  } Bits;
  UINTX Data;
} SAI_FUSE_CR_POLICY_DUNIT_COMMON_STRUCT;
#endif // ASM_INC

#define SAI_FUSE_RD_POLICY_DUNIT_COMMON_REG                0x00000160
#ifndef ASM_INC
typedef union {
  struct {
    //
    // N/A
    // 
    // Bits[63:0], RW/P, default = 0xFFFFFFFFFFFFFFFF
    //
    UINTX val : 64;
  } Bits;
  UINTX Data;
} SAI_FUSE_RD_POLICY_DUNIT_COMMON_STRUCT;
#endif // ASM_INC

#define SAI_FUSE_WR_POLICY_DUNIT_COMMON_REG                0x00000168
#ifndef ASM_INC
typedef union {
  struct {
    //
    // N/A
    // 
    // Bits[63:0], RW/P, default = 0xC0001000200
    //
    UINTX val : 64;
  } Bits;
  UINTX Data;
} SAI_FUSE_WR_POLICY_DUNIT_COMMON_STRUCT;
#endif // ASM_INC

#define SAI_SECURITY_CR_POLICY_DUNIT_COMMON_REG            0x00000170
#ifndef ASM_INC
typedef union {
  struct {
    //
    // N/A
    // 
    // Bits[63:0], RW/P, default = 0xC0001000200
    //
    UINTX val : 64;
  } Bits;
  UINTX Data;
} SAI_SECURITY_CR_POLICY_DUNIT_COMMON_STRUCT;
#endif // ASM_INC

#define SAI_SECURITY_RD_POLICY_DUNIT_COMMON_REG            0x00000178
#ifndef ASM_INC
typedef union {
  struct {
    //
    // N/A
    // 
    // Bits[63:0], RW/P, default = 0xFFFFFFFFFFFFFFFF
    //
    UINTX val : 64;
  } Bits;
  UINTX Data;
} SAI_SECURITY_RD_POLICY_DUNIT_COMMON_STRUCT;
#endif // ASM_INC

#define SAI_SECURITY_WR_POLICY_DUNIT_COMMON_REG            0x00000180
#ifndef ASM_INC
typedef union {
  struct {
    //
    // N/A
    // 
    // Bits[63:0], RW/P, default = 0xC0001000216
    //
    UINTX val : 64;
  } Bits;
  UINTX Data;
} SAI_SECURITY_WR_POLICY_DUNIT_COMMON_STRUCT;
#endif // ASM_INC

#define SAI_SCRAMBLER_CR_POLICY_DUNIT_COMMON_REG           0x00000188
#ifndef ASM_INC
typedef union {
  struct {
    //
    // N/A
    // 
    // Bits[63:0], RW/P, default = 0xC0001000200
    //
    UINTX val : 64;
  } Bits;
  UINTX Data;
} SAI_SCRAMBLER_CR_POLICY_DUNIT_COMMON_STRUCT;
#endif // ASM_INC

#define SAI_SCRAMBLER_RD_POLICY_DUNIT_COMMON_REG           0x00000190
#ifndef ASM_INC
typedef union {
  struct {
    //
    // N/A
    // 
    // Bits[63:0], RW/P, default = 0x0
    //
    UINTX val : 64;
  } Bits;
  UINTX Data;
} SAI_SCRAMBLER_RD_POLICY_DUNIT_COMMON_STRUCT;
#endif // ASM_INC

#define SAI_SCRAMBLER_WR_POLICY_DUNIT_COMMON_REG           0x00000198
#ifndef ASM_INC
typedef union {
  struct {
    //
    // N/A
    // 
    // Bits[63:0], RW/P, default = 0xC0001000212
    //
    UINTX val : 64;
  } Bits;
  UINTX Data;
} SAI_SCRAMBLER_WR_POLICY_DUNIT_COMMON_STRUCT;
#endif // ASM_INC

#define SAI_MCA_SECURITY_CR_POLICY_DUNIT_COMMON_REG        0x000001A0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // N/A
    // 
    // Bits[63:0], RW/P, default = 0xC0001000200
    //
    UINTX val : 64;
  } Bits;
  UINTX Data;
} SAI_MCA_SECURITY_CR_POLICY_DUNIT_COMMON_STRUCT;
#endif // ASM_INC

#define SAI_MCA_SECURITY_RD_POLICY_DUNIT_COMMON_REG        0x000001A8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // N/A
    // 
    // Bits[63:0], RW/P, default = 0xFFFFFFFFFFFFFFFF
    //
    UINTX val : 64;
  } Bits;
  UINTX Data;
} SAI_MCA_SECURITY_RD_POLICY_DUNIT_COMMON_STRUCT;
#endif // ASM_INC

#define SAI_MCA_SECURITY_WR_POLICY_DUNIT_COMMON_REG        0x000001B0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // N/A
    // 
    // Bits[63:0], RW/P, default = 0xC0001000216
    //
    UINTX val : 64;
  } Bits;
  UINTX Data;
} SAI_MCA_SECURITY_WR_POLICY_DUNIT_COMMON_STRUCT;
#endif // ASM_INC

#define SAI_DCPGC_CR_POLICY_DUNIT_COMMON_REG               0x000001D0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // N/A
    // 
    // Bits[63:0], RW/P, default = 0xC0001000200
    //
    UINTX val : 64;
  } Bits;
  UINTX Data;
} SAI_DCPGC_CR_POLICY_DUNIT_COMMON_STRUCT;
#endif // ASM_INC

#define SAI_DCPGC_RD_POLICY_DUNIT_COMMON_REG               0x000001D8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // N/A
    // 
    // Bits[63:0], RW/P, default = 0xFFFFFFFFFFFFFFFF
    //
    UINTX val : 64;
  } Bits;
  UINTX Data;
} SAI_DCPGC_RD_POLICY_DUNIT_COMMON_STRUCT;
#endif // ASM_INC

#define SAI_DCPGC_WR_POLICY_DUNIT_COMMON_REG               0x000001E0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // N/A
    // 
    // Bits[63:0], RW/P, default = 0xC0001000212
    //
    UINTX val : 64;
  } Bits;
  UINTX Data;
} SAI_DCPGC_WR_POLICY_DUNIT_COMMON_STRUCT;
#endif // ASM_INC


#endif // _DUNIT_COMMON_H_
