/** @file
  File name:    DDRCC0.h
  Input File:   DNV_MRC.xlsx

  THIS FILE IS AUTO-GENERATED BY THE MSP TOOL. DO NOT CHANGE THIS CODE.

  If edits are needed in this file, they must be done via the MSP tool.

  If there is additional project-specific data required by the MSP, it
  can be placed in DDRCC0.h, which is used for non-tool-generated
  data

  Includes register defines specific to a project.

  Copyright (c) 2005-2018 Intel Corporation. All rights reserved
  This software and associated documentation (if any) is furnished
  under a license and may only be used or copied in accordance
  with the terms of the license. Except as permitted by such
  license, no part of this software or documentation may be
  reproduced, stored in a retrieval system, or transmitted in any
  form or by any means without the express written consent of
  Intel Corporation.
**/
#ifndef _DDRCC0_H_
#define _DDRCC0_H_

#include "DataTypes.h"

#if USE_64_BIT_VARIABLES
#define UINTX UINT64
#else
#define UINTX UINT32
#endif

#define TXDLLCFG0_DDRCC0_REG                               0x00000000
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Enable 2xclk output to rxdqssdl block for HVM testing
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINTX txdll_2xclkdfxen : 1;
    //
    // Charge pump trim bits. Currently the same as the drvsel[br][br]1600MHz = 010[br]1866MHz
    // = 011[br]2133MHz = 100[br]2400MHz = 101[br]2667MHz = 111 
    // 
    // Bits[3:1], RW, default = 0x1
    //
    UINTX txdll_cptrim : 3;
    //
    // Delay Cell bias strength[br][br]1600MHz = 010[br]1866MHz = 011[br]2133MHz = 100[br]2400MHz
    // = 101[br]2667MHz = 111 
    // 
    // Bits[6:4], RW, default = 0x2
    //
    UINTX txdll_drvsel : 3;
    //
    // Bypasses Master DLL so ref2xclk goes directly to pi outputs
    // 
    // Bits[7:7], RW, default = 0x0
    //
    UINTX txdll_mdllbypassen : 1;
    //
    // MDLL enable, from low to high
    // 
    // Bits[8:8], RW, default = 0x0
    //
    UINTX txdll_mdllen : 1;
    //
    // Set tuning for Phase Interpolator:[br][br]1600MHz = 100[br]1866MHz = 100[br]2133MHz
    // = 101[br]2400MHz = 101[br]2667MHz = 101 
    // 
    // Bits[11:9], RW, default = 0x1
    //
    UINTX txdll_pidrvsel : 3;
    //
    // enable process trim option. currently a placeholder
    // 
    // Bits[12:12], RW, default = 0x0
    //
    UINTX txdll_proctrimen : 1;
    //
    // process trim code
    // 
    // Bits[15:13], RW, default = 0x0
    //
    UINTX txdll_proctrim : 3;
    //
    // hiz pbias to allow overdrive in dfx mode
    // 
    // Bits[16:16], RW, default = 0x0
    //
    UINTX txdll_pbiashizdfxen : 1;
    //
    // hiz nbias to allow overdrive in dfx mode
    // 
    // Bits[17:17], RW, default = 0x0
    //
    UINTX txdll_nbiashizdfxen : 1;
    //
    // Reserved
    // 
    // Bits[31:18], RO, default = 0x0
    //
    UINTX reserved : 14;
  } Bits;
  UINTX Data;
} TXDLLCFG0_DDRCC0_STRUCT;
#endif // ASM_INC

#define TXDLLCFG1_DDRCC0_REG                               0x00000004
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Tx ref Bypass ph0 enable. 0: Use PI Clk Output, 1: Bypass and use input 2x clk
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINTX txdll_ref2xph0pibypassen : 1;
    //
    // PI Code for ref PI phase 0 output
    // 
    // Bits[6:1], RW, default = 0x0
    //
    UINTX txdll_ref2xph0picode : 6;
    //
    // Enable TX ref PI phase 0 enable
    // 
    // Bits[7:7], RW, default = 0x0
    //
    UINTX txdll_ref2xph0pien : 1;
    //
    // Enable TX ref PI phase 0 output enable
    // 
    // Bits[8:8], RW, default = 0x0
    //
    UINTX txdll_ref2xph0piouten : 1;
    //
    // Tx ref Bypass ph90 enable. 0: Use PI Clk Output, 1: Bypass and use input 2x clk
    // 
    // Bits[9:9], RW, default = 0x0
    //
    UINTX txdll_ref2xph90pibypassen : 1;
    //
    // PI Code for ref PI phase 90 output
    // 
    // Bits[15:10], RW, default = 0x0
    //
    UINTX txdll_ref2xph90picode : 6;
    //
    // Enable TX ref PI phase 90 enable
    // 
    // Bits[16:16], RW, default = 0x0
    //
    UINTX txdll_ref2xph90pien : 1;
    //
    // Enable TX ref PI phase 90 output enable
    // 
    // Bits[17:17], RW, default = 0x0
    //
    UINTX txdll_ref2xph90piouten : 1;
    //
    // Reserved
    // 
    // Bits[31:18], RO, default = 0x0
    //
    UINTX reserved : 14;
  } Bits;
  UINTX Data;
} TXDLLCFG1_DDRCC0_STRUCT;
#endif // ASM_INC

#define TXDLLCFG2_DDRCC0_REG                               0x00000008
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Tx ref Bypass ph180 enable. 0: Use PI Clk Output, 1: Bypass and use input 2x clk
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINTX txdll_ref2xph180pibypassen : 1;
    //
    // PI Code for ref PI phase 180 output
    // 
    // Bits[6:1], RW, default = 0x0
    //
    UINTX txdll_ref2xph180picode : 6;
    //
    // Enable TX ref PI phase 180 enable
    // 
    // Bits[7:7], RW, default = 0x0
    //
    UINTX txdll_ref2xph180pien : 1;
    //
    // Enable TX ref PI phase 180 output enable
    // 
    // Bits[8:8], RW, default = 0x0
    //
    UINTX txdll_ref2xph180piouten : 1;
    //
    // Tx ref Bypass ph270 enable. 0: Use PI Clk Output, 1: Bypass and use input 2x clk
    // 
    // Bits[9:9], RW, default = 0x0
    //
    UINTX txdll_ref2xph270pibypassen : 1;
    //
    // PI Code for ref PI phase 270 output
    // 
    // Bits[15:10], RW, default = 0x0
    //
    UINTX txdll_ref2xph270picode : 6;
    //
    // Enable TX ref PI phase 270 enable
    // 
    // Bits[16:16], RW, default = 0x0
    //
    UINTX txdll_ref2xph270pien : 1;
    //
    // Enable TX ref PI phase 270 output enable
    // 
    // Bits[17:17], RW, default = 0x1
    //
    UINTX txdll_ref2xph270piouten : 1;
    //
    // Reserved
    // 
    // Bits[31:18], RO, default = 0x0
    //
    UINTX reserved : 14;
  } Bits;
  UINTX Data;
} TXDLLCFG2_DDRCC0_STRUCT;
#endif // ASM_INC

#define TXDLLCFG5_DDRCC0_REG                               0x0000000C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Byte0 Group[5:0] Bypass enable. 0: Use PI Clk Output, 1: Bypass and use ref clk
    // 
    // Bits[11:0], RW, default = 0x0
    //
    UINTX txdll_siggrppibypassen : 12;
    //
    // DLL Startup signal is high for these many cycles after mdllen goes high:   00
    // (64 cycles)    01 (16 cycles)   10 (32 cycles)   11 (128 cycles) 
    // 
    // Bits[13:12], RW, default = 0x0
    //
    UINTX txdll_starttimesel : 2;
    //
    // Weak Lock enable
    // 
    // Bits[14:14], RW, default = 0x0
    //
    UINTX txdll_weaklocken : 1;
    //
    // 1 = prevents biasgen going into halfmode even in weaklock. 0= biasgen goes into
    // halfmode during weaklock 
    // 
    // Bits[15:15], RW, default = 0x0
    //
    UINTX txdll_weaklockhalfmodegate : 1;
    //
    // Allows nbiasgen to be set in halfmode outside of weaklock
    // 
    // Bits[16:16], RW, default = 0x0
    //
    UINTX txdll_weaklockhalfmodeoverride : 1;
    //
    // invert clk going into refmask related flops
    // 
    // Bits[17:17], RW, default = 0x0
    //
    UINTX txdll_weaklockrefmaskclkinvert : 1;
    //
    // Reserved
    // 
    // Bits[31:18], RO, default = 0x0
    //
    UINTX reserved : 14;
  } Bits;
  UINTX Data;
} TXDLLCFG5_DDRCC0_STRUCT;
#endif // ASM_INC

#define TXDLLCFG6_DDRCC0_REG                               0x00000010
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Enable TX Signal group[11:0] Phase Interpolator
    // 
    // Bits[11:0], RW, default = 0x0
    //
    UINTX txdll_siggrppien : 12;
    //
    // Enable TX Signal group[11:0] output
    // 
    // Bits[23:12], RW, default = 0x0
    //
    UINTX txdll_siggrppiouten : 12;
    //
    // Select how many clk cycles before stopping weaklock and enabling phase detector
    // 
    // Bits[26:24], RW, default = 0x0
    //
    UINTX txdll_weaklockrefmaskdly : 3;
    //
    // invert clk going into vcdl clock gating related flops
    // 
    // Bits[27:27], RW, default = 0x0
    //
    UINTX txdll_weaklockvcdlgateclkinvert : 1;
    //
    // Reserved
    // 
    // Bits[31:28], RO, default = 0x0
    //
    UINTX reserved : 4;
  } Bits;
  UINTX Data;
} TXDLLCFG6_DDRCC0_STRUCT;
#endif // ASM_INC

#define TXDLLCFG7_DDRCC0_REG                               0x00000014
#ifndef ASM_INC
typedef union {
  struct {
    //
    // analog select mux for output 0
    // 
    // Bits[2:0], RW, default = 0x0
    //
    UINTX txdll_anaobs0sel : 3;
    //
    // analog select mux for output 1
    // 
    // Bits[5:3], RW, default = 0x0
    //
    UINTX txdll_anaobs1sel : 3;
    //
    // DFX digital 0 mux select
    // 
    // Bits[11:6], RW, default = 0x0
    //
    UINTX txdll_digobs0sel : 6;
    //
    // DFX digital 1 mux select
    // 
    // Bits[17:12], RW, default = 0x0
    //
    UINTX txdll_digobs1sel : 6;
    //
    // Reserved
    // 
    // Bits[31:18], RO, default = 0x0
    //
    UINTX reserved : 14;
  } Bits;
  UINTX Data;
} TXDLLCFG7_DDRCC0_STRUCT;
#endif // ASM_INC

#define RXVREFCFG_DDRCC0_REG                               0x00000018
#ifndef ASM_INC
typedef union {
  struct {
    //
    // VREF Code
    // 
    // Bits[5:0], RW, default = 0x20
    //
    UINTX rxvref_vrefctrl : 6;
    //
    // Enable VREF
    // 
    // Bits[6:6], RW, default = 0x0
    //
    UINTX rxvref_vrefen : 1;
    //
    // Range select to pick between DDR3 and DDR4. [br]0 - DDR3 (Default)  [br]1- DDR4
    // 
    // Bits[7:7], RW, default = 0x0
    //
    UINTX rxvref_vrefrangesel : 1;
    //
    // Reserved
    // 
    // Bits[31:8], RO, default = 0x0
    //
    UINTX reserved : 24;
  } Bits;
  UINTX Data;
} RXVREFCFG_DDRCC0_STRUCT;
#endif // ASM_INC

#define OBSCFG_DDRCC0_REG                                  0x0000001C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // select signal for analog obs mux a.
    // 
    // Bits[3:0], RW, default = 0x0
    //
    UINTX lcomp_anaobs0sel : 4;
    //
    // select signal for analog obs mux b.
    // 
    // Bits[7:4], RW, default = 0x0
    //
    UINTX lcomp_anaobs1sel : 4;
    //
    // select signal for digital obs mux a.
    // 
    // Bits[11:8], RW, default = 0x0
    //
    UINTX lcomp_digobs0sel : 4;
    //
    // select signal for digital obs mux b.
    // 
    // Bits[15:12], RW, default = 0x0
    //
    UINTX lcomp_digobs1sel : 4;
    //
    // Reserved
    // 
    // Bits[31:16], RO, default = 0x0
    //
    UINTX reserved : 16;
  } Bits;
  UINTX Data;
} OBSCFG_DDRCC0_STRUCT;
#endif // ASM_INC

#define LCOMP_CFG0_DDRCC0_REG                              0x00000020
#ifndef ASM_INC
typedef union {
  struct {
    //
    // scr_lcomp_pdn_ctl_vrefctrl[7:0]
    // 
    // Bits[7:0], RW, default = 0x0
    //
    UINTX lcomp_pdn_ctl_vrefctrl : 8;
    //
    // scr_lcomp_pdn_cmd_vrefctrl[7:0]
    // 
    // Bits[15:8], RW, default = 0x0
    //
    UINTX lcomp_pdn_cmd_vrefctrl : 8;
    //
    // Reserved
    // 
    // Bits[31:16], RO, default = 0x0
    //
    UINTX reserved : 16;
  } Bits;
  UINTX Data;
} LCOMP_CFG0_DDRCC0_STRUCT;
#endif // ASM_INC

#define LCOMP_CFG1_DDRCC0_REG                              0x00000024
#ifndef ASM_INC
typedef union {
  struct {
    //
    // scr_lcomp_ctl_tapsel[4:0]
    // 
    // Bits[4:0], RW, default = 0x0
    //
    UINTX lcomp_ctl_tapsel : 5;
    //
    // scr_lcomp_cmd_tapsel[4:0]
    // 
    // Bits[9:5], RW, default = 0x0
    //
    UINTX lcomp_cmd_tapsel : 5;
    //
    // RCOMP PDN Static Bit Live Code from FSM. AJC NOTE: THIS WILL PROBABLY CHANGE FOR
    // 0P8 
    // 
    // Bits[12:10], RW, default = 0x7
    //
    UINTX lcomp_pdnrcompstaticlive : 3;
    //
    // Pull-up RCOMP code for driver static leg: Used for PDN Rcomp.
    // 
    // Bits[15:13], RW, default = 0x7
    //
    UINTX lcomp_puprcompstatic : 3;
    //
    // DCOMP DFT pin to enable a static leg check for the delay cell.
    // 
    // Bits[16:16], RW, default = 0x1
    //
    UINTX lcomp_dlycellstaticlegen : 1;
    //
    // dfx legtest enable pin. Allows for independent control of the lower 4 legs of
    // the deley element which are controlled by the decoder. 1: enabled       0 : disabled
    // (default) 
    // 
    // Bits[17:17], RW, default = 0x0
    //
    UINTX lcomp_pbddfxtesten : 1;
    //
    // vrefrangesel
    // 
    // Bits[18:18], RW, default = 0x1
    //
    UINTX lcomp_vrefrangesel : 1;
    //
    // new pin for testing each of the driver legs individually during per leg testing
    // mode. 
    // 
    // Bits[19:19], RW, default = 0x1
    //
    UINTX lcomp_drvseg0en : 1;
    //
    // Reserved
    // 
    // Bits[31:20], RO, default = 0x0
    //
    UINTX reserved : 12;
  } Bits;
  UINTX Data;
} LCOMP_CFG1_DDRCC0_STRUCT;
#endif // ASM_INC

#define COMP_RST_DDRCC0_REG                                0x00000028
#ifndef ASM_INC
typedef union {
  struct {
    //
    // c73ddr402_Comp unit reset-bar. Combined with PM reset control
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINTX comprst_b : 1;
    //
    // Reserved
    // 
    // Bits[31:1], RO, default = 0x0
    //
    UINTX reserved : 31;
  } Bits;
  UINTX Data;
} COMP_RST_DDRCC0_STRUCT;
#endif // ASM_INC

#define DIGCTL_CMN_DDRCC0_REG                              0x0000002C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Ref2x divider counters async reset-bar. This is used to reset the flops of the
    // dividers counters. 
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINTX cmn_clkgenrst_b : 1;
    //
    // Reserved
    // 
    // Bits[31:1], RO, default = 0x0
    //
    UINTX reserved : 31;
  } Bits;
  UINTX Data;
} DIGCTL_CMN_DDRCC0_STRUCT;
#endif // ASM_INC

#define SPIDCLK_CTRL1_DDRCC0_REG                           0x00000030
#ifndef ASM_INC
typedef union {
  struct {
    //
    // spidclk PLL selection
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINTX spidclk_pllsel : 1;
    //
    // Reserved
    // 
    // Bits[31:1], RO, default = 0x0
    //
    UINTX reserved : 31;
  } Bits;
  UINTX Data;
} SPIDCLK_CTRL1_DDRCC0_STRUCT;
#endif // ASM_INC

#define DFXVISA_ULM0PATTGEN_DDRCC0_REG                     0x00000100
#ifndef ASM_INC
typedef union {
  struct {
    //
    // VISA Pattern Generation
    // 
    // Bits[3:0], RW, default = 0x0
    //
    UINTX dfxvisa_ulm0pattgen_lsb : 4;
    //
    // VISA Pattern Generation
    // 
    // Bits[6:4], RW, default = 0x0
    //
    UINTX dfxvisa_ulm0pattgen_msb : 3;
    //
    // Reserved
    // 
    // Bits[31:7], RO, default = 0x0
    //
    UINTX reserved : 25;
  } Bits;
  UINTX Data;
} DFXVISA_ULM0PATTGEN_DDRCC0_STRUCT;
#endif // ASM_INC

#define DFXVISA_ULM0LN0_DDRCC0_REG                         0x00000104
#ifndef ASM_INC
typedef union {
  struct {
    //
    // VISA ULM0LN0 (DATA) Select
    // 
    // Bits[7:0], RW, default = 0x0
    //
    UINTX dfxvisa_ulm0ln0_datasel : 8;
    //
    // VISA ULM0LN0 CLK Select
    // 
    // Bits[15:8], RW, default = 0x0
    //
    UINTX dfxvisa_ulm0ln0_clksel : 8;
    //
    // VISA Bypass ULM0LN0
    // 
    // Bits[16:16], RW, default = 0x0
    //
    UINTX dfxvisa_ulm0ln0_bypass : 1;
    //
    // Reserved
    // 
    // Bits[31:17], RO, default = 0x0
    //
    UINTX reserved : 15;
  } Bits;
  UINTX Data;
} DFXVISA_ULM0LN0_DDRCC0_STRUCT;
#endif // ASM_INC

#define DFXVISA_ULM0LN1_DDRCC0_REG                         0x00000108
#ifndef ASM_INC
typedef union {
  struct {
    //
    // VISA ULM0LN1 (DATA) Select
    // 
    // Bits[7:0], RW, default = 0x0
    //
    UINTX dfxvisa_ulm0ln1_datasel : 8;
    //
    // VISA ULM0LN1 CLK Select
    // 
    // Bits[15:8], RW, default = 0x0
    //
    UINTX dfxvisa_ulm0ln1_clksel : 8;
    //
    // VISA Bypass ULM0LN1
    // 
    // Bits[16:16], RW, default = 0x0
    //
    UINTX dfxvisa_ulm0ln1_bypass : 1;
    //
    // Reserved
    // 
    // Bits[31:17], RO, default = 0x0
    //
    UINTX reserved : 15;
  } Bits;
  UINTX Data;
} DFXVISA_ULM0LN1_DDRCC0_STRUCT;
#endif // ASM_INC

#define DFXVISA_ULM1PATTGEN_DDRCC0_REG                     0x0000010C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // VISA Pattern Generation
    // 
    // Bits[3:0], RW, default = 0x0
    //
    UINTX dfxvisa_ulm1pattgen_lsb : 4;
    //
    // VISA Pattern Generation
    // 
    // Bits[6:4], RW, default = 0x0
    //
    UINTX dfxvisa_ulm1pattgen_msb : 3;
    //
    // Reserved
    // 
    // Bits[31:7], RO, default = 0x0
    //
    UINTX reserved : 25;
  } Bits;
  UINTX Data;
} DFXVISA_ULM1PATTGEN_DDRCC0_STRUCT;
#endif // ASM_INC

#define DFXVISA_ULM1LN0_DDRCC0_REG                         0x00000110
#ifndef ASM_INC
typedef union {
  struct {
    //
    // VISA ULM1LN0 (DATA) Select
    // 
    // Bits[7:0], RW, default = 0x0
    //
    UINTX dfxvisa_ulm1ln0_datasel : 8;
    //
    // VISA ULM1LN0 CLK Select
    // 
    // Bits[15:8], RW, default = 0x0
    //
    UINTX dfxvisa_ulm1ln0_clksel : 8;
    //
    // VISA Bypass ULM1LN0
    // 
    // Bits[16:16], RW, default = 0x0
    //
    UINTX dfxvisa_ulm1ln0_bypass : 1;
    //
    // Reserved
    // 
    // Bits[31:17], RO, default = 0x0
    //
    UINTX reserved : 15;
  } Bits;
  UINTX Data;
} DFXVISA_ULM1LN0_DDRCC0_STRUCT;
#endif // ASM_INC

#define DFXVISA_ULM1LN1_DDRCC0_REG                         0x00000114
#ifndef ASM_INC
typedef union {
  struct {
    //
    // VISA ULM1LN1 (DATA) Select
    // 
    // Bits[7:0], RW, default = 0x0
    //
    UINTX dfxvisa_ulm1ln1_datasel : 8;
    //
    // VISA ULM1LN1 CLK Select
    // 
    // Bits[15:8], RW, default = 0x0
    //
    UINTX dfxvisa_ulm1ln1_clksel : 8;
    //
    // VISA Bypass ULM1LN1
    // 
    // Bits[16:16], RW, default = 0x0
    //
    UINTX dfxvisa_ulm1ln1_bypass : 1;
    //
    // Reserved
    // 
    // Bits[31:17], RO, default = 0x0
    //
    UINTX reserved : 15;
  } Bits;
  UINTX Data;
} DFXVISA_ULM1LN1_DDRCC0_STRUCT;
#endif // ASM_INC

#define MON0CFG_DDRCC0_REG                                 0x00000118
#ifndef ASM_INC
typedef union {
  struct {
    //
    // master enable for both anamux0 and anamux1 in all ckebb cells. 1 = anamux0 and
    // anamux1 can be used. 0 = anamux0 and anamux1 disabled reguardless of any other
    // programming 
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINTX mon0_anaen : 1;
    //
    // mon port analog mux 0 enable
    // 
    // Bits[1:1], RW, default = 0x0
    //
    UINTX mon0_anaobs0en : 1;
    //
    // code for mon port analog mux 0
    // 
    // Bits[4:2], RW, default = 0x0
    //
    UINTX mon0_anaobs0sel : 3;
    //
    // mon port analog mux 1 enable
    // 
    // Bits[5:5], RW, default = 0x0
    //
    UINTX mon0_anaobs1en : 1;
    //
    // code for mon port analog mux 1
    // 
    // Bits[8:6], RW, default = 0x0
    //
    UINTX mon0_anaobs1sel : 3;
    //
    // mon port comparator input switch
    // 
    // Bits[9:9], RW, default = 0x0
    //
    UINTX mon0_compswitch : 1;
    //
    // code for mon port digital mux 0
    // 
    // Bits[14:10], RW, default = 0x0
    //
    UINTX mon0_digobs0sel : 5;
    //
    // code for mon port digital mux 1
    // 
    // Bits[19:15], RW, default = 0x0
    //
    UINTX mon0_digobs1sel : 5;
    //
    // code for mon port vref for comparator
    // 
    // Bits[25:20], RW, default = 0x0
    //
    UINTX mon0_vrefctrl : 6;
    //
    // mon port vref and comparator enable
    // 
    // Bits[26:26], RW, default = 0x0
    //
    UINTX mon0_vrefen : 1;
    //
    // mon port comparator output 0 to digital register (region 0)
    // 
    // Bits[27:27], RO/V, default = 0x0
    //
    UINTX mon0_compout0 : 1;
    //
    // mon port comparator output 1 to digital register (region 0)
    // 
    // Bits[28:28], RO/V, default = 0x0
    //
    UINTX mon0_compout1 : 1;
    //
    // Reserved
    // 
    // Bits[31:29], RO, default = 0x0
    //
    UINTX reserved : 3;
  } Bits;
  UINTX Data;
} MON0CFG_DDRCC0_STRUCT;
#endif // ASM_INC

#define MON1CFG_DDRCC0_REG                                 0x0000011C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // master enable for both anamux0 and anamux1 in all ckebb cells. 1 = anamux0 and
    // anamux1 can be used. 0 = anamux0 and anamux1 disabled reguardless of any other
    // programming 
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINTX mon1_anaen : 1;
    //
    // mon port analog mux 0 enable
    // 
    // Bits[1:1], RW, default = 0x0
    //
    UINTX mon1_anaobs0en : 1;
    //
    // code for mon port analog mux 0
    // 
    // Bits[4:2], RW, default = 0x0
    //
    UINTX mon1_anaobs0sel : 3;
    //
    // mon port analog mux 1 enable
    // 
    // Bits[5:5], RW, default = 0x0
    //
    UINTX mon1_anaobs1en : 1;
    //
    // code for mon port analog mux 1
    // 
    // Bits[8:6], RW, default = 0x0
    //
    UINTX mon1_anaobs1sel : 3;
    //
    // mon port comparator input switch
    // 
    // Bits[9:9], RW, default = 0x0
    //
    UINTX mon1_compswitch : 1;
    //
    // code for mon port digital mux 0
    // 
    // Bits[14:10], RW, default = 0x0
    //
    UINTX mon1_digobs0sel : 5;
    //
    // code for mon port digital mux 1
    // 
    // Bits[19:15], RW, default = 0x0
    //
    UINTX mon1_digobs1sel : 5;
    //
    // code for mon port vref for comparator
    // 
    // Bits[25:20], RW, default = 0x0
    //
    UINTX mon1_vrefctrl : 6;
    //
    // mon port vref and comparator enable
    // 
    // Bits[26:26], RW, default = 0x0
    //
    UINTX mon1_vrefen : 1;
    //
    // mon port comparator output 0 to digital register (region 1)
    // 
    // Bits[27:27], RO/V, default = 0x0
    //
    UINTX mon1_compout0 : 1;
    //
    // mon port comparator output 1 to digital register (region 1)
    // 
    // Bits[28:28], RO/V, default = 0x0
    //
    UINTX mon1_compout1 : 1;
    //
    // Reserved
    // 
    // Bits[31:29], RO, default = 0x0
    //
    UINTX reserved : 3;
  } Bits;
  UINTX Data;
} MON1CFG_DDRCC0_STRUCT;
#endif // ASM_INC

#define DIGCTL_CH0_DDRCC0_REG                              0x00000180
#ifndef ASM_INC
typedef union {
  struct {
    //
    // SPID clock clock domain reset-bar. Combined with PM reset control
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINTX ch0_spidrst_b : 1;
    //
    // CC1 I/O buffer activate: Reset for final TX flops in CC1 upartition.[br]Tristates
    // IO buffers.[br]Disable Rx sections of IO buffers.[br]0 = reset , 1 = out of reset
    // 
    // Bits[1:1], RW, default = 0x0
    //
    UINTX ch0_iobufact : 1;
    //
    // Multi Cycle Path Control. 0 = NO Pipelining, 1 = Pipelining (1 Stage)
    // 
    // Bits[2:2], RW, default = 0x0
    //
    UINTX ch0_rdmcpsel : 1;
    //
    // Reserved
    // 
    // Bits[4:3], RO, default = 0x0
    //
    UINTX reserved : 2;
    //
    // Reserved
    // 
    // Bits[6:5], RO, default = 0x0
    //
    UINTX reserved_1 : 2;
    //
    // Write Leveling Enable: 0 = Write Leveling off (normal mode). 1 - Write Leveling
    // on (training) 
    // 
    // Bits[7:7], RW, default = 0x0
    //
    UINTX ch0_wrlvl : 1;
    //
    // Reserved
    // 
    // Bits[31:8], RO, default = 0x0
    //
    UINTX reserved_2 : 24;
  } Bits;
  UINTX Data;
} DIGCTL_CH0_DDRCC0_STRUCT;
#endif // ASM_INC

#define PTROFFSET_CH0_DDRCC0_REG                           0x00000184
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Initial offset for 2x clock read pointers
    // 
    // Bits[4:0], RW, default = 0x0
    //
    UINTX ch0_ref2xrdptrinit : 5;
    //
    // Reserved
    // 
    // Bits[31:5], RO, default = 0x0
    //
    UINTX reserved : 27;
  } Bits;
  UINTX Data;
} PTROFFSET_CH0_DDRCC0_STRUCT;
#endif // ASM_INC

#define CMDSIGCTL_CH0_DDRCC0_REG                           0x00000188
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Command signal clock deadband select. Cmd group 0. 00: No Deadband Zone[br]01:
    // No Deadband Zone 270 pathsel[br]10: Deadband 90 degree path sel[br]11: Deadband
    // 180 degree path sel. 
    // 
    // Bits[1:0], RW, default = 0x0
    //
    UINTX ch0_grp0cmddbsel : 2;
    //
    // Command signal clock read pointer offset. Cmd group 0
    // 
    // Bits[6:2], RW, default = 0x0
    //
    UINTX ch0_grp0cmdsigrdptroffset : 5;
    //
    // Command signal clock deadband select. Cmd group 1. 00: No Deadband Zone[br]01:
    // No Deadband Zone 270 pathsel[br]10: Deadband 90 degree path sel[br]11: Deadband
    // 180 degree path sel. 
    // 
    // Bits[8:7], RW, default = 0x0
    //
    UINTX ch0_grp1cmddbsel : 2;
    //
    // Command signal clock read pointer offset. Cmd group 1
    // 
    // Bits[13:9], RW, default = 0x0
    //
    UINTX ch0_grp1cmdsigrdptroffset : 5;
    //
    // Reserved
    // 
    // Bits[31:14], RO, default = 0x0
    //
    UINTX reserved : 18;
  } Bits;
  UINTX Data;
} CMDSIGCTL_CH0_DDRCC0_STRUCT;
#endif // ASM_INC

#define CMDDRVEN_CH0_DDRCC0_REG                            0x0000018C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Command tristate enables per bit. 1 = buffer enabled, 0 = tristate[br]for CC0:
    //  scr_catxdrven[7:2],[br]for CC2: {scr_cidtxdrven,scr_catxdrven[18],scr_catxdrven[20:19],scr_catxdrven[22:21]}
    // 
    // Bits[5:0], RW, default = 0x0
    //
    UINTX ch0_cmdtxdrven : 6;
    //
    // Reserved
    // 
    // Bits[31:6], RO, default = 0x0
    //
    UINTX reserved : 26;
  } Bits;
  UINTX Data;
} CMDDRVEN_CH0_DDRCC0_STRUCT;
#endif // ASM_INC

#define CTLSIGCTL_CH0_DDRCC0_REG                           0x00000190
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Control signal clock deadband select. Ctl group 0. 00: No Deadband Zone[br]01:
    // No Deadband Zone 270 pathsel[br]10: Deadband 90 degree path sel[br]11: Deadband
    // 180 degree path sel. 
    // 
    // Bits[1:0], RW, default = 0x0
    //
    UINTX ch0_grp0ctldbsel : 2;
    //
    // Control signal clock read pointer offset. Ctl group 0
    // 
    // Bits[6:2], RW, default = 0x0
    //
    UINTX ch0_grp0ctlsigrdptroffset : 5;
    //
    // Control signal clock deadband select. Ctl group 1. 00: No Deadband Zone[br]01:
    // No Deadband Zone 270 pathsel[br]10: Deadband 90 degree path sel[br]11: Deadband
    // 180 degree path sel. 
    // 
    // Bits[8:7], RW, default = 0x0
    //
    UINTX ch0_grp1ctldbsel : 2;
    //
    // Control signal clock read pointer offset. Ctl group 1
    // 
    // Bits[13:9], RW, default = 0x0
    //
    UINTX ch0_grp1ctlsigrdptroffset : 5;
    //
    // Reserved
    // 
    // Bits[31:14], RO, default = 0x0
    //
    UINTX reserved : 18;
  } Bits;
  UINTX Data;
} CTLSIGCTL_CH0_DDRCC0_STRUCT;
#endif // ASM_INC

#define TXDLLCFG3_CH0_DDRCC0_REG                           0x00000194
#ifndef ASM_INC
typedef union {
  struct {
    //
    // PI Code for Signal Group0 output
    // 
    // Bits[5:0], RW, default = 0x0
    //
    UINTX txdll_siggrp00picode : 6;
    //
    // PI Code for Signal Group1 output
    // 
    // Bits[11:6], RW, default = 0x0
    //
    UINTX txdll_siggrp01picode : 6;
    //
    // PI Code for Signal Group2 output
    // 
    // Bits[17:12], RW, default = 0x0
    //
    UINTX txdll_siggrp02picode : 6;
    //
    // Reserved
    // 
    // Bits[31:18], RO, default = 0x0
    //
    UINTX reserved : 14;
  } Bits;
  UINTX Data;
} TXDLLCFG3_CH0_DDRCC0_STRUCT;
#endif // ASM_INC

#define TXDLLCFG4_CH0_DDRCC0_REG                           0x00000198
#ifndef ASM_INC
typedef union {
  struct {
    //
    // PI Code for Signal Group6 output
    // 
    // Bits[5:0], RW, default = 0x0
    //
    UINTX txdll_siggrp06picode : 6;
    //
    // PI Code for Signal Group7 output
    // 
    // Bits[11:6], RW, default = 0x0
    //
    UINTX txdll_siggrp07picode : 6;
    //
    // PI Code for Signal Group8 output
    // 
    // Bits[17:12], RW, default = 0x0
    //
    UINTX txdll_siggrp08picode : 6;
    //
    // Reserved
    // 
    // Bits[31:18], RO, default = 0x0
    //
    UINTX reserved : 14;
  } Bits;
  UINTX Data;
} TXDLLCFG4_CH0_DDRCC0_STRUCT;
#endif // ASM_INC

#define CTLDRVEN_CH0_DDRCC0_REG                            0x0000019C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Control tristate enables per bit. 1 = buffer enabled, 0 = tristate[br]for CC0:
    // scr_cketxdrven[3:0],[br]for CC2: scr_csntxdrven[3:0] 
    // 
    // Bits[3:0], RW, default = 0x0
    //
    UINTX ch0_ctltxdrven : 4;
    //
    // Reserved
    // 
    // Bits[31:4], RO, default = 0x0
    //
    UINTX reserved : 28;
  } Bits;
  UINTX Data;
} CTLDRVEN_CH0_DDRCC0_STRUCT;
#endif // ASM_INC

#define CTLCMDSIGCTL_CH0_DDRCC0_REG                        0x000001A0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Control/Command signal clock deadband select. Ctlcmd group 0. 00: No Deadband
    // Zone[br]01: No Deadband Zone 270 pathsel[br]10: Deadband 90 degree path sel[br]11:
    // Deadband 180 degree path sel. 
    // 
    // Bits[1:0], RW, default = 0x0
    //
    UINTX ch0_grp0ctlcmddbsel : 2;
    //
    // Control/Command signal clock read pointer offset. Ctlcmd group 0
    // 
    // Bits[6:2], RW, default = 0x0
    //
    UINTX ch0_grp0ctlcmdsigrdptroffset : 5;
    //
    // Control/Command signal clock deadband select. Ctlcmd group 1. 00: No Deadband
    // Zone[br]01: No Deadband Zone 270 pathsel[br]10: Deadband 90 degree path sel[br]11:
    // Deadband 180 degree path sel. 
    // 
    // Bits[8:7], RW, default = 0x0
    //
    UINTX ch0_grp1ctlcmddbsel : 2;
    //
    // Control/Command signal clock read pointer offset. Ctlcmd group 1
    // 
    // Bits[13:9], RW, default = 0x0
    //
    UINTX ch0_grp1ctlcmdsigrdptroffset : 5;
    //
    // Reserved
    // 
    // Bits[31:14], RO, default = 0x0
    //
    UINTX reserved : 18;
  } Bits;
  UINTX Data;
} CTLCMDSIGCTL_CH0_DDRCC0_STRUCT;
#endif // ASM_INC

#define CTLCMDDRVEN_CH0_DDRCC0_REG                         0x000001A4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Control/Command tristate enables per bit. 1 = buffer enabled, 0 = tristate[br]for
    // CC0: {scr_catxdrven[1],scr_alertdrven,scr_partxdrven,scr_catxdrven[0]},[br]for
    // CC2: scr_odttxdrven[3:0] 
    // 
    // Bits[3:0], RW, default = 0x0
    //
    UINTX ch0_ctlcmdtxdrven : 4;
    //
    // Reserved
    // 
    // Bits[31:4], RO, default = 0x0
    //
    UINTX reserved : 28;
  } Bits;
  UINTX Data;
} CTLCMDDRVEN_CH0_DDRCC0_STRUCT;
#endif // ASM_INC

#define CMD_AFE_CH0_DDRCC0_REG                             0x000001A8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Pull-down RCOMP code for driver static leg. DQ/CLK uses [3:0]  & CMD uses [3]
    // since it has no EQ support. 
    // 
    // Bits[2:0], RW, default = 0x7
    //
    UINTX ch0_cmd_pdndrvstatic : 3;
    //
    // Pull-up RCOMP code for driver static leg. DQ/CLK uses [3:0]  & CMD uses [3] since
    // it has no EQ support. 
    // 
    // Bits[5:3], RW, default = 0x7
    //
    UINTX ch0_cmd_pupdrvstatic : 3;
    //
    // cmd rx enable
    // 
    // Bits[6:6], RW, default = 0x0
    //
    UINTX ch0_cmd_rxen : 1;
    //
    // Delay cell static leg enable, Support DFX Per leg testing of delay cells in Predriver
    // Logic/Delay c73ddr402_comp.                                                  
    //                                                                              
    //                                                                              
    //                                1: enabled       (default)                    
    //                                0: disabled 
    // 
    // Bits[7:7], RW, default = 0x1
    //
    UINTX ch0_cmd_dlycellstaticlegen : 1;
    //
    // Stretches falling edge of Buffer enable pulse to support Early DQ mode.[br][1:0]
    // is used as POR,    [br]00=default pulse width[br]01=minimum stretch on width[br]10=intermediate
    // stretch on pulse[br]11=maximum stretch on pulse. 
    // 
    // Bits[9:8], RW, default = 0x0
    //
    UINTX ch0_cmd_drvenstretch : 2;
    //
    // Transmitter segment enable. Only used to enable DFX Per Leg checks.
    // 
    // Bits[13:10], RW, default = 0xF
    //
    UINTX ch0_cmd_drvsegen : 4;
    //
    // Fall TCO c73ddr402_COMP code
    // 
    // Bits[19:14], RW, default = 0x3F
    //
    UINTX ch0_cmd_tcocompfall : 6;
    //
    // Rise TCO c73ddr402_COMP code
    // 
    // Bits[25:20], RW, default = 0x3F
    //
    UINTX ch0_cmd_tcocomprise : 6;
    //
    // dfx legtest enable pin. Allows for independent control of the lower 4 legs of
    // the deley element which are controlled by the decoder. 1: enabled       0 : disabled
    // (default) 
    // 
    // Bits[26:26], RW, default = 0x0
    //
    UINTX ch0_cmd_pbddfxtesten : 1;
    //
    // Reserved
    // 
    // Bits[31:27], RO, default = 0x0
    //
    UINTX reserved : 5;
  } Bits;
  UINTX Data;
} CMD_AFE_CH0_DDRCC0_STRUCT;
#endif // ASM_INC

#define CTL_AFE_CH0_DDRCC0_REG                             0x000001AC
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Pull-down RCOMP code for driver static leg for CTL buffers
    // 
    // Bits[2:0], RW, default = 0x7
    //
    UINTX ch0_ctl_pdndrvstatic : 3;
    //
    // Pull-up RCOMP code for driver static leg for CTL buffers
    // 
    // Bits[5:3], RW, default = 0x7
    //
    UINTX ch0_ctl_pupdrvstatic : 3;
    //
    // ctl rx enable
    // 
    // Bits[6:6], RW, default = 0x0
    //
    UINTX ch0_ctl_rxen : 1;
    //
    // Delay cell static leg enable, Support DFX Per leg testing of delay cells in Predriver
    // Logic/Delay c73ddr402_comp.                                                  
    //                                                                              
    //                                                                              
    //                                1: enabled       (default)                    
    //                                0: disabled 
    // 
    // Bits[7:7], RW, default = 0x1
    //
    UINTX ch0_ctl_dlycellstaticlegen : 1;
    //
    // Stretches falling edge of Buffer enable pulse to support Early DQ mode.  [br]00=default
    // pulse width[br]01=minimum stretch on width[br]10=intermediate stretch on pulse[br]11=maximum
    // stretch on pulse. 
    // 
    // Bits[9:8], RW, default = 0x0
    //
    UINTX ch0_ctl_drvenstretch : 2;
    //
    // Transmitter segment enable. Only used to enable DFX Per Leg checks.
    // 
    // Bits[13:10], RW, default = 0x7
    //
    UINTX ch0_ctl_drvsegen : 4;
    //
    // Fall TCO c73ddr402_COMP code
    // 
    // Bits[19:14], RW, default = 0x3F
    //
    UINTX ch0_ctl_tcocompfall : 6;
    //
    // Rise TCO c73ddr402_COMP code
    // 
    // Bits[25:20], RW, default = 0x3F
    //
    UINTX ch0_ctl_tcocomprise : 6;
    //
    // dfx legtest enable pin. Allows for independent control of the lower 4 legs of
    // the deley element which are controlled by the decoder. 1: enabled       0 : disabled
    // (default) 
    // 
    // Bits[26:26], RW, default = 0x0
    //
    UINTX ch0_ctl_pbddfxtesten : 1;
    //
    // Reserved
    // 
    // Bits[31:27], RO, default = 0x0
    //
    UINTX reserved : 5;
  } Bits;
  UINTX Data;
} CTL_AFE_CH0_DDRCC0_STRUCT;
#endif // ASM_INC

#define CTLCMD_AFE_CH0_DDRCC0_REG                          0x000001B0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // alert rx enable
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINTX ch0_alert_rxen : 1;
    //
    // Reserved
    // 
    // Bits[31:1], RO, default = 0x0
    //
    UINTX reserved : 31;
  } Bits;
  UINTX Data;
} CTLCMD_AFE_CH0_DDRCC0_STRUCT;
#endif // ASM_INC

#define OBSCFG_CH0_DDRCC0_REG                              0x000001B4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // DIG Buf mux select 0
    // 
    // Bits[3:0], RW, default = 0x0
    //
    UINTX ch0_cmd_digobs0sel : 4;
    //
    // DIG Buf mux select 1
    // 
    // Bits[7:4], RW, default = 0x0
    //
    UINTX ch0_cmd_digobs1sel : 4;
    //
    // DIG Buf mux select 0
    // 
    // Bits[11:8], RW, default = 0x0
    //
    UINTX ch0_ctl_digobs0sel : 4;
    //
    // DIG Buf mux select 1
    // 
    // Bits[15:12], RW, default = 0x0
    //
    UINTX ch0_ctl_digobs1sel : 4;
    //
    // Reserved
    // 
    // Bits[31:16], RO, default = 0x0
    //
    UINTX reserved : 16;
  } Bits;
  UINTX Data;
} OBSCFG_CH0_DDRCC0_STRUCT;
#endif // ASM_INC

#define MRGMODE_CH0_DDRCC0_REG                             0x00000280
#ifndef ASM_INC
typedef union {
  struct {
    //
    // DFX margin mode TX data phase 0
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINTX ch0_dfxmrgtxd_ph0 : 1;
    //
    // DFX margin mode TX data phase 1
    // 
    // Bits[1:1], RW, default = 0x0
    //
    UINTX ch0_dfxmrgtxd_ph1 : 1;
    //
    // DFX margin mode RX compare values
    // 
    // Bits[9:2], RW, default = 0x0
    //
    UINTX ch0_dfxmrgtxd_cmp : 8;
    //
    // DFX margin mode TX override enable
    // 
    // Bits[10:10], RW, default = 0x0
    //
    UINTX ch0_dfxmrgtx_ovren : 1;
    //
    // DFX margin mode TX write enable
    // 
    // Bits[11:11], RW, default = 0x0
    //
    UINTX ch0_dfxmrgtxwren : 1;
    //
    // DFX margin mode TX strobe data
    // 
    // Bits[13:12], RW, default = 0x0
    //
    UINTX ch0_dfxmrgtxd_strb : 2;
    //
    // Reserved
    // 
    // Bits[31:14], RO, default = 0x0
    //
    UINTX reserved : 18;
  } Bits;
  UINTX Data;
} MRGMODE_CH0_DDRCC0_STRUCT;
#endif // ASM_INC

#define MRGMODE_DB_CH0_DDRCC0_REG                          0x00000284
#ifndef ASM_INC
typedef union {
  struct {
    //
    // DFX margin mode RX DB compare values
    // 
    // Bits[7:0], RW, default = 0x0
    //
    UINTX ch0_dfxmrgtxd_db_cmp : 8;
    //
    // Reserved
    // 
    // Bits[31:8], RO, default = 0x0
    //
    UINTX reserved : 24;
  } Bits;
  UINTX Data;
} MRGMODE_DB_CH0_DDRCC0_STRUCT;
#endif // ASM_INC

#define DIGCTL_CH1_DDRCC0_REG                              0x000003B0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // SPID clock clock domain reset-bar. Combined with PM reset control
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINTX ch1_spidrst_b : 1;
    //
    // CC1 I/O buffer activate: Reset for final TX flops in CC1 upartition.[br]Tristates
    // IO buffers.[br]Disable Rx sections of IO buffers.[br]0 = reset , 1 = out of reset
    // 
    // Bits[1:1], RW, default = 0x0
    //
    UINTX ch1_iobufact : 1;
    //
    // Multi Cycle Path Control. 0 = NO Pipelining, 1 = Pipelining (1 Stage)
    // 
    // Bits[2:2], RW, default = 0x0
    //
    UINTX ch1_rdmcpsel : 1;
    //
    // Reserved
    // 
    // Bits[4:3], RO, default = 0x0
    //
    UINTX reserved : 2;
    //
    // Reserved
    // 
    // Bits[6:5], RO, default = 0x0
    //
    UINTX reserved_1 : 2;
    //
    // Write Leveling Enable: 0 = Write Leveling off (normal mode). 1 - Write Leveling
    // on (training) 
    // 
    // Bits[7:7], RW, default = 0x0
    //
    UINTX ch1_wrlvl : 1;
    //
    // Reserved
    // 
    // Bits[31:8], RO, default = 0x0
    //
    UINTX reserved_2 : 24;
  } Bits;
  UINTX Data;
} DIGCTL_CH1_DDRCC0_STRUCT;
#endif // ASM_INC

#define PTROFFSET_CH1_DDRCC0_REG                           0x000003B4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Initial offset for 2x clock read pointers
    // 
    // Bits[4:0], RW, default = 0x0
    //
    UINTX ch1_ref2xrdptrinit : 5;
    //
    // Reserved
    // 
    // Bits[31:5], RO, default = 0x0
    //
    UINTX reserved : 27;
  } Bits;
  UINTX Data;
} PTROFFSET_CH1_DDRCC0_STRUCT;
#endif // ASM_INC

#define CMDSIGCTL_CH1_DDRCC0_REG                           0x000003B8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Command signal clock deadband select. Cmd group 0. 00: No Deadband Zone[br]01:
    // No Deadband Zone 270 pathsel[br]10: Deadband 90 degree path sel[br]11: Deadband
    // 180 degree path sel. 
    // 
    // Bits[1:0], RW, default = 0x0
    //
    UINTX ch1_grp0cmddbsel : 2;
    //
    // Command signal clock read pointer offset. Cmd group 0
    // 
    // Bits[6:2], RW, default = 0x0
    //
    UINTX ch1_grp0cmdsigrdptroffset : 5;
    //
    // Command signal clock deadband select. Cmd group 1. 00: No Deadband Zone[br]01:
    // No Deadband Zone 270 pathsel[br]10: Deadband 90 degree path sel[br]11: Deadband
    // 180 degree path sel. 
    // 
    // Bits[8:7], RW, default = 0x0
    //
    UINTX ch1_grp1cmddbsel : 2;
    //
    // Command signal clock read pointer offset. Cmd group 1
    // 
    // Bits[13:9], RW, default = 0x0
    //
    UINTX ch1_grp1cmdsigrdptroffset : 5;
    //
    // Reserved
    // 
    // Bits[31:14], RO, default = 0x0
    //
    UINTX reserved : 18;
  } Bits;
  UINTX Data;
} CMDSIGCTL_CH1_DDRCC0_STRUCT;
#endif // ASM_INC

#define CMDDRVEN_CH1_DDRCC0_REG                            0x000003BC
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Command tristate enables per bit. 1 = buffer enabled, 0 = tristate[br]for CC0:
    //  scr_catxdrven[7:2],[br]for CC2: {scr_cidtxdrven,scr_catxdrven[18],scr_catxdrven[20:19],scr_catxdrven[22:21]}
    // 
    // Bits[5:0], RW, default = 0x0
    //
    UINTX ch1_cmdtxdrven : 6;
    //
    // Reserved
    // 
    // Bits[31:6], RO, default = 0x0
    //
    UINTX reserved : 26;
  } Bits;
  UINTX Data;
} CMDDRVEN_CH1_DDRCC0_STRUCT;
#endif // ASM_INC

#define CTLSIGCTL_CH1_DDRCC0_REG                           0x000003C0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Control signal clock deadband select. Ctl group 0. 00: No Deadband Zone[br]01:
    // No Deadband Zone 270 pathsel[br]10: Deadband 90 degree path sel[br]11: Deadband
    // 180 degree path sel. 
    // 
    // Bits[1:0], RW, default = 0x0
    //
    UINTX ch1_grp0ctldbsel : 2;
    //
    // Control signal clock read pointer offset. Ctl group 0
    // 
    // Bits[6:2], RW, default = 0x0
    //
    UINTX ch1_grp0ctlsigrdptroffset : 5;
    //
    // Control signal clock deadband select. Ctl group 1. 00: No Deadband Zone[br]01:
    // No Deadband Zone 270 pathsel[br]10: Deadband 90 degree path sel[br]11: Deadband
    // 180 degree path sel. 
    // 
    // Bits[8:7], RW, default = 0x0
    //
    UINTX ch1_grp1ctldbsel : 2;
    //
    // Control signal clock read pointer offset. Ctl group 1
    // 
    // Bits[13:9], RW, default = 0x0
    //
    UINTX ch1_grp1ctlsigrdptroffset : 5;
    //
    // Reserved
    // 
    // Bits[31:14], RO, default = 0x0
    //
    UINTX reserved : 18;
  } Bits;
  UINTX Data;
} CTLSIGCTL_CH1_DDRCC0_STRUCT;
#endif // ASM_INC

#define TXDLLCFG3_CH1_DDRCC0_REG                           0x000003C4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // PI Code for Signal Group3 output
    // 
    // Bits[5:0], RW, default = 0x0
    //
    UINTX txdll_siggrp03picode : 6;
    //
    // PI Code for Signal Group4 output
    // 
    // Bits[11:6], RW, default = 0x0
    //
    UINTX txdll_siggrp04picode : 6;
    //
    // PI Code for Signal Group5 output
    // 
    // Bits[17:12], RW, default = 0x0
    //
    UINTX txdll_siggrp05picode : 6;
    //
    // Reserved
    // 
    // Bits[31:18], RO, default = 0x0
    //
    UINTX reserved : 14;
  } Bits;
  UINTX Data;
} TXDLLCFG3_CH1_DDRCC0_STRUCT;
#endif // ASM_INC

#define TXDLLCFG4_CH1_DDRCC0_REG                           0x000003C8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // PI Code for Signal Group9 output
    // 
    // Bits[5:0], RW, default = 0x0
    //
    UINTX txdll_siggrp09picode : 6;
    //
    // PI Code for Signal Group10 output
    // 
    // Bits[11:6], RW, default = 0x0
    //
    UINTX txdll_siggrp10picode : 6;
    //
    // PI Code for Signal Group11 output
    // 
    // Bits[17:12], RW, default = 0x0
    //
    UINTX txdll_siggrp11picode : 6;
    //
    // Reserved
    // 
    // Bits[31:18], RO, default = 0x0
    //
    UINTX reserved : 14;
  } Bits;
  UINTX Data;
} TXDLLCFG4_CH1_DDRCC0_STRUCT;
#endif // ASM_INC

#define CTLDRVEN_CH1_DDRCC0_REG                            0x000003CC
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Control tristate enables per bit. 1 = buffer enabled, 0 = tristate[br]for CC0:
    // scr_cketxdrven[3:0],[br]for CC2: scr_csntxdrven[3:0] 
    // 
    // Bits[3:0], RW, default = 0x0
    //
    UINTX ch1_ctltxdrven : 4;
    //
    // Reserved
    // 
    // Bits[31:4], RO, default = 0x0
    //
    UINTX reserved : 28;
  } Bits;
  UINTX Data;
} CTLDRVEN_CH1_DDRCC0_STRUCT;
#endif // ASM_INC

#define CTLCMDSIGCTL_CH1_DDRCC0_REG                        0x000003D0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Control/Command signal clock deadband select. Ctlcmd group 0. 00: No Deadband
    // Zone[br]01: No Deadband Zone 270 pathsel[br]10: Deadband 90 degree path sel[br]11:
    // Deadband 180 degree path sel. 
    // 
    // Bits[1:0], RW, default = 0x0
    //
    UINTX ch1_grp0ctlcmddbsel : 2;
    //
    // Control/Command signal clock read pointer offset. Ctlcmd group 0
    // 
    // Bits[6:2], RW, default = 0x0
    //
    UINTX ch1_grp0ctlcmdsigrdptroffset : 5;
    //
    // Control/Command signal clock deadband select. Ctlcmd group 1. 00: No Deadband
    // Zone[br]01: No Deadband Zone 270 pathsel[br]10: Deadband 90 degree path sel[br]11:
    // Deadband 180 degree path sel. 
    // 
    // Bits[8:7], RW, default = 0x0
    //
    UINTX ch1_grp1ctlcmddbsel : 2;
    //
    // Control/Command signal clock read pointer offset. Ctlcmd group 1
    // 
    // Bits[13:9], RW, default = 0x0
    //
    UINTX ch1_grp1ctlcmdsigrdptroffset : 5;
    //
    // Reserved
    // 
    // Bits[31:14], RO, default = 0x0
    //
    UINTX reserved : 18;
  } Bits;
  UINTX Data;
} CTLCMDSIGCTL_CH1_DDRCC0_STRUCT;
#endif // ASM_INC

#define CTLCMDDRVEN_CH1_DDRCC0_REG                         0x000003D4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Control/Command tristate enables per bit. 1 = buffer enabled, 0 = tristate[br]for
    // CC0: {scr_catxdrven[1],scr_alertdrven,scr_partxdrven,scr_catxdrven[0]},[br]for
    // CC2: scr_odttxdrven[3:0] 
    // 
    // Bits[3:0], RW, default = 0x0
    //
    UINTX ch1_ctlcmdtxdrven : 4;
    //
    // Reserved
    // 
    // Bits[31:4], RO, default = 0x0
    //
    UINTX reserved : 28;
  } Bits;
  UINTX Data;
} CTLCMDDRVEN_CH1_DDRCC0_STRUCT;
#endif // ASM_INC

#define CMD_AFE_CH1_DDRCC0_REG                             0x000003D8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Pull-down RCOMP code for driver static leg. DQ/CLK uses [3:0]  & CMD uses [3]
    // since it has no EQ support. 
    // 
    // Bits[2:0], RW, default = 0x7
    //
    UINTX ch1_cmd_pdndrvstatic : 3;
    //
    // Pull-up RCOMP code for driver static leg. DQ/CLK uses [3:0]  & CMD uses [3] since
    // it has no EQ support. 
    // 
    // Bits[5:3], RW, default = 0x7
    //
    UINTX ch1_cmd_pupdrvstatic : 3;
    //
    // cmd rx enable
    // 
    // Bits[6:6], RW, default = 0x0
    //
    UINTX ch1_cmd_rxen : 1;
    //
    // Delay cell static leg enable, Support DFX Per leg testing of delay cells in Predriver
    // Logic/Delay c73ddr402_comp.                                                  
    //                                                                              
    //                                                                              
    //                                1: enabled       (default)                    
    //                                0: disabled 
    // 
    // Bits[7:7], RW, default = 0x1
    //
    UINTX ch1_cmd_dlycellstaticlegen : 1;
    //
    // Stretches falling edge of Buffer enable pulse to support Early DQ mode.[br][1:0]
    // is used as POR,    [br]00=default pulse width[br]01=minimum stretch on width[br]10=intermediate
    // stretch on pulse[br]11=maximum stretch on pulse. 
    // 
    // Bits[9:8], RW, default = 0x0
    //
    UINTX ch1_cmd_drvenstretch : 2;
    //
    // Transmitter segment enable. Only used to enable DFX Per Leg checks.
    // 
    // Bits[13:10], RW, default = 0xF
    //
    UINTX ch1_cmd_drvsegen : 4;
    //
    // Fall TCO c73ddr402_COMP code
    // 
    // Bits[19:14], RW, default = 0x3F
    //
    UINTX ch1_cmd_tcocompfall : 6;
    //
    // Rise TCO c73ddr402_COMP code
    // 
    // Bits[25:20], RW, default = 0x3F
    //
    UINTX ch1_cmd_tcocomprise : 6;
    //
    // dfx legtest enable pin. Allows for independent control of the lower 4 legs of
    // the deley element which are controlled by the decoder. 1: enabled       0 : disabled
    // (default) 
    // 
    // Bits[26:26], RW, default = 0x0
    //
    UINTX ch1_cmd_pbddfxtesten : 1;
    //
    // Reserved
    // 
    // Bits[31:27], RO, default = 0x0
    //
    UINTX reserved : 5;
  } Bits;
  UINTX Data;
} CMD_AFE_CH1_DDRCC0_STRUCT;
#endif // ASM_INC

#define CTL_AFE_CH1_DDRCC0_REG                             0x000003DC
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Pull-down RCOMP code for driver static leg for CTL buffers
    // 
    // Bits[2:0], RW, default = 0x7
    //
    UINTX ch1_ctl_pdndrvstatic : 3;
    //
    // Pull-up RCOMP code for driver static leg for CTL buffers
    // 
    // Bits[5:3], RW, default = 0x7
    //
    UINTX ch1_ctl_pupdrvstatic : 3;
    //
    // ctl rx enable
    // 
    // Bits[6:6], RW, default = 0x0
    //
    UINTX ch1_ctl_rxen : 1;
    //
    // Delay cell static leg enable, Support DFX Per leg testing of delay cells in Predriver
    // Logic/Delay c73ddr402_comp.                                                  
    //                                                                              
    //                                                                              
    //                                1: enabled       (default)                    
    //                                0: disabled 
    // 
    // Bits[7:7], RW, default = 0x1
    //
    UINTX ch1_ctl_dlycellstaticlegen : 1;
    //
    // Stretches falling edge of Buffer enable pulse to support Early DQ mode.  [br]00=default
    // pulse width[br]01=minimum stretch on width[br]10=intermediate stretch on pulse[br]11=maximum
    // stretch on pulse. 
    // 
    // Bits[9:8], RW, default = 0x0
    //
    UINTX ch1_ctl_drvenstretch : 2;
    //
    // Transmitter segment enable. Only used to enable DFX Per Leg checks.
    // 
    // Bits[13:10], RW, default = 0x7
    //
    UINTX ch1_ctl_drvsegen : 4;
    //
    // Fall TCO c73ddr402_COMP code
    // 
    // Bits[19:14], RW, default = 0x3F
    //
    UINTX ch1_ctl_tcocompfall : 6;
    //
    // Rise TCO c73ddr402_COMP code
    // 
    // Bits[25:20], RW, default = 0x3F
    //
    UINTX ch1_ctl_tcocomprise : 6;
    //
    // dfx legtest enable pin. Allows for independent control of the lower 4 legs of
    // the deley element which are controlled by the decoder. 1: enabled       0 : disabled
    // (default) 
    // 
    // Bits[26:26], RW, default = 0x0
    //
    UINTX ch1_ctl_pbddfxtesten : 1;
    //
    // Reserved
    // 
    // Bits[31:27], RO, default = 0x0
    //
    UINTX reserved : 5;
  } Bits;
  UINTX Data;
} CTL_AFE_CH1_DDRCC0_STRUCT;
#endif // ASM_INC

#define CTLCMD_AFE_CH1_DDRCC0_REG                          0x000003E0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // alert rx enable
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINTX ch1_alert_rxen : 1;
    //
    // Reserved
    // 
    // Bits[31:1], RO, default = 0x0
    //
    UINTX reserved : 31;
  } Bits;
  UINTX Data;
} CTLCMD_AFE_CH1_DDRCC0_STRUCT;
#endif // ASM_INC

#define OBSCFG_CH1_DDRCC0_REG                              0x000003E4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // DIG Buf mux select 0
    // 
    // Bits[3:0], RW, default = 0x0
    //
    UINTX ch1_cmd_digobs0sel : 4;
    //
    // DIG Buf mux select 1
    // 
    // Bits[7:4], RW, default = 0x0
    //
    UINTX ch1_cmd_digobs1sel : 4;
    //
    // DIG Buf mux select 0
    // 
    // Bits[11:8], RW, default = 0x0
    //
    UINTX ch1_ctl_digobs0sel : 4;
    //
    // DIG Buf mux select 1
    // 
    // Bits[15:12], RW, default = 0x0
    //
    UINTX ch1_ctl_digobs1sel : 4;
    //
    // Reserved
    // 
    // Bits[31:16], RO, default = 0x0
    //
    UINTX reserved : 16;
  } Bits;
  UINTX Data;
} OBSCFG_CH1_DDRCC0_STRUCT;
#endif // ASM_INC

#define MRGMODE_CH1_DDRCC0_REG                             0x000004B0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // DFX margin mode TX data phase 0
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINTX ch1_dfxmrgtxd_ph0 : 1;
    //
    // DFX margin mode TX data phase 1
    // 
    // Bits[1:1], RW, default = 0x0
    //
    UINTX ch1_dfxmrgtxd_ph1 : 1;
    //
    // DFX margin mode RX compare values
    // 
    // Bits[9:2], RW, default = 0x0
    //
    UINTX ch1_dfxmrgtxd_cmp : 8;
    //
    // DFX margin mode TX override enable
    // 
    // Bits[10:10], RW, default = 0x0
    //
    UINTX ch1_dfxmrgtx_ovren : 1;
    //
    // DFX margin mode TX write enable
    // 
    // Bits[11:11], RW, default = 0x0
    //
    UINTX ch1_dfxmrgtxwren : 1;
    //
    // DFX margin mode TX strobe data
    // 
    // Bits[13:12], RW, default = 0x0
    //
    UINTX ch1_dfxmrgtxd_strb : 2;
    //
    // Reserved
    // 
    // Bits[31:14], RO, default = 0x0
    //
    UINTX reserved : 18;
  } Bits;
  UINTX Data;
} MRGMODE_CH1_DDRCC0_STRUCT;
#endif // ASM_INC

#define MRGMODE_DB_CH1_DDRCC0_REG                          0x000004B4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // DFX margin mode RX DB compare values
    // 
    // Bits[7:0], RW, default = 0x0
    //
    UINTX ch1_dfxmrgtxd_db_cmp : 8;
    //
    // Reserved
    // 
    // Bits[31:8], RO, default = 0x0
    //
    UINTX reserved : 24;
  } Bits;
  UINTX Data;
} MRGMODE_DB_CH1_DDRCC0_STRUCT;
#endif // ASM_INC

#define CC02_LRCOMP_CFG1_DDRCC0_REG                        0x000005E0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Delay after enabling Rcomp before starting measurement timer
    // 
    // Bits[7:0], RW, default = 0xE
    //
    UINTX reserved : 8;
    //
    // Number of binary search steps
    // 
    // Bits[11:8], RW, default = 0xA
    //
    UINTX reserved_1 : 4;
    //
    // Initial step value for Rcomp binary search
    // 
    // Bits[18:12], RW, default = 0x20
    //
    UINTX lrcomp_initstep : 7;
    //
    // Initial value for Rcomp binary search
    // 
    // Bits[25:19], RW, default = 0x0
    //
    UINTX reserved_2 : 7;
    //
    // Number of times to repeat and average the Rcomp compensation
    // 
    // Bits[30:26], RW, default = 0x1
    //
    UINTX reserved_3 : 5;
    //
    // Reserved bits
    // 
    // Bits[31:31], RO, default = 0x0
    //
    UINTX reserved_4 : 1;
  } Bits;
  UINTX Data;
} CC02_LRCOMP_CFG1_DDRCC0_STRUCT;
#endif // ASM_INC

#define CC02_LRCOMP_CFG2_DDRCC0_REG                        0x000005E4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // indicates the division ratio of the c73ddr402_comp clock w.r.t spid clk
    // 
    // Bits[1:0], RW, default = 0x1
    //
    UINTX reserved : 2;
    //
    // set it to '1' to select the membus form gcomp, '0' to select it from previous
    // module. 
    // 
    // Bits[2:2], RW, default = 0x0
    //
    UINTX reserved_1 : 1;
    //
    // Rcomp sample time 3
    // 
    // Bits[10:3], RW, default = 0xE
    //
    UINTX reserved_2 : 8;
    //
    // Rcomp sample time 2
    // 
    // Bits[18:11], RW, default = 0xE
    //
    UINTX reserved_3 : 8;
    //
    // Rcomp sample time 1
    // 
    // Bits[26:19], RW, default = 0xE
    //
    UINTX reserved_4 : 8;
    //
    // Reserved bits
    // 
    // Bits[31:27], RO, default = 0x0
    //
    UINTX reserved_5 : 5;
  } Bits;
  UINTX Data;
} CC02_LRCOMP_CFG2_DDRCC0_STRUCT;
#endif // ASM_INC

#define CC02_LRCOMP_OVR0_DDRCC0_REG                        0x000005E8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // not used
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINTX reserved : 1;
    //
    // not used
    // 
    // Bits[7:1], RW, default = 0x0
    //
    UINTX reserved_1 : 7;
    //
    // Pull down override enable
    // 
    // Bits[9:8], RW, default = 0x0
    //
    UINTX reserved_2 : 2;
    //
    // Pull up override enable
    // 
    // Bits[11:10], RW, default = 0x0
    //
    UINTX reserved_3 : 2;
    //
    // override enable for override for pull down live rcomp code going to AFE
    // 
    // Bits[12:12], RW, default = 0x0
    //
    UINTX reserved_4 : 1;
    //
    // override for pull down live rcomp code going to AFE
    // 
    // Bits[19:13], RW, default = 0x1
    //
    UINTX reserved_5 : 7;
    //
    // Reserved bits
    // 
    // Bits[31:20], RO, default = 0x0
    //
    UINTX reserved_6 : 12;
  } Bits;
  UINTX Data;
} CC02_LRCOMP_OVR0_DDRCC0_STRUCT;
#endif // ASM_INC

#define CC02_LRCOMP_CTL0_DDRCC0_REG                        0x000005EC
#ifndef ASM_INC
typedef union {
  struct {
    //
    // config contorl for disabling rcomp code per group.
    // 
    // Bits[1:0], RW, default = 0x0
    //
    UINTX reserved : 2;
    //
    // enable for config concifg control for updating rcomp codes.
    // 
    // Bits[2:2], RW, default = 0x0
    //
    UINTX reserved_1 : 1;
    //
    // config control for updating rcomp codes.
    // 
    // Bits[3:3], RW, default = 0x0
    //
    UINTX reserved_2 : 1;
    //
    // not used.
    // 
    // Bits[9:4], RW, default = 0x0
    //
    UINTX reserved_3 : 6;
    //
    // static leg signal for PD c73ddr402_comp buffer.
    // 
    // Bits[10:10], RW, default = 0x1
    //
    UINTX reserved_4 : 1;
    //
    // static live signal for PD c73ddr402_comp buffer.
    // 
    // Bits[11:11], RW, default = 0x1
    //
    UINTX reserved_5 : 1;
    //
    // selects the bus_quiet_time_gnt signal for lcomp buffer.
    // 
    // Bits[13:12], RW, default = 0x1
    //
    UINTX reserved_6 : 2;
    //
    // Reserved bits
    // 
    // Bits[31:14], RO, default = 0x0
    //
    UINTX reserved_7 : 18;
  } Bits;
  UINTX Data;
} CC02_LRCOMP_CTL0_DDRCC0_STRUCT;
#endif // ASM_INC

#define CC02_LRCOMP_CTL1_DDRCC0_REG                        0x000005F0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // enable indirect update, when '1', it enables indirect update for respective group,
    // when '0', it disables indirect update for that group. 
    // 
    // Bits[1:0], RW, default = 0x0
    //
    UINTX reserved : 2;
    //
    // tells the rcomp which groups are valid.
    // 
    // Bits[9:2], RW, default = 0x60
    //
    UINTX reserved_1 : 8;
    //
    // tells the rcomp to copy the adjecent code instead of evaluating it
    // 
    // Bits[17:10], RW, default = 0x0
    //
    UINTX reserved_2 : 8;
    //
    // Reserved bits
    // 
    // Bits[31:18], RO, default = 0x0
    //
    UINTX reserved_3 : 14;
  } Bits;
  UINTX Data;
} CC02_LRCOMP_CTL1_DDRCC0_STRUCT;
#endif // ASM_INC

#define CC02_LRCOMP_RSTCTL_DDRCC0_REG                      0x000005F4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // active low reset for lcomp.
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINTX reserved : 1;
    //
    // Reserved bits
    // 
    // Bits[31:1], RO, default = 0x0
    //
    UINTX reserved_1 : 31;
  } Bits;
  UINTX Data;
} CC02_LRCOMP_RSTCTL_DDRCC0_STRUCT;
#endif // ASM_INC

#define CC02_TXDLYCOMP_CLKGATE_DDRCC0_REG                  0x000005F8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Clock gating control for txdlycomp
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINTX reserved : 1;
    //
    // Clock gating control for rcomp.
    // 
    // Bits[1:1], RW, default = 0x0
    //
    UINTX reserved_1 : 1;
    //
    // Reserved bits
    // 
    // Bits[31:2], RO, default = 0x0
    //
    UINTX reserved_2 : 30;
  } Bits;
  UINTX Data;
} CC02_TXDLYCOMP_CLKGATE_DDRCC0_STRUCT;
#endif // ASM_INC

#define CC02_TXDLYCOMP_INIT_DDRCC0_REG                     0x000005FC
#ifndef ASM_INC
typedef union {
  struct {
    //
    // enable initial txdlycomp
    // 
    // Bits[0:0], RW/1S/V, default = 0x0
    //
    UINTX reserved : 1;
    //
    // Reserved bits
    // 
    // Bits[31:1], RO, default = 0x0
    //
    UINTX reserved_1 : 31;
  } Bits;
  UINTX Data;
} CC02_TXDLYCOMP_INIT_DDRCC0_STRUCT;
#endif // ASM_INC

#define CC02_LRCOMP_DEBUG_DDRCC0_REG                       0x00000600
#ifndef ASM_INC
typedef union {
  struct {
    //
    // debug ctrl bits.
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINTX reserved : 1;
    //
    // debug ctrl bits.
    // 
    // Bits[1:1], RW, default = 0x0
    //
    UINTX reserved_1 : 1;
    //
    // spare bits
    // 
    // Bits[17:2], RW, default = 0x0
    //
    UINTX reserved_2 : 16;
    //
    // Reserved bits
    // 
    // Bits[31:18], RO, default = 0x0
    //
    UINTX reserved_3 : 14;
  } Bits;
  UINTX Data;
} CC02_LRCOMP_DEBUG_DDRCC0_STRUCT;
#endif // ASM_INC

#define CC02_LRCOMP_OVR1_DDRCC0_REG                        0x00000604
#ifndef ASM_INC
typedef union {
  struct {
    //
    // grp1 pull down override code
    // 
    // Bits[6:0], RW, default = 0x0
    //
    UINTX reserved : 7;
    //
    // grp1 pull up override code
    // 
    // Bits[13:7], RW, default = 0x0
    //
    UINTX reserved_1 : 7;
    //
    // grp0 pull down override code
    // 
    // Bits[20:14], RW, default = 0x0
    //
    UINTX reserved_2 : 7;
    //
    // grp0 pull up override code
    // 
    // Bits[27:21], RW, default = 0x0
    //
    UINTX reserved_3 : 7;
    //
    // Reserved bits
    // 
    // Bits[31:28], RO, default = 0x0
    //
    UINTX reserved_4 : 4;
  } Bits;
  UINTX Data;
} CC02_LRCOMP_OVR1_DDRCC0_STRUCT;
#endif // ASM_INC

#define CC02_TXDLYCOMP_0_DDRCC0_REG                        0x00000608
#ifndef ASM_INC
typedef union {
  struct {
    //
    // TBD
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINTX reserved : 1;
    //
    // continuous enable mode for txdlycomp
    // 
    // Bits[1:1], RW, default = 0x0
    //
    UINTX reserved_1 : 1;
    //
    // TBD
    // 
    // Bits[2:2], RW/1C/V, default = 0x0
    //
    UINTX reserved_2 : 1;
    //
    // config value for grp0 fine code.
    // 
    // Bits[10:3], RW, default = 0x0
    //
    UINTX reserved_3 : 8;
    //
    // config value for grp0 coarse code.
    // 
    // Bits[18:11], RW, default = 0x0
    //
    UINTX reserved_4 : 8;
    //
    // bits for override control of grp0 code
    // 
    // Bits[19:19], RW, default = 0x0
    //
    UINTX reserved_5 : 1;
    //
    // bits to disable for group0 code update.
    // 
    // Bits[20:20], RW, default = 0x0
    //
    UINTX reserved_6 : 1;
    //
    // select the delay tap node in AFE for group0
    // 
    // Bits[25:21], RW, default = 0x2
    //
    UINTX reserved_7 : 5;
    //
    // enable for config update contorl for txdlycomp code.
    // 
    // Bits[26:26], RW, default = 0x0
    //
    UINTX reserved_8 : 1;
    //
    // config update contorl for txdlyocmp code
    // 
    // Bits[27:27], RW, default = 0x0
    //
    UINTX reserved_9 : 1;
    //
    // Reserved bits
    // 
    // Bits[31:28], RO, default = 0x0
    //
    UINTX reserved_10 : 4;
  } Bits;
  UINTX Data;
} CC02_TXDLYCOMP_0_DDRCC0_STRUCT;
#endif // ASM_INC

#define CC02_TXDLYCOMP_1_DDRCC0_REG                        0x0000060C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // config value for grp1 fine code.
    // 
    // Bits[7:0], RW, default = 0x0
    //
    UINTX reserved : 8;
    //
    // config value for grp1 coarse code.
    // 
    // Bits[15:8], RW, default = 0x0
    //
    UINTX reserved_1 : 8;
    //
    // bits for override control of grp1 code
    // 
    // Bits[16:16], RW, default = 0x0
    //
    UINTX reserved_2 : 1;
    //
    // bits to disable for group1 code update.
    // 
    // Bits[17:17], RW, default = 0x0
    //
    UINTX reserved_3 : 1;
    //
    // select the delay tap node in AFE for group1
    // 
    // Bits[22:18], RW, default = 0x2
    //
    UINTX reserved_4 : 5;
    //
    // Reserved bits
    // 
    // Bits[31:23], RO, default = 0x0
    //
    UINTX reserved_5 : 9;
  } Bits;
  UINTX Data;
} CC02_TXDLYCOMP_1_DDRCC0_STRUCT;
#endif // ASM_INC

#define CC02_TXDLYCOMPOVR_DDRCC0_REG                       0x00000610
#ifndef ASM_INC
typedef union {
  struct {
    //
    // TX Delay c73ddr402_comp MAX value of fine code.
    // 
    // Bits[3:0], RW, default = 0x8
    //
    UINTX reserved : 4;
    //
    // TX Delay c73ddr402_comp MAX value of coarse code.
    // 
    // Bits[7:4], RW, default = 0x7
    //
    UINTX reserved_1 : 4;
    //
    // Enable for TX Delay ocmp live code override value.
    // 
    // Bits[8:8], RW, default = 0x0
    //
    UINTX reserved_2 : 1;
    //
    // TX Delay c73ddr402_comp live code override value
    // 
    // Bits[16:9], RW, default = 0x0
    //
    UINTX reserved_3 : 8;
    //
    // Reserved bits
    // 
    // Bits[31:17], RO, default = 0x0
    //
    UINTX reserved_4 : 15;
  } Bits;
  UINTX Data;
} CC02_TXDLYCOMPOVR_DDRCC0_STRUCT;
#endif // ASM_INC

#define CC02_LRCOMP_CODES_0_DDRCC0_REG                     0x00000614
#ifndef ASM_INC
typedef union {
  struct {
    //
    // reserved
    // 
    // Bits[7:0], RO/V, default = 0x8
    //
    UINTX reserved : 8;
    //
    // reserved
    // 
    // Bits[15:8], RO/V, default = 0x7
    //
    UINTX reserved_1 : 8;
    //
    // reserved
    // 
    // Bits[23:16], RO/V, default = 0x0
    //
    UINTX reserved_2 : 8;
    //
    // reserved
    // 
    // Bits[31:24], RO/V, default = 0x0
    //
    UINTX reserved_3 : 8;
  } Bits;
  UINTX Data;
} CC02_LRCOMP_CODES_0_DDRCC0_STRUCT;
#endif // ASM_INC

#define CC02_LTXDLYCOMP_CODES_0_DDRCC0_REG                 0x00000618
#ifndef ASM_INC
typedef union {
  struct {
    //
    // reserved
    // 
    // Bits[7:0], RO/V, default = 0x8
    //
    UINTX reserved : 8;
    //
    // reserved
    // 
    // Bits[15:8], RO/V, default = 0x7
    //
    UINTX reserved_1 : 8;
    //
    // reserved
    // 
    // Bits[23:16], RO/V, default = 0x0
    //
    UINTX reserved_2 : 8;
    //
    // reserved
    // 
    // Bits[31:24], RO/V, default = 0x0
    //
    UINTX reserved_3 : 8;
  } Bits;
  UINTX Data;
} CC02_LTXDLYCOMP_CODES_0_DDRCC0_STRUCT;
#endif // ASM_INC

#define CC02_LRCOMP_CTL2_DDRCC0_REG                        0x0000061C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // For future designs, where there might be a need to generate a stage3 enable for
    // AFE. It needs to be '1' otherwise. 
    // 
    // Bits[3:0], RW, default = 0x1
    //
    UINTX reserved : 4;
    //
    // For future designs, where there might be a need to generate a stage3 enable for
    // AFE. It needs to be '1' otherwise. 
    // 
    // Bits[7:4], RW, default = 0x1
    //
    UINTX reserved_1 : 4;
    //
    // For future designs, where there might be a need to generate a stage3 enable for
    // AFE. It needs to be '1' otherwise. 
    // 
    // Bits[11:8], RW, default = 0x1
    //
    UINTX reserved_2 : 4;
    //
    // the number of cycles after lcomp receives the bus_quiet_time_gnt signal, and before
    // it takes any action. This allows the phy to finish off any running read/write
    // cycles 
    // 
    // Bits[18:12], RW, default = 0x1
    //
    UINTX reserved_3 : 7;
    //
    // Reserved bits
    // 
    // Bits[31:19], RO, default = 0x0
    //
    UINTX reserved_4 : 13;
  } Bits;
  UINTX Data;
} CC02_LRCOMP_CTL2_DDRCC0_STRUCT;
#endif // ASM_INC

#define CC02_LRCOMP_CTL3_DDRCC0_REG                        0x00000620
#ifndef ASM_INC
typedef union {
  struct {
    //
    // pull down verf ctrl voltage code for grp1
    // 
    // Bits[5:0], RW, default = 0x20
    //
    UINTX reserved : 6;
    //
    // pull down verf ctrl voltage code for grp0
    // 
    // Bits[11:6], RW, default = 0x20
    //
    UINTX reserved_1 : 6;
    //
    // Masking bit for indirect update for (stg3) stage 3 latches in AFE. Should be always
    // '1' in DNV. 
    // 
    // Bits[12:12], RW, default = 0x1
    //
    UINTX reserved_2 : 1;
    //
    // Reserved bits
    // 
    // Bits[31:13], RO, default = 0x0
    //
    UINTX reserved_3 : 19;
  } Bits;
  UINTX Data;
} CC02_LRCOMP_CTL3_DDRCC0_STRUCT;
#endif // ASM_INC

#define CC02_LRCOMP_CTL4_DDRCC0_REG                        0x00000624
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Length of update pulse = lrcomp_update_len+1 comp_clk cycles
    // 
    // Bits[3:0], RW, default = 0x0
    //
    UINTX reserved : 4;
    //
    // Width of CLK rcomp stage 2 latch enable = lrcomp_clk_stg2_width + 1 comp_clk cycles
    // 
    // Bits[7:4], RW, default = 0x0
    //
    UINTX reserved_1 : 4;
    //
    // Reserved bits
    // 
    // Bits[31:8], RO, default = 0x0
    //
    UINTX reserved_2 : 24;
  } Bits;
  UINTX Data;
} CC02_LRCOMP_CTL4_DDRCC0_STRUCT;
#endif // ASM_INC

#define CC02_LRCOMP_CTL5_DDRCC0_REG                        0x00000628
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Rcomp max value of code. The live code wont go beyond this. If the c73ddr402_comp
    // sm gives a value greater than this, it will be capped to this value. 
    // 
    // Bits[6:0], RW, default = 0x3F
    //
    UINTX reserved : 7;
    //
    // Not used. Reserved for future usage of LCOMP channel enable
    // 
    // Bits[8:7], RW, default = 0x3
    //
    UINTX reserved_1 : 2;
    //
    // Reserved bits
    // 
    // Bits[31:9], RO, default = 0x0
    //
    UINTX reserved_2 : 23;
  } Bits;
  UINTX Data;
} CC02_LRCOMP_CTL5_DDRCC0_STRUCT;
#endif // ASM_INC

#define CC02_TXDLYCOMP_2_DDRCC0_REG                        0x0000062C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Delay after sending timing reference pulse before sampling updn
    // 
    // Bits[7:0], RW, default = 0x0
    //
    UINTX reserved : 8;
    //
    // Delay before sending timing reference pulse
    // 
    // Bits[11:8], RW, default = 0x0
    //
    UINTX reserved_1 : 4;
    //
    // cadence continuous enable mode for txdlycomp
    // 
    // Bits[12:12], RW, default = 0x0
    //
    UINTX reserved_2 : 1;
    //
    // Reserved bits
    // 
    // Bits[31:13], RO, default = 0x0
    //
    UINTX reserved_3 : 19;
  } Bits;
  UINTX Data;
} CC02_TXDLYCOMP_2_DDRCC0_STRUCT;
#endif // ASM_INC


#endif // _DDRCC0_H_
