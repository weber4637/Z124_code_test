/** @file
  File name:    DDRCC1_PHY.h
  Input File:   DNV_MRC.xlsx

  THIS FILE IS AUTO-GENERATED BY THE MSP TOOL. DO NOT CHANGE THIS CODE.

  If edits are needed in this file, they must be done via the MSP tool.

  If there is additional project-specific data required by the MSP, it
  can be placed in DDRCC1_PHY.h, which is used for non-tool-generated
  data

  Includes register defines specific to a project.

  Copyright (c) 2005-2018 Intel Corporation. All rights reserved
  This software and associated documentation (if any) is furnished
  under a license and may only be used or copied in accordance
  with the terms of the license. Except as permitted by such
  license, no part of this software or documentation may be
  reproduced, stored in a retrieval system, or transmitted in any
  form or by any means without the express written consent of
  Intel Corporation.
**/
#ifndef _DDRCC1_PHY_H_
#define _DDRCC1_PHY_H_

#include "DataTypes.h"

#if USE_64_BIT_VARIABLES
#define UINTX UINT64
#else
#define UINTX UINT32
#endif

#define TXDLLCFG0_DDRCC1_PHY_REG                           0x00000000
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Enable 2xclk output to rxdqssdl block for HVM testing
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINTX txdll_2xclkdfxen : 1;
    //
    // Charge pump trim bits. Currently the same as the drvsel[br][br]1600MHz = 010[br]1866MHz
    // = 011[br]2133MHz = 100[br]2400MHz = 101[br]2667MHz = 111 
    // 
    // Bits[3:1], RW, default = 0x1
    //
    UINTX txdll_cptrim : 3;
    //
    // Delay Cell bias strength[br][br]1600MHz = 010[br]1866MHz = 011[br]2133MHz = 100[br]2400MHz
    // = 101[br]2667MHz = 111 
    // 
    // Bits[6:4], RW, default = 0x2
    //
    UINTX txdll_drvsel : 3;
    //
    // Bypasses Master DLL so ref2xclk goes directly to pi outputs
    // 
    // Bits[7:7], RW, default = 0x0
    //
    UINTX txdll_mdllbypassen : 1;
    //
    // MDLL enable, from low to high
    // 
    // Bits[8:8], RW, default = 0x0
    //
    UINTX txdll_mdllen : 1;
    //
    // Set tuning for Phase Interpolator:[br][br]1600MHz = 100[br]1866MHz = 100[br]2133MHz
    // = 101[br]2400MHz = 101[br]2667MHz = 101 
    // 
    // Bits[11:9], RW, default = 0x1
    //
    UINTX txdll_pidrvsel : 3;
    //
    // enable process trim option. currently a placeholder
    // 
    // Bits[12:12], RW, default = 0x0
    //
    UINTX txdll_proctrimen : 1;
    //
    // process trim code
    // 
    // Bits[15:13], RW, default = 0x0
    //
    UINTX txdll_proctrim : 3;
    //
    // hiz pbias to allow overdrive in dfx mode
    // 
    // Bits[16:16], RW, default = 0x0
    //
    UINTX txdll_pbiashizdfxen : 1;
    //
    // hiz nbias to allow overdrive in dfx mode
    // 
    // Bits[17:17], RW, default = 0x0
    //
    UINTX txdll_nbiashizdfxen : 1;
    //
    // Reserved
    // 
    // Bits[31:18], RO, default = 0x0
    //
    UINTX reserved : 14;
  } Bits;
  UINTX Data;
} TXDLLCFG0_DDRCC1_PHY_STRUCT;
#endif // ASM_INC

#define TXDLLCFG1_DDRCC1_PHY_REG                           0x00000004
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Tx ref Bypass ph0 enable. 0: Use PI Clk Output, 1: Bypass and use input 2x clk
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINTX txdll_ref2xph0pibypassen : 1;
    //
    // PI Code for ref PI phase 0 output
    // 
    // Bits[6:1], RW, default = 0x0
    //
    UINTX txdll_ref2xph0picode : 6;
    //
    // Enable TX ref PI phase 0 enable
    // 
    // Bits[7:7], RW, default = 0x0
    //
    UINTX txdll_ref2xph0pien : 1;
    //
    // Enable TX ref PI phase 0 output enable
    // 
    // Bits[8:8], RW, default = 0x0
    //
    UINTX txdll_ref2xph0piouten : 1;
    //
    // Tx ref Bypass ph90 enable. 0: Use PI Clk Output, 1: Bypass and use input 2x clk
    // 
    // Bits[9:9], RW, default = 0x0
    //
    UINTX txdll_ref2xph90pibypassen : 1;
    //
    // PI Code for ref PI phase 90 output
    // 
    // Bits[15:10], RW, default = 0x0
    //
    UINTX txdll_ref2xph90picode : 6;
    //
    // Enable TX ref PI phase 90 enable
    // 
    // Bits[16:16], RW, default = 0x0
    //
    UINTX txdll_ref2xph90pien : 1;
    //
    // Enable TX ref PI phase 90 output enable
    // 
    // Bits[17:17], RW, default = 0x0
    //
    UINTX txdll_ref2xph90piouten : 1;
    //
    // Reserved
    // 
    // Bits[31:18], RO, default = 0x0
    //
    UINTX reserved : 14;
  } Bits;
  UINTX Data;
} TXDLLCFG1_DDRCC1_PHY_STRUCT;
#endif // ASM_INC

#define TXDLLCFG2_DDRCC1_PHY_REG                           0x00000008
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Tx ref Bypass ph180 enable. 0: Use PI Clk Output, 1: Bypass and use input 2x clk
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINTX txdll_ref2xph180pibypassen : 1;
    //
    // PI Code for ref PI phase 180 output
    // 
    // Bits[6:1], RW, default = 0x0
    //
    UINTX txdll_ref2xph180picode : 6;
    //
    // Enable TX ref PI phase 180 enable
    // 
    // Bits[7:7], RW, default = 0x0
    //
    UINTX txdll_ref2xph180pien : 1;
    //
    // Enable TX ref PI phase 180 output enable
    // 
    // Bits[8:8], RW, default = 0x0
    //
    UINTX txdll_ref2xph180piouten : 1;
    //
    // Tx ref Bypass ph270 enable. 0: Use PI Clk Output, 1: Bypass and use input 2x clk
    // 
    // Bits[9:9], RW, default = 0x0
    //
    UINTX txdll_ref2xph270pibypassen : 1;
    //
    // PI Code for ref PI phase 270 output
    // 
    // Bits[15:10], RW, default = 0x0
    //
    UINTX txdll_ref2xph270picode : 6;
    //
    // Enable TX ref PI phase 270 enable
    // 
    // Bits[16:16], RW, default = 0x0
    //
    UINTX txdll_ref2xph270pien : 1;
    //
    // Enable TX ref PI phase 270 output enable
    // 
    // Bits[17:17], RW, default = 0x1
    //
    UINTX txdll_ref2xph270piouten : 1;
    //
    // Reserved
    // 
    // Bits[31:18], RO, default = 0x0
    //
    UINTX reserved : 14;
  } Bits;
  UINTX Data;
} TXDLLCFG2_DDRCC1_PHY_STRUCT;
#endif // ASM_INC

#define TXDLLCFG5_DDRCC1_PHY_REG                           0x0000000C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Byte0 Group[5:0] Bypass enable. 0: Use PI Clk Output, 1: Bypass and use ref clk
    // 
    // Bits[11:0], RW, default = 0x0
    //
    UINTX txdll_siggrppibypassen : 12;
    //
    // DLL Startup signal is high for these many cycles after mdllen goes high:   00
    // (64 cycles)    01 (16 cycles)   10 (32 cycles)   11 (128 cycles) 
    // 
    // Bits[13:12], RW, default = 0x0
    //
    UINTX txdll_starttimesel : 2;
    //
    // Weak Lock enable
    // 
    // Bits[14:14], RW, default = 0x0
    //
    UINTX txdll_weaklocken : 1;
    //
    // 1 = prevents biasgen going into halfmode even in weaklock. 0= biasgen goes into
    // halfmode during weaklock 
    // 
    // Bits[15:15], RW, default = 0x0
    //
    UINTX txdll_weaklockhalfmodegate : 1;
    //
    // Allows nbiasgen to be set in halfmode outside of weaklock
    // 
    // Bits[16:16], RW, default = 0x0
    //
    UINTX txdll_weaklockhalfmodeoverride : 1;
    //
    // invert clk going into refmask related flops
    // 
    // Bits[17:17], RW, default = 0x0
    //
    UINTX txdll_weaklockrefmaskclkinvert : 1;
    //
    // Reserved
    // 
    // Bits[31:18], RO, default = 0x0
    //
    UINTX reserved : 14;
  } Bits;
  UINTX Data;
} TXDLLCFG5_DDRCC1_PHY_STRUCT;
#endif // ASM_INC

#define TXDLLCFG6_DDRCC1_PHY_REG                           0x00000010
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Enable TX Signal group[11:0] Phase Interpolator
    // 
    // Bits[11:0], RW, default = 0x0
    //
    UINTX txdll_siggrppien : 12;
    //
    // Enable TX Signal group[11:0] output
    // 
    // Bits[23:12], RW, default = 0x0
    //
    UINTX txdll_siggrppiouten : 12;
    //
    // Select how many clk cycles before stopping weaklock and enabling phase detector
    // 
    // Bits[26:24], RW, default = 0x0
    //
    UINTX txdll_weaklockrefmaskdly : 3;
    //
    // invert clk going into vcdl clock gating related flops
    // 
    // Bits[27:27], RW, default = 0x0
    //
    UINTX txdll_weaklockvcdlgateclkinvert : 1;
    //
    // Reserved
    // 
    // Bits[31:28], RO, default = 0x0
    //
    UINTX reserved : 4;
  } Bits;
  UINTX Data;
} TXDLLCFG6_DDRCC1_PHY_STRUCT;
#endif // ASM_INC

#define TXDLLCFG7_DDRCC1_PHY_REG                           0x00000014
#ifndef ASM_INC
typedef union {
  struct {
    //
    // analog select mux for output 0
    // 
    // Bits[2:0], RW, default = 0x0
    //
    UINTX txdll_anaobs0sel : 3;
    //
    // analog select mux for output 1
    // 
    // Bits[5:3], RW, default = 0x0
    //
    UINTX txdll_anaobs1sel : 3;
    //
    // DFX digital 0 mux select
    // 
    // Bits[11:6], RW, default = 0x0
    //
    UINTX txdll_digobs0sel : 6;
    //
    // DFX digital 1 mux select
    // 
    // Bits[17:12], RW, default = 0x0
    //
    UINTX txdll_digobs1sel : 6;
    //
    // Reserved
    // 
    // Bits[31:18], RO, default = 0x0
    //
    UINTX reserved : 14;
  } Bits;
  UINTX Data;
} TXDLLCFG7_DDRCC1_PHY_STRUCT;
#endif // ASM_INC

#define RXVREFCFG_DDRCC1_PHY_REG                           0x00000018
#ifndef ASM_INC
typedef union {
  struct {
    //
    // VREF Code
    // 
    // Bits[5:0], RW, default = 0x20
    //
    UINTX rxvref_vrefctrl : 6;
    //
    // Enable VREF
    // 
    // Bits[6:6], RW, default = 0x0
    //
    UINTX rxvref_vrefen : 1;
    //
    // Range select to pick between DDR3 and DDR4. [br]0 - DDR3 (Default)  [br]1- DDR4
    // 
    // Bits[7:7], RW, default = 0x0
    //
    UINTX rxvref_vrefrangesel : 1;
    //
    // Reserved
    // 
    // Bits[31:8], RO, default = 0x0
    //
    UINTX reserved : 24;
  } Bits;
  UINTX Data;
} RXVREFCFG_DDRCC1_PHY_STRUCT;
#endif // ASM_INC

#define RSTBCFG_DDRCC1_PHY_REG                             0x0000001C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Set for the buffer
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINTX rstbtx_set : 1;
    //
    // Reset control for the buffer
    // 
    // Bits[1:1], RW, default = 0x0
    //
    UINTX rstbtx_reset : 1;
    //
    // Tri-state control for Reset buffer (DFX).
    // 
    // Bits[2:2], RW, default = 0x0
    //
    UINTX rstbtx_enb : 1;
    //
    // DFX for Reset receiver.
    // 
    // Bits[3:3], RW, default = 0x0
    //
    UINTX rstbrx_diffampen : 1;
    //
    // Reserved
    // 
    // Bits[31:4], RO, default = 0x0
    //
    UINTX reserved : 28;
  } Bits;
  UINTX Data;
} RSTBCFG_DDRCC1_PHY_STRUCT;
#endif // ASM_INC

#define MPLLCFG0_DDRCC1_PHY_REG                            0x00000020
#ifndef ASM_INC
typedef union {
  struct {
    //
    // multiplexer muxf 0.5x/1x clock bypass input select
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINTX mpll_1xor0p5xbypclksel : 1;
    //
    // 0.5x/1x clock tree drive output enable
    // 
    // Bits[1:1], RW, default = 0x0
    //
    UINTX mpll_1xor0p5xclken : 1;
    //
    // mplldivs 1xor0p5xclk multiplexer select (muxb). not part of adpll.
    // 
    // Bits[3:2], RW, default = 0x3
    //
    UINTX mpll_1xor0p5xclkmuxsel : 2;
    //
    // 0.5x/1x clock d-unit output enable
    // 
    // Bits[4:4], RW, default = 0x0
    //
    UINTX mpll_1xor0p5xsocclken : 1;
    //
    // multiplexer muxe 2x clock bypass input select
    // 
    // Bits[5:5], RW, default = 0x0
    //
    UINTX mpll_2xbypclksel : 1;
    //
    // mplldivs 2xclk output post divider enable (divc). not part of adpll.
    // 
    // Bits[6:6], RW, default = 0x0
    //
    UINTX mpll_2xclkdiven : 1;
    //
    // mplldivs 2xclk output post divider ratio select (divc);used for deriving 0.5x/1x
    // clock in some modes of operation. not part of adpll. 
    // 
    // Bits[9:7], RW, default = 0x4
    //
    UINTX mpll_2xclkdivsel : 3;
    //
    // 2x clock tree drive output enable
    // 
    // Bits[10:10], RW, default = 0x0
    //
    UINTX mpll_2xclken : 1;
    //
    // mplldivs 2xclk long loop feedback div-by-2 enable (divd). only used in some modes.
    // not part of adpll. 
    // 
    // Bits[11:11], RW, default = 0x0
    //
    UINTX mpll_2xclklongloopdiven : 1;
    //
    // mplldivs 2xclk multiplexer select (muxc). not part of adpll.
    // 
    // Bits[13:12], RW, default = 0x1
    //
    UINTX mpll_2xclkmuxsel : 2;
    //
    // mplldivs feedback divider enable (divb). not part of adpll.
    // 
    // Bits[14:14], RW, default = 0x0
    //
    UINTX mpll_fbdiven : 1;
    //
    // mplldivs feedback divider ratio select (divb). sometimes other dividers such as
    // the adpll dividers can be in series with this divider. not part of adpll. 
    // 
    // Bits[19:15], RW, default = 0x4
    //
    UINTX mpll_fbdivsel : 5;
    //
    // mplldivs feedback multiplexer select (muxa). not part of adpll.
    // 
    // Bits[21:20], RW, default = 0x0
    //
    UINTX mpll_fbmuxsel : 2;
    //
    // mplldivs divider reset bar
    // 
    // Bits[22:22], RW, default = 0x0
    //
    UINTX mpll_mplldivsrstb : 1;
    //
    // mplldivs reference divider enable (diva). not part of adpll.
    // 
    // Bits[23:23], RW, default = 0x0
    //
    UINTX mpll_refdiven : 1;
    //
    // mplldivs reference divider ratio select (diva). not part of adpll.
    // 
    // Bits[28:24], RW, default = 0x2
    //
    UINTX mpll_refdivsel : 5;
    //
    // mplldivs reference multiplexer select (muxd). not part of adpll.
    // 
    // Bits[30:29], RW, default = 0x0
    //
    UINTX mpll_refmuxsel : 2;
    //
    // Reset-bar for ref2xclk divider logic. Delay matched to ref2xclk0 through CKEBB
    // and TXDLL. Combined with PM control 
    // 
    // Bits[31:31], RW, default = 0x0
    //
    UINTX mpll_divrawrstb : 1;
  } Bits;
  UINTX Data;
} MPLLCFG0_DDRCC1_PHY_STRUCT;
#endif // ASM_INC

#define MPLLCFG1_DDRCC1_PHY_REG                            0x00000024
#ifndef ASM_INC
typedef union {
  struct {
    //
    // ADPLL Enable.
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINTX adpll_pllen : 1;
    //
    // reserved
    // 
    // Bits[1:1], RW, default = 0x0
    //
    UINTX adpll_sfron : 1;
    //
    // indicator for a violation in pll (overflow issues;pll lost lock;etc). routed also
    // to visa. details of the violation could be found in visa outputs 
    // 
    // Bits[2:2], RO/V, default = 0x0
    //
    UINTX adpll_errorflag : 1;
    //
    // lock indicator. routed also to visa
    // 
    // Bits[3:3], RO/V, default = 0x0
    //
    UINTX adpll_plllock : 1;
    //
    // o_locktimer asserts after the coresponding ip pll lock time spec (in refclk cycles)
    // starting from i_refclk_ack assertion and after all cold boot calibration sequence
    // done. i_locktimercnt_th would determine the number of refclk cycles 
    // 
    // Bits[4:4], RO/V, default = 0x0
    //
    UINTX adpll_plltimerlock : 1;
    //
    // Divsyncrstb clock enable
    // 
    // Bits[5:5], RW, default = 0x1
    //
    UINTX mpll_divsyncen : 1;
    //
    // Reserved
    // 
    // Bits[31:6], RO, default = 0x0
    //
    UINTX reserved : 26;
  } Bits;
  UINTX Data;
} MPLLCFG1_DDRCC1_PHY_STRUCT;
#endif // ASM_INC

#define OBSCFG_DDRCC1_PHY_REG                              0x00000028
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Select signal for Analog Obs mux A.
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINTX cx_anaobs0sel : 1;
    //
    // Select signal for Analog Obs mux B.
    // 
    // Bits[1:1], RW, default = 0x0
    //
    UINTX cx_anaobs1sel : 1;
    //
    // Select signal for Digital Obs mux A.
    // 
    // Bits[8:2], RW, default = 0x0
    //
    UINTX cx_digobs0sel : 7;
    //
    // Select signal for Digital Obs mux B.
    // 
    // Bits[15:9], RW, default = 0x0
    //
    UINTX cx_digobs1sel : 7;
    //
    // select signal for analog obs mux a.
    // 
    // Bits[19:16], RW, default = 0x0
    //
    UINTX lcomp_anaobs0sel : 4;
    //
    // select signal for analog obs mux b.
    // 
    // Bits[23:20], RW, default = 0x0
    //
    UINTX lcomp_anaobs1sel : 4;
    //
    // select signal for digital obs mux a.
    // 
    // Bits[27:24], RW, default = 0x0
    //
    UINTX lcomp_digobs0sel : 4;
    //
    // select signal for digital obs mux b.
    // 
    // Bits[31:28], RW, default = 0x0
    //
    UINTX lcomp_digobs1sel : 4;
  } Bits;
  UINTX Data;
} OBSCFG_DDRCC1_PHY_STRUCT;
#endif // ASM_INC

#define GCOMP_CFG0_DDRCC1_PHY_REG                          0x0000002C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // CLK buffer rcomp pull-up Vref control setting
    // 
    // Bits[7:0], RW, default = 0x0
    //
    UINTX gcomp_pup_clk_vrefctrl : 8;
    //
    // CTL buffer rcomp pull-up Vref control setting
    // 
    // Bits[15:8], RW, default = 0x0
    //
    UINTX gcomp_pup_ctl_vrefctrl : 8;
    //
    // CMD buffer rcomp pull-up Vref control setting
    // 
    // Bits[23:16], RW, default = 0x0
    //
    UINTX gcomp_pup_cmd_vrefctrl : 8;
    //
    // DQ buffer rcomp pull-up Vref control setting
    // 
    // Bits[29:24], RW, default = 0x0
    //
    UINTX gcomp_pup_dq_vrefctrl : 6;
    //
    // Reserved
    // 
    // Bits[31:30], RO, default = 0x0
    //
    UINTX reserved : 2;
  } Bits;
  UINTX Data;
} GCOMP_CFG0_DDRCC1_PHY_STRUCT;
#endif // ASM_INC

#define GCOMP_CFG1_DDRCC1_PHY_REG                          0x00000030
#ifndef ASM_INC
typedef union {
  struct {
    //
    // DQS buffer rcomp pull-up Vref control setting
    // 
    // Bits[7:0], RW, default = 0x0
    //
    UINTX gcomp_pup_dqs_vrefctrl : 8;
    //
    // DQ ODT rcomp pull-up Vref control setting
    // 
    // Bits[15:8], RW, default = 0x0
    //
    UINTX gcomp_pup_dqodt_vrefctrl : 8;
    //
    // DQS ODT rcomp pull-up Vref control setting
    // 
    // Bits[23:16], RW, default = 0x0
    //
    UINTX gcomp_pup_dqsodt_vrefctrl : 8;
    //
    // PUP Static Bit Live Code from FSM. DDR3L/3U : ODT - 0100; DQ - 1111; CMD - 1000
    //  && DDR4 : ODT - 1111(40-60)  & 0100 (60-120);  DQ - 1111; CMD - 1000. AJC NOTE:
    // THIS WILL PROBABLY CHANGE FOR 0P8 
    // 
    // Bits[26:24], RW, default = 0x7
    //
    UINTX gcomp_puprcompstaticlive_a0a1 : 3;
    //
    // PUP RCOMP: DFT pin to discharge RCOMP pad to ground during per leg test modes
    // 
    // Bits[27:27], RW, default = 0x0
    //
    UINTX gcomp_dftnmostognd : 1;
    //
    // vrefrangesel
    // 
    // Bits[28:28], RW, default = 0x1
    //
    UINTX gcomp_vrefrangesel : 1;
    //
    // Reserved
    // 
    // Bits[31:29], RO, default = 0x0
    //
    UINTX reserved : 3;
  } Bits;
  UINTX Data;
} GCOMP_CFG1_DDRCC1_PHY_STRUCT;
#endif // ASM_INC

#define GCOMP_CFG2_DDRCC1_PHY_REG                          0x00000034
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Analog Observation Mux A Output
    // 
    // Bits[3:0], RW, default = 0x0
    //
    UINTX gcomp_anaobs0sel : 4;
    //
    // Analog Observation Mux B Output
    // 
    // Bits[7:4], RW, default = 0x0
    //
    UINTX gcomp_anaobs1sel : 4;
    //
    // Digital Observation Mux A Output
    // 
    // Bits[11:8], RW, default = 0x0
    //
    UINTX gcomp_digobs0sel : 4;
    //
    // Digital Observation Mux B Output
    // 
    // Bits[15:12], RW, default = 0x0
    //
    UINTX gcomp_digobs1sel : 4;
    //
    // Reserved
    // 
    // Bits[31:16], RO, default = 0x0
    //
    UINTX reserved : 16;
  } Bits;
  UINTX Data;
} GCOMP_CFG2_DDRCC1_PHY_STRUCT;
#endif // ASM_INC

#define LCOMP_CFG0_DDRCC1_PHY_REG                          0x00000038
#ifndef ASM_INC
typedef union {
  struct {
    //
    // scr_lcomp_pdn_clk_vrefctrl[7:0]
    // 
    // Bits[7:0], RW, default = 0x0
    //
    UINTX lcomp_pdn_clk_vrefctrl : 8;
    //
    // scr_lcomp_pdn_ctl_vrefctrl[7:0]
    // 
    // Bits[15:8], RW, default = 0x0
    //
    UINTX lcomp_pdn_ctl_vrefctrl : 8;
    //
    // scr_lcomp_pdn_cmd_vrefctrl[7:0]
    // 
    // Bits[23:16], RW, default = 0x0
    //
    UINTX lcomp_pdn_cmd_vrefctrl : 8;
    //
    // scr_lcomp_clk_tapsel[4:0]
    // 
    // Bits[28:24], RW, default = 0x0
    //
    UINTX lcomp_clk_tapsel : 5;
    //
    // Reserved
    // 
    // Bits[31:29], RO, default = 0x0
    //
    UINTX reserved : 3;
  } Bits;
  UINTX Data;
} LCOMP_CFG0_DDRCC1_PHY_STRUCT;
#endif // ASM_INC

#define LCOMP_CFG1_DDRCC1_PHY_REG                          0x0000003C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // scr_lcomp_ctl_tapsel[4:0]
    // 
    // Bits[4:0], RW, default = 0x0
    //
    UINTX lcomp_ctl_tapsel : 5;
    //
    // scr_lcomp_cmd_tapsel[4:0]
    // 
    // Bits[9:5], RW, default = 0x0
    //
    UINTX lcomp_cmd_tapsel : 5;
    //
    // RCOMP PDN Static Bit Live Code from FSM. AJC NOTE: THIS WILL PROBABLY CHANGE FOR
    // 0P8 
    // 
    // Bits[12:10], RW, default = 0x7
    //
    UINTX lcomp_pdnrcompstaticlive : 3;
    //
    // Pull-up RCOMP code for driver static leg: Used for PDN Rcomp. AJC NOTE: THIS WILL
    // PROBABLY CHANGE FOR 0P8 
    // 
    // Bits[15:13], RW, default = 0x7
    //
    UINTX lcomp_puprcompstatic : 3;
    //
    // DCOMP DFT pin to enable a static leg check for the delay cell.
    // 
    // Bits[16:16], RW, default = 0x1
    //
    UINTX lcomp_dlycellstaticlegen : 1;
    //
    // dfx legtest enable pin. Allows for independent control of the lower 4 legs of
    // the deley element which are controlled by the decoder. 1: enabled       0 : disabled
    // (default) 
    // 
    // Bits[17:17], RW, default = 0x0
    //
    UINTX lcomp_pbddfxtesten : 1;
    //
    // vrefrangesel
    // 
    // Bits[18:18], RW, default = 0x1
    //
    UINTX lcomp_vrefrangesel : 1;
    //
    // new pin for testing each of the driver legs individually during per leg testing
    // mode. 
    // 
    // Bits[19:19], RW, default = 0x1
    //
    UINTX lcomp_drvseg0en : 1;
    //
    // Reserved
    // 
    // Bits[31:20], RO, default = 0x0
    //
    UINTX reserved : 12;
  } Bits;
  UINTX Data;
} LCOMP_CFG1_DDRCC1_PHY_STRUCT;
#endif // ASM_INC

#define COMP_RST_DDRCC1_PHY_REG                            0x00000040
#ifndef ASM_INC
typedef union {
  struct {
    //
    // c73ddr402_Comp unit reset-bar. Combined with PM reset control
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINTX comprst_b : 1;
    //
    // Reserved
    // 
    // Bits[31:1], RO, default = 0x0
    //
    UINTX reserved : 31;
  } Bits;
  UINTX Data;
} COMP_RST_DDRCC1_PHY_STRUCT;
#endif // ASM_INC

#define CRI_CLKGATECFG_DDRCC1_PHY_REG                      0x00000044
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Idle count limit for ISM which is determines when the block should transition
    // to IDLE_REQ. Recommended value = 8'd16. A value of zero breaks the design resulting
    // in an unresponsive endpoint. 
    // 
    // Bits[7:0], RW, default = 0x10
    //
    UINTX cgctrl_idlecnt : 8;
    //
    // Clock gate defeature. When set to 1, disables side_clk gating within the endpoint
    // when ISM is IDLE. Set to 0 for normal operation. Recommended value = 0 
    // 
    // Bits[8:8], RW, default = 0x1
    //
    UINTX cgctrl_clkgatedef : 1;
    //
    // Clock gate enable. When set to 1, enables the ISM to leave ACTIVE and gates the
    // side_clk if in the IDLE state. When set to 0, the ISM never leaves ACTIVE once
    // it gets to that state and the clock is never gated. Recommended value = 1. 
    // 
    // Bits[9:9], RW, default = 0x1
    //
    UINTX cgctrl_clkgaten : 1;
    //
    // Reserved
    // 
    // Bits[31:10], RO, default = 0x0
    //
    UINTX reserved : 22;
  } Bits;
  UINTX Data;
} CRI_CLKGATECFG_DDRCC1_PHY_STRUCT;
#endif // ASM_INC

#define CRI_PGATECFG_DDRCC1_PHY_REG                        0x00000048
#ifndef ASM_INC
typedef union {
  struct {
    //
    // CRI Power Gating Enable. When set to '1' - CRI Power gating logic is enabled.
    // When set to '0' - CRI Power gating logic is disabled. Not used on DNV: set to
    // 0 
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINTX cripgen : 1;
    //
    // Config override for staggered power gate enable. When set to '1' cripgen_staggered[3:0]
    // is equal to the value set in cripgen_staggered register field. When set to '0',
    // cripgen_staggered[3:0] is equal to the logic defined value. 
    // 
    // Bits[1:1], RW, default = 0x0
    //
    UINTX cripgen_staggered_ovr : 1;
    //
    // Config control for staggered power gate enable. This config value is used for
    // the cripgen_staggered[3:0] when config override in cripgen_staggered_ovr is set
    // to '1'. This value is ignored if cripgen_staggered_ovr is set to '0'. 
    // 
    // Bits[5:2], RW, default = 0x0
    //
    UINTX cripgen_staggered : 4;
    //
    // Config override for isolation enable. This config value is used for isol_en when
    // config override in cripg_isolen_ovr is set to '1'. This value is ignored if cripg_isolen_ovr
    // is set to '0'. 
    // 
    // Bits[6:6], RW, default = 0x0
    //
    UINTX cripg_isolen_ovr : 1;
    //
    // Config control for isolation enable. This config value is used for isol_en when
    // config override in cripg_isolen_ovr is set to '1'. This value is ignored if cripg_isolen_ovr
    // is set to '0'. 
    // 
    // Bits[7:7], RW, default = 0x0
    //
    UINTX cripg_isolen : 1;
    //
    // Config control for side clock req. This config value is used to override o_side_clkreq.
    // When this config bit is set to '1', o_side_clkreq is set to '1' except when in
    // CLKREQDSRT state of the CRIPG FSM 
    // 
    // Bits[8:8], RW, default = 0x0
    //
    UINTX cripg_side_clkreq_ovr : 1;
    //
    // Config control for side clock req. This config value is used to override o_side_clkreq.
    // When this config bit is set to '1', o_side_clkreq is set to '1' except when in
    // CLKREQDSRT state of the CRIPG FSM 
    // 
    // Bits[9:9], RW, default = 0x0
    //
    UINTX cripg_clkgaten_ovr : 1;
    //
    // Reserved
    // 
    // Bits[31:10], RO, default = 0x0
    //
    UINTX reserved : 22;
  } Bits;
  UINTX Data;
} CRI_PGATECFG_DDRCC1_PHY_STRUCT;
#endif // ASM_INC

#define CRI_PGDELAY0_DDRCC1_PHY_REG                        0x0000004C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // When both fabric and agent ISMs are idle. This delay indicates the no. of cycle
    // the FSMs need to be idle after receiving clkack before entering power gating flow.
    // A value of zero breaks the design resulting in an unresponsive powergating control.
    // 
    // Bits[7:0], RW, default = 0x14
    //
    UINTX cripg_ism_idle_dly : 8;
    //
    // On wakeup, this indicates the no. of cycles that FSM stays in PWRUGCLKACK after
    // receiving clkack. A value of zero breaks the design resulting in an unresponsive
    // powergating control. 
    // 
    // Bits[15:8], RW, default = 0x3
    //
    UINTX cripg_clkreq_dsrt_dly : 8;
    //
    // No. of cycles after agent ism idle lock/unlock before FSM moves on from ISMLOCK/ISMUNLOCK.
    // A value of zero breaks the design resulting in an unresponsive powergating control.
    // 
    // Bits[18:16], RW, default = 0x3
    //
    UINTX cripg_ism_lock_dly : 3;
    //
    // No. of cycles after staggered reset assertion/de-assertion before FSM moves on
    // from RSTASRT/RSTDSRT. A value of zero breaks the design resulting in an unresponsive
    // powergating control. 
    // 
    // Bits[21:19], RW, default = 0x2
    //
    UINTX cripg_rst_asrt_dly : 3;
    //
    // No. of cycles after isolation cells are enabled/disabled before FSM moves on from
    // ISOLEN/ISOLDIS. A value of zero breaks the design resulting in an unresponsive
    // powergating control. 
    // 
    // Bits[23:22], RW, default = 0x2
    //
    UINTX cripg_isol_en_dly : 2;
    //
    // Reserved
    // 
    // Bits[31:24], RO, default = 0x0
    //
    UINTX reserved : 8;
  } Bits;
  UINTX Data;
} CRI_PGDELAY0_DDRCC1_PHY_STRUCT;
#endif // ASM_INC

#define CRI_PGDELAY1_DDRCC1_PHY_REG                        0x00000050
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Delay for staggered power gate disable. Determines the number of cycles interval
    // between each power gate enable bit being de-asserted. Cripgctrl FSM is in PWRUNGATE
    // state. A value of zero breaks the design resulting in an unresponsive powergating
    // control. 
    // 
    // Bits[2:0], RW, default = 0x1
    //
    UINTX cripg_disable_stgdly : 3;
    //
    // Delay for staggered power gate enable. Determines the number of cycles interval
    // between each power gate enable bit being asserted. Cripgctrl FSM is in PWRGATE
    // state. A value of zero breaks the design resulting in an unresponsive powergating
    // control. 
    // 
    // Bits[5:3], RW, default = 0x1
    //
    UINTX cripg_enable_stgdly : 3;
    //
    // Delay for staggered power gate enable. Determines the number of cycles interval
    // between each power gate enable bit being asserted. Cripgctrl FSM is in PWRGATE
    // state. Value of 0 not supported. 
    // 
    // Bits[13:6], RW, default = 0x3
    //
    UINTX cripg_clkgaten_dly : 8;
    //
    // Reserved
    // 
    // Bits[31:14], RO, default = 0x0
    //
    UINTX reserved : 18;
  } Bits;
  UINTX Data;
} CRI_PGDELAY1_DDRCC1_PHY_STRUCT;
#endif // ASM_INC

#define DIGCTL_CMN_DDRCC1_PHY_REG                          0x00000054
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Ref2x divider counters async reset-bar. This is used to reset the flops of the
    // dividers counters. 
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINTX cmn_clkgenrst_b : 1;
    //
    // Reserved
    // 
    // Bits[31:1], RO, default = 0x0
    //
    UINTX reserved : 31;
  } Bits;
  UINTX Data;
} DIGCTL_CMN_DDRCC1_PHY_STRUCT;
#endif // ASM_INC

#define SPIDCLK_CTRL_DDRCC1_PHY_REG                        0x00000058
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Spidclk Request
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINTX spidclk_clkreq : 1;
    //
    // Reserved
    // 
    // Bits[31:1], RO, default = 0x0
    //
    UINTX reserved : 31;
  } Bits;
  UINTX Data;
} SPIDCLK_CTRL_DDRCC1_PHY_STRUCT;
#endif // ASM_INC

#define SPIDCLK_CTRL1_DDRCC1_PHY_REG                       0x0000005C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // spidclk PLL selection
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINTX spidclk_pllsel : 1;
    //
    // Reserved
    // 
    // Bits[31:1], RO, default = 0x0
    //
    UINTX reserved : 31;
  } Bits;
  UINTX Data;
} SPIDCLK_CTRL1_DDRCC1_PHY_STRUCT;
#endif // ASM_INC

#define ADPLL_CMN_CTRL0_DDRCC1_PHY_REG                     0x00000060
#ifndef ASM_INC
typedef union {
  struct {
    //
    // force clock gating off in all modes
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINTX adpll_cmn_clkgateenb : 1;
    //
    // Reserved
    // 
    // Bits[31:1], RO, default = 0x0
    //
    UINTX reserved : 31;
  } Bits;
  UINTX Data;
} ADPLL_CMN_CTRL0_DDRCC1_PHY_STRUCT;
#endif // ASM_INC

#define ADPLL_CMN_CTRL1_DDRCC1_PHY_REG                     0x00000064
#ifndef ASM_INC
typedef union {
  struct {
    //
    // enable sigma delta
    // 
    // Bits[0:0], RW, default = 0x1
    //
    UINTX adpll_cmn_dcoditheren : 1;
    //
    // select sigma delta over sampling clock
    // 
    // Bits[2:1], RW, default = 0x0
    //
    UINTX adpll_cmn_dcoditherclksel : 2;
    //
    // long loop clock select through dcoclk_ext clock
    // 
    // Bits[3:3], RW, default = 0x0
    //
    UINTX adpll_cmn_dcoclkextsel : 1;
    //
    // forces dco calibration when exiting deep sleep mode. required if changing feedback
    // divider ratio or refclk frequency 
    // 
    // Bits[4:4], RW, default = 0x1
    //
    UINTX adpll_cmn_dcocal : 1;
    //
    // Reserved
    // 
    // Bits[31:5], RO, default = 0x0
    //
    UINTX reserved : 27;
  } Bits;
  UINTX Data;
} ADPLL_CMN_CTRL1_DDRCC1_PHY_STRUCT;
#endif // ASM_INC

#define ADPLL_CMN_CTRL2_DDRCC1_PHY_REG                     0x00000068
#ifndef ASM_INC
typedef union {
  struct {
    //
    // flag indicator driven by the ip to flag that ip core power is gated
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINTX adpll_cmn_firewallen : 1;
    //
    // defines distance of fine code from edges that would trigger sfr trimming. distance
    // defined by 2^(fine_limit+5) 
    // 
    // Bits[2:1], RW, default = 0x1
    //
    UINTX adpll_cmn_finelimit : 2;
    //
    // force feedback divider reset off in all modes
    // 
    // Bits[3:3], RW, default = 0x0
    //
    UINTX adpll_cmn_fbdivrstenb : 1;
    //
    // generic 8bit feedback divider ratio. n=i_fbdivratio
    // 
    // Bits[11:4], RW, default = 0xC
    //
    UINTX adpll_cmn_fbdivratio : 8;
    //
    // external feedback clock select (allowing use of external feedback divider). in
    // this case;user must set fbdivratio to the feedback ratio he uses 
    // 
    // Bits[12:12], RW, default = 0x0
    //
    UINTX adpll_cmn_fbclkextsel : 1;
    //
    // Reserved
    // 
    // Bits[31:13], RO, default = 0x0
    //
    UINTX reserved : 19;
  } Bits;
  UINTX Data;
} ADPLL_CMN_CTRL2_DDRCC1_PHY_STRUCT;
#endif // ASM_INC

#define ADPLL_CMN_CTRL3_DDRCC1_PHY_REG                     0x0000006C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // kp filter coefficient;2^n. two's complement
    // 
    // Bits[3:0], RW, default = 0xF
    //
    UINTX adpll_cmn_propcoeff : 4;
    //
    // kp scaling during startup for faster lock (2^n)
    // 
    // Bits[5:4], RW, default = 0x1
    //
    UINTX adpll_cmn_kpscale : 2;
    //
    // controls number of refclk cycles at startup at which kp and ki are scaled up for
    // faster lock (kpscale;kiscale) 
    // 
    // Bits[7:6], RW, default = 0x1
    //
    UINTX adpll_cmn_kpkiscalecnt : 2;
    //
    // ki scaling during startup for faster lock (2^n)
    // 
    // Bits[9:8], RW, default = 0x2
    //
    UINTX adpll_cmn_kiscale : 2;
    //
    // ki filter coefficient;2^n. two's complement
    // 
    // Bits[14:10], RW, default = 0x1B
    //
    UINTX adpll_cmn_intcoeff : 5;
    //
    // Reserved
    // 
    // Bits[31:15], RO, default = 0x0
    //
    UINTX reserved : 17;
  } Bits;
  UINTX Data;
} ADPLL_CMN_CTRL3_DDRCC1_PHY_STRUCT;
#endif // ASM_INC

#define ADPLL_CMN_CTRL4_DDRCC1_PHY_REG                     0x00000070
#ifndef ASM_INC
typedef union {
  struct {
    //
    // phase error threshold at which pll is unlocked (hh max pe allowed)
    // 
    // Bits[1:0], RW, default = 0x2
    //
    UINTX adpll_cmn_lockwdetwin : 2;
    //
    // set this bus to the number of refclk cycles after which the o_locktimer is asserted;
    // 
    // Bits[8:2], RW, default = 0x43
    //
    UINTX adpll_cmn_locktimercntth : 7;
    //
    // lock counter 32 (l) or 64 (h) cycles
    // 
    // Bits[9:9], RW, default = 0x0
    //
    UINTX adpll_cmn_lockdetcnt : 1;
    //
    // Reserved
    // 
    // Bits[31:10], RO, default = 0x0
    //
    UINTX reserved : 22;
  } Bits;
  UINTX Data;
} ADPLL_CMN_CTRL4_DDRCC1_PHY_STRUCT;
#endif // ASM_INC

#define ADPLL_CMN_CTRL5_DDRCC1_PHY_REG                     0x00000074
#ifndef ASM_INC
typedef union {
  struct {
    //
    // control delay of refclk_dly clock that is used by dco latches
    // 
    // Bits[1:0], RW, default = 0x1
    //
    UINTX adpll_cmn_refclkdlysel : 2;
    //
    // force power gating off in all modes
    // 
    // Bits[2:2], RW, default = 0x0
    //
    UINTX adpll_cmn_pwrgateenb : 1;
    //
    // general configuration bits: quick_phase; use_refclkdel2dcolat
    // 
    // Bits[18:3], RW, default = 0x0
    //
    UINTX adpll_cmn_pllconfig : 16;
    //
    // currently reserved bits. pre divider control. m=i_ndiv (only 1 to 7 are valid)
    // 
    // Bits[22:19], RW, default = 0x1
    //
    UINTX adpll_cmn_ndiv : 4;
    //
    // Reserved
    // 
    // Bits[31:23], RO, default = 0x0
    //
    UINTX reserved : 9;
  } Bits;
  UINTX Data;
} ADPLL_CMN_CTRL5_DDRCC1_PHY_STRUCT;
#endif // ASM_INC

#define ADPLL_CMN_CTRL6_DDRCC1_PHY_REG                     0x00000078
#ifndef ASM_INC
typedef union {
  struct {
    //
    // set this bus to round((frefclk / 20mhz) - 1) to allow adpll generate an absolute
    // timer for sfr trimming;sfr calibration;sfr on and dco settle 
    // 
    // Bits[3:0], RW, default = 0x6
    //
    UINTX adpll_cmn_sfrtimercoef : 4;
    //
    // sfr supply indicator.
    // 
    // Bits[5:4], RW, default = 0x2
    //
    UINTX adpll_cmn_sfrsupplymode : 2;
    //
    // sfr spare config registers
    // 
    // Bits[9:6], RW, default = 0x0
    //
    UINTX adpll_cmn_sfrspare : 4;
    //
    // set to round(1.1ghz/fref)-1 for proper sfr calibration
    // 
    // Bits[17:10], RW, default = 0xD
    //
    UINTX adpll_cmn_sfrcalibfmincnt : 8;
    //
    // set to round(3.43ghz/fref)-1 for proper sfr calibration
    // 
    // Bits[25:18], RW, default = 0x22
    //
    UINTX adpll_cmn_sfrcalibfmaxcnt : 8;
    //
    // Reserved
    // 
    // Bits[31:26], RO, default = 0x0
    //
    UINTX reserved : 6;
  } Bits;
  UINTX Data;
} ADPLL_CMN_CTRL6_DDRCC1_PHY_STRUCT;
#endif // ASM_INC

#define ADPLL_CMN_CTRL7_DDRCC1_PHY_REG                     0x0000007C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // visa 2 reg start address
    // 
    // Bits[4:0], RW, default = 0x0
    //
    UINTX adpll_cmn_visaregstartindex : 5;
    //
    // set to round(1.47ghz/frefclk)-1 for proper tdc calibration
    // 
    // Bits[12:5], RW, default = 0xC
    //
    UINTX adpll_cmn_tdccalibosccnt : 8;
    //
    // force tdc calibration in normal locking
    // 
    // Bits[13:13], RW, default = 0x0
    //
    UINTX adpll_cmn_tdccalen : 1;
    //
    // Reserved
    // 
    // Bits[31:14], RO, default = 0x0
    //
    UINTX reserved : 18;
  } Bits;
  UINTX Data;
} ADPLL_CMN_CTRL7_DDRCC1_PHY_STRUCT;
#endif // ASM_INC

#define ADPLL_CMN_CTRL8_DDRCC1_PHY_REG                     0x00000080
#ifndef ASM_INC
typedef union {
  struct {
    //
    // 0p5x/1x clock reference input
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINTX mplldiv_cmn_1xor0p5xrefclk : 1;
    //
    // 0.5x/1x clock bypass input
    // 
    // Bits[1:1], RW, default = 0x0
    //
    UINTX mplldiv_cmn_1xor0p5xbypclk : 1;
    //
    // Reserved
    // 
    // Bits[31:2], RO, default = 0x0
    //
    UINTX reserved : 30;
  } Bits;
  UINTX Data;
} ADPLL_CMN_CTRL8_DDRCC1_PHY_STRUCT;
#endif // ASM_INC

#define PM_CMN_RSTB_DDRCC1_PHY_REG                         0x00000084
#ifndef ASM_INC
typedef union {
  struct {
    //
    // PM module reset from config register
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINTX pm_pmrst_b : 1;
    //
    // Reserved
    // 
    // Bits[31:1], RO, default = 0x0
    //
    UINTX reserved : 31;
  } Bits;
  UINTX Data;
} PM_CMN_RSTB_DDRCC1_PHY_STRUCT;
#endif // ASM_INC

#define PM_CMN_CFG_DDRCC1_PHY_REG                          0x00000088
#ifndef ASM_INC
typedef union {
  struct {
    //
    // PM clock ack
    // 
    // Bits[0:0], RO/V, default = 0x0
    //
    UINTX pmclk_ack : 1;
    //
    // PM clock request
    // 
    // Bits[1:1], RW, default = 0x0
    //
    UINTX pmclk_clkreq : 1;
    //
    // Reserved
    // 
    // Bits[31:2], RO, default = 0x0
    //
    UINTX reserved : 30;
  } Bits;
  UINTX Data;
} PM_CMN_CFG_DDRCC1_PHY_STRUCT;
#endif // ASM_INC

#define GCOMP_CFG3_DDRCC1_PHY_REG                          0x0000008C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // PUP Static Bit Live Code from FSM. DDR3L/3U : ODT - 0100; DQ - 1111; CMD - 1000
    //  && DDR4 : ODT - 1111(40-60)  & 0100 (60-120);  DQ - 1111; CMD - 1000. AJC NOTE:
    // THIS WILL PROBABLY CHANGE FOR 0P8 
    // 
    // Bits[2:0], RW, default = 0x7
    //
    UINTX gcomp_puprcompstaticlive : 3;
    //
    // PUP DQS ODT Static Bit Live Code from FSM. DDR3L/3U : ODT - 0100; DQ - 1111; CMD
    // - 1000  && DDR4 : ODT - 1111(40-60)  & 0100 (60-120);  DQ - 1111; CMD - 1000.
    // AJC NOTE: THIS WILL PROBABLY CHANGE FOR 0P8 
    // 
    // Bits[5:3], RW, default = 0x7
    //
    UINTX gcomp_puprcompdqsodtstaticlive : 3;
    //
    // PUP DQ ODT Static Bit Live Code from FSM. DDR3L/3U : ODT - 0100; DQ - 1111; CMD
    // - 1000  && DDR4 : ODT - 1111(40-60)  & 0100 (60-120);  DQ - 1111; CMD - 1000.
    // AJC NOTE: THIS WILL PROBABLY CHANGE FOR 0P8 
    // 
    // Bits[8:6], RW, default = 0x7
    //
    UINTX gcomp_puprcompdqodtstaticlive : 3;
    //
    // Reserved
    // 
    // Bits[31:9], RO, default = 0x0
    //
    UINTX reserved : 23;
  } Bits;
  UINTX Data;
} GCOMP_CFG3_DDRCC1_PHY_STRUCT;
#endif // ASM_INC

#define DFXVISA_ULM0PATTGEN_DDRCC1_PHY_REG                 0x00000100
#ifndef ASM_INC
typedef union {
  struct {
    //
    // VISA Pattern Generation
    // 
    // Bits[2:0], RW, default = 0x0
    //
    UINTX dfxvisa_ulm0pattgen_lsb : 3;
    //
    // VISA Pattern Generation
    // 
    // Bits[6:3], RW, default = 0x0
    //
    UINTX dfxvisa_ulm0pattgen_msb : 4;
    //
    // Reserved
    // 
    // Bits[31:7], RO, default = 0x0
    //
    UINTX reserved : 25;
  } Bits;
  UINTX Data;
} DFXVISA_ULM0PATTGEN_DDRCC1_PHY_STRUCT;
#endif // ASM_INC

#define DFXVISA_ULM0LN0_DDRCC1_PHY_REG                     0x00000104
#ifndef ASM_INC
typedef union {
  struct {
    //
    // VISA ULM0LN0 (DATA) Select
    // 
    // Bits[7:0], RW, default = 0x0
    //
    UINTX dfxvisa_ulm0ln0_datasel : 8;
    //
    // VISA ULM0LN0 CLK Select
    // 
    // Bits[15:8], RW, default = 0x0
    //
    UINTX dfxvisa_ulm0ln0_clksel : 8;
    //
    // VISA Bypass ULM0LN0
    // 
    // Bits[16:16], RW, default = 0x0
    //
    UINTX dfxvisa_ulm0ln0_bypass : 1;
    //
    // Reserved
    // 
    // Bits[31:17], RO, default = 0x0
    //
    UINTX reserved : 15;
  } Bits;
  UINTX Data;
} DFXVISA_ULM0LN0_DDRCC1_PHY_STRUCT;
#endif // ASM_INC

#define DFXVISA_ULM0LN1_DDRCC1_PHY_REG                     0x00000108
#ifndef ASM_INC
typedef union {
  struct {
    //
    // VISA ULM0LN1 (DATA) Select
    // 
    // Bits[7:0], RW, default = 0x0
    //
    UINTX dfxvisa_ulm0ln1_datasel : 8;
    //
    // VISA ULM0LN1 CLK Select
    // 
    // Bits[15:8], RW, default = 0x0
    //
    UINTX dfxvisa_ulm0ln1_clksel : 8;
    //
    // VISA Bypass ULM0LN1
    // 
    // Bits[16:16], RW, default = 0x0
    //
    UINTX dfxvisa_ulm0ln1_bypass : 1;
    //
    // Reserved
    // 
    // Bits[31:17], RO, default = 0x0
    //
    UINTX reserved : 15;
  } Bits;
  UINTX Data;
} DFXVISA_ULM0LN1_DDRCC1_PHY_STRUCT;
#endif // ASM_INC

#define DFXVISA_ULM1PATTGEN_DDRCC1_PHY_REG                 0x0000010C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // VISA Pattern Generation
    // 
    // Bits[2:0], RW, default = 0x0
    //
    UINTX dfxvisa_ulm1pattgen_lsb : 3;
    //
    // VISA Pattern Generation
    // 
    // Bits[6:3], RW, default = 0x0
    //
    UINTX dfxvisa_ulm1pattgen_msb : 4;
    //
    // Reserved
    // 
    // Bits[31:7], RO, default = 0x0
    //
    UINTX reserved : 25;
  } Bits;
  UINTX Data;
} DFXVISA_ULM1PATTGEN_DDRCC1_PHY_STRUCT;
#endif // ASM_INC

#define DFXVISA_ULM1LN0_DDRCC1_PHY_REG                     0x00000110
#ifndef ASM_INC
typedef union {
  struct {
    //
    // VISA ULM1LN0 (DATA) Select
    // 
    // Bits[7:0], RW, default = 0x0
    //
    UINTX dfxvisa_ulm1ln0_datasel : 8;
    //
    // VISA ULM1LN0 CLK Select
    // 
    // Bits[15:8], RW, default = 0x0
    //
    UINTX dfxvisa_ulm1ln0_clksel : 8;
    //
    // VISA Bypass ULM1LN0
    // 
    // Bits[16:16], RW, default = 0x0
    //
    UINTX dfxvisa_ulm1ln0_bypass : 1;
    //
    // Reserved
    // 
    // Bits[31:17], RO, default = 0x0
    //
    UINTX reserved : 15;
  } Bits;
  UINTX Data;
} DFXVISA_ULM1LN0_DDRCC1_PHY_STRUCT;
#endif // ASM_INC

#define DFXVISA_ULM1LN1_DDRCC1_PHY_REG                     0x00000114
#ifndef ASM_INC
typedef union {
  struct {
    //
    // VISA ULM1LN1 (DATA) Select
    // 
    // Bits[7:0], RW, default = 0x0
    //
    UINTX dfxvisa_ulm1ln1_datasel : 8;
    //
    // VISA ULM1LN1 CLK Select
    // 
    // Bits[15:8], RW, default = 0x0
    //
    UINTX dfxvisa_ulm1ln1_clksel : 8;
    //
    // VISA Bypass ULM1LN1
    // 
    // Bits[16:16], RW, default = 0x0
    //
    UINTX dfxvisa_ulm1ln1_bypass : 1;
    //
    // Reserved
    // 
    // Bits[31:17], RO, default = 0x0
    //
    UINTX reserved : 15;
  } Bits;
  UINTX Data;
} DFXVISA_ULM1LN1_DDRCC1_PHY_STRUCT;
#endif // ASM_INC

#define MON0CFG_DDRCC1_PHY_REG                             0x00000118
#ifndef ASM_INC
typedef union {
  struct {
    //
    // master enable for both anamux0 and anamux1 in all ckebb cells. 1 = anamux0 and
    // anamux1 can be used. 0 = anamux0 and anamux1 disabled reguardless of any other
    // programming 
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINTX mon0_anaen : 1;
    //
    // mon port analog mux 0 enable
    // 
    // Bits[1:1], RW, default = 0x0
    //
    UINTX mon0_anaobs0en : 1;
    //
    // code for mon port analog mux 0
    // 
    // Bits[4:2], RW, default = 0x0
    //
    UINTX mon0_anaobs0sel : 3;
    //
    // mon port analog mux 1 enable
    // 
    // Bits[5:5], RW, default = 0x0
    //
    UINTX mon0_anaobs1en : 1;
    //
    // code for mon port analog mux 1
    // 
    // Bits[8:6], RW, default = 0x0
    //
    UINTX mon0_anaobs1sel : 3;
    //
    // mon port comparator input switch
    // 
    // Bits[9:9], RW, default = 0x0
    //
    UINTX mon0_compswitch : 1;
    //
    // code for mon port digital mux 0
    // 
    // Bits[14:10], RW, default = 0x0
    //
    UINTX mon0_digobs0sel : 5;
    //
    // code for mon port digital mux 1
    // 
    // Bits[19:15], RW, default = 0x0
    //
    UINTX mon0_digobs1sel : 5;
    //
    // code for mon port vref for comparator
    // 
    // Bits[25:20], RW, default = 0x0
    //
    UINTX mon0_vrefctrl : 6;
    //
    // mon port vref and comparator enable
    // 
    // Bits[26:26], RW, default = 0x0
    //
    UINTX mon0_vrefen : 1;
    //
    // mon port comparator output 0 to digital register (region 0)
    // 
    // Bits[27:27], RO/V, default = 0x0
    //
    UINTX mon0_compout0 : 1;
    //
    // mon port comparator output 1 to digital register (region 0)
    // 
    // Bits[28:28], RO/V, default = 0x0
    //
    UINTX mon0_compout1 : 1;
    //
    // Reserved
    // 
    // Bits[31:29], RO, default = 0x0
    //
    UINTX reserved : 3;
  } Bits;
  UINTX Data;
} MON0CFG_DDRCC1_PHY_STRUCT;
#endif // ASM_INC

#define MON1CFG_DDRCC1_PHY_REG                             0x0000011C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // master enable for both anamux0 and anamux1 in all ckebb cells. 1 = anamux0 and
    // anamux1 can be used. 0 = anamux0 and anamux1 disabled reguardless of any other
    // programming 
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINTX mon1_anaen : 1;
    //
    // mon port analog mux 0 enable
    // 
    // Bits[1:1], RW, default = 0x0
    //
    UINTX mon1_anaobs0en : 1;
    //
    // code for mon port analog mux 0
    // 
    // Bits[4:2], RW, default = 0x0
    //
    UINTX mon1_anaobs0sel : 3;
    //
    // mon port analog mux 1 enable
    // 
    // Bits[5:5], RW, default = 0x0
    //
    UINTX mon1_anaobs1en : 1;
    //
    // code for mon port analog mux 1
    // 
    // Bits[8:6], RW, default = 0x0
    //
    UINTX mon1_anaobs1sel : 3;
    //
    // mon port comparator input switch
    // 
    // Bits[9:9], RW, default = 0x0
    //
    UINTX mon1_compswitch : 1;
    //
    // code for mon port digital mux 0
    // 
    // Bits[14:10], RW, default = 0x0
    //
    UINTX mon1_digobs0sel : 5;
    //
    // code for mon port digital mux 1
    // 
    // Bits[19:15], RW, default = 0x0
    //
    UINTX mon1_digobs1sel : 5;
    //
    // code for mon port vref for comparator
    // 
    // Bits[25:20], RW, default = 0x0
    //
    UINTX mon1_vrefctrl : 6;
    //
    // mon port vref and comparator enable
    // 
    // Bits[26:26], RW, default = 0x0
    //
    UINTX mon1_vrefen : 1;
    //
    // mon port comparator output 0 to digital register (region 1)
    // 
    // Bits[27:27], RO/V, default = 0x0
    //
    UINTX mon1_compout0 : 1;
    //
    // mon port comparator output 1 to digital register (region 1)
    // 
    // Bits[28:28], RO/V, default = 0x0
    //
    UINTX mon1_compout1 : 1;
    //
    // Reserved
    // 
    // Bits[31:29], RO, default = 0x0
    //
    UINTX reserved : 3;
  } Bits;
  UINTX Data;
} MON1CFG_DDRCC1_PHY_STRUCT;
#endif // ASM_INC

#define MONCFG_DDRCC1_PHY_REG                              0x00000120
#ifndef ASM_INC
typedef union {
  struct {
    //
    // 0 = divider 1u in divide by 2
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINTX mon_digobsdivsel1u : 1;
    //
    // 0 = divider 1l in divide by 2
    // 
    // Bits[1:1], RW, default = 0x0
    //
    UINTX mon_digobsdivsel1l : 1;
    //
    // 0 = divider 0u in divide by 2
    // 
    // Bits[2:2], RW, default = 0x0
    //
    UINTX mon_digobsdivsel0u : 1;
    //
    // 0 = divider 0l in divide by 2
    // 
    // Bits[3:3], RW, default = 0x0
    //
    UINTX mon_digobsdivsel0l : 1;
    //
    // 0 = divider 1u in reset and so 1u signal path is divide by 1
    // 
    // Bits[4:4], RW, default = 0x0
    //
    UINTX mon_digobsdivrstb1u : 1;
    //
    // 0 = divider 1l in reset and so 1l signal path is divide by 1
    // 
    // Bits[5:5], RW, default = 0x0
    //
    UINTX mon_digobsdivrstb1l : 1;
    //
    // 0 = divider 0u in reset and so 0u signal path is divide by 1
    // 
    // Bits[6:6], RW, default = 0x0
    //
    UINTX mon_digobsdivrstb0u : 1;
    //
    // 0 = divider 0l in reset and so 0l signal path is divide by 1
    // 
    // Bits[7:7], RW, default = 0x0
    //
    UINTX mon_digobsdivrstb0l : 1;
    //
    // Reserved
    // 
    // Bits[31:8], RO, default = 0x0
    //
    UINTX reserved : 24;
  } Bits;
  UINTX Data;
} MONCFG_DDRCC1_PHY_STRUCT;
#endif // ASM_INC

#define MONDRVCFG_DDRCC1_PHY_REG                           0x00000124
#ifndef ASM_INC
typedef union {
  struct {
    //
    // lower analog enable
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINTX mondrv_analen : 1;
    //
    // upper analog enable
    // 
    // Bits[1:1], RW, default = 0x0
    //
    UINTX mondrv_anauen : 1;
    //
    // Differential & Single-ended mode control of digital. 00=Diff or SE monitoring,
    // 01=Diff monitoring, 10=Diff monitoring, 11=Diff or SE monitoring. See mon_hp_cas
    // for details. 
    // 
    // Bits[3:2], RW, default = 0x2
    //
    UINTX mondrv_digdiffmode : 2;
    //
    // enable/disable digital output driver 0.
    // 
    // Bits[4:4], RW, default = 0x0
    //
    UINTX mondrv_digdrv0en : 1;
    //
    // drive impedance control for digital driver 0. High-Z=000000; min impedance-111111.
    // See Monitor Port CAS for impedance table drive. 
    // 
    // Bits[10:5], RW, default = 0x0
    //
    UINTX mondrv_digdrv0rstrength : 6;
    //
    // enable/disable digital output driver 1.
    // 
    // Bits[11:11], RW, default = 0x0
    //
    UINTX mondrv_digdrv1en : 1;
    //
    // drive impedance control for digital driver 1. High-Z=000000; min impedance-111111.
    // See Monitor Port CAS for impedance table drive. 
    // 
    // Bits[17:12], RW, default = 0x0
    //
    UINTX mondrv_digdrv1rstrength : 6;
    //
    // digital mux 0 select
    // 
    // Bits[18:18], RW, default = 0x0
    //
    UINTX mondrv_digobs0sel : 1;
    //
    // digital mux 1 select
    // 
    // Bits[19:19], RW, default = 0x0
    //
    UINTX mondrv_digobs1sel : 1;
    //
    // Reserved
    // 
    // Bits[31:20], RO, default = 0x0
    //
    UINTX reserved : 12;
  } Bits;
  UINTX Data;
} MONDRVCFG_DDRCC1_PHY_STRUCT;
#endif // ASM_INC

#define MONLCFG_DDRCC1_PHY_REG                             0x00000128
#ifndef ASM_INC
typedef union {
  struct {
    //
    // master enable for both anamux0 and anamux1 in all ckebb cells. 1 = anamux0 and
    // anamux1 can be used. 0 = anamux0 and anamux1 disabled reguardless of any other
    // programming (lower mux chain) 
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINTX monl_anaen : 1;
    //
    // mon port analog mux 0 enable (lower mux chain)
    // 
    // Bits[1:1], RW, default = 0x0
    //
    UINTX monl_anaobs0en : 1;
    //
    // code for mon port analog mux 0 (lower mux chain)
    // 
    // Bits[4:2], RW, default = 0x0
    //
    UINTX monl_anaobs0sel : 3;
    //
    // mon port analog mux 1 enable (lower mux chain)
    // 
    // Bits[5:5], RW, default = 0x0
    //
    UINTX monl_anaobs1en : 1;
    //
    // code for mon port analog mux 1 (lower mux chain)
    // 
    // Bits[8:6], RW, default = 0x0
    //
    UINTX monl_anaobs1sel : 3;
    //
    // mon port comparator input switch (lower mux chain)
    // 
    // Bits[9:9], RW, default = 0x0
    //
    UINTX monl_compswitch : 1;
    //
    // code for mon port digital mux 0 (lower mux chain)
    // 
    // Bits[14:10], RW, default = 0x0
    //
    UINTX monl_digobs0sel : 5;
    //
    // code for mon port digital mux 1 (lower mux chain)
    // 
    // Bits[19:15], RW, default = 0x0
    //
    UINTX monl_digobs1sel : 5;
    //
    // code for mon port vref for comparator (lower mux chain)
    // 
    // Bits[25:20], RW, default = 0x0
    //
    UINTX monl_vrefctrl : 6;
    //
    // mon port vref and comparator enable (lower mux chain)
    // 
    // Bits[26:26], RW, default = 0x0
    //
    UINTX monl_vrefen : 1;
    //
    // mon port comparator output 0 to digital register (lower mux chain)
    // 
    // Bits[27:27], RO/V, default = 0x0
    //
    UINTX monl_compout0 : 1;
    //
    // mon port comparator output 1 to digital register (lower mux chain)
    // 
    // Bits[28:28], RO/V, default = 0x0
    //
    UINTX monl_compout1 : 1;
    //
    // Reserved
    // 
    // Bits[31:29], RO, default = 0x0
    //
    UINTX reserved : 3;
  } Bits;
  UINTX Data;
} MONLCFG_DDRCC1_PHY_STRUCT;
#endif // ASM_INC

#define MONUCFG_DDRCC1_PHY_REG                             0x0000012C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // master enable for both anamux0 and anamux1 in all ckebb cells. 1 = anamux0 and
    // anamux1 can be used. 0 = anamux0 and anamux1 disabled reguardless of any other
    // programming (upper mux chain) 
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINTX monu_anaen : 1;
    //
    // mon port analog mux 0 enable (upper mux chain)
    // 
    // Bits[1:1], RW, default = 0x0
    //
    UINTX monu_anaobs0en : 1;
    //
    // code for mon port analog mux 0 (upper mux chain)
    // 
    // Bits[4:2], RW, default = 0x0
    //
    UINTX monu_anaobs0sel : 3;
    //
    // mon port analog mux 1 enable (upper mux chain)
    // 
    // Bits[5:5], RW, default = 0x0
    //
    UINTX monu_anaobs1en : 1;
    //
    // code for mon port analog mux 1 (upper mux chain)
    // 
    // Bits[8:6], RW, default = 0x0
    //
    UINTX monu_anaobs1sel : 3;
    //
    // mon port comparator input switch (upper mux chain)
    // 
    // Bits[9:9], RW, default = 0x0
    //
    UINTX monu_compswitch : 1;
    //
    // code for mon port digital mux 0 (upper mux chain)
    // 
    // Bits[14:10], RW, default = 0x0
    //
    UINTX monu_digobs0sel : 5;
    //
    // code for mon port digital mux 1 (upper mux chain)
    // 
    // Bits[19:15], RW, default = 0x0
    //
    UINTX monu_digobs1sel : 5;
    //
    // code for mon port vref for comparator (upper mux chain)
    // 
    // Bits[25:20], RW, default = 0x0
    //
    UINTX monu_vrefctrl : 6;
    //
    // mon port vref and comparator enable (upper mux chain)
    // 
    // Bits[26:26], RW, default = 0x0
    //
    UINTX monu_vrefen : 1;
    //
    // mon port comparator output 0 to digital register (upper mux chain)
    // 
    // Bits[27:27], RO/V, default = 0x0
    //
    UINTX monu_compout0 : 1;
    //
    // mon port comparator output 1 to digital register (upper mux chain)
    // 
    // Bits[28:28], RO/V, default = 0x0
    //
    UINTX monu_compout1 : 1;
    //
    // Reserved
    // 
    // Bits[31:29], RO, default = 0x0
    //
    UINTX reserved : 3;
  } Bits;
  UINTX Data;
} MONUCFG_DDRCC1_PHY_STRUCT;
#endif // ASM_INC

#define DIGCTL_CH0_DDRCC1_PHY_REG                          0x00000180
#ifndef ASM_INC
typedef union {
  struct {
    //
    // SPID clock clock domain reset-bar. Combined with PM reset control
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINTX ch0_spidrst_b : 1;
    //
    // Write pointer enable. Combined with PM control
    // 
    // Bits[1:1], RW, default = 0x0
    //
    UINTX ch0_wrptren : 1;
    //
    // Boot sequence initialisation complete SPID output to Dunit. 1 = initialisation
    // completed 
    // 
    // Bits[2:2], RW, default = 0x0
    //
    UINTX ch0_spid_init_complete : 1;
    //
    // CC1 I/O buffer activate: Reset for final TX flops in CC1 upartition.[br]Tristates
    // IO buffers.[br]Disable Rx sections of IO buffers.[br]0 = reset , 1 = out of reset
    // 
    // Bits[3:3], RW, default = 0x0
    //
    UINTX ch0_iobufact : 1;
    //
    // Multi Cycle Path Control. 0 = NO Pipelining, 1 = Pipelining (1 Stage)
    // 
    // Bits[4:4], RW, default = 0x0
    //
    UINTX ch0_rdmcpsel : 1;
    //
    // Reserved
    // 
    // Bits[6:5], RO, default = 0x0
    //
    UINTX reserved : 2;
    //
    // Reserved
    // 
    // Bits[8:7], RO, default = 0x0
    //
    UINTX reserved_1 : 2;
    //
    // Ch0 Spidclk clkack return from SOC to acknowledge that spidclk drop off are running.
    // 
    // Bits[9:9], RO/V, default = 0x0
    //
    UINTX ch0_spidclk_clkack : 1;
    //
    // CH0 bus_quiet_time_req config.           1: to enable the bus_quiet_time_req to
    // SOC for CH0.                                                      0: to disable
    // the bus_quiet_time_req to SOC for CH0. 
    // 
    // Bits[10:10], RW, default = 0x0
    //
    UINTX ch0_bus_quiet_time_req : 1;
    //
    // CH0 selfrefresh_exit req config.            1: to enable the self-refresh exit
    // request to SOC for CH0.                           0: to disable the self-refresh
    // exit request to SOC for CH0. 
    // 
    // Bits[11:11], RW, default = 0x0
    //
    UINTX ch0_selfrefresh_exit_req : 1;
    //
    // Reserved
    // 
    // Bits[31:12], RO, default = 0x0
    //
    UINTX reserved_2 : 20;
  } Bits;
  UINTX Data;
} DIGCTL_CH0_DDRCC1_PHY_STRUCT;
#endif // ASM_INC

#define PTROFFSET_CH0_DDRCC1_PHY_REG                       0x00000184
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Initial offset for 2x clock read pointers
    // 
    // Bits[4:0], RW, default = 0x0
    //
    UINTX ch0_ref2xrdptrinit : 5;
    //
    // Reserved
    // 
    // Bits[31:5], RO, default = 0x0
    //
    UINTX reserved : 27;
  } Bits;
  UINTX Data;
} PTROFFSET_CH0_DDRCC1_PHY_STRUCT;
#endif // ASM_INC

#define CMDSIGCTL_CH0_DDRCC1_PHY_REG                       0x00000188
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Command signal clock deadband select. Cmd group 0. 00: No Deadband Zone[br]01:
    // No Deadband Zone 270 pathsel[br]10: Deadband 90 degree path sel[br]11: Deadband
    // 180 degree path sel. 
    // 
    // Bits[1:0], RW, default = 0x0
    //
    UINTX ch0_grp0cmddbsel : 2;
    //
    // Command signal clock read pointer offset. Cmd group 0
    // 
    // Bits[6:2], RW, default = 0x0
    //
    UINTX ch0_grp0cmdsigrdptroffset : 5;
    //
    // Command signal clock deadband select. Cmd group 1. 00: No Deadband Zone[br]01:
    // No Deadband Zone 270 pathsel[br]10: Deadband 90 degree path sel[br]11: Deadband
    // 180 degree path sel. 
    // 
    // Bits[8:7], RW, default = 0x0
    //
    UINTX ch0_grp1cmddbsel : 2;
    //
    // Command signal clock read pointer offset. Cmd group 1
    // 
    // Bits[13:9], RW, default = 0x0
    //
    UINTX ch0_grp1cmdsigrdptroffset : 5;
    //
    // Reserved
    // 
    // Bits[31:14], RO, default = 0x0
    //
    UINTX reserved : 18;
  } Bits;
  UINTX Data;
} CMDSIGCTL_CH0_DDRCC1_PHY_STRUCT;
#endif // ASM_INC

#define CMDDRVEN_CH0_DDRCC1_PHY_REG                        0x0000018C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Reserved
    // 
    // Bits[8:0], RO, default = 0x0
    //
    UINTX reserved : 9;
    //
    // Command tristate enables per bit. 1 = buffer enabled, 0 = tristate
    // 
    // Bits[18:9], RW, default = 0x0
    //
    UINTX ch0_cmdtxdrven : 10;
    //
    // Reserved
    // 
    // Bits[31:19], RO, default = 0x0
    //
    UINTX reserved_1 : 13;
  } Bits;
  UINTX Data;
} CMDDRVEN_CH0_DDRCC1_PHY_STRUCT;
#endif // ASM_INC

#define CLKSIGCTL_CH0_DDRCC1_PHY_REG                       0x00000190
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Clock rank 0 signal clock deadband select. 00: No Deadband Zone[br]01: No Deadband
    // Zone 270 pathsel[br]10: Deadband 90 degree path sel[br]11: Deadband 180 degree
    // path sel. 
    // 
    // Bits[1:0], RW, default = 0x0
    //
    UINTX ch0_rk0clkdbsel : 2;
    //
    // Clock rank 1 signal clock deadband select. 00: No Deadband Zone[br]01: No Deadband
    // Zone 270 pathsel[br]10: Deadband 90 degree path sel[br]11: Deadband 180 degree
    // path sel. 
    // 
    // Bits[3:2], RW, default = 0x0
    //
    UINTX ch0_rk1clkdbsel : 2;
    //
    // Clock rank 2 signal clock deadband select. 00: No Deadband Zone[br]01: No Deadband
    // Zone 270 pathsel[br]10: Deadband 90 degree path sel[br]11: Deadband 180 degree
    // path sel. 
    // 
    // Bits[5:4], RW, default = 0x0
    //
    UINTX ch0_rk2clkdbsel : 2;
    //
    // Clock rank 3 signal clock deadband select. 00: No Deadband Zone[br]01: No Deadband
    // Zone 270 pathsel[br]10: Deadband 90 degree path sel[br]11: Deadband 180 degree
    // path sel. 
    // 
    // Bits[7:6], RW, default = 0x0
    //
    UINTX ch0_rk3clkdbsel : 2;
    //
    // Clock rank 0 signal clock read pointer offset
    // 
    // Bits[12:8], RW, default = 0x0
    //
    UINTX ch0_rk0clksigrdptroffset : 5;
    //
    // Clock rank 1 signal clock read pointer offset
    // 
    // Bits[17:13], RW, default = 0x0
    //
    UINTX ch0_rk1clksigrdptroffset : 5;
    //
    // Clock rank 2 signal clock read pointer offset
    // 
    // Bits[22:18], RW, default = 0x0
    //
    UINTX ch0_rk2clksigrdptroffset : 5;
    //
    // Clock rank 3 signal clock read pointer offset
    // 
    // Bits[27:23], RW, default = 0x0
    //
    UINTX ch0_rk3clksigrdptroffset : 5;
    //
    // Reserved
    // 
    // Bits[31:28], RO, default = 0x0
    //
    UINTX reserved : 4;
  } Bits;
  UINTX Data;
} CLKSIGCTL_CH0_DDRCC1_PHY_STRUCT;
#endif // ASM_INC

#define TXDLLCFG3_CH0_DDRCC1_PHY_REG                       0x00000194
#ifndef ASM_INC
typedef union {
  struct {
    //
    // PI Code for Signal Group0 output
    // 
    // Bits[5:0], RW, default = 0x0
    //
    UINTX txdll_siggrp00picode : 6;
    //
    // PI Code for Signal Group1 output
    // 
    // Bits[11:6], RW, default = 0x0
    //
    UINTX txdll_siggrp01picode : 6;
    //
    // PI Code for Signal Group2 output
    // 
    // Bits[17:12], RW, default = 0x0
    //
    UINTX txdll_siggrp02picode : 6;
    //
    // Reserved
    // 
    // Bits[31:18], RO, default = 0x0
    //
    UINTX reserved : 14;
  } Bits;
  UINTX Data;
} TXDLLCFG3_CH0_DDRCC1_PHY_STRUCT;
#endif // ASM_INC

#define TXDLLCFG4_CH0_DDRCC1_PHY_REG                       0x00000198
#ifndef ASM_INC
typedef union {
  struct {
    //
    // PI Code for Signal Group6 output
    // 
    // Bits[5:0], RW, default = 0x0
    //
    UINTX txdll_siggrp06picode : 6;
    //
    // PI Code for Signal Group7 output
    // 
    // Bits[11:6], RW, default = 0x0
    //
    UINTX txdll_siggrp07picode : 6;
    //
    // PI Code for Signal Group8 output
    // 
    // Bits[17:12], RW, default = 0x0
    //
    UINTX txdll_siggrp08picode : 6;
    //
    // Reserved
    // 
    // Bits[31:18], RO, default = 0x0
    //
    UINTX reserved : 14;
  } Bits;
  UINTX Data;
} TXDLLCFG4_CH0_DDRCC1_PHY_STRUCT;
#endif // ASM_INC

#define CLKMISC_CH0_DDRCC1_PHY_REG                         0x0000019C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Clock output phase inversion. 0 = No clock inversion. 1 = clock inverted
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINTX ch0_clknegxposb : 1;
    //
    // Clock tristate enables per rank. 1 = buffer enabled, 0 = tristate
    // 
    // Bits[4:1], RW, default = 0x0
    //
    UINTX ch0_clktxdrven : 4;
    //
    // Reserved
    // 
    // Bits[31:5], RO, default = 0x0
    //
    UINTX reserved : 27;
  } Bits;
  UINTX Data;
} CLKMISC_CH0_DDRCC1_PHY_STRUCT;
#endif // ASM_INC

#define DIGOBS_CH0_DDRCC1_PHY_REG                          0x000001A0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // reserved
    // 
    // Bits[3:0], RW, default = 0x0
    //
    UINTX ch0_cmdbuf_digobs1sel : 4;
    //
    // reserved
    // 
    // Bits[7:4], RW, default = 0x0
    //
    UINTX ch0_cmdbuf_digobs0sel : 4;
    //
    // reserved
    // 
    // Bits[11:8], RW, default = 0x0
    //
    UINTX ch0_clkbuf_digobs1sel : 4;
    //
    // reserved
    // 
    // Bits[15:12], RW, default = 0x0
    //
    UINTX ch0_clkbuf_digobs0sel : 4;
    //
    // Reserved
    // 
    // Bits[31:16], RO, default = 0x0
    //
    UINTX reserved : 16;
  } Bits;
  UINTX Data;
} DIGOBS_CH0_DDRCC1_PHY_STRUCT;
#endif // ASM_INC

#define CMD_AFE_CH0_DDRCC1_PHY_REG                         0x000001A4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Pull-down RCOMP code for driver static leg. DQ/CLK uses [3:0]  & CMD uses [3]
    // since it has no EQ support. 
    // 
    // Bits[2:0], RW, default = 0x7
    //
    UINTX ch0_cmd_pdndrvstatic : 3;
    //
    // Pull-up RCOMP code for driver static leg. DQ/CLK uses [3:0]  & CMD uses [3] since
    // it has no EQ support. 
    // 
    // Bits[5:3], RW, default = 0x7
    //
    UINTX ch0_cmd_pupdrvstatic : 3;
    //
    // cmd rx enable
    // 
    // Bits[6:6], RW, default = 0x0
    //
    UINTX ch0_cmd_rxen : 1;
    //
    // Delay cell static leg enable, Support DFX Per leg testing of delay cells in Predriver
    // Logic/Delay c73ddr402_comp.                                                  
    //                                                                              
    //                                                                              
    //                                1: enabled       (default)                    
    //                                0: disabled 
    // 
    // Bits[7:7], RW, default = 0x1
    //
    UINTX ch0_cmd_dlycellstaticlegen : 1;
    //
    // Stretches falling edge of Buffer enable pulse to support Early DQ mode.[br][1:0]
    // is used as POR,    [br]00=default pulse width[br]01=minimum stretch on width[br]10=intermediate
    // stretch on pulse[br]11=maximum stretch on pulse. 
    // 
    // Bits[9:8], RW, default = 0x0
    //
    UINTX ch0_cmd_drvenstretch : 2;
    //
    // Transmitter segment enable. Only used to enable DFX Per Leg checks.
    // 
    // Bits[13:10], RW, default = 0xF
    //
    UINTX ch0_cmd_drvsegen : 4;
    //
    // Fall TCO c73ddr402_COMP code
    // 
    // Bits[19:14], RW, default = 0x3F
    //
    UINTX ch0_cmd_tcocompfall : 6;
    //
    // Rise TCO c73ddr402_COMP code
    // 
    // Bits[25:20], RW, default = 0x3F
    //
    UINTX ch0_cmd_tcocomprise : 6;
    //
    // dfx legtest enable pin. Allows for independent control of the lower 4 legs of
    // the deley element which are controlled by the decoder. 1: enabled       0 : disabled
    // (default) 
    // 
    // Bits[26:26], RW, default = 0x0
    //
    UINTX ch0_cmd_pbddfxtesten : 1;
    //
    // Reserved
    // 
    // Bits[31:27], RO, default = 0x0
    //
    UINTX reserved : 5;
  } Bits;
  UINTX Data;
} CMD_AFE_CH0_DDRCC1_PHY_STRUCT;
#endif // ASM_INC

#define CLK_AFE_CH0_DDRCC1_PHY_REG                         0x000001A8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Pull-down RCOMP code for driver static leg for CLK buffers
    // 
    // Bits[2:0], RW, default = 0x7
    //
    UINTX ch0_clk_pdndrvstatic : 3;
    //
    // Pull-up RCOMP code for driver static leg for CLK buffers
    // 
    // Bits[5:3], RW, default = 0x7
    //
    UINTX ch0_clk_pupdrvstatic : 3;
    //
    // This signal is to differentiate RDIMM CLK functionality from other DIMM types.
    // During S3 mode, RDIMM CLK is required to pulled down to GND (like CKE buffer).
    // The value of this signal is '1'  for RDIMM and '0' for other DIMM types. 
    // 
    // Bits[6:6], RW, default = 0x0
    //
    UINTX ch0_clk_clktristateenb : 1;
    //
    // clk rx enable
    // 
    // Bits[7:7], RW, default = 0x0
    //
    UINTX ch0_clk_rxen : 1;
    //
    // Delay cell static leg enable, Support DFX Per leg testing of delay cells in Predriver
    // Logic/Delay c73ddr402_comp.                                                  
    //                                                                              
    //                                                                              
    //                                1: enabled       (default)                    
    //                                0: disabled 
    // 
    // Bits[8:8], RW, default = 0x1
    //
    UINTX ch0_clk_dlycellstaticlegen : 1;
    //
    // Stretches falling edge of Buffer enable pulse to support Early DQ mode.  [br]00=default
    // pulse width[br]01=minimum stretch on width[br]10=intermediate stretch on pulse[br]11=maximum
    // stretch on pulse. 
    // 
    // Bits[10:9], RW, default = 0x0
    //
    UINTX ch0_clk_drvenstretch : 2;
    //
    // Transmitter segment enable. Only used to enable DFX Per Leg checks.
    // 
    // Bits[13:11], RW, default = 0x7
    //
    UINTX ch0_clk_drvsegen : 3;
    //
    // Selects early or late version of Pre-drive Delay line for RCOMP code Update. 00=>
    // 1st delaycell, 01=> 2nd delaycell, 10=>3rd delaycell, 11=>Reserved 
    // 
    // Bits[15:14], RW, default = 0x1
    //
    UINTX ch0_clk_rcompdelaysel : 2;
    //
    // Selects early or late version of Pre-drive Delay line for SCOMP code Update. 00=>
    // 1st delaycell, 01=> 2nd delaycell, 10=>3rd delaycell, 11=>Reserved 
    // 
    // Bits[17:16], RW, default = 0x1
    //
    UINTX ch0_clk_scompdelaysel : 2;
    //
    // Fall TCO c73ddr402_COMP code
    // 
    // Bits[23:18], RW, default = 0x3F
    //
    UINTX ch0_clk_tcocompfall : 6;
    //
    // Rise TCO c73ddr402_COMP code
    // 
    // Bits[29:24], RW, default = 0x3F
    //
    UINTX ch0_clk_tcocomprise : 6;
    //
    // dfx legtest enable pin. Allows for independent control of the lower 4 legs of
    // the deley element which are controlled by the decoder. 1: enabled       0 : disabled
    // (default) 
    // 
    // Bits[30:30], RW, default = 0x0
    //
    UINTX ch0_clk_pbddfxtesten : 1;
    //
    // Active LOW reset signal for CLK buffer update logic synchronizer flops
    // 
    // Bits[31:31], RW, default = 0x0
    //
    UINTX ch0_clkbuf_resetb : 1;
  } Bits;
  UINTX Data;
} CLK_AFE_CH0_DDRCC1_PHY_STRUCT;
#endif // ASM_INC

#define CLK_COMPOVR_AFE_CH0_DDRCC1_PHY_REG                 0x000001AC
#ifndef ASM_INC
typedef union {
  struct {
    //
    // SCOMP code override for CLK buffers
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINTX ch0_clktx_scompoverride : 1;
    //
    // RCOMP code override for CLK buffers
    // 
    // Bits[1:1], RW, default = 0x0
    //
    UINTX ch0_clktx_rcompoverride : 1;
    //
    // Reserved
    // 
    // Bits[31:2], RO, default = 0x0
    //
    UINTX reserved : 30;
  } Bits;
  UINTX Data;
} CLK_COMPOVR_AFE_CH0_DDRCC1_PHY_STRUCT;
#endif // ASM_INC

#define MRGMODE_CH0_DDRCC1_PHY_REG                         0x00000280
#ifndef ASM_INC
typedef union {
  struct {
    //
    // DFX margin mode TX data phase 0
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINTX ch0_dfxmrgtxd_ph0 : 1;
    //
    // DFX margin mode TX data phase 1
    // 
    // Bits[1:1], RW, default = 0x0
    //
    UINTX ch0_dfxmrgtxd_ph1 : 1;
    //
    // DFX margin mode RX compare values
    // 
    // Bits[9:2], RW, default = 0x0
    //
    UINTX ch0_dfxmrgtxd_cmp : 8;
    //
    // DFX margin mode TX override enable
    // 
    // Bits[10:10], RW, default = 0x0
    //
    UINTX ch0_dfxmrgtx_ovren : 1;
    //
    // DFX margin mode TX write enable
    // 
    // Bits[11:11], RW, default = 0x0
    //
    UINTX ch0_dfxmrgtxwren : 1;
    //
    // DFX margin mode TX strobe data
    // 
    // Bits[13:12], RW, default = 0x0
    //
    UINTX ch0_dfxmrgtxd_strb : 2;
    //
    // Reserved
    // 
    // Bits[31:14], RO, default = 0x0
    //
    UINTX reserved : 18;
  } Bits;
  UINTX Data;
} MRGMODE_CH0_DDRCC1_PHY_STRUCT;
#endif // ASM_INC

#define MRGMODE_DB_CH0_DDRCC1_PHY_REG                      0x00000284
#ifndef ASM_INC
typedef union {
  struct {
    //
    // DFX margin mode RX DB compare values
    // 
    // Bits[7:0], RW, default = 0x0
    //
    UINTX ch0_dfxmrgtxd_db_cmp : 8;
    //
    // Reserved
    // 
    // Bits[31:8], RO, default = 0x0
    //
    UINTX reserved : 24;
  } Bits;
  UINTX Data;
} MRGMODE_DB_CH0_DDRCC1_PHY_STRUCT;
#endif // ASM_INC

#define PM_CH0_PGOVR_DDRCC1_PHY_REG                        0x000002B0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Power mux (ungated): Enable VNN
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINTX ch0_pswitch_cmn_vnnpwron : 1;
    //
    // Power mux (ungated): Enable VCCA
    // 
    // Bits[1:1], RW, default = 0x0
    //
    UINTX ch0_pswitch_cmn_vccapwron : 1;
    //
    // Select VCCA mode of operation
    // 
    // Bits[2:2], RW, default = 0x0
    //
    UINTX ch0_vcca_sel : 1;
    //
    // 0 for 2 bit stagger ata time sel and 1 for 1 bit stagger at a time
    // 
    // Bits[3:3], RW, default = 0x0
    //
    UINTX ch0_pm_stagger_bits_sel : 1;
    //
    // ref2xrstb override
    // 
    // Bits[4:4], RW, default = 0x0
    //
    UINTX ch0_pm_ref2xrstb_ovr : 1;
    //
    // ref2x phase 0 override
    // 
    // Bits[5:5], RW, default = 0x0
    //
    UINTX ch0_pm_ref2xph0_ovr : 1;
    //
    // dll c73ddr402_comp clock gate overiride
    // 
    // Bits[6:6], RW, default = 0x0
    //
    UINTX ch0_pm_dllcomp_clkgate_ovr : 1;
    //
    // PWR VNNA On Staggered value
    // 
    // Bits[14:7], RW, default = 0x0
    //
    UINTX ch0_pm_vnnapwronstaggered : 8;
    //
    // PWR VNNA On Staggered Override
    // 
    // Bits[15:15], RW, default = 0x0
    //
    UINTX ch0_pm_vnnapwronstaggered_ovr : 1;
    //
    // PWR VCCA On Staggered value
    // 
    // Bits[23:16], RW, default = 0x0
    //
    UINTX ch0_pm_vccapwronstaggered : 8;
    //
    // PWR VCCA On Staggered Override
    // 
    // Bits[24:24], RW, default = 0x0
    //
    UINTX ch0_pm_vccapwronstaggered_ovr : 1;
    //
    // Reserved
    // 
    // Bits[31:25], RO, default = 0x0
    //
    UINTX reserved : 7;
  } Bits;
  UINTX Data;
} PM_CH0_PGOVR_DDRCC1_PHY_STRUCT;
#endif // ASM_INC

#define PM_CH0_CONFIG0_DDRCC1_PHY_REG                      0x000002B4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // c73ddr402_COMP Enbale Value
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINTX ch0_pm_comp_en : 1;
    //
    // c73ddr402_COMP Enbale Overide
    // 
    // Bits[1:1], RW, default = 0x0
    //
    UINTX ch0_pm_comp_en_ovr : 1;
    //
    // SFR On Override
    // 
    // Bits[2:2], RW, default = 0x0
    //
    UINTX ch0_pm_adpll_sfron_ovr : 1;
    //
    // ADPLL Enable Override
    // 
    // Bits[3:3], RW, default = 0x0
    //
    UINTX ch0_pm_adpllen_ovr : 1;
    //
    // SDLL Enable Override
    // 
    // Bits[4:4], RW, default = 0x0
    //
    UINTX ch0_pm_ckdll_sdllen_ovr : 1;
    //
    // IOBUFACT Override
    // 
    // Bits[5:5], RW, default = 0x0
    //
    UINTX ch0_pm_iobufact_ovr : 1;
    //
    // DIFFAMP Enable Overide
    // 
    // Bits[6:6], RW, default = 0x0
    //
    UINTX ch0_pm_diffampenable_ovr : 1;
    //
    // Clock Gate Value
    // 
    // Bits[7:7], RW, default = 0x0
    //
    UINTX ch0_pm_clkgateen_val : 1;
    //
    // Clock Gate Override
    // 
    // Bits[8:8], RW, default = 0x0
    //
    UINTX ch0_pm_clkgateen_ovr : 1;
    //
    // Isolation Enable Value
    // 
    // Bits[9:9], RW, default = 0x0
    //
    UINTX ch0_pm_isolen : 1;
    //
    // Isolation Override
    // 
    // Bits[10:10], RW, default = 0x0
    //
    UINTX ch0_pm_isolen_ovr : 1;
    //
    // Reserved
    // 
    // Bits[31:11], RO, default = 0x0
    //
    UINTX reserved : 21;
  } Bits;
  UINTX Data;
} PM_CH0_CONFIG0_DDRCC1_PHY_STRUCT;
#endif // ASM_INC

#define PM_CH0_CONFIG1_DDRCC1_PHY_REG                      0x000002B8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Select between VNN and LDO: 1 = LDO Selected / 0 = VNN Selected (default)
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINTX ch0_pm_select_ldo : 1;
    //
    // PM adpll lock
    // 
    // Bits[1:1], RO/V, default = 0x0
    //
    UINTX ch0_pm_adpll_lock : 1;
    //
    // 2x Reset Value
    // 
    // Bits[2:2], RW, default = 0x0
    //
    UINTX ch0_pm_pg2xrst_b : 1;
    //
    // 2x Reset Override
    // 
    // Bits[3:3], RW, default = 0x0
    //
    UINTX ch0_pm_pg2xrst_b_ovr : 1;
    //
    // Clock DLL Flop Reset Value
    // 
    // Bits[4:4], RW, default = 0x0
    //
    UINTX ch0_pm_clkdll_floprstb : 1;
    //
    // Clock DLL Flop Reset Override
    // 
    // Bits[5:5], RW, default = 0x0
    //
    UINTX ch0_pm_clkdll_floprstb_ovr : 1;
    //
    // Write Pointer Enable Override
    // 
    // Bits[6:6], RW, default = 0x0
    //
    UINTX ch0_pm_wrptren_ovr : 1;
    //
    // Delay between power off and power on in hvm mode
    // 
    // Bits[10:7], RW, default = 0x4
    //
    UINTX ch0_pm_hvm_delay : 4;
    //
    // HVM Request
    // 
    // Bits[11:11], RW/1S/V, default = 0x0
    //
    UINTX ch0_pm_hvm_req : 1;
    //
    // Reserved
    // 
    // Bits[14:12], RO, default = 0x0
    //
    UINTX reserved : 3;
    //
    // Clock Gate Enable
    // 
    // Bits[15:15], RW, default = 0x0
    //
    UINTX ch0_pm_clkgateen : 1;
    //
    // Reserved
    // 
    // Bits[31:16], RO, default = 0x0
    //
    UINTX reserved_1 : 16;
  } Bits;
  UINTX Data;
} PM_CH0_CONFIG1_DDRCC1_PHY_STRUCT;
#endif // ASM_INC

#define PM_CH0_CONFIG2_DDRCC1_PHY_REG                      0x000002BC
#ifndef ASM_INC
typedef union {
  struct {
    //
    // PIOUT Enable Override
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINTX ch0_pm_piouten_ovr : 1;
    //
    // PI Enable Override
    // 
    // Bits[1:1], RW, default = 0x0
    //
    UINTX ch0_pm_pien_ovr : 1;
    //
    // DQRX FIFO Reset Override
    // 
    // Bits[2:2], RW, default = 0x0
    //
    UINTX ch0_pm_dqrxfiforstb_ovr : 1;
    //
    // VREFEN  Overide value
    // 
    // Bits[3:3], RW, default = 0x0
    //
    UINTX ch0_pm_vrefen_ovr : 1;
    //
    // VREF EN Overide value
    // 
    // Bits[4:4], RW, default = 0x0
    //
    UINTX ch0_pm_vrefen : 1;
    //
    // VREF IO BUFACT Overide
    // 
    // Bits[5:5], RW, default = 0x0
    //
    UINTX ch0_pm_vrefiobufact_ovr : 1;
    //
    // VREF IO BUFACT Overide value
    // 
    // Bits[6:6], RW, default = 0x0
    //
    UINTX ch0_pm_vrefiobufact : 1;
    //
    // c73ddr402_COMP Asyncupdate Override
    // 
    // Bits[7:7], RO, default = 0x0
    //
    UINTX reserved : 1;
    //
    // ADPLL-Out Output Enable Override
    // 
    // Bits[8:8], RW, default = 0x0
    //
    UINTX ch0_pm_adpllouten_ovr : 1;
    //
    // By-Pass Enable
    // 
    // Bits[9:9], RW, default = 0x0
    //
    UINTX ch0_pm_adpll_bypass_en : 1;
    //
    // PM TXDLL DB Refclk PI Enable Override
    // 
    // Bits[10:10], RW, default = 0x0
    //
    UINTX ch0_pm_txdlldbrefclkpienoverride : 1;
    //
    // PM TXDLLSIGGRP PI Enable Override
    // 
    // Bits[11:11], RW, default = 0x0
    //
    UINTX ch0_pm_txdllsiggrppienoverride : 1;
    //
    // PM DQS count resetb Override
    // 
    // Bits[12:12], RW, default = 0x0
    //
    UINTX ch0_pm_dqscountrstboverride : 1;
    //
    // PM RXDLL PI Enable Override
    // 
    // Bits[13:13], RW, default = 0x0
    //
    UINTX ch0_pm_rxdllpienoverride : 1;
    //
    // PM RXDLL Enable Override
    // 
    // Bits[14:14], RW, default = 0x0
    //
    UINTX ch0_pm_rxdllenoverride : 1;
    //
    // PM c73ddr402_COMP Clock Enable Override
    // 
    // Bits[15:15], RW, default = 0x0
    //
    UINTX ch0_pm_compclken_ovr : 1;
    //
    // PM DIVRAWRSTB Override
    // 
    // Bits[16:16], RW, default = 0x0
    //
    UINTX ch0_pm_divrawrstb_ovr : 1;
    //
    // PM SPID Clock Request Override
    // 
    // Bits[17:17], RW, default = 0x0
    //
    UINTX ch0_pm_spidclkreq_ovr : 1;
    //
    // SPID  clock req enable
    // 
    // Bits[18:18], RW, default = 0x0
    //
    UINTX ch0_pm_spidclkreq_en : 1;
    //
    // Reserved
    // 
    // Bits[31:19], RO, default = 0x0
    //
    UINTX reserved_1 : 13;
  } Bits;
  UINTX Data;
} PM_CH0_CONFIG2_DDRCC1_PHY_STRUCT;
#endif // ASM_INC

#define PM_CH0_CONFIG3_DDRCC1_PHY_REG                      0x000002C0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // siggrppien txdll override
    // 
    // Bits[5:0], RO, default = 0x0
    //
    UINTX reserved : 6;
    //
    // ref2xph0pien txdll override
    // 
    // Bits[10:6], RO, default = 0x0
    //
    UINTX reserved_1 : 5;
    //
    // SPID Clock Override
    // 
    // Bits[11:11], RW, default = 0x0
    //
    UINTX ch0_pm_spidclkenovrride : 1;
    //
    // LDO Power On Override
    // 
    // Bits[12:12], RW, default = 0x0
    //
    UINTX ch0_pm_ldopg_pwron_ovr : 1;
    //
    // Reserved
    // 
    // Bits[31:13], RO, default = 0x0
    //
    UINTX reserved_2 : 19;
  } Bits;
  UINTX Data;
} PM_CH0_CONFIG3_DDRCC1_PHY_STRUCT;
#endif // ASM_INC

#define PM_CH0_CONFIG4_DDRCC1_PHY_REG                      0x000002C4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // PM ADPLLOUT Enable Delay
    // 
    // Bits[7:0], RW, default = 0x0
    //
    UINTX ch0_pm_adpllout_enable_dly : 8;
    //
    // PM DIVRST Disable Delay
    // 
    // Bits[15:8], RW, default = 0x0
    //
    UINTX ch0_pm_divrst_disable_dly : 8;
    //
    // PM SPID Clock Disable Delay
    // 
    // Bits[23:16], RW, default = 0x0
    //
    UINTX ch0_pm_spidclk_disable_dly : 8;
    //
    // PM SPID Clock Enable Delay
    // 
    // Bits[31:24], RW, default = 0x0
    //
    UINTX ch0_pm_spidclk_enable_dly : 8;
  } Bits;
  UINTX Data;
} PM_CH0_CONFIG4_DDRCC1_PHY_STRUCT;
#endif // ASM_INC

#define PM_CH0_CONFIG5_DDRCC1_PHY_REG                      0x000002C8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // PM ADPLLEN OFF Delay
    // 
    // Bits[7:0], RW, default = 0x3
    //
    UINTX ch0_pm_adpllen_off_dly : 8;
    //
    // PM ADPLLEN ON Delay
    // 
    // Bits[23:8], RW, default = 0xBB8
    //
    UINTX ch0_pm_adpllen_on_dly : 16;
    //
    // PM DIVRST Enable Delay
    // 
    // Bits[31:24], RW, default = 0x0
    //
    UINTX ch0_pm_divrst_enable_dly : 8;
  } Bits;
  UINTX Data;
} PM_CH0_CONFIG5_DDRCC1_PHY_STRUCT;
#endif // ASM_INC

#define PM_CH0_DELAY0_DDRCC1_PHY_REG                       0x000002CC
#ifndef ASM_INC
typedef union {
  struct {
    //
    // ref2x phase 0 disble delay
    // 
    // Bits[3:0], RW, default = 0x0
    //
    UINTX ch0_pm_ref2xph0_disable_dly : 4;
    //
    // dllcomp clock disable  gate delay
    // 
    // Bits[7:4], RW, default = 0x0
    //
    UINTX ch0_pm_dllcompcg_disable_dly : 4;
    //
    // ref2x phase 0 enable delay
    // 
    // Bits[11:8], RW, default = 0x0
    //
    UINTX ch0_pm_ref2xph0_enable_dly : 4;
    //
    // dllcomp clock enable  gate delay
    // 
    // Bits[15:12], RW, default = 0x0
    //
    UINTX ch0_pm_dllcompcg_enable_dly : 4;
    //
    // Delay to assert/de-assert IO BUFFER ACTIVATE
    // 
    // Bits[23:16], RW, default = 0x1
    //
    UINTX ch0_pm_iobufact_dly : 8;
    //
    // Wait timer for the message interface to provide delay before ack/nack is aaserted
    // or deaaserted 
    // 
    // Bits[27:24], RW, default = 0x0
    //
    UINTX ch0_pm_acktime : 4;
    //
    // Reserved
    // 
    // Bits[31:28], RO, default = 0x0
    //
    UINTX reserved : 4;
  } Bits;
  UINTX Data;
} PM_CH0_DELAY0_DDRCC1_PHY_STRUCT;
#endif // ASM_INC

#define PM_CH0_DELAY1_DDRCC1_PHY_REG                       0x000002D0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Delay after which the pmseq state machine moves from en_comp state to en_sigref
    // state 
    // 
    // Bits[15:0], RW, default = 0x190
    //
    UINTX ch0_pm_comp_enable_dly : 16;
    //
    // Delay to turn on the PI's associated with the DLLs in each module
    // 
    // Bits[23:16], RW, default = 0x4
    //
    UINTX ch0_pm_sdll_enable_dly : 8;
    //
    // Delay to turn on the PI's associated with the wrptr in each module
    // 
    // Bits[31:24], RW, default = 0x2
    //
    UINTX ch0_pm_wrptr_enable_dly : 8;
  } Bits;
  UINTX Data;
} PM_CH0_DELAY1_DDRCC1_PHY_STRUCT;
#endif // ASM_INC

#define PM_CH0_DELAY2_DDRCC1_PHY_REG                       0x000002D4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Delay to turn off the PI's associated with the DLLs in each module
    // 
    // Bits[7:0], RW, default = 0x2
    //
    UINTX ch0_pm_sdll_disable_dly : 8;
    //
    // Delay to turn off the PI's associated with the wrptr in each module
    // 
    // Bits[15:8], RW, default = 0x2
    //
    UINTX ch0_pm_wrptr_disable_dly : 8;
    //
    // Delay after which the pmseq state machine moves from adpll_sfron state to adpll_on_hs
    // state 
    // 
    // Bits[31:16], RW, default = 0xC8
    //
    UINTX ch0_pm_adpll_sfron_dly : 16;
  } Bits;
  UINTX Data;
} PM_CH0_DELAY2_DDRCC1_PHY_STRUCT;
#endif // ASM_INC

#define PM_CH0_DELAY3_DDRCC1_PHY_REG                       0x000002D8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Delay after which the pmseq state machine moves from dis_comp state to adpll_off_hs
    // state 
    // 
    // Bits[15:0], RW, default = 0x0
    //
    UINTX ch0_pm_adpll_sfroff_dly : 16;
    //
    // Reserved
    // 
    // Bits[31:16], RW, default = 0x0
    //
    UINTX ch0_pm_comp_disable_dly : 16;
  } Bits;
  UINTX Data;
} PM_CH0_DELAY3_DDRCC1_PHY_STRUCT;
#endif // ASM_INC

#define PM_CH0_DELAY4_DDRCC1_PHY_REG                       0x000002DC
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Delay for the clock gate or clock ungate
    // 
    // Bits[3:0], RW, default = 0x4
    //
    UINTX ch0_pm_clkgate_wait_timer : 4;
    //
    // Delay for the isolate and un-isolate
    // 
    // Bits[7:4], RW, default = 0x2
    //
    UINTX ch0_pm_isol2pgdly : 4;
    //
    // Delay between each power gating stagger FSM state transition
    // 
    // Bits[15:8], RW, default = 0xA
    //
    UINTX ch0_pm_pg_enable_stgdly : 8;
    //
    // Delay between each power un-gating stagger FSM state transition
    // 
    // Bits[23:16], RW, default = 0xA
    //
    UINTX ch0_pm_pg_disable_stgdly : 8;
    //
    // Delay to turn on the PI's associated with the Locked DLLs in each module
    // 
    // Bits[31:24], RW, default = 0x45
    //
    UINTX ch0_pm_sdll_lock_dly : 8;
  } Bits;
  UINTX Data;
} PM_CH0_DELAY4_DDRCC1_PHY_STRUCT;
#endif // ASM_INC

#define PM_CH0_DELAY5_DDRCC1_PHY_REG                       0x000002E0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Delay to assert pgphyrst_d
    // 
    // Bits[7:0], RW, default = 0x4
    //
    UINTX ch0_pm_pgphyrstb_disable_dly : 8;
    //
    // Delay to deassert pgphyrst_b
    // 
    // Bits[15:8], RW, default = 0x4
    //
    UINTX ch0_pm_pgphyrstb_enable_dly : 8;
    //
    // Delay to assert pg2xrst_b
    // 
    // Bits[23:16], RW, default = 0x4
    //
    UINTX ch0_pm_pg2xrstb_disable_dly : 8;
    //
    // Delay to deassert pg2xrstb
    // 
    // Bits[31:24], RW, default = 0x4
    //
    UINTX ch0_pm_pg2xrstb_enable_dly : 8;
  } Bits;
  UINTX Data;
} PM_CH0_DELAY5_DDRCC1_PHY_STRUCT;
#endif // ASM_INC

#define PM_CH0_DELAY6_DDRCC1_PHY_REG                       0x000002E4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Delay after vrefiobufact set to 0
    // 
    // Bits[11:0], RW, default = 0x4
    //
    UINTX ch0_pm_vrefiobufact_disable_dly : 12;
    //
    // Delay after vrefiobufact set to 1
    // 
    // Bits[23:12], RW, default = 0x4
    //
    UINTX ch0_pm_vrefiobufact_enable_dly : 12;
    //
    // Reserved (was Delay after c73ddr402_comp async override set to 1 in PM2)
    // 
    // Bits[29:24], RO, default = 0x0
    //
    UINTX reserved : 6;
    //
    // Reserved
    // 
    // Bits[31:30], RO, default = 0x0
    //
    UINTX reserved_1 : 2;
  } Bits;
  UINTX Data;
} PM_CH0_DELAY6_DDRCC1_PHY_STRUCT;
#endif // ASM_INC

#define PM_CH0_DELAY7_DDRCC1_PHY_REG                       0x000002E8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Delay after vrefen set to 0
    // 
    // Bits[11:0], RW, default = 0x4
    //
    UINTX ch0_pm_vrefen_disable_dly : 12;
    //
    // Delay after vrefen set to 1
    // 
    // Bits[23:12], RW, default = 0x4
    //
    UINTX ch0_pm_vrefen_enable_dly : 12;
    //
    // Reserved (was Delay after c73ddr402_comp async override set to 0 in PM2)
    // 
    // Bits[29:24], RO, default = 0x0
    //
    UINTX reserved : 6;
    //
    // Reserved
    // 
    // Bits[31:30], RO, default = 0x0
    //
    UINTX reserved_1 : 2;
  } Bits;
  UINTX Data;
} PM_CH0_DELAY7_DDRCC1_PHY_STRUCT;
#endif // ASM_INC

#define PM_CH0_DELAY8_DDRCC1_PHY_REG                       0x000002EC
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Enable PI delay
    // 
    // Bits[3:0], RW, default = 0x0
    //
    UINTX ch0_pm_pien_dly : 4;
    //
    // Enable LDO vref delay
    // 
    // Bits[7:4], RW, default = 0x0
    //
    UINTX ch0_pm_disable_ldovref_dly : 4;
    //
    // Enable LDO isol dleay
    // 
    // Bits[10:8], RW, default = 0x0
    //
    UINTX ch0_pm_disable_isol_dly : 3;
    //
    // Enable LDO Power gate delay
    // 
    // Bits[18:11], RW, default = 0x0
    //
    UINTX ch0_pm_disable_ldopg_dly : 8;
    //
    // disable ref2xrstb
    // 
    // Bits[21:19], RW, default = 0x2
    //
    UINTX ch0_pm_ref2xrstb_disable_dly : 3;
    //
    // enable ref2xrstb
    // 
    // Bits[24:22], RW, default = 0x2
    //
    UINTX ch0_pm_ref2xrstb_enable_dly : 3;
    //
    // Reserved
    // 
    // Bits[31:25], RO, default = 0x0
    //
    UINTX reserved : 7;
  } Bits;
  UINTX Data;
} PM_CH0_DELAY8_DDRCC1_PHY_STRUCT;
#endif // ASM_INC

#define PM_CH0_DELAY9_DDRCC1_PHY_REG                       0x000002F0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Disable LDO vref delay
    // 
    // Bits[15:0], RW, default = 0x0
    //
    UINTX ch0_pm_enable_ldovref_dly : 16;
    //
    // Disable LDO isol dleay
    // 
    // Bits[18:16], RW, default = 0x0
    //
    UINTX ch0_pm_enable_isol_dly : 3;
    //
    // Disable LDO Power gate delay
    // 
    // Bits[22:19], RW, default = 0x0
    //
    UINTX ch0_pm_enable_ldopg_dly : 4;
    //
    // Disable PI Output delay
    // 
    // Bits[26:23], RW, default = 0x0
    //
    UINTX ch0_pm_piout_disable_dly : 4;
    //
    // Enable PI Output delay
    // 
    // Bits[30:27], RW, default = 0x0
    //
    UINTX ch0_pm_piout_enable_dly : 4;
    //
    // Reserved
    // 
    // Bits[31:31], RO, default = 0x0
    //
    UINTX reserved : 1;
  } Bits;
  UINTX Data;
} PM_CH0_DELAY9_DDRCC1_PHY_STRUCT;
#endif // ASM_INC

#define PM_CH0_SWMSG_DDRCC1_PHY_REG                        0x000002F4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Config based Power Management Message
    // 
    // Bits[4:0], RW, default = 0x0
    //
    UINTX ch0_pm_sw_msg : 5;
    //
    // Config based Power Management Message Request
    // 
    // Bits[5:5], RW/1S/V, default = 0x0
    //
    UINTX ch0_pm_sw_req : 1;
    //
    // PM software acknowledge
    // 
    // Bits[6:6], RO/V, default = 0x0
    //
    UINTX ch0_pm_sw_ack : 1;
    //
    // HVM PM Message
    // 
    // Bits[11:7], RW, default = 0x4
    //
    UINTX ch0_pm_hvm_pmmsg : 5;
    //
    // PM message status
    // 
    // Bits[16:12], RO/V, default = 0x0
    //
    UINTX ch0_pm_cfg_status : 5;
    //
    // Reserved
    // 
    // Bits[31:17], RO, default = 0x0
    //
    UINTX reserved : 15;
  } Bits;
  UINTX Data;
} PM_CH0_SWMSG_DDRCC1_PHY_STRUCT;
#endif // ASM_INC

#define DIGCTL_CH1_DDRCC1_PHY_REG                          0x000003B0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // SPID clock clock domain reset-bar. Combined with PM reset control
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINTX ch1_spidrst_b : 1;
    //
    // Write pointer enable. Combined with PM control
    // 
    // Bits[1:1], RW, default = 0x0
    //
    UINTX ch1_wrptren : 1;
    //
    // Boot sequence initialisation complete SPID output to Dunit. 1 = initialisation
    // completed 
    // 
    // Bits[2:2], RW, default = 0x0
    //
    UINTX ch1_spid_init_complete : 1;
    //
    // CC1 I/O buffer activate: Reset for final TX flops in CC1 upartition.[br]Tristates
    // IO buffers.[br]Disable Rx sections of IO buffers.[br]0 = reset , 1 = out of reset
    // 
    // Bits[3:3], RW, default = 0x0
    //
    UINTX ch1_iobufact : 1;
    //
    // Multi Cycle Path Control. 0 = NO Pipelining, 1 = Pipelining (1 Stage)
    // 
    // Bits[4:4], RW, default = 0x0
    //
    UINTX ch1_rdmcpsel : 1;
    //
    // Reserved
    // 
    // Bits[6:5], RO, default = 0x0
    //
    UINTX reserved : 2;
    //
    // Reserved
    // 
    // Bits[8:7], RO, default = 0x0
    //
    UINTX reserved_1 : 2;
    //
    // Ch1 Spidclk clkack return from SOC to acknowledge that spidclk drop off are running.
    // 
    // Bits[9:9], RO/V, default = 0x0
    //
    UINTX ch1_spidclk_clkack : 1;
    //
    // CH1 bus_quiet_time_req config.                          1: to enable the bus_quiet_time_req
    // to SOC for CH1.                                                              
    //              0: to disable the bus_quiet_time_req to SOC for CH1. 
    // 
    // Bits[10:10], RW, default = 0x0
    //
    UINTX ch1_bus_quiet_time_req : 1;
    //
    // CH1 selfrefresh_exit req config.                           1: to enable the self-refresh
    // exit request to SOC for CH1.                                                 
    //                      0: to disable the self-refresh exit request to SOC for CH1.
    // 
    // Bits[11:11], RW, default = 0x0
    //
    UINTX ch1_selfrefresh_exit_req : 1;
    //
    // Reserved
    // 
    // Bits[31:12], RO, default = 0x0
    //
    UINTX reserved_2 : 20;
  } Bits;
  UINTX Data;
} DIGCTL_CH1_DDRCC1_PHY_STRUCT;
#endif // ASM_INC

#define PTROFFSET_CH1_DDRCC1_PHY_REG                       0x000003B4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Initial offset for 2x clock read pointers
    // 
    // Bits[4:0], RW, default = 0x0
    //
    UINTX ch1_ref2xrdptrinit : 5;
    //
    // Reserved
    // 
    // Bits[31:5], RO, default = 0x0
    //
    UINTX reserved : 27;
  } Bits;
  UINTX Data;
} PTROFFSET_CH1_DDRCC1_PHY_STRUCT;
#endif // ASM_INC

#define CMDSIGCTL_CH1_DDRCC1_PHY_REG                       0x000003B8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Command signal clock deadband select. Cmd group 0. 00: No Deadband Zone[br]01:
    // No Deadband Zone 270 pathsel[br]10: Deadband 90 degree path sel[br]11: Deadband
    // 180 degree path sel. 
    // 
    // Bits[1:0], RW, default = 0x0
    //
    UINTX ch1_grp0cmddbsel : 2;
    //
    // Command signal clock read pointer offset. Cmd group 0
    // 
    // Bits[6:2], RW, default = 0x0
    //
    UINTX ch1_grp0cmdsigrdptroffset : 5;
    //
    // Command signal clock deadband select. Cmd group 1. 00: No Deadband Zone[br]01:
    // No Deadband Zone 270 pathsel[br]10: Deadband 90 degree path sel[br]11: Deadband
    // 180 degree path sel. 
    // 
    // Bits[8:7], RW, default = 0x0
    //
    UINTX ch1_grp1cmddbsel : 2;
    //
    // Command signal clock read pointer offset. Cmd group 1
    // 
    // Bits[13:9], RW, default = 0x0
    //
    UINTX ch1_grp1cmdsigrdptroffset : 5;
    //
    // Reserved
    // 
    // Bits[31:14], RO, default = 0x0
    //
    UINTX reserved : 18;
  } Bits;
  UINTX Data;
} CMDSIGCTL_CH1_DDRCC1_PHY_STRUCT;
#endif // ASM_INC

#define CMDDRVEN_CH1_DDRCC1_PHY_REG                        0x000003BC
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Reserved
    // 
    // Bits[8:0], RO, default = 0x0
    //
    UINTX reserved : 9;
    //
    // Command tristate enables per bit. 1 = buffer enabled, 0 = tristate
    // 
    // Bits[18:9], RW, default = 0x0
    //
    UINTX ch1_cmdtxdrven : 10;
    //
    // Reserved
    // 
    // Bits[31:19], RO, default = 0x0
    //
    UINTX reserved_1 : 13;
  } Bits;
  UINTX Data;
} CMDDRVEN_CH1_DDRCC1_PHY_STRUCT;
#endif // ASM_INC

#define CLKSIGCTL_CH1_DDRCC1_PHY_REG                       0x000003C0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Clock rank 0 signal clock deadband select. 00: No Deadband Zone[br]01: No Deadband
    // Zone 270 pathsel[br]10: Deadband 90 degree path sel[br]11: Deadband 180 degree
    // path sel. 
    // 
    // Bits[1:0], RW, default = 0x0
    //
    UINTX ch1_rk0clkdbsel : 2;
    //
    // Clock rank 1 signal clock deadband select. 00: No Deadband Zone[br]01: No Deadband
    // Zone 270 pathsel[br]10: Deadband 90 degree path sel[br]11: Deadband 180 degree
    // path sel. 
    // 
    // Bits[3:2], RW, default = 0x0
    //
    UINTX ch1_rk1clkdbsel : 2;
    //
    // Clock rank 2 signal clock deadband select. 00: No Deadband Zone[br]01: No Deadband
    // Zone 270 pathsel[br]10: Deadband 90 degree path sel[br]11: Deadband 180 degree
    // path sel. 
    // 
    // Bits[5:4], RW, default = 0x0
    //
    UINTX ch1_rk2clkdbsel : 2;
    //
    // Clock rank 3 signal clock deadband select. 00: No Deadband Zone[br]01: No Deadband
    // Zone 270 pathsel[br]10: Deadband 90 degree path sel[br]11: Deadband 180 degree
    // path sel. 
    // 
    // Bits[7:6], RW, default = 0x0
    //
    UINTX ch1_rk3clkdbsel : 2;
    //
    // Clock rank 0 signal clock read pointer offset
    // 
    // Bits[12:8], RW, default = 0x0
    //
    UINTX ch1_rk0clksigrdptroffset : 5;
    //
    // Clock rank 1 signal clock read pointer offset
    // 
    // Bits[17:13], RW, default = 0x0
    //
    UINTX ch1_rk1clksigrdptroffset : 5;
    //
    // Clock rank 2 signal clock read pointer offset
    // 
    // Bits[22:18], RW, default = 0x0
    //
    UINTX ch1_rk2clksigrdptroffset : 5;
    //
    // Clock rank 3 signal clock read pointer offset
    // 
    // Bits[27:23], RW, default = 0x0
    //
    UINTX ch1_rk3clksigrdptroffset : 5;
    //
    // Reserved
    // 
    // Bits[31:28], RO, default = 0x0
    //
    UINTX reserved : 4;
  } Bits;
  UINTX Data;
} CLKSIGCTL_CH1_DDRCC1_PHY_STRUCT;
#endif // ASM_INC

#define TXDLLCFG3_CH1_DDRCC1_PHY_REG                       0x000003C4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // PI Code for Signal Group3 output
    // 
    // Bits[5:0], RW, default = 0x0
    //
    UINTX txdll_siggrp03picode : 6;
    //
    // PI Code for Signal Group4 output
    // 
    // Bits[11:6], RW, default = 0x0
    //
    UINTX txdll_siggrp04picode : 6;
    //
    // PI Code for Signal Group5 output
    // 
    // Bits[17:12], RW, default = 0x0
    //
    UINTX txdll_siggrp05picode : 6;
    //
    // Reserved
    // 
    // Bits[31:18], RO, default = 0x0
    //
    UINTX reserved : 14;
  } Bits;
  UINTX Data;
} TXDLLCFG3_CH1_DDRCC1_PHY_STRUCT;
#endif // ASM_INC

#define TXDLLCFG4_CH1_DDRCC1_PHY_REG                       0x000003C8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // PI Code for Signal Group9 output
    // 
    // Bits[5:0], RW, default = 0x0
    //
    UINTX txdll_siggrp09picode : 6;
    //
    // PI Code for Signal Group10 output
    // 
    // Bits[11:6], RW, default = 0x0
    //
    UINTX txdll_siggrp10picode : 6;
    //
    // PI Code for Signal Group11 output
    // 
    // Bits[17:12], RW, default = 0x0
    //
    UINTX txdll_siggrp11picode : 6;
    //
    // Reserved
    // 
    // Bits[31:18], RO, default = 0x0
    //
    UINTX reserved : 14;
  } Bits;
  UINTX Data;
} TXDLLCFG4_CH1_DDRCC1_PHY_STRUCT;
#endif // ASM_INC

#define CLKMISC_CH1_DDRCC1_PHY_REG                         0x000003CC
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Clock output phase inversion. 0 = No clock inversion. 1 = clock inverted
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINTX ch1_clknegxposb : 1;
    //
    // Clock tristate enables per rank. 1 = buffer enabled, 0 = tristate
    // 
    // Bits[4:1], RW, default = 0x0
    //
    UINTX ch1_clktxdrven : 4;
    //
    // Reserved
    // 
    // Bits[31:5], RO, default = 0x0
    //
    UINTX reserved : 27;
  } Bits;
  UINTX Data;
} CLKMISC_CH1_DDRCC1_PHY_STRUCT;
#endif // ASM_INC

#define DIGOBS_CH1_DDRCC1_PHY_REG                          0x000003D0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // reserved
    // 
    // Bits[3:0], RW, default = 0x0
    //
    UINTX ch1_cmdbuf_digobs1sel : 4;
    //
    // reserved
    // 
    // Bits[7:4], RW, default = 0x0
    //
    UINTX ch1_cmdbuf_digobs0sel : 4;
    //
    // reserved
    // 
    // Bits[11:8], RW, default = 0x0
    //
    UINTX ch1_clkbuf_digobs1sel : 4;
    //
    // reserved
    // 
    // Bits[15:12], RW, default = 0x0
    //
    UINTX ch1_clkbuf_digobs0sel : 4;
    //
    // Reserved
    // 
    // Bits[31:16], RO, default = 0x0
    //
    UINTX reserved : 16;
  } Bits;
  UINTX Data;
} DIGOBS_CH1_DDRCC1_PHY_STRUCT;
#endif // ASM_INC

#define CMD_AFE_CH1_DDRCC1_PHY_REG                         0x000003D4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Pull-down RCOMP code for driver static leg. DQ/CLK uses [3:0]  & CMD uses [3]
    // since it has no EQ support. 
    // 
    // Bits[2:0], RW, default = 0x7
    //
    UINTX ch1_cmd_pdndrvstatic : 3;
    //
    // Pull-up RCOMP code for driver static leg. DQ/CLK uses [3:0]  & CMD uses [3] since
    // it has no EQ support. 
    // 
    // Bits[5:3], RW, default = 0x7
    //
    UINTX ch1_cmd_pupdrvstatic : 3;
    //
    // cmd rx enable
    // 
    // Bits[6:6], RW, default = 0x0
    //
    UINTX ch1_cmd_rxen : 1;
    //
    // Delay cell static leg enable, Support DFX Per leg testing of delay cells in Predriver
    // Logic/Delay c73ddr402_comp.                                                  
    //                                                                              
    //                                                                              
    //                                1: enabled       (default)                    
    //                                0: disabled 
    // 
    // Bits[7:7], RW, default = 0x1
    //
    UINTX ch1_cmd_dlycellstaticlegen : 1;
    //
    // Stretches falling edge of Buffer enable pulse to support Early DQ mode.[br][1:0]
    // is used as POR,    [br]00=default pulse width[br]01=minimum stretch on width[br]10=intermediate
    // stretch on pulse[br]11=maximum stretch on pulse. 
    // 
    // Bits[9:8], RW, default = 0x0
    //
    UINTX ch1_cmd_drvenstretch : 2;
    //
    // Transmitter segment enable. Only used to enable DFX Per Leg checks.
    // 
    // Bits[13:10], RW, default = 0xF
    //
    UINTX ch1_cmd_drvsegen : 4;
    //
    // Fall TCO c73ddr402_COMP code
    // 
    // Bits[19:14], RW, default = 0x3F
    //
    UINTX ch1_cmd_tcocompfall : 6;
    //
    // Rise TCO c73ddr402_COMP code
    // 
    // Bits[25:20], RW, default = 0x3F
    //
    UINTX ch1_cmd_tcocomprise : 6;
    //
    // dfx legtest enable pin. Allows for independent control of the lower 4 legs of
    // the deley element which are controlled by the decoder. 1: enabled       0 : disabled
    // (default) 
    // 
    // Bits[26:26], RW, default = 0x0
    //
    UINTX ch1_cmd_pbddfxtesten : 1;
    //
    // Reserved
    // 
    // Bits[31:27], RO, default = 0x0
    //
    UINTX reserved : 5;
  } Bits;
  UINTX Data;
} CMD_AFE_CH1_DDRCC1_PHY_STRUCT;
#endif // ASM_INC

#define CLK_AFE_CH1_DDRCC1_PHY_REG                         0x000003D8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Pull-down RCOMP code for driver static leg for CLK buffers
    // 
    // Bits[2:0], RW, default = 0x7
    //
    UINTX ch1_clk_pdndrvstatic : 3;
    //
    // Pull-up RCOMP code for driver static leg for CLK buffers
    // 
    // Bits[5:3], RW, default = 0x7
    //
    UINTX ch1_clk_pupdrvstatic : 3;
    //
    // This signal is to differentiate RDIMM CLK functionality from other DIMM types.
    // During S3 mode, RDIMM CLK is required to pulled down to GND (like CKE buffer).
    // The value of this signal is '1'  for RDIMM and '0' for other DIMM types. 
    // 
    // Bits[6:6], RW, default = 0x0
    //
    UINTX ch1_clk_clktristateenb : 1;
    //
    // clk rx enable
    // 
    // Bits[7:7], RW, default = 0x0
    //
    UINTX ch1_clk_rxen : 1;
    //
    // Delay cell static leg enable, Support DFX Per leg testing of delay cells in Predriver
    // Logic/Delay c73ddr402_comp.                                                  
    //                                                                              
    //                                                                              
    //                                1: enabled       (default)                    
    //                                0: disabled 
    // 
    // Bits[8:8], RW, default = 0x1
    //
    UINTX ch1_clk_dlycellstaticlegen : 1;
    //
    // Stretches falling edge of Buffer enable pulse to support Early DQ mode.  [br]00=default
    // pulse width[br]01=minimum stretch on width[br]10=intermediate stretch on pulse[br]11=maximum
    // stretch on pulse. 
    // 
    // Bits[10:9], RW, default = 0x0
    //
    UINTX ch1_clk_drvenstretch : 2;
    //
    // Transmitter segment enable. Only used to enable DFX Per Leg checks.
    // 
    // Bits[13:11], RW, default = 0x7
    //
    UINTX ch1_clk_drvsegen : 3;
    //
    // Selects early or late version of Pre-drive Delay line for RCOMP code Update. 00=>
    // 1st delaycell, 01=> 2nd delaycell, 10=>3rd delaycell, 11=>Reserved 
    // 
    // Bits[15:14], RW, default = 0x1
    //
    UINTX ch1_clk_rcompdelaysel : 2;
    //
    // Selects early or late version of Pre-drive Delay line for SCOMP code Update. 00=>
    // 1st delaycell, 01=> 2nd delaycell, 10=>3rd delaycell, 11=>Reserved 
    // 
    // Bits[17:16], RW, default = 0x1
    //
    UINTX ch1_clk_scompdelaysel : 2;
    //
    // Fall TCO c73ddr402_COMP code
    // 
    // Bits[23:18], RW, default = 0x3F
    //
    UINTX ch1_clk_tcocompfall : 6;
    //
    // Rise TCO c73ddr402_COMP code
    // 
    // Bits[29:24], RW, default = 0x3F
    //
    UINTX ch1_clk_tcocomprise : 6;
    //
    // dfx legtest enable pin. Allows for independent control of the lower 4 legs of
    // the deley element which are controlled by the decoder. 1: enabled       0 : disabled
    // (default) 
    // 
    // Bits[30:30], RW, default = 0x0
    //
    UINTX ch1_clk_pbddfxtesten : 1;
    //
    // Active LOW reset signal for CLK buffer update logic synchronizer flops
    // 
    // Bits[31:31], RW, default = 0x0
    //
    UINTX ch1_clkbuf_resetb : 1;
  } Bits;
  UINTX Data;
} CLK_AFE_CH1_DDRCC1_PHY_STRUCT;
#endif // ASM_INC

#define CLK_COMPOVR_AFE_CH1_DDRCC1_PHY_REG                 0x000003DC
#ifndef ASM_INC
typedef union {
  struct {
    //
    // SCOMP code override for CLK buffers
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINTX ch1_clktx_scompoverride : 1;
    //
    // RCOMP code override for CLK buffers
    // 
    // Bits[1:1], RW, default = 0x0
    //
    UINTX ch1_clktx_rcompoverride : 1;
    //
    // Reserved
    // 
    // Bits[31:2], RO, default = 0x0
    //
    UINTX reserved : 30;
  } Bits;
  UINTX Data;
} CLK_COMPOVR_AFE_CH1_DDRCC1_PHY_STRUCT;
#endif // ASM_INC

#define MRGMODE_CH1_DDRCC1_PHY_REG                         0x000004B0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // DFX margin mode TX data phase 0
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINTX ch1_dfxmrgtxd_ph0 : 1;
    //
    // DFX margin mode TX data phase 1
    // 
    // Bits[1:1], RW, default = 0x0
    //
    UINTX ch1_dfxmrgtxd_ph1 : 1;
    //
    // DFX margin mode RX compare values
    // 
    // Bits[9:2], RW, default = 0x0
    //
    UINTX ch1_dfxmrgtxd_cmp : 8;
    //
    // DFX margin mode TX override enable
    // 
    // Bits[10:10], RW, default = 0x0
    //
    UINTX ch1_dfxmrgtx_ovren : 1;
    //
    // DFX margin mode TX write enable
    // 
    // Bits[11:11], RW, default = 0x0
    //
    UINTX ch1_dfxmrgtxwren : 1;
    //
    // DFX margin mode TX strobe data
    // 
    // Bits[13:12], RW, default = 0x0
    //
    UINTX ch1_dfxmrgtxd_strb : 2;
    //
    // Reserved
    // 
    // Bits[31:14], RO, default = 0x0
    //
    UINTX reserved : 18;
  } Bits;
  UINTX Data;
} MRGMODE_CH1_DDRCC1_PHY_STRUCT;
#endif // ASM_INC

#define MRGMODE_DB_CH1_DDRCC1_PHY_REG                      0x000004B4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // DFX margin mode RX DB compare values
    // 
    // Bits[7:0], RW, default = 0x0
    //
    UINTX ch1_dfxmrgtxd_db_cmp : 8;
    //
    // Reserved
    // 
    // Bits[31:8], RO, default = 0x0
    //
    UINTX reserved : 24;
  } Bits;
  UINTX Data;
} MRGMODE_DB_CH1_DDRCC1_PHY_STRUCT;
#endif // ASM_INC

#define PM_CH1_PGOVR_DDRCC1_PHY_REG                        0x000004E0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Power mux (ungated): Enable VNN
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINTX ch1_pswitch_cmn_vnnpwron : 1;
    //
    // Power mux (ungated): Enable VCCA
    // 
    // Bits[1:1], RW, default = 0x0
    //
    UINTX ch1_pswitch_cmn_vccapwron : 1;
    //
    // Select VCCA mode of operation
    // 
    // Bits[2:2], RW, default = 0x0
    //
    UINTX ch1_vcca_sel : 1;
    //
    // 0 for 2 bit stagger ata time sel and 1 for 1 bit stagger at a time
    // 
    // Bits[3:3], RW, default = 0x0
    //
    UINTX ch1_pm_stagger_bits_sel : 1;
    //
    // ref2xrstb override
    // 
    // Bits[4:4], RW, default = 0x0
    //
    UINTX ch1_pm_ref2xrstb_ovr : 1;
    //
    // ref2x phase 0 override
    // 
    // Bits[5:5], RW, default = 0x0
    //
    UINTX ch1_pm_ref2xph0_ovr : 1;
    //
    // dll c73ddr402_comp clock gate overiride
    // 
    // Bits[6:6], RW, default = 0x0
    //
    UINTX ch1_pm_dllcomp_clkgate_ovr : 1;
    //
    // PWR VNNA On Staggered value
    // 
    // Bits[14:7], RW, default = 0x0
    //
    UINTX ch1_pm_vnnapwronstaggered : 8;
    //
    // PWR VNNA On Staggered Override
    // 
    // Bits[15:15], RW, default = 0x0
    //
    UINTX ch1_pm_vnnapwronstaggered_ovr : 1;
    //
    // PWR VCCA On Staggered value
    // 
    // Bits[23:16], RW, default = 0x0
    //
    UINTX ch1_pm_vccapwronstaggered : 8;
    //
    // PWR VCCA On Staggered Override
    // 
    // Bits[24:24], RW, default = 0x0
    //
    UINTX ch1_pm_vccapwronstaggered_ovr : 1;
    //
    // Reserved
    // 
    // Bits[31:25], RO, default = 0x0
    //
    UINTX reserved : 7;
  } Bits;
  UINTX Data;
} PM_CH1_PGOVR_DDRCC1_PHY_STRUCT;
#endif // ASM_INC

#define PM_CH1_CONFIG0_DDRCC1_PHY_REG                      0x000004E4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // c73ddr402_COMP Enbale Value
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINTX ch1_pm_comp_en : 1;
    //
    // c73ddr402_COMP Enbale Overide
    // 
    // Bits[1:1], RW, default = 0x0
    //
    UINTX ch1_pm_comp_en_ovr : 1;
    //
    // SFR On Override
    // 
    // Bits[2:2], RW, default = 0x0
    //
    UINTX ch1_pm_adpll_sfron_ovr : 1;
    //
    // ADPLL Enable Override
    // 
    // Bits[3:3], RW, default = 0x0
    //
    UINTX ch1_pm_adpllen_ovr : 1;
    //
    // SDLL Enable Override
    // 
    // Bits[4:4], RW, default = 0x0
    //
    UINTX ch1_pm_ckdll_sdllen_ovr : 1;
    //
    // IOBUFACT Override
    // 
    // Bits[5:5], RW, default = 0x0
    //
    UINTX ch1_pm_iobufact_ovr : 1;
    //
    // DIFFAMP Enable Overide
    // 
    // Bits[6:6], RW, default = 0x0
    //
    UINTX ch1_pm_diffampenable_ovr : 1;
    //
    // Clock Gate Value
    // 
    // Bits[7:7], RW, default = 0x0
    //
    UINTX ch1_pm_clkgateen_val : 1;
    //
    // Clock Gate Override
    // 
    // Bits[8:8], RW, default = 0x0
    //
    UINTX ch1_pm_clkgateen_ovr : 1;
    //
    // Isolation Enable Value
    // 
    // Bits[9:9], RW, default = 0x0
    //
    UINTX ch1_pm_isolen : 1;
    //
    // Isolation Override
    // 
    // Bits[10:10], RW, default = 0x0
    //
    UINTX ch1_pm_isolen_ovr : 1;
    //
    // Reserved
    // 
    // Bits[31:11], RO, default = 0x0
    //
    UINTX reserved : 21;
  } Bits;
  UINTX Data;
} PM_CH1_CONFIG0_DDRCC1_PHY_STRUCT;
#endif // ASM_INC

#define PM_CH1_CONFIG1_DDRCC1_PHY_REG                      0x000004E8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Select between VNN and LDO: 1 = LDO Selected / 0 = VNN Selected (default)
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINTX ch1_pm_select_ldo : 1;
    //
    // PM adpll lock
    // 
    // Bits[1:1], RO/V, default = 0x0
    //
    UINTX ch1_pm_adpll_lock : 1;
    //
    // 2x Reset Value
    // 
    // Bits[2:2], RW, default = 0x0
    //
    UINTX ch1_pm_pg2xrst_b : 1;
    //
    // 2x Reset Override
    // 
    // Bits[3:3], RW, default = 0x0
    //
    UINTX ch1_pm_pg2xrst_b_ovr : 1;
    //
    // Clock DLL Flop Reset Value
    // 
    // Bits[4:4], RW, default = 0x0
    //
    UINTX ch1_pm_clkdll_floprstb : 1;
    //
    // Clock DLL Flop Reset Override
    // 
    // Bits[5:5], RW, default = 0x0
    //
    UINTX ch1_pm_clkdll_floprstb_ovr : 1;
    //
    // Write Pointer Enable Override
    // 
    // Bits[6:6], RW, default = 0x0
    //
    UINTX ch1_pm_wrptren_ovr : 1;
    //
    // Delay between power off and power on in hvm mode
    // 
    // Bits[10:7], RW, default = 0x4
    //
    UINTX ch1_pm_hvm_delay : 4;
    //
    // HVM Request
    // 
    // Bits[11:11], RW/1S/V, default = 0x0
    //
    UINTX ch1_pm_hvm_req : 1;
    //
    // Reserved
    // 
    // Bits[14:12], RO, default = 0x0
    //
    UINTX reserved : 3;
    //
    // Clock Gate Enable
    // 
    // Bits[15:15], RW, default = 0x0
    //
    UINTX ch1_pm_clkgateen : 1;
    //
    // Reserved
    // 
    // Bits[31:16], RO, default = 0x0
    //
    UINTX reserved_1 : 16;
  } Bits;
  UINTX Data;
} PM_CH1_CONFIG1_DDRCC1_PHY_STRUCT;
#endif // ASM_INC

#define PM_CH1_CONFIG2_DDRCC1_PHY_REG                      0x000004EC
#ifndef ASM_INC
typedef union {
  struct {
    //
    // PIOUT Enable Override
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINTX ch1_pm_piouten_ovr : 1;
    //
    // PI Enable Override
    // 
    // Bits[1:1], RW, default = 0x0
    //
    UINTX ch1_pm_pien_ovr : 1;
    //
    // DQRX FIFO Reset Override
    // 
    // Bits[2:2], RW, default = 0x0
    //
    UINTX ch1_pm_dqrxfiforstb_ovr : 1;
    //
    // VREFEN  Overide value
    // 
    // Bits[3:3], RW, default = 0x0
    //
    UINTX ch1_pm_vrefen_ovr : 1;
    //
    // VREF EN Overide value
    // 
    // Bits[4:4], RW, default = 0x0
    //
    UINTX ch1_pm_vrefen : 1;
    //
    // VREF IO BUFACT Overide
    // 
    // Bits[5:5], RW, default = 0x0
    //
    UINTX ch1_pm_vrefiobufact_ovr : 1;
    //
    // VREF IO BUFACT Overide value
    // 
    // Bits[6:6], RW, default = 0x0
    //
    UINTX ch1_pm_vrefiobufact : 1;
    //
    // c73ddr402_COMP Asyncupdate Override
    // 
    // Bits[7:7], RO, default = 0x0
    //
    UINTX reserved : 1;
    //
    // ADPLL-Out Output Enable Override
    // 
    // Bits[8:8], RW, default = 0x0
    //
    UINTX ch1_pm_adpllouten_ovr : 1;
    //
    // By-Pass Enable
    // 
    // Bits[9:9], RW, default = 0x0
    //
    UINTX ch1_pm_adpll_bypass_en : 1;
    //
    // PM TXDLL DB Refclk PI Enable Override
    // 
    // Bits[10:10], RW, default = 0x0
    //
    UINTX ch1_pm_txdlldbrefclkpienoverride : 1;
    //
    // PM TXDLLSIGGRP PI Enable Override
    // 
    // Bits[11:11], RW, default = 0x0
    //
    UINTX ch1_pm_txdllsiggrppienoverride : 1;
    //
    // PM DQS count resetb Override
    // 
    // Bits[12:12], RW, default = 0x0
    //
    UINTX ch1_pm_dqscountrstboverride : 1;
    //
    // PM RXDLL PI Enable Override
    // 
    // Bits[13:13], RW, default = 0x0
    //
    UINTX ch1_pm_rxdllpienoverride : 1;
    //
    // PM RXDLL Enable Override
    // 
    // Bits[14:14], RW, default = 0x0
    //
    UINTX ch1_pm_rxdllenoverride : 1;
    //
    // PM c73ddr402_COMP Clock Enable Override
    // 
    // Bits[15:15], RW, default = 0x0
    //
    UINTX ch1_pm_compclken_ovr : 1;
    //
    // PM DIVRAWRSTB Override
    // 
    // Bits[16:16], RW, default = 0x0
    //
    UINTX ch1_pm_divrawrstb_ovr : 1;
    //
    // PM SPID Clock Request Override
    // 
    // Bits[17:17], RW, default = 0x0
    //
    UINTX ch1_pm_spidclkreq_ovr : 1;
    //
    // SPID  clock req enable
    // 
    // Bits[18:18], RW, default = 0x0
    //
    UINTX ch1_pm_spidclkreq_en : 1;
    //
    // Reserved
    // 
    // Bits[31:19], RO, default = 0x0
    //
    UINTX reserved_1 : 13;
  } Bits;
  UINTX Data;
} PM_CH1_CONFIG2_DDRCC1_PHY_STRUCT;
#endif // ASM_INC

#define PM_CH1_CONFIG3_DDRCC1_PHY_REG                      0x000004F0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // siggrppien txdll override
    // 
    // Bits[5:0], RO, default = 0x0
    //
    UINTX reserved : 6;
    //
    // ref2xph0pien txdll override
    // 
    // Bits[10:6], RO, default = 0x0
    //
    UINTX reserved_1 : 5;
    //
    // SPID Clock Override
    // 
    // Bits[11:11], RW, default = 0x0
    //
    UINTX ch1_pm_spidclkenovrride : 1;
    //
    // LDO Power On Override
    // 
    // Bits[12:12], RW, default = 0x0
    //
    UINTX ch1_pm_ldopg_pwron_ovr : 1;
    //
    // Reserved
    // 
    // Bits[31:13], RO, default = 0x0
    //
    UINTX reserved_2 : 19;
  } Bits;
  UINTX Data;
} PM_CH1_CONFIG3_DDRCC1_PHY_STRUCT;
#endif // ASM_INC

#define PM_CH1_CONFIG4_DDRCC1_PHY_REG                      0x000004F4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // PM ADPLLOUT Enable Delay
    // 
    // Bits[7:0], RW, default = 0x0
    //
    UINTX ch1_pm_adpllout_enable_dly : 8;
    //
    // PM DIVRST Disable Delay
    // 
    // Bits[15:8], RW, default = 0x0
    //
    UINTX ch1_pm_divrst_disable_dly : 8;
    //
    // PM SPID Clock Disable Delay
    // 
    // Bits[23:16], RW, default = 0x0
    //
    UINTX ch1_pm_spidclk_disable_dly : 8;
    //
    // PM SPID Clock Enable Delay
    // 
    // Bits[31:24], RW, default = 0x0
    //
    UINTX ch1_pm_spidclk_enable_dly : 8;
  } Bits;
  UINTX Data;
} PM_CH1_CONFIG4_DDRCC1_PHY_STRUCT;
#endif // ASM_INC

#define PM_CH1_CONFIG5_DDRCC1_PHY_REG                      0x000004F8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // PM ADPLLEN OFF Delay
    // 
    // Bits[7:0], RW, default = 0x3
    //
    UINTX ch1_pm_adpllen_off_dly : 8;
    //
    // PM ADPLLEN ON Delay
    // 
    // Bits[23:8], RW, default = 0xBB8
    //
    UINTX ch1_pm_adpllen_on_dly : 16;
    //
    // PM DIVRST Enable Delay
    // 
    // Bits[31:24], RW, default = 0x0
    //
    UINTX ch1_pm_divrst_enable_dly : 8;
  } Bits;
  UINTX Data;
} PM_CH1_CONFIG5_DDRCC1_PHY_STRUCT;
#endif // ASM_INC

#define PM_CH1_DELAY0_DDRCC1_PHY_REG                       0x000004FC
#ifndef ASM_INC
typedef union {
  struct {
    //
    // ref2x phase 0 disble delay
    // 
    // Bits[3:0], RW, default = 0x0
    //
    UINTX ch1_pm_ref2xph0_disable_dly : 4;
    //
    // dllcomp clock disable  gate delay
    // 
    // Bits[7:4], RW, default = 0x0
    //
    UINTX ch1_pm_dllcompcg_disable_dly : 4;
    //
    // ref2x phase 0 enable delay
    // 
    // Bits[11:8], RW, default = 0x0
    //
    UINTX ch1_pm_ref2xph0_enable_dly : 4;
    //
    // dllcomp clock enable  gate delay
    // 
    // Bits[15:12], RW, default = 0x0
    //
    UINTX ch1_pm_dllcompcg_enable_dly : 4;
    //
    // Delay to assert/de-assert IO BUFFER ACTIVATE
    // 
    // Bits[23:16], RW, default = 0x1
    //
    UINTX ch1_pm_iobufact_dly : 8;
    //
    // Wait timer for the message interface to provide delay before ack/nack is aaserted
    // or deaaserted 
    // 
    // Bits[27:24], RW, default = 0x0
    //
    UINTX ch1_pm_acktime : 4;
    //
    // Reserved
    // 
    // Bits[31:28], RO, default = 0x0
    //
    UINTX reserved : 4;
  } Bits;
  UINTX Data;
} PM_CH1_DELAY0_DDRCC1_PHY_STRUCT;
#endif // ASM_INC

#define PM_CH1_DELAY1_DDRCC1_PHY_REG                       0x00000500
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Delay after which the pmseq state machine moves from en_comp state to en_sigref
    // state 
    // 
    // Bits[15:0], RW, default = 0x190
    //
    UINTX ch1_pm_comp_enable_dly : 16;
    //
    // Delay to turn on the PI's associated with the DLLs in each module
    // 
    // Bits[23:16], RW, default = 0x4
    //
    UINTX ch1_pm_sdll_enable_dly : 8;
    //
    // Delay to turn on the PI's associated with the wrptr in each module
    // 
    // Bits[31:24], RW, default = 0x2
    //
    UINTX ch1_pm_wrptr_enable_dly : 8;
  } Bits;
  UINTX Data;
} PM_CH1_DELAY1_DDRCC1_PHY_STRUCT;
#endif // ASM_INC

#define PM_CH1_DELAY2_DDRCC1_PHY_REG                       0x00000504
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Delay to turn off the PI's associated with the DLLs in each module
    // 
    // Bits[7:0], RW, default = 0x2
    //
    UINTX ch1_pm_sdll_disable_dly : 8;
    //
    // Delay to turn off the PI's associated with the wrptr in each module
    // 
    // Bits[15:8], RW, default = 0x2
    //
    UINTX ch1_pm_wrptr_disable_dly : 8;
    //
    // Delay after which the pmseq state machine moves from adpll_sfron state to adpll_on_hs
    // state 
    // 
    // Bits[31:16], RW, default = 0xC8
    //
    UINTX ch1_pm_adpll_sfron_dly : 16;
  } Bits;
  UINTX Data;
} PM_CH1_DELAY2_DDRCC1_PHY_STRUCT;
#endif // ASM_INC

#define PM_CH1_DELAY3_DDRCC1_PHY_REG                       0x00000508
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Delay after which the pmseq state machine moves from dis_comp state to adpll_off_hs
    // state 
    // 
    // Bits[15:0], RW, default = 0x0
    //
    UINTX ch1_pm_adpll_sfroff_dly : 16;
    //
    // Reserved
    // 
    // Bits[31:16], RW, default = 0x0
    //
    UINTX ch1_pm_comp_disable_dly : 16;
  } Bits;
  UINTX Data;
} PM_CH1_DELAY3_DDRCC1_PHY_STRUCT;
#endif // ASM_INC

#define PM_CH1_DELAY4_DDRCC1_PHY_REG                       0x0000050C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Delay for the clock gate or clock ungate
    // 
    // Bits[3:0], RW, default = 0x4
    //
    UINTX ch1_pm_clkgate_wait_timer : 4;
    //
    // Delay for the isolate and un-isolate
    // 
    // Bits[7:4], RW, default = 0x2
    //
    UINTX ch1_pm_isol2pgdly : 4;
    //
    // Delay between each power gating stagger FSM state transition
    // 
    // Bits[15:8], RW, default = 0xA
    //
    UINTX ch1_pm_pg_enable_stgdly : 8;
    //
    // Delay between each power un-gating stagger FSM state transition
    // 
    // Bits[23:16], RW, default = 0xA
    //
    UINTX ch1_pm_pg_disable_stgdly : 8;
    //
    // Delay to turn on the PI's associated with the Locked DLLs in each module
    // 
    // Bits[31:24], RW, default = 0x45
    //
    UINTX ch1_pm_sdll_lock_dly : 8;
  } Bits;
  UINTX Data;
} PM_CH1_DELAY4_DDRCC1_PHY_STRUCT;
#endif // ASM_INC

#define PM_CH1_DELAY5_DDRCC1_PHY_REG                       0x00000510
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Delay to assert pgphyrst_d
    // 
    // Bits[7:0], RW, default = 0x4
    //
    UINTX ch1_pm_pgphyrstb_disable_dly : 8;
    //
    // Delay to deassert pgphyrst_b
    // 
    // Bits[15:8], RW, default = 0x4
    //
    UINTX ch1_pm_pgphyrstb_enable_dly : 8;
    //
    // Delay to assert pg2xrst_b
    // 
    // Bits[23:16], RW, default = 0x4
    //
    UINTX ch1_pm_pg2xrstb_disable_dly : 8;
    //
    // Delay to deassert pg2xrstb
    // 
    // Bits[31:24], RW, default = 0x4
    //
    UINTX ch1_pm_pg2xrstb_enable_dly : 8;
  } Bits;
  UINTX Data;
} PM_CH1_DELAY5_DDRCC1_PHY_STRUCT;
#endif // ASM_INC

#define PM_CH1_DELAY6_DDRCC1_PHY_REG                       0x00000514
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Delay after vrefiobufact set to 0
    // 
    // Bits[11:0], RW, default = 0x4
    //
    UINTX ch1_pm_vrefiobufact_disable_dly : 12;
    //
    // Delay after vrefiobufact set to 1
    // 
    // Bits[23:12], RW, default = 0x4
    //
    UINTX ch1_pm_vrefiobufact_enable_dly : 12;
    //
    // Reserved (was Delay after c73ddr402_comp async override set to 1 in PM2)
    // 
    // Bits[29:24], RO, default = 0x0
    //
    UINTX reserved : 6;
    //
    // Reserved
    // 
    // Bits[31:30], RO, default = 0x0
    //
    UINTX reserved_1 : 2;
  } Bits;
  UINTX Data;
} PM_CH1_DELAY6_DDRCC1_PHY_STRUCT;
#endif // ASM_INC

#define PM_CH1_DELAY7_DDRCC1_PHY_REG                       0x00000518
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Delay after vrefen set to 0
    // 
    // Bits[11:0], RW, default = 0x4
    //
    UINTX ch1_pm_vrefen_disable_dly : 12;
    //
    // Delay after vrefen set to 1
    // 
    // Bits[23:12], RW, default = 0x4
    //
    UINTX ch1_pm_vrefen_enable_dly : 12;
    //
    // Reserved (was Delay after c73ddr402_comp async override set to 0 in PM2)
    // 
    // Bits[29:24], RO, default = 0x0
    //
    UINTX reserved : 6;
    //
    // Reserved
    // 
    // Bits[31:30], RO, default = 0x0
    //
    UINTX reserved_1 : 2;
  } Bits;
  UINTX Data;
} PM_CH1_DELAY7_DDRCC1_PHY_STRUCT;
#endif // ASM_INC

#define PM_CH1_DELAY8_DDRCC1_PHY_REG                       0x0000051C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Enable PI delay
    // 
    // Bits[3:0], RW, default = 0x0
    //
    UINTX ch1_pm_pien_dly : 4;
    //
    // Enable LDO vref delay
    // 
    // Bits[7:4], RW, default = 0x0
    //
    UINTX ch1_pm_disable_ldovref_dly : 4;
    //
    // Enable LDO isol dleay
    // 
    // Bits[10:8], RW, default = 0x0
    //
    UINTX ch1_pm_disable_isol_dly : 3;
    //
    // Enable LDO Power gate delay
    // 
    // Bits[18:11], RW, default = 0x0
    //
    UINTX ch1_pm_disable_ldopg_dly : 8;
    //
    // disable ref2xrstb
    // 
    // Bits[21:19], RW, default = 0x2
    //
    UINTX ch1_pm_ref2xrstb_disable_dly : 3;
    //
    // enable ref2xrstb
    // 
    // Bits[24:22], RW, default = 0x2
    //
    UINTX ch1_pm_ref2xrstb_enable_dly : 3;
    //
    // Reserved
    // 
    // Bits[31:25], RO, default = 0x0
    //
    UINTX reserved : 7;
  } Bits;
  UINTX Data;
} PM_CH1_DELAY8_DDRCC1_PHY_STRUCT;
#endif // ASM_INC

#define PM_CH1_DELAY9_DDRCC1_PHY_REG                       0x00000520
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Disable LDO vref delay
    // 
    // Bits[15:0], RW, default = 0x0
    //
    UINTX ch1_pm_enable_ldovref_dly : 16;
    //
    // Disable LDO isol dleay
    // 
    // Bits[18:16], RW, default = 0x0
    //
    UINTX ch1_pm_enable_isol_dly : 3;
    //
    // Disable LDO Power gate delay
    // 
    // Bits[22:19], RW, default = 0x0
    //
    UINTX ch1_pm_enable_ldopg_dly : 4;
    //
    // Disable PI Output delay
    // 
    // Bits[26:23], RW, default = 0x0
    //
    UINTX ch1_pm_piout_disable_dly : 4;
    //
    // Enable PI Output delay
    // 
    // Bits[30:27], RW, default = 0x0
    //
    UINTX ch1_pm_piout_enable_dly : 4;
    //
    // Reserved
    // 
    // Bits[31:31], RO, default = 0x0
    //
    UINTX reserved : 1;
  } Bits;
  UINTX Data;
} PM_CH1_DELAY9_DDRCC1_PHY_STRUCT;
#endif // ASM_INC

#define PM_CH1_SWMSG_DDRCC1_PHY_REG                        0x00000524
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Config based Power Management Message
    // 
    // Bits[4:0], RW, default = 0x0
    //
    UINTX ch1_pm_sw_msg : 5;
    //
    // Config based Power Management Message Request
    // 
    // Bits[5:5], RW/1S/V, default = 0x0
    //
    UINTX ch1_pm_sw_req : 1;
    //
    // PM software acknowledge
    // 
    // Bits[6:6], RO/V, default = 0x0
    //
    UINTX ch1_pm_sw_ack : 1;
    //
    // HVM PM Message
    // 
    // Bits[11:7], RW, default = 0x4
    //
    UINTX ch1_pm_hvm_pmmsg : 5;
    //
    // PM message status
    // 
    // Bits[16:12], RO/V, default = 0x0
    //
    UINTX ch1_pm_cfg_status : 5;
    //
    // Reserved
    // 
    // Bits[31:17], RO, default = 0x0
    //
    UINTX reserved : 15;
  } Bits;
  UINTX Data;
} PM_CH1_SWMSG_DDRCC1_PHY_STRUCT;
#endif // ASM_INC

#define CC1_LRCOMP_CFG1_DDRCC1_PHY_REG                     0x000005E0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Delay after enabling Rcomp before starting measurement timer
    // 
    // Bits[7:0], RW, default = 0xE
    //
    UINTX reserved : 8;
    //
    // Number of binary search steps
    // 
    // Bits[11:8], RW, default = 0xA
    //
    UINTX reserved_1 : 4;
    //
    // Initial step value for Rcomp binary search
    // 
    // Bits[18:12], RW, default = 0x20
    //
    UINTX lrcomp_initstep : 7;
    //
    // Initial value for Rcomp binary search
    // 
    // Bits[25:19], RW, default = 0x0
    //
    UINTX reserved_2 : 7;
    //
    // Number of times to repeat and average the Rcomp compensation
    // 
    // Bits[30:26], RW, default = 0x1
    //
    UINTX reserved_3 : 5;
    //
    // Reserved bits
    // 
    // Bits[31:31], RO, default = 0x0
    //
    UINTX reserved_4 : 1;
  } Bits;
  UINTX Data;
} CC1_LRCOMP_CFG1_DDRCC1_PHY_STRUCT;
#endif // ASM_INC

#define CC1_LRCOMP_CFG2_DDRCC1_PHY_REG                     0x000005E4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // indicates the division ratio of the c73ddr402_comp clock w.r.t spid clk
    // 
    // Bits[1:0], RW, default = 0x1
    //
    UINTX reserved : 2;
    //
    // set it to '1' to select the membus form gcomp, '0' to select it from previous
    // module. 
    // 
    // Bits[2:2], RW, default = 0x0
    //
    UINTX reserved_1 : 1;
    //
    // Rcomp sample time 3
    // 
    // Bits[10:3], RW, default = 0xE
    //
    UINTX reserved_2 : 8;
    //
    // Rcomp sample time 2
    // 
    // Bits[18:11], RW, default = 0xE
    //
    UINTX reserved_3 : 8;
    //
    // Rcomp sample time 1
    // 
    // Bits[26:19], RW, default = 0xE
    //
    UINTX reserved_4 : 8;
    //
    // Reserved bits
    // 
    // Bits[31:27], RO, default = 0x0
    //
    UINTX reserved_5 : 5;
  } Bits;
  UINTX Data;
} CC1_LRCOMP_CFG2_DDRCC1_PHY_STRUCT;
#endif // ASM_INC

#define CC1_LRCOMP_OVR0_DDRCC1_PHY_REG                     0x000005E8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // not used
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINTX reserved : 1;
    //
    // not used
    // 
    // Bits[7:1], RW, default = 0x0
    //
    UINTX reserved_1 : 7;
    //
    // Pull down override enable
    // 
    // Bits[9:8], RW, default = 0x0
    //
    UINTX reserved_2 : 2;
    //
    // Pull up override enable
    // 
    // Bits[11:10], RW, default = 0x0
    //
    UINTX reserved_3 : 2;
    //
    // override enable for override for pull down live rcomp code going to AFE
    // 
    // Bits[12:12], RW, default = 0x0
    //
    UINTX reserved_4 : 1;
    //
    // override for pull down live rcomp code going to AFE
    // 
    // Bits[19:13], RW, default = 0x1
    //
    UINTX reserved_5 : 7;
    //
    // Reserved bits
    // 
    // Bits[31:20], RO, default = 0x0
    //
    UINTX reserved_6 : 12;
  } Bits;
  UINTX Data;
} CC1_LRCOMP_OVR0_DDRCC1_PHY_STRUCT;
#endif // ASM_INC

#define CC1_LRCOMP_CTL0_DDRCC1_PHY_REG                     0x000005EC
#ifndef ASM_INC
typedef union {
  struct {
    //
    // config contorl for disabling rcomp code per group.
    // 
    // Bits[1:0], RW, default = 0x0
    //
    UINTX reserved : 2;
    //
    // enable for config concifg control for updating rcomp codes.
    // 
    // Bits[2:2], RW, default = 0x0
    //
    UINTX reserved_1 : 1;
    //
    // config control for updating rcomp codes.
    // 
    // Bits[3:3], RW, default = 0x0
    //
    UINTX reserved_2 : 1;
    //
    // not used.
    // 
    // Bits[9:4], RW, default = 0x0
    //
    UINTX reserved_3 : 6;
    //
    // static leg signal for PD c73ddr402_comp buffer.
    // 
    // Bits[10:10], RW, default = 0x1
    //
    UINTX reserved_4 : 1;
    //
    // static live signal for PD c73ddr402_comp buffer.
    // 
    // Bits[11:11], RW, default = 0x1
    //
    UINTX reserved_5 : 1;
    //
    // selects the bus_quiet_time_gnt signal for lcomp buffer.
    // 
    // Bits[13:12], RW, default = 0x1
    //
    UINTX reserved_6 : 2;
    //
    // Reserved bits
    // 
    // Bits[31:14], RO, default = 0x0
    //
    UINTX reserved_7 : 18;
  } Bits;
  UINTX Data;
} CC1_LRCOMP_CTL0_DDRCC1_PHY_STRUCT;
#endif // ASM_INC

#define CC1_LRCOMP_CTL1_DDRCC1_PHY_REG                     0x000005F0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // enable indirect update, when '1', it enables indirect update for respective group,
    // when '0', it disables indirect update for that group. 
    // 
    // Bits[1:0], RW, default = 0x0
    //
    UINTX reserved : 2;
    //
    // tells the rcomp which groups are valid.
    // 
    // Bits[9:2], RW, default = 0x30
    //
    UINTX reserved_1 : 8;
    //
    // tells the rcomp to copy the adjecent code instead of evaluating it
    // 
    // Bits[17:10], RW, default = 0x0
    //
    UINTX reserved_2 : 8;
    //
    // Reserved bits
    // 
    // Bits[31:18], RO, default = 0x0
    //
    UINTX reserved_3 : 14;
  } Bits;
  UINTX Data;
} CC1_LRCOMP_CTL1_DDRCC1_PHY_STRUCT;
#endif // ASM_INC

#define CC1_LRCOMP_RSTCTL_DDRCC1_PHY_REG                   0x000005F4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // active low reset for lcomp.
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINTX reserved : 1;
    //
    // Reserved bits
    // 
    // Bits[31:1], RO, default = 0x0
    //
    UINTX reserved_1 : 31;
  } Bits;
  UINTX Data;
} CC1_LRCOMP_RSTCTL_DDRCC1_PHY_STRUCT;
#endif // ASM_INC

#define CC1_TXDLYCOMP_CLKGATE_DDRCC1_PHY_REG               0x000005F8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Clock gating control for txdlycomp
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINTX reserved : 1;
    //
    // Clock gating control for rcomp.
    // 
    // Bits[1:1], RW, default = 0x0
    //
    UINTX reserved_1 : 1;
    //
    // Reserved bits
    // 
    // Bits[31:2], RO, default = 0x0
    //
    UINTX reserved_2 : 30;
  } Bits;
  UINTX Data;
} CC1_TXDLYCOMP_CLKGATE_DDRCC1_PHY_STRUCT;
#endif // ASM_INC

#define CC1_TXDLYCOMP_INIT_DDRCC1_PHY_REG                  0x000005FC
#ifndef ASM_INC
typedef union {
  struct {
    //
    // enable initial txdlycomp
    // 
    // Bits[0:0], RW/1S/V, default = 0x0
    //
    UINTX reserved : 1;
    //
    // Reserved bits
    // 
    // Bits[31:1], RO, default = 0x0
    //
    UINTX reserved_1 : 31;
  } Bits;
  UINTX Data;
} CC1_TXDLYCOMP_INIT_DDRCC1_PHY_STRUCT;
#endif // ASM_INC

#define CC1_LRCOMP_DEBUG_DDRCC1_PHY_REG                    0x00000600
#ifndef ASM_INC
typedef union {
  struct {
    //
    // debug ctrl bits.
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINTX reserved : 1;
    //
    // debug ctrl bits.
    // 
    // Bits[1:1], RW, default = 0x0
    //
    UINTX reserved_1 : 1;
    //
    // spare bits
    // 
    // Bits[17:2], RW, default = 0x0
    //
    UINTX reserved_2 : 16;
    //
    // Reserved bits
    // 
    // Bits[31:18], RO, default = 0x0
    //
    UINTX reserved_3 : 14;
  } Bits;
  UINTX Data;
} CC1_LRCOMP_DEBUG_DDRCC1_PHY_STRUCT;
#endif // ASM_INC

#define CC1_LRCOMP_OVR1_DDRCC1_PHY_REG                     0x00000604
#ifndef ASM_INC
typedef union {
  struct {
    //
    // grp1 pull down override code
    // 
    // Bits[6:0], RW, default = 0x0
    //
    UINTX reserved : 7;
    //
    // grp1 pull up override code
    // 
    // Bits[13:7], RW, default = 0x0
    //
    UINTX reserved_1 : 7;
    //
    // grp0 pull down override code
    // 
    // Bits[20:14], RW, default = 0x0
    //
    UINTX reserved_2 : 7;
    //
    // grp0 pull up override code
    // 
    // Bits[27:21], RW, default = 0x0
    //
    UINTX reserved_3 : 7;
    //
    // Reserved bits
    // 
    // Bits[31:28], RO, default = 0x0
    //
    UINTX reserved_4 : 4;
  } Bits;
  UINTX Data;
} CC1_LRCOMP_OVR1_DDRCC1_PHY_STRUCT;
#endif // ASM_INC

#define CC1_TXDLYCOMP_0_DDRCC1_PHY_REG                     0x00000608
#ifndef ASM_INC
typedef union {
  struct {
    //
    // TBD
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINTX reserved : 1;
    //
    // continuous enable mode for txdlycomp
    // 
    // Bits[1:1], RW, default = 0x0
    //
    UINTX reserved_1 : 1;
    //
    // TBD
    // 
    // Bits[2:2], RW/1C/V, default = 0x0
    //
    UINTX reserved_2 : 1;
    //
    // config value for grp0 fine code.
    // 
    // Bits[10:3], RW, default = 0x0
    //
    UINTX reserved_3 : 8;
    //
    // config value for grp0 coarse code.
    // 
    // Bits[18:11], RW, default = 0x0
    //
    UINTX reserved_4 : 8;
    //
    // bits for override control of grp0 code
    // 
    // Bits[19:19], RW, default = 0x0
    //
    UINTX reserved_5 : 1;
    //
    // bits to disable for group0 code update.
    // 
    // Bits[20:20], RW, default = 0x0
    //
    UINTX reserved_6 : 1;
    //
    // select the delay tap node in AFE for group0
    // 
    // Bits[25:21], RW, default = 0x2
    //
    UINTX reserved_7 : 5;
    //
    // enable for config update contorl for txdlycomp code.
    // 
    // Bits[26:26], RW, default = 0x0
    //
    UINTX reserved_8 : 1;
    //
    // config update contorl for txdlyocmp code
    // 
    // Bits[27:27], RW, default = 0x0
    //
    UINTX reserved_9 : 1;
    //
    // Reserved bits
    // 
    // Bits[31:28], RO, default = 0x0
    //
    UINTX reserved_10 : 4;
  } Bits;
  UINTX Data;
} CC1_TXDLYCOMP_0_DDRCC1_PHY_STRUCT;
#endif // ASM_INC

#define CC1_TXDLYCOMP_1_DDRCC1_PHY_REG                     0x0000060C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // config value for grp1 fine code.
    // 
    // Bits[7:0], RW, default = 0x0
    //
    UINTX reserved : 8;
    //
    // config value for grp1 coarse code.
    // 
    // Bits[15:8], RW, default = 0x0
    //
    UINTX reserved_1 : 8;
    //
    // bits for override control of grp1 code
    // 
    // Bits[16:16], RW, default = 0x0
    //
    UINTX reserved_2 : 1;
    //
    // bits to disable for group1 code update.
    // 
    // Bits[17:17], RW, default = 0x0
    //
    UINTX reserved_3 : 1;
    //
    // select the delay tap node in AFE for group1
    // 
    // Bits[22:18], RW, default = 0x2
    //
    UINTX reserved_4 : 5;
    //
    // Reserved bits
    // 
    // Bits[31:23], RO, default = 0x0
    //
    UINTX reserved_5 : 9;
  } Bits;
  UINTX Data;
} CC1_TXDLYCOMP_1_DDRCC1_PHY_STRUCT;
#endif // ASM_INC

#define CC1_TXDLYCOMPOVR_DDRCC1_PHY_REG                    0x00000610
#ifndef ASM_INC
typedef union {
  struct {
    //
    // TX Delay c73ddr402_comp MAX value of fine code.
    // 
    // Bits[3:0], RW, default = 0x8
    //
    UINTX reserved : 4;
    //
    // TX Delay c73ddr402_comp MAX value of coarse code.
    // 
    // Bits[7:4], RW, default = 0x7
    //
    UINTX reserved_1 : 4;
    //
    // Enable for TX Delay ocmp live code override value.
    // 
    // Bits[8:8], RW, default = 0x0
    //
    UINTX reserved_2 : 1;
    //
    // TX Delay c73ddr402_comp live code override value
    // 
    // Bits[16:9], RW, default = 0x0
    //
    UINTX reserved_3 : 8;
    //
    // Reserved bits
    // 
    // Bits[31:17], RO, default = 0x0
    //
    UINTX reserved_4 : 15;
  } Bits;
  UINTX Data;
} CC1_TXDLYCOMPOVR_DDRCC1_PHY_STRUCT;
#endif // ASM_INC

#define CC1_LRCOMP_CODES_0_DDRCC1_PHY_REG                  0x00000614
#ifndef ASM_INC
typedef union {
  struct {
    //
    // reserved
    // 
    // Bits[7:0], RO/V, default = 0x8
    //
    UINTX reserved : 8;
    //
    // reserved
    // 
    // Bits[15:8], RO/V, default = 0x7
    //
    UINTX reserved_1 : 8;
    //
    // reserved
    // 
    // Bits[23:16], RO/V, default = 0x0
    //
    UINTX reserved_2 : 8;
    //
    // reserved
    // 
    // Bits[31:24], RO/V, default = 0x0
    //
    UINTX reserved_3 : 8;
  } Bits;
  UINTX Data;
} CC1_LRCOMP_CODES_0_DDRCC1_PHY_STRUCT;
#endif // ASM_INC

#define CC1_LTXDLYCOMP_CODES_0_DDRCC1_PHY_REG              0x00000618
#ifndef ASM_INC
typedef union {
  struct {
    //
    // reserved
    // 
    // Bits[7:0], RO/V, default = 0x8
    //
    UINTX reserved : 8;
    //
    // reserved
    // 
    // Bits[15:8], RO/V, default = 0x7
    //
    UINTX reserved_1 : 8;
    //
    // reserved
    // 
    // Bits[23:16], RO/V, default = 0x0
    //
    UINTX reserved_2 : 8;
    //
    // reserved
    // 
    // Bits[31:24], RO/V, default = 0x0
    //
    UINTX reserved_3 : 8;
  } Bits;
  UINTX Data;
} CC1_LTXDLYCOMP_CODES_0_DDRCC1_PHY_STRUCT;
#endif // ASM_INC

#define CC1_LRCOMP_CTL2_DDRCC1_PHY_REG                     0x0000061C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // For future designs, where there might be a need to generate a stage3 enable for
    // AFE. It needs to be '1' otherwise. 
    // 
    // Bits[3:0], RW, default = 0x1
    //
    UINTX reserved : 4;
    //
    // For future designs, where there might be a need to generate a stage3 enable for
    // AFE. It needs to be '1' otherwise. 
    // 
    // Bits[7:4], RW, default = 0x1
    //
    UINTX reserved_1 : 4;
    //
    // For future designs, where there might be a need to generate a stage3 enable for
    // AFE. It needs to be '1' otherwise. 
    // 
    // Bits[11:8], RW, default = 0x1
    //
    UINTX reserved_2 : 4;
    //
    // the number of cycles after lcomp receives the bus_quiet_time_gnt signal, and before
    // it takes any action. This allows the phy to finish off any running read/write
    // cycles 
    // 
    // Bits[18:12], RW, default = 0x1
    //
    UINTX reserved_3 : 7;
    //
    // Reserved bits
    // 
    // Bits[31:19], RO, default = 0x0
    //
    UINTX reserved_4 : 13;
  } Bits;
  UINTX Data;
} CC1_LRCOMP_CTL2_DDRCC1_PHY_STRUCT;
#endif // ASM_INC

#define CC1_LRCOMP_CTL3_DDRCC1_PHY_REG                     0x00000620
#ifndef ASM_INC
typedef union {
  struct {
    //
    // pull down verf ctrl voltage code for grp1
    // 
    // Bits[5:0], RW, default = 0x20
    //
    UINTX reserved : 6;
    //
    // pull down verf ctrl voltage code for grp0
    // 
    // Bits[11:6], RW, default = 0x20
    //
    UINTX reserved_1 : 6;
    //
    // Masking bit for indirect update for (stg3) stage 3 latches in AFE. Should be always
    // '1' in DNV. 
    // 
    // Bits[12:12], RW, default = 0x1
    //
    UINTX reserved_2 : 1;
    //
    // Manual update for stg3 latches (Async).
    // 
    // Bits[13:13], RW, default = 0x0
    //
    UINTX reserved_3 : 1;
    //
    // Manual update for stg3 latches (sync).
    // 
    // Bits[14:14], RW, default = 0x0
    //
    UINTX reserved_4 : 1;
    //
    // Reserved bits
    // 
    // Bits[31:15], RO, default = 0x0
    //
    UINTX reserved_5 : 17;
  } Bits;
  UINTX Data;
} CC1_LRCOMP_CTL3_DDRCC1_PHY_STRUCT;
#endif // ASM_INC

#define CC1_LRCOMP_CTL4_DDRCC1_PHY_REG                     0x00000624
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Length of update pulse = lrcomp_update_len+1 comp_clk cycles
    // 
    // Bits[3:0], RW, default = 0x0
    //
    UINTX reserved : 4;
    //
    // Width of CLK rcomp stage 2 latch enable = lrcomp_clk_stg2_width + 1 comp_clk cycles
    // 
    // Bits[7:4], RW, default = 0x0
    //
    UINTX reserved_1 : 4;
    //
    // Reserved bits
    // 
    // Bits[31:8], RO, default = 0x0
    //
    UINTX reserved_2 : 24;
  } Bits;
  UINTX Data;
} CC1_LRCOMP_CTL4_DDRCC1_PHY_STRUCT;
#endif // ASM_INC

#define CC1_LRCOMP_CTL5_DDRCC1_PHY_REG                     0x00000628
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Rcomp max value of code. The live code wont go beyond this. If the c73ddr402_comp
    // sm gives a value greater than this, it will be capped to this value. 
    // 
    // Bits[6:0], RW, default = 0x3F
    //
    UINTX reserved : 7;
    //
    // LCOMP channel enable for generating and controlling ospid_selfrefresh_exit_req
    // signal: 00: both channels are disabled, 01: any channel is enabled, Others: reserved
    // 
    // Bits[8:7], RW, default = 0x3
    //
    UINTX reserved_1 : 2;
    //
    // Reserved bits
    // 
    // Bits[31:9], RO, default = 0x0
    //
    UINTX reserved_2 : 23;
  } Bits;
  UINTX Data;
} CC1_LRCOMP_CTL5_DDRCC1_PHY_STRUCT;
#endif // ASM_INC

#define CC1_TXDLYCOMP_2_DDRCC1_PHY_REG                     0x0000062C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Delay after sending timing reference pulse before sampling updn
    // 
    // Bits[7:0], RW, default = 0x0
    //
    UINTX reserved : 8;
    //
    // Delay before sending timing reference pulse
    // 
    // Bits[11:8], RW, default = 0x0
    //
    UINTX reserved_1 : 4;
    //
    // cadence continuous enable mode for txdlycomp
    // 
    // Bits[12:12], RW, default = 0x0
    //
    UINTX reserved_2 : 1;
    //
    // Reserved bits
    // 
    // Bits[31:13], RO, default = 0x0
    //
    UINTX reserved_3 : 19;
  } Bits;
  UINTX Data;
} CC1_TXDLYCOMP_2_DDRCC1_PHY_STRUCT;
#endif // ASM_INC

#define DPIC_GRCOMP_CFG1_DDRCC1_PHY_REG                    0x000006E0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Delay after enabling Rcomp before starting measurement timer
    // 
    // Bits[7:0], RW, default = 0xE
    //
    UINTX reserved : 8;
    //
    // Number of binary search steps
    // 
    // Bits[11:8], RW, default = 0xA
    //
    UINTX reserved_1 : 4;
    //
    // Initial step value for Rcomp binary search
    // 
    // Bits[18:12], RW, default = 0x20
    //
    UINTX rcomp_initstep : 7;
    //
    // Initial value for Rcomp binary search
    // 
    // Bits[25:19], RW, default = 0x0
    //
    UINTX reserved_2 : 7;
    //
    // Number of times to repeat and average the Rcomp compensation
    // 
    // Bits[30:26], RW, default = 0x1
    //
    UINTX reserved_3 : 5;
    //
    // Reserved bits
    // 
    // Bits[31:31], RO, default = 0x0
    //
    UINTX reserved_4 : 1;
  } Bits;
  UINTX Data;
} DPIC_GRCOMP_CFG1_DDRCC1_PHY_STRUCT;
#endif // ASM_INC

#define DPIC_GRCOMP_CFG2_DDRCC1_PHY_REG                    0x000006E4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Debug bits.
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINTX reserved : 1;
    //
    // indicates the division ratio of the c73ddr402_comp clock w.r.t spid clk
    // 
    // Bits[2:1], RW, default = 0x1
    //
    UINTX reserved_1 : 2;
    //
    // GCOMP voltage reference enable
    // 
    // Bits[3:3], RW, default = 0x0
    //
    UINTX reserved_2 : 1;
    //
    // Rcomp sample time 3
    // 
    // Bits[11:4], RW, default = 0xE
    //
    UINTX reserved_3 : 8;
    //
    // Rcomp sample time 2
    // 
    // Bits[19:12], RW, default = 0xE
    //
    UINTX reserved_4 : 8;
    //
    // Rcomp sample time 1
    // 
    // Bits[27:20], RW, default = 0xE
    //
    UINTX reserved_5 : 8;
    //
    // Reserved bits
    // 
    // Bits[31:28], RO, default = 0x0
    //
    UINTX reserved_6 : 4;
  } Bits;
  UINTX Data;
} DPIC_GRCOMP_CFG2_DDRCC1_PHY_STRUCT;
#endif // ASM_INC

#define DPIC_GRCOMP_CFG3_DDRCC1_PHY_REG                    0x000006E8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Rcomp max value of code. The live code wont go beyond this. If the c73ddr402_comp
    // sm gives a value greater than this, it will be capped to this value. 
    // 
    // Bits[6:0], RW, default = 0x3A
    //
    UINTX reserved : 7;
    //
    // GCOMP channel enable for controlling ispid_selfrefresh_exit_gnt signal: bit 1
    // indicates channel 1 and bit 0 indicates channel 0. 00: both channels are disabled,
    // 01: channel #1 disabled and channel #0 enabled, 10: channel #1 enabled and channel
    // #0 enabled, 11: channel #1 enabled and channel #0 enabled 
    // 
    // Bits[8:7], RW, default = 0x3
    //
    UINTX reserved_1 : 2;
    //
    // Reserved bits
    // 
    // Bits[31:9], RO, default = 0x0
    //
    UINTX reserved_2 : 23;
  } Bits;
  UINTX Data;
} DPIC_GRCOMP_CFG3_DDRCC1_PHY_STRUCT;
#endif // ASM_INC

#define CC1_GRCOMP_OVR_DDRCC1_PHY_REG                      0x000006EC
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Reserved bits
    // 
    // Bits[14:0], RO, default = 0x0
    //
    UINTX reserved : 15;
    //
    // Reserved bits
    // 
    // Bits[22:15], RO, default = 0x0
    //
    UINTX reserved_1 : 8;
    //
    // override enable for override for pull up live rcomp code going to AFE
    // 
    // Bits[23:23], RW, default = 0x0
    //
    UINTX reserved_2 : 1;
    //
    // override for pull up live rcomp code going to AFE
    // 
    // Bits[30:24], RW, default = 0x0
    //
    UINTX reserved_3 : 7;
    //
    // Reserved bits
    // 
    // Bits[31:31], RO, default = 0x0
    //
    UINTX reserved_4 : 1;
  } Bits;
  UINTX Data;
} CC1_GRCOMP_OVR_DDRCC1_PHY_STRUCT;
#endif // ASM_INC

#define DPIC_GRCOMP_VREF_0_DDRCC1_PHY_REG                  0x000006F0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // vrefctrl voltage
    // 
    // Bits[7:0], RW, default = 0x18
    //
    UINTX comp_vref_grp3 : 8;
    //
    // vrefctrl voltage
    // 
    // Bits[15:8], RW, default = 0x18
    //
    UINTX comp_vref_grp2 : 8;
    //
    // vrefctrl voltage
    // 
    // Bits[23:16], RW, default = 0x18
    //
    UINTX comp_vref_grp1 : 8;
    //
    // vrefctrl voltage
    // 
    // Bits[31:24], RW, default = 0x18
    //
    UINTX comp_vref_grp0 : 8;
  } Bits;
  UINTX Data;
} DPIC_GRCOMP_VREF_0_DDRCC1_PHY_STRUCT;
#endif // ASM_INC

#define DPIC_GRCOMP_VREF_1_DDRCC1_PHY_REG                  0x000006F4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // vrefctrl voltage
    // 
    // Bits[7:0], RW, default = 0x18
    //
    UINTX reserved : 8;
    //
    // vrefctrl voltage
    // 
    // Bits[15:8], RW, default = 0x18
    //
    UINTX reserved_1 : 8;
    //
    // vrefctrl voltage
    // 
    // Bits[23:16], RW, default = 0x18
    //
    UINTX reserved_2 : 8;
    //
    // Reserved bits
    // 
    // Bits[31:24], RO, default = 0x0
    //
    UINTX reserved_3 : 8;
  } Bits;
  UINTX Data;
} DPIC_GRCOMP_VREF_1_DDRCC1_PHY_STRUCT;
#endif // ASM_INC

#define CC1_GRCOMP_RSTCTL_DDRCC1_PHY_REG                   0x000006F8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // async active low reset for gcomp
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINTX reserved : 1;
    //
    // This count estimates the number of cycles it would take for all LCOMP from the
    // start of LCOMP evaluation to the finish of LCOMP evaluation. 
    // 
    // Bits[15:1], RW, default = 0x960
    //
    UINTX reserved_1 : 15;
    //
    // Number of clock cycles, for the design to wait before taking action on bus_quiet_time_gnt.
    // This must be set the same as LCOMP bqt_settle_width 
    // 
    // Bits[22:16], RW, default = 0x1
    //
    UINTX reserved_2 : 7;
    //
    // tells the rcomp to copy the adjecent code instead of evaluating it
    // 
    // Bits[30:23], RW, default = 0x0
    //
    UINTX reserved_3 : 8;
    //
    // Reserved bits
    // 
    // Bits[31:31], RO, default = 0x0
    //
    UINTX reserved_4 : 1;
  } Bits;
  UINTX Data;
} CC1_GRCOMP_RSTCTL_DDRCC1_PHY_STRUCT;
#endif // ASM_INC

#define CC1_GRCOMP_CLKGATE_DDRCC1_PHY_REG                  0x000006FC
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Clock gating contorl for rcomp.
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINTX reserved : 1;
    //
    // Reserved bits
    // 
    // Bits[31:1], RO, default = 0x0
    //
    UINTX reserved_1 : 31;
  } Bits;
  UINTX Data;
} CC1_GRCOMP_CLKGATE_DDRCC1_PHY_STRUCT;
#endif // ASM_INC

#define CC1_GRCOMP_INIT_DDRCC1_PHY_REG                     0x00000700
#ifndef ASM_INC
typedef union {
  struct {
    //
    // bit to start the initial rcomp
    // 
    // Bits[0:0], RW/1S/V, default = 0x0
    //
    UINTX reserved : 1;
    //
    // Reserved bits
    // 
    // Bits[31:1], RO, default = 0x0
    //
    UINTX reserved_1 : 31;
  } Bits;
  UINTX Data;
} CC1_GRCOMP_INIT_DDRCC1_PHY_STRUCT;
#endif // ASM_INC

#define CC1_GRCOMP_PERIODICCOMP_DDRCC1_PHY_REG             0x00000704
#ifndef ASM_INC
typedef union {
  struct {
    //
    // bit to enable the periodic rcomp.
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINTX reserved : 1;
    //
    // It enables the periodic txdlycomp
    // 
    // Bits[1:1], RW, default = 0x0
    //
    UINTX reserved_1 : 1;
    //
    // Reserved bits
    // 
    // Bits[31:2], RO, default = 0x0
    //
    UINTX reserved_2 : 30;
  } Bits;
  UINTX Data;
} CC1_GRCOMP_PERIODICCOMP_DDRCC1_PHY_STRUCT;
#endif // ASM_INC

#define DPIC_GRCOMP_CTL_DDRCC1_PHY_REG                     0x00000708
#ifndef ASM_INC
typedef union {
  struct {
    //
    // static leg signal for the AFE
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINTX reserved : 1;
    //
    // this tells a timer to start the periodic c73ddr402_comp cycle when this number
    // of cycles are completed. For silicon POR, this value set 20'h1F400 @32KHz alwayonclk
    // for 4s setting. 
    // 
    // Bits[20:1], RW, default = 0x7D00
    //
    UINTX reserved_1 : 20;
    //
    // Not used.
    // 
    // Bits[26:21], RW, default = 0x0
    //
    UINTX reserved_2 : 6;
    //
    // Reserved bits
    // 
    // Bits[31:27], RO, default = 0x0
    //
    UINTX reserved_3 : 5;
  } Bits;
  UINTX Data;
} DPIC_GRCOMP_CTL_DDRCC1_PHY_STRUCT;
#endif // ASM_INC


#endif // _DDRCC1_PHY_H_
