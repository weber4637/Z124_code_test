/** @file
  File name:    PMC_PCI_CFG.h
  Input File:   DNV_MRC.xlsx

  THIS FILE IS AUTO-GENERATED BY THE MSP TOOL. DO NOT CHANGE THIS CODE.

  If edits are needed in this file, they must be done via the MSP tool.

  If there is additional project-specific data required by the MSP, it
  can be placed in PMC_PCI_CFG.h, which is used for non-tool-generated
  data

  Includes register defines specific to a project.

  Copyright (c) 2005-2018 Intel Corporation. All rights reserved
  This software and associated documentation (if any) is furnished
  under a license and may only be used or copied in accordance
  with the terms of the license. Except as permitted by such
  license, no part of this software or documentation may be
  reproduced, stored in a retrieval system, or transmitted in any
  form or by any means without the express written consent of
  Intel Corporation.
**/
#ifndef _PMC_PCI_CFG_H_
#define _PMC_PCI_CFG_H_

#include "DataTypes.h"

#if USE_64_BIT_VARIABLES
#define UINTX UINT64
#else
#define UINTX UINT32
#endif

#define PCIID_PMC_PCI_CFG_REG                              0x00000000
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Indicates Intel
    // 
    // Bits[15:0], RO, default = 0x8086
    //
    UINTX vid : 16;
    //
    // These bits are controlled as follows:[br]
    // Bits [15:10]: hardwired (101111 for SPT-LP)[br]
    // Bits [9:7): fuses (global device ID - 000 by default)[br]
    // Bits [6:5]: hardwired (10 for SPT)[br]
    // Bits [4:0]: DID fuses (00 to 1F - variable).
    // 
    // Bits[31:16], RO/V, default = 0x0
    //
    UINTX did : 16;
  } Bits;
  UINTX Data;
} PCIID_PMC_PCI_CFG_STRUCT;
#endif // ASM_INC

#define PCISTS_PCICMD_PMC_PCI_CFG_REG                      0x00000004
#ifndef ASM_INC
typedef union {
  struct {
    //
    // PMC does not define any IO BARs in the standard PCI header BAR offsets. 
    // 
    // Bits[0:0], RO, default = 0x0
    //
    UINTX iose : 1;
    //
    // Controls a device's response to Memory Space accesses. This bit controls whether
    // the host to PMC MMIO BAR is enabled or not. 
    // 
    // Bits[1:1], RW, default = 0x0
    //
    UINTX mse : 1;
    //
    // Bus master Enable does not apply to messages sent out by PMC. 
    // 
    // Bits[2:2], RW, default = 0x1
    //
    UINTX bme : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[18:3], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 16;
    //
    // The PMC function does not generate interrupts.
    // 
    // Bits[19:19], RO, default = 0x0
    //
    UINTX is : 1;
    //
    // There is no capabilities list in the PMC function. 
    // 
    // Bits[20:20], RO, default = 0x0
    //
    UINTX clist : 1;
    //
    // Reserved - bit has no meaning on internal backbone.
    // 
    // Bits[21:21], RO, default = 0x0
    //
    UINTX c66 : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[22:22], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 1;
    //
    // Reserved - bit has no meaning on internal backbone.
    // 
    // Bits[23:23], RO, default = 0x0
    //
    UINTX fbc : 1;
    //
    // Set when the bridge receives a completion packet from the backbone from a previous
    // request, and detects a parity error. 
    // 
    // Bits[24:24], RW/1C/V, default = 0x0
    //
    UINTX dpd : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[26:25], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 2;
    //
    // Set when the bridge generates a completion packet with target abort status on
    // the backbone. 
    // 
    // Bits[27:27], RW/1C/V, default = 0x0
    //
    UINTX sta : 1;
    //
    // Set when the bridge receives a completion with completer abort status from the
    // backbone. 
    // 
    // Bits[28:28], RW/1C/V, default = 0x0
    //
    UINTX rta : 1;
    //
    // Set when the bridge receives a completion with unsupported request status from
    // the backbone. 
    // 
    // Bits[29:29], RW/1C/V, default = 0x0
    //
    UINTX rma : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[30:30], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_3 : 1;
    //
    // Set when the bridge detects a parity error on the internal backbone. 
    // 
    // Bits[31:31], RW/1C/V, default = 0x0
    //
    UINTX dpe : 1;
  } Bits;
  UINTX Data;
} PCISTS_PCICMD_PMC_PCI_CFG_STRUCT;
#endif // ASM_INC

#define PCICC_PCIRID_PMC_PCI_CFG_REG                       0x00000008
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Indicates the part revision.
    // 
    // Bits[7:0], RW/V, default = 0x0
    //
    UINTX rid : 8;
    //
    // No programming interface.
    // 
    // Bits[15:8], RO, default = 0x0
    //
    UINTX pi : 8;
    //
    // Indicates an unspecified 'other' memory controller.
    // 
    // Bits[23:16], RO, default = 0x80
    //
    UINTX scc : 8;
    //
    // Indicates a memory controller device class.
    // 
    // Bits[31:24], RO, default = 0x5
    //
    UINTX bcc : 8;
  } Bits;
  UINTX Data;
} PCICC_PCIRID_PMC_PCI_CFG_STRUCT;
#endif // ASM_INC

#define PCIHTYPE_PCIMLT_PMC_PCI_CFG_REG                    0x0000000C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // N/A
    // 
    // Bits[7:0], RO, default = 0x0
    //
    UINTX rsvd_7_0 : 8;
    //
    // N/A
    // 
    // Bits[15:8], RO, default = 0x0
    //
    UINTX rsvd_pcimlt : 8;
    //
    // Indicates a generic device header.
    // 
    // Bits[22:16], RO, default = 0x0
    //
    UINTX htype : 7;
    //
    // Indicates that this is part of a multi-function device.
    // 
    // Bits[23:23], RO, default = 0x1
    //
    UINTX mfd : 1;
    //
    // N/A
    // 
    // Bits[31:24], RO, default = 0x0
    //
    UINTX rsvd_31_24 : 8;
  } Bits;
  UINTX Data;
} PCIHTYPE_PCIMLT_PMC_PCI_CFG_STRUCT;
#endif // ASM_INC

#define PM_DATA_BAR_PMC_PCI_CFG_REG                        0x00000010
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Hardwired to 0 to identify a Memory BAR.
    // 
    // Bits[0:0], RO, default = 0x0
    //
    UINTX memspace : 1;
    //
    // Hardwired to 0 to indicate that Base register is 32 bits wide and mapping can
    // be done anywhere in the 32-bit Memory Space. 
    // 
    // Bits[2:1], RO, default = 0x0
    //
    UINTX typ : 2;
    //
    // A device can mark a range as prefetchable if there are no side effects on reads,
    // the device returns all bytes on reads regardless of the byte enables.[br] 
    // 				Hardwired to 0 to indicate the device's memory space as notprefetchable.
    // 
    // Bits[3:3], RO, default = 0x0
    //
    UINTX prefetch : 1;
    //
    // Hardwired to 0 to indicate 16KB of memory space
    // 
    // Bits[13:4], RO, default = 0x0
    //
    UINTX memsize : 10;
    //
    // Software programs this register with the base address of the device's memory region
    // 
    // Bits[31:14], RW, default = 0x0
    //
    UINTX membar : 18;
  } Bits;
  UINTX Data;
} PM_DATA_BAR_PMC_PCI_CFG_STRUCT;
#endif // ASM_INC

#define PCISID_PMC_PCI_CFG_REG                             0x0000002C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Written by BIOS.Not used by hardware.
    // 
    // Bits[15:0], RW/O, default = 0x0
    //
    UINTX ssvid : 16;
    //
    // Written by BIOS. Not used by hardware.
    // 
    // Bits[31:16], RW/O, default = 0x0
    //
    UINTX ssid : 16;
  } Bits;
  UINTX Data;
} PCISID_PMC_PCI_CFG_STRUCT;
#endif // ASM_INC

#define ABASE_PMC_PCI_CFG_REG                              0x00000040
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Always 1 to indicate I/O space.
    // 
    // Bits[0:0], RO, default = 0x1
    //
    UINTX stype : 1;
    //
    // Always 0.
    // 
    // Bits[7:1], RO, default = 0x0
    //
    UINTX rsvd_7_1 : 7;
    //
    // Provides the 256 bytes of I/O space for ACPI logic.
    //              [br]
    //              [br]This field is locked by GEN_PMCON_B.ACPI_BASE_LOCK
    // 
    // Bits[31:8], RW/L, default = 0x0
    //
    UINTX ba : 24;
  } Bits;
  UINTX Data;
} ABASE_PMC_PCI_CFG_STRUCT;
#endif // ASM_INC

#define ACTL_PMC_PCI_CFG_REG                               0x00000044
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Specifies on which IRQ the SCI will internally appear.  If not using the APIC,
    // the SCI must be routed to IRQ[9-11], and that interrupt is not sharable with the
    // SERIRQ stream, but is shareable with other PCI interrupts.  If using the APIC,
    // the SCI can also be mapped to IRQ20-23, and can be shared with other interrupts.[br][br]
    // Bits - SCI Map[br]
    // ---- - -------[br]
    // 000 - IRQ9[br]
    // 001 - IRQ10[br]
    // 010 - IRQ11[br]
    // 011 - Reserved[br]
    // 100 - IRQ20 (only if APIC is enabled)[br]
    // 101 - IRQ21 (only if APIC is enabled)[br]
    // 110 - IRQ22 (only if APIC is enabled)[br]
    // 111 - IRQ23 (only if APIC is enabled)[br]
    // [br]
    // When the interrupt is mapped to APIC interrupts 9, 10 or 11, the APIC should be
    // programmed for active-high reception.  When the interrupt is mapped to APIC interrupts
    // 20 through 23, the APIC should be programmed for active-low reception. 
    // 
    // Bits[2:0], RW, default = 0x0
    //
    UINTX scis : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[6:3], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 4;
    //
    // When set, decode of the I/O range pointed to by the ACPI base register is enabled
    // and the ACPI power management function is enabled.   
    // 
    // Bits[7:7], RW, default = 0x0
    //
    UINTX en : 1;
    //
    // When set , decode of the Mem range pointed by PWRMBASE is enabled.
    // 
    // Bits[8:8], RW, default = 0x0
    //
    UINTX pwrm_en : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:9], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 23;
  } Bits;
  UINTX Data;
} ACTL_PMC_PCI_CFG_STRUCT;
#endif // ASM_INC

#define PWRMBASE_PMC_PCI_CFG_REG                           0x00000048
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Always 0 to indicate memory space.
    // 
    // Bits[0:0], RO, default = 0x0
    //
    UINTX stype : 1;
    //
    // Always 0.
    // 
    // Bits[11:1], RO, default = 0x0
    //
    UINTX rsvd : 11;
    //
    // Provides the 4K bytes of memory space for Power Mgmt registers. 
    // 
    // Bits[31:12], RW, default = 0x0
    //
    UINTX ba : 20;
  } Bits;
  UINTX Data;
} PWRMBASE_PMC_PCI_CFG_STRUCT;
#endif // ASM_INC

#define GEN_PMCON_A_PMC_PCI_CFG_REG                        0x000000A0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Software sets these bits to control the rate at which the periodic SMI# is generated:[br]
    // 00 = 64 seconds (default), 01 = 32 seconds, 10 = 16 seconds, 11 = 8 seconds[br]
    // Tolerance for the timer is +/- 1 second.
    // 
    // Bits[1:0], RW, default = 0x0
    //
    UINTX per_smi_sel : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[2:2], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 1;
    //
    // When this bit is set, writes to the ESPI_SMI_EN bit will have no effect. Once
    // the ESPI_SMI_LOCK bit is set, writes of 0 to ESPI_SMI_LOCK bit will have no effect
    // (i.e. once set, this bit can only be cleared by host_prim_rst_b). 
    // 
    // Bits[3:3], RW/L, default = 0x0
    //
    UINTX espi_smi_lock : 1;
    //
    // When this bit is set, writes to the GLB_SMI_EN bit will have no effect. Once the
    // SMI_LOCK bit is set, writes of 0 to SMI_LOCK bit will have no effect (i.e. once
    // set, this bit can only be cleared by host_prim_rst_b). 
    // 
    // Bits[4:4], RW/L, default = 0x0
    //
    UINTX smi_lock : 1;
    //
    // When this bit is 0, the PMC only allows L1.LOW entry if the CPUs BCLK request
    // is de-asserted.[br] 
    // When this bit is 1, the PMC allows L1.LOW entry regardless of whether the CPUs
    // BCLK request is asserted/de-asserted. 
    // 
    // Bits[5:5], RW, default = 0x0
    //
    UINTX allow_l1low_bclkreq_on : 1;
    //
    // When this bit is 0, the PMC only allows L1.LOW entry if the OPI voltage is off.[br]
    // When this bit is 1, the PMC allows L1.LOW entry regardless of whether the OPI
    // voltage is on/off. 
    // 
    // Bits[6:6], RW, default = 0x0
    //
    UINTX allow_l1low_opi_on : 1;
    //
    // When this bit is 0, the PMC only allows L1.LOW entry if the CPU is in Cx (EA =
    // 0).[br] 
    // When set to 1, the PMC allows L1.LOW entry regardless of the value of EA.
    // 
    // Bits[7:7], RW, default = 0x0
    //
    UINTX allow_l1low_c0 : 1;
    //
    // N/A
    // 
    // Bits[8:8], RO, default = 0x0
    //
    UINTX rsvd_8 : 1;
    //
    // This read-only bit indicates the current state of the PWRBTN# signal.[br]
    //   1= High, 0 = Low.[br]
    // The value reflected in this bit is dependent upon PM_CFG1.PB_DB_MODE.  The PB_DB_MODE
    // bit's value causes the following behavior:[br] 
    //  - '0': PWRBTN_LVL is taken from the debounced PWRBTN# pin value that is seen
    // at the output of a 16ms debouncer.[br] 
    //  - '1': PWRBTN_LVL is taken from the raw PWRBTN# pin (before the debouncer).
    // 
    // Bits[9:9], RO/V, default = 0x0
    //
    UINTX pwrbtn_lvl : 1;
    //
    // This bit acts as a global enable for the SCI associated with the PCI express ports.
    // If this bit is not set, then the various PCI Express ports and MCH cannot cause
    // the PCI_EXP_STS bit to go active. 
    // 
    // Bits[10:10], RW, default = 0x0
    //
    UINTX bios_pci_exp_en : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[11:11], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 1;
    //
    // When this bit is left at [quote]0[quote] (default), PMC allows SBXB Clock gating
    // only when the CPU is in a non-C0 state.When set to [quote]1[quote], the SPXB backbone
    // clock can be gated when the CPU is in C0 or Cx state assuming all other gating
    // conditions are satisfied.[br] 
    // Note: If C0 Power Management Disable Fuse is 1, hardware will always see 0 as
    // an output from this register. BIOS reading this register should always return
    // the correct value. 
    // 
    // Bits[12:12], RW, default = 0x0
    //
    UINTX allow_spxb_cg_inc0 : 1;
    //
    // When this bit is left at [quote]0[quote] (default), PMC allows OPI PLL Shutdown
    // only when the CPU is in a non-C0 state. When set to [quote]1[quote], the OPI PLL
    // can be shut down when the CPU is in C0 or Cx state assuming all other gating conditions
    // are satisfied.[br] 
    // Note: If C0 Power Management Disable Fuse is 1, hardware will always see 0 as
    // an output from this register. BIOS reading this register should always return
    // the correct value.[br] 
    // Note: The signal driven by this configuration bit is connected to both OPI and
    // USB3/PXP PLLs to support PLL shutdown when backbone clock is sourced from the
    // USB3/PXP PLL (a backup mode). 
    // 
    // Bits[13:13], RW, default = 0x0
    //
    UINTX allow_opi_pll_sd_inc0 : 1;
    //
    // 0: Enable CRI clock gating in the modPHY[br]
    // 1: Disable CRI clock gating in the modPHY[br]
    // Note: If C0 Power Management Disable Fuse is [quote]1[quote], hardware will always
    // see [quote]1[quote] as an output from this register. BIOS reading this register
    // should always return the correct value. 
    // 
    // Bits[14:14], RW, default = 0x0
    //
    UINTX mphy_criclk_gate_ovr : 1;
    //
    // When this bit is left at [quote]0[quote] (default), PMC allows iCLK PLL Shutdown
    // only when the CPU is in a non- C0 state. When set to [quote]1[quote], the iCLK
    // PLL can be shut down when the CPU is in C0 or Cx state assuming all other gating
    // conditions are satisfied.[br] 
    // Note: If C0 Power Management Disable Fuse is 1, hardware will always see 0 as
    // an output from this register. BIOS reading this register should always return
    // the correct value. 
    // 
    // Bits[15:15], RW, default = 0x0
    //
    UINTX allow_iclk_pll_sd_inc0 : 1;
    //
    // This bit is set after a global reset (not G3 or DeepSx) occurs.  See the GEN_PMCON_B.HOST_RST_STS
    // bit for potential usage models. 
    // 
    // Bits[16:16], RW/1C/V, default = 0x0
    //
    UINTX gbl_rst_sts : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[17:17], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 1;
    //
    // Hardware sets this bit when the SLP_S4# assertion width is less than the time
    // programmed in the SLP_S4# Minimum Assertion Width field (D31.F0.A4h.5:4). The
    // PCH begins the timer when SLP_S4# pin (including ME override logic) is asserted
    // during S4/S5 entry, or when the pri_pwrgood_rst_b input is deasserted during SUS
    // well power-up. The status bit is cleared by software writing a 1 to the bit. Note
    // that this bit is functional regardless of the value in the SLP_S4# Assertion Stretch
    // Enable and the [quote]Disable SLP_X Stretching After SUS Power Failure[quote]
    // bits.[br] 
    // This bit is reset by the assertion of the pri_pwrgood_rst_b pin, but can be set
    // in some cases before the default value is readable.[br] 
    // 
    // Bits[18:18], RW/1C/V, default = 0x0
    //
    UINTX ms4v : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[20:19], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_3 : 2;
    //
    // This bit will be set to 1 if DRAM should have remained powered and held in Self-Refresh
    // through the last power state transition (i.e. the last time the system left S0).
    //  The scenarios where this should be the case are:[br] 
    //   - successful S3 entry & exit[br]
    //   - successful Host partition reset without power cycle[br]
    // These scenarios both involve a handshake between the PCH and the CPU/MCH.  The
    // acknowledge from the CPU/MCH back to the PCH is assumed to imply that memory was
    // successfully placed into Self-Refresh (the PCH has no way to verify whether that
    // actually occurred).[br] 
    // This bit will be cleared whenever the PCH begins a transition out of S0.[br]
    // Note: This bit should not be consulted upon wake from S1, as that state does not
    // involve the same type of handshake or placing memory into Self-Refresh.  It is
    // assumed that software is already aware that memory context is not impacted by
    // S1 and therefore does not need to check this bit.[br] 
    // 
    // Bits[21:21], RO/V, default = 0x0
    //
    UINTX mem_sr : 1;
    //
    // Reserved
    // 
    // Bits[22:22], RO, default = 0x0
    //
    UINTX rsvd_22 : 1;
    //
    // This bit does not effect hardware functionality in any way. It is provided as
    // a scratchpad bit that is maintained through main power well resets and CF9h-initiated
    // resets. BIOS is expected to set this bit prior to starting the DRAM initialization
    // sequence and to clear this bit after completing the DRAM initialization sequence.
    // BIOS can detect that a DRAM initialization sequence was interrupted by a reset
    // by reading this bit during the boot sequence. If the bit is 1, then the DRAM initialization
    // was interrupted. See Section 16.11.1 for the expected BIOS response.[br] 
    // This bit is reset by the assertion of the pri_pwrgood_rst_b pin.[br]
    // 
    // Bits[23:23], RW, default = 0x0
    //
    UINTX disb : 1;
    //
    // Reserved
    // 
    // Bits[26:24], RO, default = 0x0
    //
    UINTX rsvd_26_24 : 3;
    //
    // This bit determines the Host software contribution to whether the LAN PHY remains
    // powered in an Sx/MOFF state that was entered from S0 (rather than from G3).  See
    // the SLP_LAN# sub-section later in the chapter for more information.[br] 
    // 
    // Bits[27:27], RW, default = 0x0
    //
    UINTX sx_pp_en : 1;
    //
    // This bit determines the Host software contribution to whether the LAN PHY is powered
    // up after exiting G3 (to either Sx/MOFF or DeepSx).  See the SLP_LAN# sub-section
    // later in the chapter for more information.[br] 
    // 
    // Bits[28:28], RW, default = 0x0
    //
    UINTX ag3_pp_en : 1;
    //
    // This bit determines the Host software contribution to whether the LAN PHY remains
    // powered in DeepSx.  See the SLP_LAN# sub-section later in the chapter for more
    // information.[br] 
    // If this bit is cleared, for the PHY to be powered in deep-Sx state, SX_PP_EN must
    // be set to [quote]1[quote].[br] 
    // 
    // Bits[29:29], RW, default = 0x1
    //
    UINTX dsx_pp_dis : 1;
    //
    // This bit determines the Host software contribution to whether the LAN PHY remains
    // powered in Sx/MOFF or DeepSx while on battery.  See the SLP_LAN# sub-section later
    // in the chapter for more information.[br] 
    // 
    // Bits[30:30], RW, default = 0x0
    //
    UINTX dc_pp_dis : 1;
    //
    // When cleared, this bit causes the PMC to disable the GBE Prep non-fatal timeout,
    // causing the PMC to wait indefinitely for the ACK STS (response)for Reset/Boot
    // Prep message from the GBe MAC.[br] 
    // 			  When set, a non-fatal timeout will apply to the Reset/Boot Prep handshake.
    // If the timeout expires, the PMC will continue as if the ACK STS (response)for
    // Reset/Boot Prep message from the GBe MAC had arrived. 
    // 
    // Bits[31:31], RW, default = 0x1
    //
    UINTX gbe_prep_nfto_en : 1;
  } Bits;
  UINTX Data;
} GEN_PMCON_A_PMC_PCI_CFG_STRUCT;
#endif // ASM_INC

#define GEN_PMCON_B_PMC_PCI_CFG_REG                        0x000000A4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Determines what state to go to when power is reapplied after a power failure (G3
    // state).[br] 
    // 0 = System will return to an S0 state (boot) after power is re-applied.[br]
    // 1 = System will return to the S5 state (except if it was in S4, in which case
    // it will return to S4-like state). In the S5 state, the only enabled wake-up event
    // is the Power Button or any enabled wake event that was preserved through the power
    // failure. This bit is in the RTC well and is only cleared by rtc_pwrgood_rst_b
    // assertion.[br][br] The 1st boot behavior can be overridden through PMC soft strap
    // (AG3E_1st_boot_value). 
    // 
    // Bits[0:0], RW/1C/V, default = 0x1
    //
    UINTX ag3e : 1;
    //
    // 1 = Indicates that the trickle current (from the main battery or trickle supply)
    // was removed or failed. 0 = Indicates that the trickle current has not failed since
    // the last time the bit was cleared.[br] 
    // Software writes a 1 to this bit to clear it. This bit is in the DSW well, and
    // defaults to '1' based on dsw_pwrgood_rst_b deassertion (not cleared by any type
    // of reset).[br] 
    // Implementation Note: dsw_pwrgood_rst_b is an asynchronous set term to this bit.[br]
    // 
    // Bits[1:1], RW/1C, default = 0x1
    //
    UINTX pf : 1;
    //
    // Intel PCH will set this bit to 1 when rtc_pwrgood_rst_b indicates a weak or missing
    // battery. The bit will remain set until the software clears it by writing a 0 back
    // to this bit position. This bit is not cleared by any type of reset.[br] 
    // 
    // Bits[2:2], RW, default = 0x1
    //
    UINTX rps : 1;
    //
    // When set to 1, the SLP_S4# pin (which includes the ME override logic) will minimally
    // assert for the time specified in bits 5:4 of this register. When 0, the minimum
    // assertion time for SLP_S4# is the same as the timing defined in the timing tables
    // in Default 16.6.3.[br] 
    // This bit is provided so that all DIMMs in the system can deterministically detect
    // a power-cycle event for proper initialization. Note that there are behavioral
    // changes that may be noticeable to the end-user when this bit is set. Resume times
    // from S4 and S5 and power-up times from G3 or DeepSx may be delayed by several
    // seconds.[br] 
    // Cases in which this feature may not be desirable and therefore keeping the bit
    // cleared are:[br] 
    //       A customer decides the user confusion due to the hardware delay is a bigger
    // issue than the potential DRAM issue[br] 
    //       A customer decides the software status bit solution is adequate[br]
    //       A different DRAM type is used or the platform provides an external solution
    // to solve the power-cycling issue[br] 
    //       Validation regressions are impacted by the delay (especially after pri_pwrgood_rst_b
    // deassertion)[br] 
    //       Avoid potential resume time WHQL violations[br]
    // This bit is not writable when the SLP_Sx# Stretching Policy Lock-Down bit is set.[br]
    // This bit is cleared by rtc_pwrgood_rst_b.[br]
    // 
    // Bits[3:3], RW/L, default = 0x0
    //
    UINTX s4ase : 1;
    //
    // This 2-bit value indicates the minimum assertion width of the SLP_S4# signal to
    // guarantee that the DRAMs have been safely power-cycled. This value may be modified
    // per platform depending on DRAM types, power supply capacitance, etc. Valid values
    // are:[br] 
    //       11: 1 second[br]
    //       10: 2 seconds[br]
    //       01: 3 seconds[br]
    //       00: 4 seconds[br]
    // This value is used in two ways:[br]
    //  1.  If the SLP_S4# assertion width is ever shorter than this time, a status bit
    // (D31.F0.A2h.2) is set for BIOS to read when S0 is entered[br] 
    //  2.  If enabled by bit 3 in this register, the hardware will prevent the SLP_S4#
    // signal from deasserting within this minimum time period after asserting.[br] 
    // Note that the logic that measures this time is in the suspend power well. Therefore,
    // when leaving a G3 or DeepSx state, the minimum time is measured from the deassertion
    // of the internal suspend well reset (unless the [quote]Disable SLP_X Stretching
    // After SUS Power Failure[quote] bit is set).[br] 
    // This field is not writable when the SLP_Sx# Stretching Policy Lock-Down bit is
    // set.[br] 
    // rtc_pwrgood_rst_b forces this field to the conservative default state (00b).[br]
    // 
    // Bits[5:4], RW/L, default = 0x0
    //
    UINTX s4maw : 2;
    //
    // This 2-bit value indicates when the SWSMI timer will time out. Valid values are:[br]
    //       00 1.5ms +/- 0.6ms[br]
    //       01 16ms +/- 4ms[br]
    //       10 32ms +/- 4ms[br]
    //       11 64ms +/- 4ms[br]
    // These bits are not cleared by any type of reset except rtc_pwrgood_rst_b. Implementation
    // Note (not for EDS): SWSMI is generated based on the internal free-running 1ms
    // tick (to be accurate, it is 0.983ms/tick generated from 30ns * 2^15). Since the
    // tick is free-running, the accuracy is within the following range.[br] 
    //      # of 0.983ms tick count SWSMI range[br]
    // 64ms SWSMI 62 -to- 63 60.946ms -to- 61.929ms[br]
    // 32ms SWSMI 31 -to- 32 30.473ms -to- 31.456ms[br]
    // 16ms SWSMI 15 -to- 16 14.745ms -to- 15.728ms[br]
    // 1.5ms SWSMI 1 -to- 2 0.983ms -to- 1.966ms[br]
    // 
    // Bits[7:6], RW, default = 0x0
    //
    UINTX swsmi_ratesel : 2;
    //
    // N/A
    // 
    // Bits[8:8], RO, default = 0x0
    //
    UINTX rsvd : 1;
    //
    // This bit is set by hardware when a host partition reset (not a global reset, DeepSx,
    // or G3) occurs.[br] 
    // This bit is an optional tool to help BIOS determine when a host partition reset
    // might have collided with a wake from a valid sleep state.  A possible usage model
    // would be to consult and then write a '1' to clear this bit during the boot flow
    // before determining what action to take based on reading PM1_STS.WAK_STS = '1'.
    // If HOST_RST_STS = '1' and/or GEN_PMCON_A.GBL_RST_STS = '1', the cold reset boot
    // path could be followed rather than the resume path, regardless of the setting
    // of WAK_STS.[br] 
    // This bit does not affect PCH operation in any way, and can therefore be left set
    // if BIOS chooses not to use it. 
    // 
    // Bits[9:9], RW/1C/V, default = 0x0
    //
    UINTX host_rst_sts : 1;
    //
    // This 2-bit value indicates the minimum assertion width of the SLP_S3# signal to
    // guarantee[br] 
    // that the Main power supplies have been fully power-cycled. This value may be modified
    // per platform depending on power supply capacitance, board capacitance, power failure
    // detection circuits, etc.[br] 
    // Settings are:[br]
    //   00: 60 usec[br]
    //   01: 1 ms[br]
    //   10: 50 ms[br]
    //   11: 2 sec[br]
    // This field is not writable when the SLP_Sx# Stretching Policy Lock- Down bit is
    // set.[br] 
    // This bit is cleared by the pri_pwrgood_rst_b pin.[br]
    // 
    // Bits[11:10], RW/L, default = 0x0
    //
    UINTX slp_s3_min_asst_wdth : 2;
    //
    // When this bit is set to 1, all SLP_* pin stretching is disabled when powering
    // up after a SUS well power loss.  When this bit is left at 0, SLP_* stretching
    // will be performed after SUS power failure as enabled in various other fields.
    //  Note that if this bit is a 0, SLP_* stretch timers start on SUS well power up
    // (the PCH has no ability to count stretch time while the SUS well is powered down).[br]
    // Setting this bit can therefore prevent long delays after SUS power loss which
    // may be common in mobile platforms and in manufacturing flow testing, while still
    // allowing for the full power cycling during S3, S4 and S5 states. If the platform
    // guarantees minimum SUS power down residence in other ways, an additional PCH-induced
    // delay is not needed or wanted.[br] 
    // Note: This policy bit has a different effect on SLP_SUS# stretching than on the
    // other SLP_* pins, since SLP_SUS# is the control signal for one of the scenarios
    // where SUS well power is lost (DeepSx).  The effect of setting this bit to '1'
    // on:[br] 
    //    - SLP_S3#, SLP_S4#, SLP_A# and SLP_LAN# stretching: disabled after any SUS
    // power loss[br] 
    //    - SLP_SUS# stretching: disabled after G3, but no impact on DeepSx[br]
    // This field is not writable when the SLP_Sx# Stretching Policy Lock-Down bit is
    // set.[br] 
    // This bit is cleared by the rtc_pwrgood_rst_b pin.[br]
    // 
    // Bits[12:12], RW/L, default = 0x0
    //
    UINTX dis_slp_x_strch_sus_up : 1;
    //
    // When this bit is set to 1, the integrated LAN is enabled to wake the system from
    // S5 regardless of the value in the PME_B0_EN bit in the GPE0_EN register. This
    // allows the system BIOS to enable Wake-On-LAN regardless of the policies selected
    // through the operating system. This bit is maintained in the RTC power well, therefore
    // permitting WOL following a surprise power failure even in cases in which the system
    // may have been running in S0 without the PME Enables set. (Note that the LAN NVRAM
    // configuration must support WOL after SUS power loss.)[br] 
    // When this bit is cleared to 0, the wake-on-LAN policies are determined by OS-visible
    // bits.  This bit has no effect on wakes from S1, S3, or S4.[br] 
    // This bit is cleared by the rtc_pwrgood_rst_b pin[br]
    // 
    // Bits[13:13], RW, default = 0x0
    //
    UINTX wol_en_ovrd : 1;
    //
    // This bit is set to '1' whenever SUS well power is lost, as indicated by pri_pwrgood_rst_b
    // assertion.[br] 
    // Software writes a 1 to this bit to clear it. This bit is in the SUS well, and
    // defaults to '1' based on pri_pwrgood_rst_b assertion (not cleared by any type
    // of reset).[br] 
    // Implementation Note: pri_pwrgood_rst_b is an asynchronous set term to this bit.[br]
    // 
    // Bits[14:14], RW/1C, default = 0x1
    //
    UINTX sus_pwr_flr : 1;
    //
    // When set to '1', this bit blocks wake events from PME_B0_STS in S5, regardless
    // of the state of PME_B0_EN.  When cleared (default), wake events from PME_B0_STS
    // are allowed in S5 if PME_B0_EN = '1'.[br] 
    // Wakes from power states other than S5 are not affected by this policy bit.[br]
    // The net effect of setting PME_B0_S5_DIS = '1' is described by the truth table
    // below:[br] 
    //    Y = Wake[br]
    //    N = Don't wake[br]
    //    B0 = PME_B0_EN[br]
    //    OV = WOL Enable Override[br]
    //    B0/OV |        S1/S3/S4        |     S5[br]
    //      00  | N                      | N[br]
    //      01  | N                      | Y (LAN only)[br]
    //      11  | Y (all PME B0 sources) | Y (LAN only)[br]
    //      10  | Y (all PME B0 sources) | N[br]
    // This bit is cleared by the rtc_pwrgood_rst_b pin.[br]
    // 
    // Bits[15:15], RW, default = 0x0
    //
    UINTX pme_b0_s5_dis : 1;
    //
    // When set to 1, this bit disables all accesses to the MMIO range pointed to by
    // PM_DATA_BAR.  This does not affect the BAR value itself, which can still be changed
    // after this bit is set.  But once the bit is set to 1, the PMC will drop writes
    // to the data region pointed to by PM_DATA_BAR.  And reads will return 0.[br] 
    // 			  This bit becomes locked when a value of 1b is written to it. Writes of 0
    // to this bit are always ignored. Once locked by writing 1, the only way to clear
    // this bit is to perform a platform reset. 
    // 
    // Bits[16:16], RW/L, default = 0x0
    //
    UINTX pm_data_bar_dis : 1;
    //
    // When set to 1, this bit locks down the ACPI Base Address Register (ABASE) at offset
    // 40h. The Base Address Field becomes read-only. This bit becomes locked when a
    // value of 1b is written to it. Writes of 0 to this bit are always ignored. Once
    // locked by writing 1, the only way to clear this bit is to perform a platform reset.
    // This lockdown bit is available in both desktop and mobile. 
    // 
    // Bits[17:17], RW/L, default = 0x0
    //
    UINTX acpi_base_lock : 1;
    //
    // When set to 1, this bit locks down the following fields:[br]
    //   - GEN_PMCON_3.DIS_SLP_X_STRCH_SUSPF[br]
    //   - GEN_PMCON_3.SLP_S3_MIN_ASST_WDTH[br]
    //   - GEN_PMCON_3.S4MAW[br]
    //   - GEN_PMCON_3.S4ASE[br]
    //   - PM_CFG.SLP_A_MIN_ASST_WDTH[br]
    //   - PM_CFG.SLP_LAN_MIN_ASST_WDTH[br]
    //   - PM_CFG.PWR_CYC_DUR[br]
    // Those bits become read-only. This bit becomes locked when a value of 1b is written
    // to it. Writes of 0 to this bit are always ignored. Once locked by writing 1, the
    // only way to clear this bit is to perform a platform reset. This lockdown bit is
    // available in both desktop and mobile. 
    // 
    // Bits[18:18], RW/L, default = 0x0
    //
    UINTX slpsx_str_pol_lock : 1;
    //
    // Reserved
    // 
    // Bits[31:19], RO, default = 0x0
    //
    UINTX rsvd_31_19 : 13;
  } Bits;
  UINTX Data;
} GEN_PMCON_B_PMC_PCI_CFG_STRUCT;
#endif // ASM_INC

#define BM_CX_CNF_PMC_PCI_CFG_REG                          0x000000A8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // N/A
    // 
    // Bits[8:0], RO, default = 0x0
    //
    UINTX rsvd_8_0 : 9;
    //
    // When this bit is set to 1, the PM_SYNC pin will be used to transmit serial messages
    // to the CPU/MCH as described in the [quote]C-states[quote] section later in this
    // chapter.[br] 
    // When this bit is a 0, the PM_SYNC pin behaves as a level output pin, constantly
    // providing an OR of all of the states enabled by other bits in the PM_SYNC_MODE
    // register.[br] 
    // Note: Level mode on PM_SYNC is no longer POR and will not be validated, so the
    // only supported setting for this bit is '1'.[br] 
    // Not For EDS: As a result, mark this bit as Reserved in the EDS with a value of
    // '1'. 
    // 
    // Bits[9:9], RW, default = 0x1
    //
    UINTX pm_sync_msg_mode : 1;
    //
    // When this bit is a 1, PCH will not set the BM_STS if there is bus master activity
    // from PCI, PCI-Express and internal bus masters.[br] 
    // Note: If the BM_STS bit is already set when the BM_STS_ZERO_EN bit is set, the
    // BM_STS bit will remain set. Software will still need to clear the BM_STS bit.[br]
    // Note: BM_STS_ZERO_EN does not apply to PHOLD (LPC DMA or LPC bus master activity).
    //  A separate policy bit (PHOLD_BM_STS_BLOCK) determines whether PHOLD will set
    // BM_STS. 
    // 
    // Bits[10:10], RW, default = 0x0
    //
    UINTX bm_sts_zero_en : 1;
    //
    // This bit when set will mask to zero all the fanout of the cache flushed indication
    // received on PM_Req message. When 0, the cache flushed indication received from
    // PM_Req message is used as received. 
    // 
    // Bits[11:11], RW, default = 0x0
    //
    UINTX mask_cf : 1;
    //
    // N/A
    // 
    // Bits[13:12], RO, default = 0x0
    //
    UINTX rsvd_13_12 : 2;
    //
    // When this bit is a 1, PHOLD events (LPC DMA or LPC bus master activity) will not
    // set PM1_STS.BM_STS.  When this bit is a 0, PHOLD will set BM_STS even if BM_STS_ZERO_EN
    // = 1. 
    // 
    // Bits[14:14], RW, default = 0x0
    //
    UINTX phold_bm_sts_block : 1;
    //
    // N/A
    // 
    // Bits[15:15], RW, default = 0x0
    //
    UINTX scratchpad : 1;
    //
    // When this bit is a 1, SATA3 traffic will cause BM_STS to be set, even if the BM_STS_ZERO_EN
    // bit is set. 
    // 
    // Bits[16:16], RW, default = 0x0
    //
    UINTX sata3_break_en : 1;
    //
    // When this bit is a 1, XHCI traffic will cause BM_STS to be set, even if the BM_STS_ZERO_EN
    // bit is set. 
    // 
    // Bits[17:17], RW, default = 0x0
    //
    UINTX xhci_break_en : 1;
    //
    // N/A
    // 
    // Bits[18:18], RO, default = 0x0
    //
    UINTX rsvd_18 : 1;
    //
    // When this bit is a 1, the assertion of dmiputsnoop will cause BM_STS to be set,
    // even if the BM_STS_ZERO_EN bit is set.[br] 
    // NOT FOR EDS: This bit is added as failsafe only and should never be set.  If there
    // is some OS that depends on BM_STS, then this bit can be used to set it for all
    // snoop traffic that occurs, no matter what agent generated it. 
    // 
    // Bits[19:19], RW, default = 0x0
    //
    UINTX dpsn_break_en : 1;
    //
    // N/A
    // 
    // Bits[23:20], RO, default = 0x0
    //
    UINTX rsvd_23_20 : 4;
    //
    // When this bit is a 1, Azalia traffic will cause BM_STS to be set, even if the
    // BM_STS-ZERO_EN bit is set. 
    // 
    // Bits[24:24], RW, default = 0x0
    //
    UINTX az_break_en : 1;
    //
    // N/A
    // 
    // Bits[25:25], RO, default = 0x0
    //
    UINTX rsvd_25 : 1;
    //
    // N/A
    // 
    // Bits[29:26], RO, default = 0x0
    //
    UINTX rsvd_29_26 : 4;
    //
    // When this bit is a 1, PCI Express traffic will cause BM_STS to be set, even if
    // the BM_STS-ZERO_EN bit is set. 
    // 
    // Bits[30:30], RW, default = 0x0
    //
    UINTX pcie_break_en : 1;
    //
    // When this bit is a 1, Serial ATA traffic will cause BM_STS to be set, even if
    // the BM_STS-ZERO_EN bit is set. 
    // 
    // Bits[31:31], RW, default = 0x0
    //
    UINTX storage_break_en : 1;
  } Bits;
  UINTX Data;
} BM_CX_CNF_PMC_PCI_CFG_STRUCT;
#endif // ASM_INC

#define ETR3_PMC_PCI_CFG_REG                               0x000000AC
#ifndef ASM_INC
typedef union {
  struct {
    //
    // These bits are physically implemented but not used.
    // 
    // Bits[7:0], RW/V, default = 0x0
    //
    UINTX rsvd7_0 : 8;
    //
    // These bits are physically implemented but not used.
    // 
    // Bits[15:8], RW/V, default = 0x0
    //
    UINTX rsvd15_8 : 8;
    //
    // These bits are physically implemented but not used.[br]
    // 
    // Bits[17:16], RW, default = 0x0
    //
    UINTX rsvd17_16 : 2;
    //
    // When this bit is set, a CF9h write of 6h or Eh will not cause internal Resume
    // Well Reset (WrsmrstB) to be asserted and thus resume well logic will maintain
    // its state. When this bit is cleared, CF9h write of 6h or Eh will also reset resume
    // well logic.[br] 
    // This bit is to be used when a second reset through CF9 write is desired upon power
    // up or after resume from low power states. This bit has to be set prior to the
    // write to CF9 register and has to be cleared upon completing the reset. Failing
    // to do so prevents resume well registers from being reset in the future CF9 writes.[br]
    // 
    // Bits[18:18], RW, default = 0x0
    //
    UINTX cworwre : 1;
    //
    // When set, this bit causes the PCH to enter a debug mode.  While in this mode,
    // the PCH will skip all steps within the common preparation flow (during host partition
    // reset and Sx entry) except for SUS_STAT# assertion and host_prim_rst_b assertion.[br]
    // This bit is not writable when PM_CFG.DBG_MODE_LOCK bit is set.[br]
    // Note that setting this bit may result in unexpected behaviour in the PCH.[br]
    // 
    // Bits[19:19], RW/L, default = 0x0
    //
    UINTX skip_host_rst_hs : 1;
    //
    // When this bit is set, a CF9h write of 6h or Eh will cause a Global Reset of both
    // the Host and the ME partitions. If this bit is cleared, a CF9h write of 6h or
    // Eh will only reset the Host partition.[br] 
    // It is recommended that BIOS should set this bit early on in the boot sequence,
    // and then clear it and set the CF9LOCK bit prior to loading the OS in both an ME
    // Enabled and a ME Disabled system.[br] 
    // When this bit is set, the hardware assumes that bit 18 (CF9h Without Resume Well
    // Reset Enable) is cleared.[br] 
    // This register is locked by the CF9 Lockdown (CF9LOCK) bit. This register is not
    // reset by a CF9h reset.[br] 
    // 
    // Bits[20:20], RW/L, default = 0x0
    //
    UINTX cf9gr : 1;
    //
    // When this bit is set, the USB cache feature is disabled in the PCH power management
    // hardware.[br] 
    // Note: It is illegal to set this bit while USB caching is enabled in any USB controller.[br]
    // 
    // Bits[21:21], RW, default = 0x0
    //
    UINTX usb_cache_dis : 1;
    //
    // When this bit is '1':[br]
    //  - Handshakes  during host reset or Sx entry that previously were not subject
    // to any timeout will now be bypassed (timeout will apply).  The timeout value in
    // SUSPMCFG.PLTRST_ENT_TO is applied to these previously required handshakes.[br]
    //  - The host reset entry timeout and Sx entry timeouts are disabled regardless
    // of the values in PM_CFG.SX_ENT_TO_EN and SUSPMCFG.DIS_HPR_ENT_TO.[br][br] 
    // 
    // When this bit is '0':[br]
    //  - Required handshakes will gate the flow as normal without any timeout applied.[br]
    //  - The host reset entry timeout and Sx entry timeout operate as normal.[br][br]
    // 
    // This bit is not writable when PM_CFG.DBG_MODE_LOCK bit is set.[br]
    // 
    // Note: Setting this bit may result in unexpected behavior in the PCH.
    // 
    // Bits[22:22], RW/L, default = 0x0
    //
    UINTX rst_sx_dbg_to : 1;
    //
    // This bit when set enables 25MHz PSMI debug mode in the PCH. In this mode, the
    // PM_SYNC and PM_DOWN logic clock source and CLKOUT_CPUN is switched from the 24MHz
    // oscillator clock to a 25 MHz clock from the PCHs integrated clocking module.[br]This
    // bit is not writable when PM_CFG1.DBG_MODE_LOCK bit is set.[br] 
    // reset_type=RSMRST#
    // 
    // Bits[23:23], RW/L, default = 0x0
    //
    UINTX psmi_dbg_mode_en : 1;
    //
    // These bits are physically implemented but not used.
    // 
    // Bits[24:24], RW/V, default = 0x0
    //
    UINTX rsvd_24 : 1;
    //
    // These bits are physically implemented but not used.
    // 
    // Bits[30:25], RW/V, default = 0x0
    //
    UINTX rsvd30_25 : 6;
    //
    // When set, this will lock the [quote]CF9h Global Reset[quote] bit.[br]
    // When set, this register locks itself. This register is reset by a CF9h reset.
    // 
    // Bits[31:31], RW/V/L, default = 0x0
    //
    UINTX cf9lock : 1;
  } Bits;
  UINTX Data;
} ETR3_PMC_PCI_CFG_STRUCT;
#endif // ASM_INC

#define PMC_THROT_1_PMC_PCI_CFG_REG                        0x000000B0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // 1: When VRAlert# pin is '0', the PMC requests throttling to a T3 Tstate to the
    // PCH throttling unit.[br] 
    // 0: VRAlert# pin is not used and does not initiate any throttling requests.
    // 
    // Bits[0:0], RW/L, default = 0x0
    //
    UINTX vralert_en : 1;
    //
    // N/A
    // 
    // Bits[14:1], RO, default = 0x0
    //
    UINTX rsvd_14_1 : 14;
    //
    // When set to 1 this entire register is locked.
    // 
    // Bits[15:15], RW/L, default = 0x0
    //
    UINTX pmc_throt_lock : 1;
    //
    // N/A
    // 
    // Bits[31:16], RO, default = 0x0
    //
    UINTX rsvd_31_16 : 16;
  } Bits;
  UINTX Data;
} PMC_THROT_1_PMC_PCI_CFG_STRUCT;
#endif // ASM_INC

#define MDAP_PMC_PCI_CFG_REG                               0x000000C0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Current Maximum DMA Alignment Period value for the platform.  The format of this
    // field is intentionally made to match the TNTE field of the PM_Req/Rsp/Dmd messages
    // on DMI.  Therefore, the value in this field is defined in 10 usec units:[br] 
    //   0x1FFFF - 1.31 sec[br]
    //   0x00000 - 0us
    // 
    // Bits[16:0], RW, default = 0x0
    //
    UINTX mdap_value : 17;
    //
    // N/A
    // 
    // Bits[28:17], RO, default = 0x0
    //
    UINTX rsvd : 12;
    //
    // This bit has no associated HW function (just a scratchpad bit with fuse override).[br]
    // The intended usage model is to provide a communication mechanism between the end
    // user (likely via a BMC) and a platform driver running on the CPU.  The policy
    // being communicated on a dynamic basis is whether to turn on or off a closed loop
    // periodic alignment feature that may be supported by the platform driver.[br] 
    // Note: If the Server CPPM: S0ix in C0 Disable Fuse is 1, this register will always
    // read 0 and is Read-only. 
    // 
    // Bits[29:29], RW/V, default = 0x0
    //
    UINTX auto_policy_ctl : 1;
    //
    // When this bit is set to '1', the PMC will periodically enter S0ix during C0 in
    // order to better align traffic and hopefully increase the chances of reaching a
    // package C-state.[br] 
    // When this bit is a '0', the PMC will remain in the CPU ACTIVE state during C0.[br]
    // Note: If the Server CPPM: S0ix in C0 Disable Fuse is 1, this register will always
    // read 0 and is Read-only. 
    // 
    // Bits[30:30], RW/V, default = 0x0
    //
    UINTX pdma_en : 1;
    //
    // This bit acts as an override to several individual CPPM feature policy bits which
    // are located in RCBA memory-mapped space.  It is located in PCI config space in
    // order to be accessible to a PECI master such as a BMC.  It can be enabled/disabled
    // dynamically during run time, however, the values in OBFF_POLICY_TYPE, INT_OBFF_EN,
    // and EXT_OBFF_EN must be valid before this bit is set to one.[br] 
    // If OBFF_POLICY_TYPE = 11b (server) and MDAP_POLICY_EN = 0b:[br]
    //   - Wait for any pending S0ix transitions to complete and then park in CPU Active[br]
    //   - Dont send PM_INFO msg to EVA[br]
    //   - Dont need to track PIW or MDTL[br]
    // Note that if EXT_OBFF_EN = 0b then WAKE# will be tri-stated regardless of the
    // MDAP_POLICY_EN value.[br] 
    // If OBFF_POLICY_TYPE = 11b (server) and MDAP_POLICY_EN = 1b, the individual CPPM
    // enable bits govern the features listed above as normal.[br] 
    // If OBFF_POLICY_TYPE != 11b, MDAP_POLICY_EN has no effect.[br]
    // Note: This bit does not have any effect on LTR from the EVA or the EVA vs. PMC
    // muxing on obff[1:0].[br] 
    // Note: If CPPM Server Policy Disable Fuse is 1, this register will always read
    // 0 and is Read-only. 
    // 
    // Bits[31:31], RW/V, default = 0x0
    //
    UINTX mdap_policy_en : 1;
  } Bits;
  UINTX Data;
} MDAP_PMC_PCI_CFG_STRUCT;
#endif // ASM_INC

#define MANID_PMC_PCI_CFG_REG                              0x000000F8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Indicates the process as 1271. [br]
    // Note:  Process/Dot (PD) is 1271.8 [TBC].  Dot is reflected in bits [27:24][br]
    // Implementation Note: It is recommended that the Manufacturing ID is implemented
    // in one place and readable from all functions. This minimizes the changes required
    // for a process shrink. 
    // 
    // Bits[7:0], RO/V, default = 0xB3
    //
    UINTX pid : 8;
    //
    // N/A
    // 
    // Bits[15:8], RO/V, default = 0xF
    //
    UINTX mid : 8;
    //
    // This field is incremented for each stepping of the part.  Note that this field
    // can be used by software to differentiate steppings when the Stepping Revision
    // ID may not change.[br] 
    // A single Manufacturing Stepping ID can be implemented that is readable from all
    // functions in the chip because all of them are incremented in lock-step. 
    // 
    // Bits[23:16], RO/V, default = 0x0
    //
    UINTX msid : 8;
    //
    // Indicates the dot as .8 [br]
    // Note: Process/Dot(PD) is 1271.8 [TBC].  Process is reflected in bits [7:0]
    // 
    // Bits[27:24], RO/V, default = 0x8
    //
    UINTX dpid : 4;
    //
    // N/A
    // 
    // Bits[31:28], RO/V, default = 0x0
    //
    UINTX rsvd_31_28 : 4;
  } Bits;
  UINTX Data;
} MANID_PMC_PCI_CFG_STRUCT;
#endif // ASM_INC


#endif // _PMC_PCI_CFG_H_
