/** @file
  File name:    PMC_PCI_MMR.h
  Input File:   DNV_MRC.xlsx

  THIS FILE IS AUTO-GENERATED BY THE MSP TOOL. DO NOT CHANGE THIS CODE.

  If edits are needed in this file, they must be done via the MSP tool.

  If there is additional project-specific data required by the MSP, it
  can be placed in PMC_PCI_MMR.h, which is used for non-tool-generated
  data

  Includes register defines specific to a project.

  Copyright (c) 2005-2018 Intel Corporation. All rights reserved
  This software and associated documentation (if any) is furnished
  under a license and may only be used or copied in accordance
  with the terms of the license. Except as permitted by such
  license, no part of this software or documentation may be
  reproduced, stored in a retrieval system, or transmitted in any
  form or by any means without the express written consent of
  Intel Corporation.
**/
#ifndef _PMC_PCI_MMR_H_
#define _PMC_PCI_MMR_H_

#include "DataTypes.h"

#if USE_64_BIT_VARIABLES
#define UINTX UINT64
#else
#define UINTX UINT32
#endif

#define WADT_AC_PMC_PCI_MMR_REG                            0x00000000
#ifndef ASM_INC
typedef union {
  struct {
    //
    // This field contains the 32-bit wake alarm device timer value (granularity 1s)
    // for AC power.  The timer begins decrementing when written to a value other than
    // FFFFFFFFh (regardless of the power source when the write occurs).  Upon counting
    // down to 0:[br] 
    // 	If on AC power, GPE0b_STS.WADT_STS will be set.  This status bit being set will
    // generate a host wake if GPE0b_EN.WADT_EN is 1.[br] 
    // 	If the power source is DC at this time, the status bit is not set.  However,
    // if AC power subsequently returns to the platform, the AC Expired Timer begins
    // running.  See the WADT_EXP_AC register for details.[br] 
    // 	The timer returns to its default value of FFFFFFFFh.
    // 
    // Bits[31:0], RW/V, default = 0xFFFFFFFF
    //
    UINTX wadt_ac_val : 32;
  } Bits;
  UINTX Data;
} WADT_AC_PMC_PCI_MMR_STRUCT;
#endif // ASM_INC

#define WADT_DC_PMC_PCI_MMR_REG                            0x00000004
#ifndef ASM_INC
typedef union {
  struct {
    //
    // This field contains the 32-bit wake alarm device timer value (granularity 1s)
    // for DC power.  The timer begins decrementing when written to a value other than
    // FFFFFFFFh (regardless of the power source when the write occurs).  Upon counting
    // down to 0:[br] 
    // 	If on DC power, GPE0b_STS.WADT_STS will be set.  This status bit being set will
    // generate a host wake if GPE0b_EN.WADT_EN is 1.[br] 
    // 	If the power source is AC at this time, the status bit is not set.  However,
    // if DC power subsequently returns to the platform, the DC Expired Timer begins
    // running.  See the WADT_EXP_DC register for details.[br] 
    // 	The timer returns to its default value of FFFFFFFFh.
    // 
    // Bits[31:0], RW/V, default = 0xFFFFFFFF
    //
    UINTX wadt_dc_val : 32;
  } Bits;
  UINTX Data;
} WADT_DC_PMC_PCI_MMR_STRUCT;
#endif // ASM_INC

#define WADT_EXP_AC_PMC_PCI_MMR_REG                        0x00000008
#ifndef ASM_INC
typedef union {
  struct {
    //
    // This field contains the 32-bit wake alarm device [quote]Expired Timer[quote] value
    // (granularity 1s) for AC power.[br] 
    // The timer begins decrementing after switching from DC to AC power, in the case
    // where the WADT_AC timer has already expired while the platform was on DC power.
    //  This timer only decrements while operating on AC power.  So if the power source
    // switches back to DC power, the timer will stop (but not reset).  When AC power
    // returns, the timer will again begin decrementing.[br] 
    // Note: This timer will only begin decrementing under the conditions described above
    // if this field has been configured for something other than its default value of
    // FFFFFFFFh (i.e. FFFFFFFFh = disabled).[br] 
    // Upon expiration of this timer:[br]
    // 	If on AC power, GPE0b_STS.WADT_STS will be set.  This status bit being set will
    // generate a host wake if GPE0b_EN.WADT_EN is 1.[br] 
    // 	BOTH the AC and DC Expired Timers return to their defaults value of FFFFFFFFh.
    // 
    // Bits[31:0], RW/V, default = 0xFFFFFFFF
    //
    UINTX wadt_exp_ac_val : 32;
  } Bits;
  UINTX Data;
} WADT_EXP_AC_PMC_PCI_MMR_STRUCT;
#endif // ASM_INC

#define WADT_EXP_DC_PMC_PCI_MMR_REG                        0x0000000C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // This field contains the 32-bit wake alarm device [quote]Expired Timer[quote] value
    // (granularity 1s) for DC power.[br] 
    // The timer begins decrementing after switching from AC to DC power, in the case
    // where the WADT_DC timer has already expired while the platform was on AC power.
    //  This timer only decrements while operating on DC power.  So if the power source
    // switches back to AC power, the timer will stop (but not reset).  When DC power
    // returns, the timer will again begin decrementing.[br] 
    // Note: This timer will only begin decrementing under the conditions described above
    // if this field has been configured for something other than its default value of
    // FFFFFFFFh (i.e. FFFFFFFFh = disabled).[br] 
    // Upon expiration of this timer:[br]
    // 	If on DC power, GPE0b_STS.WADT_STS will be set.  This status bit being set will
    // generate a host wake if GPE0b_EN.WADT_EN is 1.[br] 
    // 	BOTH the AC and DC Expired Timers return to their defaults value of FFFFFFFFh.
    // 
    // Bits[31:0], RW/V, default = 0xFFFFFFFF
    //
    UINTX wadt_exp_dc_val : 32;
  } Bits;
  UINTX Data;
} WADT_EXP_DC_PMC_PCI_MMR_STRUCT;
#endif // ASM_INC

#define PRSTS_PMC_PCI_MMR_REG                              0x00000010
#ifndef ASM_INC
typedef union {
  struct {
    //
    // This bit is set when the ME generates a non-maskable wake event and is not affected
    // by any other enable bit. When this bit is set, the host power[br] 
    // management logic wakes to S0.
    // 
    // Bits[0:0], RW/1C/V, default = 0x0
    //
    UINTX me_host_wake_sts : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[3:1], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 3;
    //
    // The PCH Power Management Controller sets this bit if it wakes the host for reasons
    // other than typical host-visible wake events. This status bit provides information
    // to BIOS that the PMC caused the wake.[br] 
    // Not for EDS: Do not document this bit in the EDS. This bit will be exposed only
    // if it is needed. 
    // 
    // Bits[4:4], RW/1C/V, default = 0x0
    //
    UINTX pmc_host_wake_sts : 1;
    //
    // This bit gets set when integrated LAN Signals a Power Management Event AND the
    // system is in S5. BIOS can read this status bit to determine this wake source.
    //  Software clears this bit by writing a 1 to it. 
    // 
    // Bits[5:5], RW/1C/V, default = 0x0
    //
    UINTX wol_ovr_wk_sts : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[6:6], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 1;
    //
    // This bit will be set to '1' when the VE Watch Dog Timer triggers a reset.  It
    // will be cleared by a write of '1' by software. 
    // 
    // Bits[7:7], RW/1C/V, default = 0x0
    //
    UINTX ve_wdt_sts : 1;
    //
    // The PCH sets this bit when the PMC becomes operational after completing the Patch
    // Load, or, if no patch is needed. BIOS must wait for this bit to be set before
    // performing resets or sleep events. This bit remains valid after a PMC Patch load
    // until the next global_rst_b 
    // 
    // Bits[8:8], RO/V, default = 0x0
    //
    UINTX pmc_op_sts : 1;
    //
    // The PCH sets this bit if the loading function fails to complete within a reasonable
    // time limit. Not for EDS- See Chapter 32 for details of the PMC Patch flows. This
    // bit remains valid after a PMC Patch load is attempted until the next global_rst_b
    // 
    // Bits[9:9], RO/V, default = 0x0
    //
    UINTX patch_load_to : 1;
    //
    // The PCH sets this bit when the Patch code is not compatible with the Power[br]
    // Management Con troller Product and/or Revision. This bit remains valid after a
    // PMC Patch load is attempted until the next global_rst_b. 
    // 
    // Bits[10:10], RO/V, default = 0x0
    //
    UINTX patch_rev_not_comp : 1;
    //
    // The PCH sets this bit when the Patch code is successfully authenticated and loaded
    // into the PCH from the flash 
    // 
    // Bits[11:11], RW/1C/V, default = 0x0
    //
    UINTX patch_copied_sts : 1;
    //
    // The PCH sets this bit when one or more of the PMC Patch Modules is[br]
    // detected as not valid.[br]
    // Not for EDS- See Chapter 32 for more details of the PMC Patch flows.
    // 
    // Bits[12:12], RW/1C/V, default = 0x0
    //
    UINTX tamp_err : 1;
    //
    // The PCH sets this bit when the PMC Patch authentication fails.[br]
    // Not for EDS- See Chapter 32 for more details of the PMC Patch flows.
    // 
    // Bits[13:13], RW/1C/V, default = 0x0
    //
    UINTX auth_err : 1;
    //
    // The PCH sets this bit when there is no PMC Patch code found in the flash.[br]
    // Not for EDS: See Chapter 32 for more details of the PMC Patch flows.
    // 
    // Bits[14:14], RW/1C/V, default = 0x0
    //
    UINTX patch_not_pres : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[15:15], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 1;
    //
    // This field communicates the implementation revision of the power management functionality.[br]
    // 
    // Bits[23:16], RO/V, default = 0x0
    //
    UINTX pmc_revid : 8;
    //
    // This field communicates the Product Family of the power management functionality.[br]
    // 
    // Bits[31:24], RO/V, default = 0x5
    //
    UINTX pmc_prodid : 8;
  } Bits;
  UINTX Data;
} PRSTS_PMC_PCI_MMR_STRUCT;
#endif // ASM_INC

#define PMC_PWR_CTL_PMC_PCI_MMR_REG                        0x00000014
#ifndef ASM_INC
typedef union {
  struct {
    //
    // When set to 1, the PMC is allowed to gate the PMC Microcontroller leaf of the
    // PMC clock when the HW and FW idle conditions have been met.[br] 
    // When cleared to 0, the PMC Microcontroller leaf of the PMC clock is not dynamically
    // gated.[br] 
    // Note: If Dynamic Clock Gating Disable Fuse is 1, hardware will always see 0 as
    // an output from this register. BIOS reading this register should always return
    // the correct value. 
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINTX dcg_en_pmc_uc : 1;
    //
    // When set to 1, the PMC is allowed to gate the PMC leaf of the SPXB clocks when
    // the PMC interface to SPXB is idle.[br] 
    // When cleared to 0, the PMC SPXB clocks are not dynamically gated.[br]
    // Note: If FUSE_CORE_DCG_DIS is 1, hardware will always see 0 as an output from
    // this register. BIOS reading this register should always return the correct value.
    // 
    // Bits[1:1], RW, default = 0x0
    //
    UINTX dcg_en_spxb : 1;
    //
    // When set to 1, the PMC is allowed to gate the PMC leaf of the MBB clock when the
    // PMC interface to MBB is idle.[br] 
    // When cleared to 0, the PMC MBB clock is not dynamically gated.[br]
    // Note: If FUSE_CORE_DCG_DIS is 1, hardware will always see 0 as an output from
    // this register. BIOS reading this register should always return the correct value.
    // 
    // Bits[2:2], RW, default = 0x0
    //
    UINTX dcg_en_mbb : 1;
    //
    // When set to 1, PMC FW is allowed to throttle the PMC clock (pmc_clk and all derivatives)
    // as it sees fit.[br] 
    // When cleared to 0, the PMC clock will not be throttled.[br]
    // Note: If FUSE_CORE_DCG_DIS is 1, hardware will always see 0 as an output from
    // this register. BIOS reading this register should always return the correct value.
    // 
    // Bits[3:3], RW, default = 0x0
    //
    UINTX ct_en_pmc : 1;
    //
    // When set to 1, the PMC enables the dynamic clock gating feature of its SUS and
    // DSW well SRAMs.[br] 
    // When cleared to 0, PMC SRAM dynamic clock gating is disabled.[br]
    // Note: If FUSE_CORE_DCG_DIS is 1, hardware will always see 0 as an output from
    // this register. BIOS reading this register should always return the correct value.
    // 
    // Bits[4:4], RW, default = 0x0
    //
    UINTX dcg_en_sram : 1;
    //
    // Clock gate enable  bit for the base endpoint (soft IP) in PMC IOSF-SB endpoint,
    // which if set, allows the side_clk to be gated within the Soft IP when the ISM
    // has transitioned to idle.[br] 
    // Note: If FUSE_CORE_DCG_DIS is 1, hardware will always see 0 as an output from
    // this register. BIOS reading this register should always return the correct value.
    // 
    // Bits[5:5], RW, default = 0x0
    //
    UINTX sip_sc_cg_en : 1;
    //
    // When set to 1, the PMC is allowed to gate the SPXB Interface PMC Clock leaf of
    // the PMC clock when the corresponding logic is Idle.[br] 
    // When cleared to 0, the SPXB Interface PMC Clock leaf of the PMC clock is not dynamically
    // gated.[br] 
    // Note: If FUSE_CORE_DCG_DIS is 1, hardware will always see 0 as an output from
    // this register. BIOS reading this register should always return the correct value.
    // 
    // Bits[6:6], RW, default = 0x0
    //
    UINTX dcg_en_spxb_pmc : 1;
    //
    // When set to 1, the PMC is allowed to gate the PMC IOSF-SB leaf of the PMC clock
    // when the PMC IOSF-SB logic is  idle.[br] 
    // When cleared to 0, the PMC IOSF-SB leaf of the PMC clock is not dynamically gated.[br]
    // Note: If FUSE_CORE_DCG_DIS is 1, hardware will always see 0 as an output from
    // this register. BIOS reading this register should always return the correct value.
    // 
    // Bits[7:7], RW, default = 0x0
    //
    UINTX dcg_en_sbep : 1;
    //
    // When set to 1, the PMC is allowed to gate the MBB Interface PMC Clock leaf of
    // the PMC clock when the corresponding logic is Idle.[br] 
    // When cleared to 0, the MBB Interface PMC Clock leaf of the PMC clock is not dynamically
    // gated.[br] 
    // Note: If FUSE_CORE_DCG_DIS is 1, hardware will always see 0 as an output from
    // this register. BIOS reading this register should always return the correct value.
    // 
    // Bits[8:8], RW, default = 0x0
    //
    UINTX dcg_en_mb_pmc : 1;
    //
    // When set to 1, the PMC is allowed to gate the PMC Power Gating Central Controller
    // leaf of the PMC clock when the Power Gating Central Controller is Idle.[br] 
    // When cleared to 0, the PMC Power Gating Central Controller leaf of the PMC clock
    // is not dynamically gated.[br] 
    // Note: If FUSE_CORE_DCG_DIS is 1, hardware will always see 0 as an output from
    // this register. BIOS reading this register should always return the correct value.
    // 
    // Bits[9:9], RW, default = 0x0
    //
    UINTX dcg_en_pgcc : 1;
    //
    // This bit controls whether the IOSF SB router clock can be dynamically gated when
    // all conditions are met[br] 
    // 0 : never gate IOSF SB  router clock[br]
    // 1 : Allow IOSF SB router clock gating when the following conditions are met -[br]
    //     - All endpoints attached to the router are IDLE[br]
    //     - All ingress and egress queues of the router are idle and there are no pending
    // transactions[br] 
    // Note: If FUSE_CORE_DCG_DIS is 1, hardware will always see 0 as an output from
    // this register. BIOS reading this register should always return the correct value.
    // 
    // Bits[10:10], RW, default = 0x0
    //
    UINTX isbr_dcg_en : 1;
    //
    // When set, this disables any forcing of clkreq output signal from PMC IOSF-SB Endpoint.
    // When cleared, the clkreq signal will be forced to '1'. This (forcing of clkreq
    // signal to '1') is used to prevent Partition Clock Gating on IOSF-SB in PARLEG
    // (SUS well) from being enabled out of boot/reset. In other words, when set, this
    // bit enables Partition Clock gating on the SUS well part of IOSF-SB network in
    // PARLEG.[br] 
    // Note: If FUSE_CORE_DCG_DIS is 1, hardware will always see 0 as an output from
    // this bit. BIOS reading this register should always return the correct value. 
    // 
    // Bits[11:11], RW, default = 0x0
    //
    UINTX dis_frc_pmc_sb_clkreq : 1;
    //
    // Defined as RW so as to support any late addition of new gated clock domains in
    // PMC logic.[br] 
    // Note: If FUSE_CORE_DCG_DIS is 1, hardware will always see 0 as an output from
    // this bit. BIOS reading this register should always return the correct value. 
    // 
    // Bits[12:12], RW, default = 0x0
    //
    UINTX rsvd_cb_0 : 1;
    //
    // This value of this bit determines whether the ICC PLL must be shutdown to allow
    // PMC clock throttling in S0.[br] 
    // Encoding:[br]
    //  - '0': The ICC PLL must be shutdown to allow PMC clock throttling in S0.[br]
    //  - '1': Assuming all other conditions allow, clock throttling is enabled regardless
    // of whether the ICC PLL is shutdown. 
    // 
    // Bits[13:13], RW, default = 0x0
    //
    UINTX allow_pmc_ct_icc_pll : 1;
    //
    // This value of this bit determines whether the OPI PLL must be shutdown to allow
    // PMC clock throttling in S0.[br] 
    // Encoding:[br]
    //  - '0': The OPI PLL must be shutdown to allow PMC clock throttling in S0.[br]
    //  - '1': Assuming all other conditions allow, clock throttling is enabled regardless
    // of whether the OPI PLL is shutdown. 
    // 
    // Bits[14:14], RW, default = 0x0
    //
    UINTX allow_pmc_ct_opi_pll : 1;
    //
    // Defined as RW so as to support any late addition of new gated clock domains in
    // PMC logic.[br] 
    // Note: If FUSE_CORE_DCG_DIS is 1, hardware will always see 0 as an output from
    // this bit. BIOS reading this register should always return the correct value. 
    // 
    // Bits[15:15], RW, default = 0x0
    //
    UINTX rsvd_cb_1 : 1;
    //
    // This bit controls whether the IOSF SB clock in the SUS and ASW well partitions
    // can be dynamically gated at partition level when gate condition are met.[br] 
    // 0: IOSF SB clock in all SUS and ASW well partitions will never gate at partition
    // level.[br] 
    // 1: Allow partition level gating on IOSF SB clock in SUS and ASW well partition
    // when the following conditions are met:[br] 
    //  - All endpoints in the partition de-asserted side_clkreq.[br]
    //  - Router in the partition is idle.[br]
    //  - No endpoint or router in other partition is sending IOSF SB message to the
    // partition.[br] 
    // Note: If FUSE_CORE_DCG_DIS is 1, hardware will always see 0 as an output from
    // this bit. BIOS reading this register should always return the correct value. 
    // 
    // Bits[16:16], RW, default = 0x0
    //
    UINTX isb_susaswpcg_en : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[17:17], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 1;
    //
    // When set to 1, the PMC microcontroller and associated logic in the PMC Power-gated
    //               domain is allowed power gate when the corresponding logic is Idle.
    //           [br]When cleared to 0, the PMC microcontroller and associated logic
    // in the PMC Power-gated 
    //               domain are not gated.
    //           [br]
    //           [br]Note: If FUSE_CORE_DCG_DIS is '1', hardware will always see '0'
    // as an output from this 
    //               register. BIOS reading this register should always return the correct
    // value. 
    // 
    // Bits[18:18], RW, default = 0x0
    //
    UINTX pmc_uc_hae : 1;
    //
    // The value of this bit determines whether the GEN2 PLL must be shutdown to allow
    // PMC power gating in S0.[br] 
    // Encoding:[br]
    //  - '0': The GEN2 PLL must be shutdown to allow PMC power gating in S0.[br]
    //  - '1': Assuming all other conditions allow, power gating is enabled in S0 regardless
    // of whether the GEN2 PLL is shutdown. 
    // 
    // Bits[19:19], RW, default = 0x0
    //
    UINTX allow_pmc_pg_gen2_pll : 1;
    //
    // The value of this bit determines whether the ICC PLL must be shutdown to allow
    // PMC power gating in S0.[br] 
    // Encoding:[br]
    //  - '0': The ICC PLL must be shutdown to allow PMC power gating in S0.[br]
    //  - '1': Assuming all other conditions allow, power gating is enabled in S0 regardless
    // of whether the ICC PLL is shutdown. 
    // 
    // Bits[20:20], RW, default = 0x0
    //
    UINTX allow_pmc_pg_icc_pll : 1;
    //
    // The value of this bit determines whether all power gated domains must be shutdown
    // to allow PMC power gating in S0.[br] 
    // Encoding:[br]
    //  - '0': All PGDs must be shutdown to allow PMC power gating in S0.[br]
    //  - '1': Assuming all other conditions allow, PMC power gating is enabled in S0
    // regardless of whether any other PGD is on. 
    // 
    // Bits[21:21], RW, default = 0x0
    //
    UINTX allow_pmc_pg_pgd_on : 1;
    //
    // The value of this bit determines whether the CPU must be in C10 to allow PMC power
    // gating in S0.[br] 
    // Encoding:[br]
    //  - '0': While in S0, PMC power gating is only enabled while the CPU is in C10.[br]
    //  - '1': Assuming all other conditions allow, PMC power gating is enabled in S0
    // regardless of whether the CPU is in C10. 
    // 
    // Bits[22:22], RW, default = 0x0
    //
    UINTX allow_pmc_pg_not_c10 : 1;
    //
    // The value of this bit determines whether the SLP_S0# pin must be asserted to allow
    // PMC power gating in S0.[br] 
    // Encoding:[br]
    //  - '0': While in S0, PMC power gating is only allowed while SLP_S0# is '0'.[br]
    //  - '1': Assuming all other conditions allow, PMC power gating is enabled in S0
    // regardless of the value of the SLP_S0# pin. 
    // 
    // Bits[23:23], RW, default = 0x0
    //
    UINTX allow_pmc_pg_slp_s0 : 1;
    //
    // When set to 1, the PMC is allowed to gate the PMC Clock leaf of the PMC clock
    // feeding the Power Gating domain control  logic  when the corresponding logic is
    // Idle(ie) PMC clock feeding  the power gating domain is only gated when PMC PGD
    // is power gated [br] 
    //               When cleared to 0, PMC Clock leaf of the PMC clock feeding to the
    // power gating domain control  logic  is not dynamically gated. [br] 
    //               Note: If FUSE_CORE_DCG_DIS is 1, hardware will always see 0 as an
    // output from this register. BIOS reading this register should always return the
    // correct value. 
    // 
    // Bits[24:24], RW, default = 0x0
    //
    UINTX dcg_en_pg_pmc : 1;
    //
    // if set, then IP will PG when idle and the PMC requests power gating by asserting
    // the 
    //               pmc_(ip)_sw_pg_req_b signal.
    //           [br]NOTE: This bit corresponds to bit 0 of Chassis PCE register.
    // 
    // Bits[25:25], RO, default = 0x0
    //
    UINTX pmc_pmcre : 1;
    //
    // if set, then IP will PG when idle and the D0i3 register (D0i3C[2] = '1') is set.
    //           [br]NOTE: This bit corresponds to bit 2 of Chassis PCE register.
    // 
    // Bits[26:26], RO, default = 0x0
    //
    UINTX pmc_i3e : 1;
    //
    // if set, then IP will PG when idle and the PMCSR[1:0] register in the IP ='11'.
    //           [br]NOTE: This bit corresponds to bit 2 of Chassis PCE register.
    // 
    // Bits[27:27], RO, default = 0x0
    //
    UINTX pmc_d3he : 1;
    //
    // if clear, then IP will never assert Sleep to the retention flops. If set, then
    // IP may assert 
    //               Sleep during PG'ing.  Note that some platforms may default this
    // bit to '0', others to 
    //               '1'.
    //           [br]NOTE: This bit corresponds to bit 3 of Chassis PCE register.
    // 
    // Bits[28:28], RW, default = 0x1
    //
    UINTX pmc_se : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:29], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 3;
  } Bits;
  UINTX Data;
} PMC_PWR_CTL_PMC_PCI_MMR_STRUCT;
#endif // ASM_INC

#define PM_CFG_PMC_PCI_MMR_REG                             0x00000018
#ifndef ASM_INC
typedef union {
  struct {
    //
    // This field configures the t581 timing involved in the power down flow (CPUPWRGD
    // inactive to ICC_ICLK_INIT inactive).  Encodings (all min timings):[br] 
    //   00: 10 us (default)[br]
    //   01: 100 us[br]
    //   10: 1 ms[br]
    //   11: 10 ms[br]
    // reset_type=host_deep_rst_b
    // 
    // Bits[1:0], RW/V, default = 0x0
    //
    UINTX timing_t581 : 2;
    //
    // This policy bit determines whether PHOLD will be blocked during entry into S3/4/5
    // or Host partition reset.  When this bit is left cleared, the PCH will let any
    // pending PHOLD sequence complete and then prevent any subsequent PHOLD sequence
    // from beginning during the host_prim_rst_b entry sequence.[br] 
    // Encodings:[br]
    //    0: Block PHOLD (default)[br]
    //    1: Dont block PHOLD[br]
    // Not for EDS: Keep this bit reserved in the EDS unless it is needed for a workaround.[br]
    // reset_type=host_deep_rst_b
    // 
    // Bits[2:2], RW/V, default = 0x0
    //
    UINTX phold_blk_dis : 1;
    //
    // This policy bit determines whether the PCH will apply a timeout to the S1/S3/S4/S5
    // entry flow.  If this timeout is enabled and the entry flow appears to be hung,
    // the PCH will trigger a [quote]straight-to-S5[quote] global reset.[br] 
    // Encodings:[br]
    //    0: Timeout disabled (default)[br]
    //    1: Timeout enabled[br]
    // Not For EDS: The actual timeout value is ME-programmable (shared value with the
    // Host partition reset entry timeout).[br] 
    // Not for EDS: Keep this bit reserved in the EDS unless it is needed for a workaround.[br]
    // 
    // Bits[3:3], RW, default = 0x0
    //
    UINTX sx_ent_to_en : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[4:4], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 1;
    //
    // SW programs this pin with the value that should be reflected to the GPIO8_OCS
    // pin, when the pin is in native mode.[br] 
    // Hardware also sets this bit when the over-clocking watchdog timer expires.[br]
    // 
    // Bits[5:5], RW/V, default = 0x1
    //
    UINTX cocs : 1;
    //
    // N/A
    // 
    // Bits[7:6], RO, default = 0x0
    //
    UINTX rsvd_3 : 2;
    //
    // The value in this register determines the minimum time a platform will stay in
    // reset (SLP_S3#, SLP_S4#, SLP_S5# asserted and also SLP_A# and SLP_LAN# asserted
    // if applicable) during a host partition reset with power cycle or a global reset.
    // The duration programmed in this register takes precedence over the applicable
    // SLP_# stretch timers in these reset scenarios.[br] 
    // This field is not writable when the SLP_Sx# Stretching Policy Lock-Down bit is
    // set.[br] 
    // Note that the duration programmed in this register should never be smaller than
    // the stretch duration programmed in the following registers -[br] 
    //   - GEN_PMCON_3.SLP_S3_MIN_ASST_WDTH[br]
    //   - GEN_PMCON_3.S4MAW[br]
    //   - PM_CFG.SLP_A_MIN_ASST_WDTH[br]
    //   - PM_CFG.SLP_LAN_MIN_ASST_WDTH[br]
    // 
    // Bits[9:8], RW/L, default = 0x0
    //
    UINTX pwr_cyc_dur : 2;
    //
    // This bit controls when interrupts (SMI#, SCI) are generated in response to assertion
    // of the PWRBTN# pin.  This bit's values cause the following behavior:[br] 
    //  - '0': The 16ms debounce period applies to all usages of the PWRBTN# pin (legacy
    // behavior).[br] 
    //  - '1': When a falling edge occurs on the PWRBTN# pin, an interrupt is generated
    // and the 16ms debounce timer starts.  Subsequent interrupts are masked while the
    // debounce timer is running.[br] 
    // Note: Power button override logic always samples the post-debounce version of
    // the pin.[br] 
    // 
    // Bits[10:10], RW, default = 0x0
    //
    UINTX pb_db_mode : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[13:11], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 3;
    //
    // This 2-bit value indicates the minimum assertion width of the SLP_LAN# signal
    // to guarantee that the power to the PHY has been fully power-cycled. This value
    // may be modified per platform depending on power supply, capacitance, board capacitance,
    // power failure detection circuits, etc.[br] 
    // This field is not writable when the SLP_Sx# Stretching Policy Lock Down bit is
    // set to [quote]1[quote].[br] 
    // 
    // Bits[15:14], RW/L, default = 0x0
    //
    UINTX slp_lan_min_asst_wdth : 2;
    //
    // This 2-bit value indicates the minimum assertion width of the SLP_A# signal to
    // guarantee that the ASW power supplies have been fully power-cycled. This value
    // may be modified per platform depending on power supply capacitance, board capacitance,
    // power failure detection circuits, etc.[br] 
    // Settings are:[br]
    //   00 = 0 ms (i.e. stretching disabled - default)[br]
    //   01 = 4 s[br]
    //   10 = 98 ms[br]
    //   11 = 2 s[br]
    // This field is not writable when the SLP_Sx# Stretching Policy Lock- Down bit is
    // set.[br] 
    // This field is ignored when exiting a G3 or DeepSx state if the [quote]Disable
    // SLP_X Stretching After SUS Power Failure[quote] bit is set.[br] 
    // This bit is cleared by the rtc_pwrgood_rst_b pin.[br]
    // 
    // Bits[17:16], RW/L, default = 0x0
    //
    UINTX slp_a_min_asst_wdth : 2;
    //
    // This 2-bit value indicates the minimum assertion width of the SLP_SUS# signal
    // to guarantee that the SUS well power supplies have been fully power-cycled. This
    // value may be modified per platform depending on power supply capacitance, board
    // capacitance, power failure detection circuits, etc.[br] 
    // Settings are:[br]
    //   00 = 0 ms (i.e. stretching disabled - default)[br]
    //   01 = 500ms[br]
    //   10 = 1s[br]
    //   11 = 4s[br]
    // This field is not writable when the SLP_Sx# Stretching Policy Lock- Down bit is
    // set.[br] 
    // This field is ignored when exiting a G3 state if the [quote]Disable SLP_X Stretching
    // After SUS Power Failure[quote] bit is set.  Note that unlike with all other SLP_*
    // pin stretching, this disable bit only impacts SLP_SUS# stretching during G3 exit
    // rather than both G3 and DeepSx exit.  SLP_SUS# stretching always applies to DeepSx
    // regardless of the disable bit.[br] 
    // Programming Note: For platforms that enable DeepSx, BIOS must program SLP_SUS#
    // stretching to be greater than or equal to the largest stretching value on any
    // other SLP_* pin (SLP_S3#, SLP_S4#, SLP_LAN#, or SLP_A#).[br] 
    // This bit is cleared by the rtc_pwrgood_rst_b pin.[br]
    // 
    // Bits[19:18], RW/L, default = 0x0
    //
    UINTX slp_sus_min_asst_wdth : 2;
    //
    // N/A
    // 
    // Bits[20:20], RO, default = 0x0
    //
    UINTX rsvd_1 : 1;
    //
    // When set, this bit disables RTC wakes from waking the system from DeepSx.[br]
    // 
    // Bits[21:21], RW, default = 0x0
    //
    UINTX rtc_dsx_wake_dis : 1;
    //
    // When set to '1', this bit disallows host reads to PMC XRAM.  BIOS must set this
    // bit (to disable and lock the feature) prior to passing control to the operating
    // system on both boot and Sx resume.  This bit is self-locking (i.e. once written
    // to '1', it can only be cleared by host_prim_rst_b).[br] 
    // Not for EDS: Keep this field reserved in the EDS unless it becomes required for
    // any purpose other than debug.[br] 
    // 
    // Bits[22:22], RW/L, default = 0x0
    //
    UINTX pmc_read_disable : 1;
    //
    // If this bit is set to '1', a global reset is triggered when a parity error is
    // detected on PMC's SRAM interfaces. No action is taken on such parity errors if
    // this bit is '0'.[br] 
    // 
    // Bits[23:23], RW, default = 0x0
    //
    UINTX en_pmc_unc_err : 1;
    //
    // Software writes a 1b to this bit after completely writing a PMC Patch (and reading
    // back the PMC Message Full Status = 0b).  A value of 1b causes the PMC to execute
    // the patch and prevent any further patches until the next global reset.[br] 
    // Software must set this bit even in the case that no patch is available.  This
    // immediately returns the PMC to an operational state and prevents accidental or
    // deliberate patches from being loaded later.  The PMC is unable to service reset
    // and power management requests while waiting for the Patch Load to complete.[br]
    // Not for EDS: Keep this bit reserved in the EDS unless it is needed for a workaround.[br]
    // Once set to 1b, this bit can only be cleared by a platform reset.[br]
    // 
    // Bits[24:24], RW/L, default = 0x0
    //
    UINTX patch_load_com : 1;
    //
    // When this bit is '0' (default), USB2 PHY power gating is disabled.
    //           [br]When this bit is '1', USB2 PHY power gating can occur if all other
    // required conditions are met. 
    // 
    // Bits[25:25], RW, default = 0x0
    //
    UINTX allow_usb2_core_pg : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[26:26], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 1;
    //
    // When this bit is set to [quote]1[quote], the following bit is locked down -[br]
    //     -- ETR3.SKIP_HOST_RST_HS[br]
    //     -- ETR3.RST_SX_TO_DBG[br]
    //     -- ETR3.PSMI_DGB_MODE_EN[br]
    // This bit becomes locked when a value of 1b is written to it. Writes to 0 to this
    // bit are always ignored. Once locked, the only way the bit gets cleared is through
    // a PLTRST# assertion.[br] 
    // 
    // Bits[27:27], RW/L, default = 0x0
    //
    UINTX dbg_mode_lock : 1;
    //
    // The value of this bit determines how many times the PMC will retry time synchronization
    // before stopping and reporting failure to the initiator.[br] 
    // [br]      
    //       Encoding:[br]
    //       0  Maximum of 5 attempts[br]
    //       1  Maximum of 10 attempts
    // 
    // Bits[28:28], RW, default = 0x0
    //
    UINTX ts_maxtry : 1;
    //
    // When this bit is '0', the 24MHz crystal oscillator will always be running while
    // in S0.[br] 
    // When this bit is '1', the 24MHz crystal oscillator may be shut down in S0 (Cx
    // only) if all other conditions allow. 
    // 
    // Bits[29:29], RW, default = 0x0
    //
    UINTX allow_24_osc_sd : 1;
    //
    // This field configures t591 timing involved in the over-clocking flow (Wait times
    // between writes from PMC to ICC registers when executing BCLK slow ramp flow)[br]
    // Note: Encodings are all min timings.[br]
    // 
    // Bits[30:30], RW, default = 0x0
    //
    UINTX timing_t591 : 1;
    //
    // When set to 1, this bit indicates that the SATA interface on the PCH is completely
    // disabled. Therefore, the mPhy lanes normally assigned to SATA will operate through
    // the PCIe controller (or not be used at all).[br] 
    // When cleared, it indicates that at least some of the SATA interface lanes may
    // be used actively in the PCH by the SATA controller, so none of the four lanes
    // assigned to SATA interface can operate through the PCIe controller.[br] 
    // 
    // Bits[31:31], RW, default = 0x0
    //
    UINTX sata_dis_ind : 1;
  } Bits;
  UINTX Data;
} PM_CFG_PMC_PCI_MMR_STRUCT;
#endif // ASM_INC

#define PCH_PM_STS_PMC_PCI_MMR_REG                         0x0000001C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // PMC FW sets this bit as an indication that a ME uncorrectable error has been forwarded
    // to PMC FW.  
    // 
    // 
    // Bits[0:0], RW/1C/V, default = 0x0
    //
    UINTX me_ue_sts : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[3:1], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 3;
    //
    // PMC FW sets this bit as an indication that a message has been received on IOSF-SB
    // that was forwarded to PMC FW, but is not recognized by PMC FW.[br] 
    // NOT FOR EDS: Leave this bit reserved in the EDS. It is only meant for debug purposes.[br]
    // 
    // Bits[4:4], RW/1C/V, default = 0x0
    //
    UINTX invld_sb_msg_rcvd : 1;
    //
    // This bit is set by PMC hardware to indicate that the CPPM LTR logic has received
    // a LTR message from an unidentified source.[br] 
    // NOT FOR EDS: This bit should be reserved in the EDS. It is only meant for debug
    // purposes.[br] 
    // 
    // Bits[5:5], RW/1C/V, default = 0x0
    //
    UINTX ltr_invld_src_err_sts : 1;
    //
    // PMC FW sets this bit as an indication that a IE uncorrectable error has been forwarded
    // to PMC FW.  
    // 
    // 
    // Bits[6:6], RW/1C/V, default = 0x0
    //
    UINTX ie_ue_sts : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:7], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 1;
    //
    // When cleared to 0b, this bit indicates that the PMC will not be accepting a patch
    // from the BIOS.  The BIOS must not attempt to write a patch into the [quote]Message
    // to PMC[quote] register in this case.  In this case, the PMC must not allow patching
    // from the host and must not have any dependency on the state of the [quote]Patch
    // Load Complete[quote] bit.[br] 
    // When this bit is set to 1b, the PMC is enabled to accept a patch through the [quote]Message
    // to PMC[quote] register following the CPU Reset deassertion.  The PMC is unable
    // to handle any power management events until the [quote]Patch Load Complete[quote]
    // bit is set or 8 seconds have expired.  The BIOS must always set the [quote]Patch
    // Load Complete[quote] bit before attempting any resets or loading the OS when this
    // bit is set.[br] 
    // Not for EDS: Keep this bit reserved in the EDS unless it is needed for a workaround.
    // 
    // Bits[8:8], RO/V, default = 0x0
    //
    UINTX patch_req : 1;
    //
    // N/A
    // 
    // Bits[10:9], RO, default = 0x0
    //
    UINTX rsvd10_9 : 2;
    //
    // The triggered reset is a SPD Reset (SPD_BIOS_RESET)
    // [br]0= not SPD reset
    // [br]1= SPD Reset
    // [br]ATTR = RW Once sticky.
    // 
    // Bits[11:11], RW, default = 0x0
    //
    UINTX spd_bios_reset : 1;
    //
    // Equal Speed Enable (EUQAL_SPEED_ENABLE)
    // [br]0= Do not enable SSC PLL relock when SPD_DDR_SPEED = MAX_DDR_SKU
    // [br]1= enable SSC PLL relock when SPD_DDR_SPEED = MAX_DDR_SK
    // [br]ATTR = RW sticky
    // 
    // Bits[12:12], RW, default = 0x0
    //
    UINTX equal_speed_enable : 1;
    //
    // BIOS Discovered DDR SPEED (SPD_DDR_SPEED)
    // [br]000=ddr 1600
    // [br]001=ddr 1867
    // [br]010=ddr 2133
    // [br]011=ddr 2400
    // [br]100=ddr 2667
    // 
    // Bits[15:13], RW, default = 0x0
    //
    UINTX spd_ddr_speed : 3;
    //
    // When set to '1', this bit indicates that the Automatic DIMM Self-Refresh (ADR)
    // flow was executed during a prior global reset entry.[br] 
    // 
    // Bits[16:16], RW/1C/V, default = 0x0
    //
    UINTX adr_rst_sts : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[19:17], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 3;
    //
    // These bits are defined for workarounds to send a message or a status of an event
    // to BIOS. No usage model identified yet for any of the bits.[br] 
    // Not for EDS: These bits should be marked as Reserved in the EDS.[br]
    // 
    // Bits[23:20], RO/V, default = 0x0
    //
    UINTX pch_misc_wa : 4;
    //
    // This bit gets set to 1b automatically when the Message to PMC register (RCBA offset
    // 3320h) is written.  The PMC clears this bit when it has serviced the message.
    //  Host software should poll this bit until it returns a 0b to avoid overwriting
    // the previous message data before the PMC could service it.[br] 
    // Implementation Note (not for EDS):  This bit can be implemented by making the
    // PMCs Write Event Status bit (HOST_REG_ES_3. HOST_MEM_3320_ES) readable in this
    // location.[br] 
    // Not for EDS: Keep this bit reserved in the EDS unless it is needed for a workaround.
    // 
    // Bits[24:24], RO/V, default = 0x0
    //
    UINTX pmc_msg_full_sts : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[30:25], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_3 : 6;
    //
    // When this bit is a 1, ME is informing Host software that the PCH Soft SKU flow
    // is complete.[br] 
    // Note that this bit is RO, not RWC.  ME will ensure that this bit is always accurate
    // (no need for Host software to clear it).[br] 
    // Not for EDS: Keep this bit reserved in the EDS unless it is needed for a workaround.[br]
    // 
    // Bits[31:31], RO/V, default = 0x0
    //
    UINTX pch_ssku_valid : 1;
  } Bits;
  UINTX Data;
} PCH_PM_STS_PMC_PCI_MMR_STRUCT;
#endif // ASM_INC

#define MTPMC_PMC_PCI_MMR_REG                              0x00000020
#ifndef ASM_INC
typedef union {
  struct {
    //
    // A write to any of the bytes in this field causes an interrupt to the PMC. The
    // PMC can read the contents of this register.  The host must wait until the PMC
    // has taken action on the previous write to MTPMC, as indicated by the PMC Message
    // Full Status (PMC_MSG_FULL_STS) bit being cleared, before initiating another write
    // to the MTPMC register.  In the case of a message that involves a response from
    // the PMC (such as a PMC XRAM read), the host must also consume any data returned
    // by the PMC in the Message from PMC register (MFPMC) before initiating another
    // message.[br] 
    // Specific Encodings:[br]
    //    00000001h- Start of PMC Patch[br]
    //    XXXX0002h- Start read from PMC XRAM (XXXX= upper 16-bits = the desired address
    // in XRAM to read from)[br] 
    // Not for EDS: Don't document the encodings unless the features become an external
    // POR. 
    // 
    // Bits[31:0], RW, default = 0x0
    //
    UINTX mtpmc : 32;
  } Bits;
  UINTX Data;
} MTPMC_PMC_PCI_MMR_STRUCT;
#endif // ASM_INC

#define PCH_PM_STS2_PMC_PCI_MMR_REG                        0x00000024
#ifndef ASM_INC
typedef union {
  struct {
    //
    // The EVA did not complete the host partition reset/Sx entry handshake.
    // 
    // Bits[0:0], RW/1C/V, default = 0x0
    //
    UINTX eva_l23 : 1;
    //
    // The XHCI controller did not complete the host partition reset/Sx entry handshake.
    // 
    // Bits[1:1], RW/1C/V, default = 0x0
    //
    UINTX xhci_hrhs : 1;
    //
    // The PCH PCI Express ports did not complete the host partition reset/Sx entry handshake.
    // 
    // Bits[2:2], RW/1C/V, default = 0x0
    //
    UINTX sp_l23 : 1;
    //
    // The host SMBus controller did not complete the host partition reset handshake.
    // 
    // Bits[3:3], RW/1C/V, default = 0x0
    //
    UINTX smb_srhs : 1;
    //
    // The DMI interface did not respond to the request to entry L23.
    // 
    // Bits[4:4], RW/1C/V, default = 0x0
    //
    UINTX dmi_l23 : 1;
    //
    // The CPU did not respond to the GO_S1_XXX message.
    // 
    // Bits[5:5], RW/1C/V, default = 0x0
    //
    UINTX cpu_s1_ack : 1;
    //
    // The CPU did not respond to the GO_S345 or RESET_WARN message.
    // 
    // Bits[6:6], RW/1C/V, default = 0x0
    //
    UINTX cpu_s345rw_ack : 1;
    //
    // The integrated clocking unit did not complete the host partition reset/Sx entry
    // handshake. 
    // 
    // Bits[7:7], RW/1C/V, default = 0x0
    //
    UINTX xck_hrhs : 1;
    //
    // The SPI controller did not complete the host partition reset/Sx entry handshake.
    // 
    // Bits[8:8], RW/1C/V, default = 0x0
    //
    UINTX spi_hrhs : 1;
    //
    // EXI state transition ACK did not arrive.
    // 
    // Bits[9:9], RW/1C/V, default = 0x0
    //
    UINTX exi_state_trans_ack : 1;
    //
    // One or more SMT controllers did not respond to the CSME bus reset warning.
    // 
    // Bits[10:10], RW/1C/V, default = 0x0
    //
    UINTX smt_rst_ack : 1;
    //
    // The GbE MAC did not respond to the PSCHS message.
    // 
    // Bits[11:11], RW/1C/V, default = 0x0
    //
    UINTX pschs_ack : 1;
    //
    // The GbE PHY did not respond to the PINSTOP message.
    // 
    // Bits[12:12], RW/1C/V, default = 0x0
    //
    UINTX pinstop_ack : 1;
    //
    // ME Host Boot Preparation did not complete.
    // 
    // Bits[13:13], RW/1C/V, default = 0x0
    //
    UINTX me_hbpd : 1;
    //
    // CPU Reset Done message did not arrive from the CPU.
    // 
    // Bits[14:14], RW/1C/V, default = 0x0
    //
    UINTX crd : 1;
    //
    // N/A
    // 
    // Bits[15:15], RO, default = 0x0
    //
    UINTX rsvd15 : 1;
    //
    // SPD_RESET_PCODE
    // [br]0= PMC indicates to Pcode that this is not a SPD Reset.
    // [br]1=PMC indicates to Pcode that this is a SPD Reset
    // [br]Set by PMC when SPD Reset is triggered
    // 
    // Bits[16:16], RO/V, default = 0x0
    //
    UINTX spd_reset_pcode : 1;
    //
    // CURRENT_SPD_SPEED
    // [br]
    // [br]0xxxx = undefined, use max DDR mem config (fuse) as IDI speed
    // [br]
    // [br]1000  = DDR1600,400 MHz IDI freq
    // [br]1001 = DDR1866, 466MHz IDI freq
    // [br]1010 = DDR2133, 533MHz IDI freq 
    // [br]1011=DDR2400, 600Mhz IDI freq 
    // [br]1100 = DDR2667,667MHz  IDI freq
    // 
    // Bits[20:17], RO/V, default = 0x0
    //
    UINTX current_spd_speed : 4;
    //
    // N/A
    // 
    // Bits[23:21], RO, default = 0x0
    //
    UINTX rsvd23_21 : 3;
    //
    // CPU failed to send PINFO.[br]
    // Not for EDS: This bit should not be disclosed unless needed for a workaround.
    // 
    // Bits[24:24], RW/1C/V, default = 0x0
    //
    UINTX cpuid_pinfo_rsp_to : 1;
    //
    // ME failed to load patch.[br]
    // Not for EDS: This bit should not be disclosed unless needed for a workaround.
    // 
    // Bits[25:25], RW/1C/V, default = 0x0
    //
    UINTX me_patch_timeout : 1;
    //
    // SMT response data overflowed maximum buffer size.[br]
    // Not for EDS: This bit should not be disclosed unless needed for a workaround.
    // 
    // Bits[26:26], RW/1C/V, default = 0x0
    //
    UINTX smt_rsp_data_of : 1;
    //
    // Attempt to access registers in the LAN MAC failed.[br]
    // Not for EDS: This bit should not be disclosed unless needed for a workaround.
    // 
    // Bits[27:27], RW/1C/V, default = 0x0
    //
    UINTX mac_access_fail : 1;
    //
    // OS mailbox full.[br]
    // Not for EDS: This bit should not be disclosed unless needed for a workaround.
    // 
    // Bits[28:28], RW/1C/V, default = 0x0
    //
    UINTX mb_full : 1;
    //
    // More than one entity registered for the same event.[br]
    // Not for EDS: This bit should not be disclosed unless needed for a workaround.
    // 
    // Bits[29:29], RW/1C/V, default = 0x0
    //
    UINTX reg_conflict : 1;
    //
    // Maximum number of pipe slots exceeded.[br]
    // Not for EDS: This bit should not be disclosed unless needed for a workaround.
    // 
    // Bits[30:30], RW/1C/V, default = 0x0
    //
    UINTX pipe_slots_empty : 1;
    //
    // Interrupt fired which FW does not have a handler for/did not expect.[br]
    // Not for EDS: This bit should not be disclosed unless needed for a workaround.
    // 
    // Bits[31:31], RW/1C/V, default = 0x0
    //
    UINTX invalid_int : 1;
  } Bits;
  UINTX Data;
} PCH_PM_STS2_PMC_PCI_MMR_STRUCT;
#endif // ASM_INC

#define S3_PWRGATE_POL_PMC_PCI_MMR_REG                     0x00000028
#ifndef ASM_INC
typedef union {
  struct {
    //
    // A '1' in this bit enables power gating of the SUS well in S3 while operating on
    // AC power (based on the AC_PRESENT pin value). 
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINTX s3ac_gate_sus : 1;
    //
    // A '1' in this bit enables power gating of the SUS well in S3 while operating on
    // DC power (based on the AC_PRESENT pin value). 
    // 
    // Bits[1:1], RW, default = 0x0
    //
    UINTX s3dc_gate_sus : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:2], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 30;
  } Bits;
  UINTX Data;
} S3_PWRGATE_POL_PMC_PCI_MMR_STRUCT;
#endif // ASM_INC

#define S4_PWRGATE_POL_PMC_PCI_MMR_REG                     0x0000002C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // A '1' in this bit enables power gating of the SUS well in S4 while operating on
    // AC power (based on the AC_PRESENT pin value). 
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINTX s4ac_gate_sus : 1;
    //
    // A '1' in this bit enables power gating of the SUS well in S4 while operating on
    // DC power (based on the AC_PRESENT pin value). 
    // 
    // Bits[1:1], RW, default = 0x0
    //
    UINTX s4dc_gate_sus : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:2], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 30;
  } Bits;
  UINTX Data;
} S4_PWRGATE_POL_PMC_PCI_MMR_STRUCT;
#endif // ASM_INC

#define S5_PWRGATE_POL_PMC_PCI_MMR_REG                     0x00000030
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[13:0], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 14;
    //
    // A '1' in this bit enables power gating of the SUS well in S5 while operating on
    // AC power (based on the AC_PRESENT pin value). 
    // 
    // Bits[14:14], RW, default = 0x0
    //
    UINTX s5ac_gate_sus : 1;
    //
    // A '1' in this bit enables power gating of the SUS well in S5 while operating on
    // DC power (based on the AC_PRESENT pin value). 
    // 
    // Bits[15:15], RW, default = 0x0
    //
    UINTX s5dc_gate_sus : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:16], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 16;
  } Bits;
  UINTX Data;
} S5_PWRGATE_POL_PMC_PCI_MMR_STRUCT;
#endif // ASM_INC

#define DSX_CFG_PMC_PCI_MMR_REG                            0x00000034
#ifndef ASM_INC
typedef union {
  struct {
    //
    // When this bit is 1, the GP27 pin is monitored while in DeepSx, supporting waking
    // from DeepSx due to assertion of this pin.  In this case, the platform must drive
    // the pin to the correct value while in DeepSx.  DeepSx disabled configurations
    // must leave this bit at 0.[br] 
    // When this bit is 0:[br]
    // DeepSx enabled configurations: The PCH internal pull-down on GP27 pin is enabled
    // in deep-Sx and during G3 exit  and the pin is not monitored during this time.[br]
    // DeepSx disabled configurations: The PCH internal pull-down is never enabled[br]
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINTX gp27_pin_dsx_en : 1;
    //
    // When this bit is 1, the internal pull-down on the AC_PRESENT pin is disabled.
    //  However, the pulldown is not necessarily enabled if the bit '0.  This bit must
    // be left at 0 for DeepSx disabled configurations, and the pulldown is disabled
    // for those configurations even though the bit is 0.  To support ME wakes from DeepSx
    // using MGPIO2, the pin is always monitored regardless of the value of this host
    // policy bit.[br] 
    // When this bit is 0:[br]
    // DeepSx enabled configurations: The PCH internal pull-down on AC_PRESENT is enabled
    // in deep-Sx and during G3 exit.[br] 
    // DeepSx disabled configurations: The PCH internal pull-down on AC_PRESENT is always
    // disabled.[br] 
    // Note: This bit has no impact on GPIO31 functionality (muxed with AC_PRESENT).
    //  GPIO31 is still only driven/monitored while the SUS well is up.[br] 
    // 
    // Bits[1:1], RW, default = 0x0
    //
    UINTX acpres_pd_dsx_dis : 1;
    //
    // When this bit is 1, the PCI Express WAKE# pin is monitored while in DeepSx, supporting
    // waking from DeepSx due to assertion of this pin.  In this case, the platform must
    // externally pull up the pin to the DSW (instead of pulling up to the SUS as has
    // historically been the case).  DeepSx disabled configurations must leave this bit
    // at 0.[br] 
    // When this bit is 0:[br]
    // DeepSx enabled configurations: The PCH internal pull-down on the WAKE# pin is
    // enabled in deep-Sx and during G3 exit and the pin is not monitored during this
    // time.[br] 
    // DeepSx disabled configurations: The PCH internal pull-down on the WAKE# pin is
    // never enabled[br] 
    // 
    // Bits[2:2], RW, default = 0x0
    //
    UINTX wake_pin_dsx_en : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:3], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 29;
  } Bits;
  UINTX Data;
} DSX_CFG_PMC_PCI_MMR_STRUCT;
#endif // ASM_INC

#define MFPMC_PMC_PCI_MMR_REG                              0x00000038
#ifndef ASM_INC
typedef union {
  struct {
    //
    // The data in this register is typically updated in response to a host write to
    // the MTPMC register.[br] 
    // The only defined use of this register is in response to a [quote]XXXX0002h- Start
    // read from PMC XRAM[quote] write to the MTPMC register.  In that scenario, the
    // data returned by PMC represents the contents of XRAM at the address requested
    // by the host (in the upper 16 bits of the MTPMC register).[br] 
    // Not for EDS: Don't document the encoding unless this feature becomes an external
    // POR. 
    // 
    // Bits[31:0], RO/V, default = 0x0
    //
    UINTX mfpmc : 32;
  } Bits;
  UINTX Data;
} MFPMC_PMC_PCI_MMR_STRUCT;
#endif // ASM_INC

#define PM_CFG2_PMC_PCI_MMR_REG                            0x0000003C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // When bits in this register are set to '1', the associated USB ports are enabled
    // for wake on connect in/after DeepSx.[br] 
    // Note: Bits must be cleared for the ports connected to integrated (onboard) USB
    // devices.  Only walk-up ports may have their enable bits set to '1' to enable wake
    // on connect from DeepSx.[br] 
    // 
    // Bits[13:0], RW, default = 0x0
    //
    UINTX usb_dsx_per_port_en : 14;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:14], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 10;
    //
    // While in/after DeepSx and when PM_CFG2.USB_CON_DSX_MODE = '0', this pin controls
    // whether the value driven on the USBWAKEOUT# pin is debounced. Note: internal processing
    // of the USB connect in/after DeepSx always acts on the debounced version of the
    // connection signal.[br] 
    // '0': The raw USB connect signal is driven onto the pin.[br]
    // '1': The debounced version of the USB connect signal is driven onto the pin.[br]
    // 
    // Bits[24:24], RW, default = 0x0
    //
    UINTX usb_con_dsx_out_db : 1;
    //
    // This bit determines how the PCH responds to a USB connect event in/after DeepSx.[br]
    // '0': The USB device connection signal will be routed to the USBWAKEOUT# pin.[br]
    // '1': The USB device connection will be managed within the PCH.[br]
    // 
    // Bits[25:25], RW, default = 0x0
    //
    UINTX usb_con_dsx_mode : 1;
    //
    // BIOS uses this bit to control the DRAM_RESET# pin from the PCH, which is routed
    // to the reset pin on the DRAM.[br] 
    // Encoding:[br]
    //   0 - DRAM_RESET# = '0'[br]
    //   1 - DRAM_RESET# output is tri-stated.[br]
    // Note: This bit is cleared to '0' by HW when SLP_S4# goes low.[br]
    // 
    // Bits[26:26], RW/V, default = 0x0
    //
    UINTX dram_reset_ctl : 1;
    //
    // Not for EDS:
    //           [br]
    //           [br]When both this bit and PMC_SOFT_STRAP_X.STH_DBG_MSG_EN are set to
    // '1', the PMC hardware will 
    //               send software trace hub debug messages to North Peak when requested
    // by PMC FW. 
    //           [br]
    //           [br]When cleared to '0', the PMC hardware will never send the software
    // trace hub debug messages 
    //               to North Peak, even if requested by PMC FW.
    // 
    // Bits[27:27], RW, default = 0x0
    //
    UINTX en_dbg_msg : 1;
    //
    // When this bit is '0' (default), the PMC's power button logic will act upon the
    // input value 
    //               from the GPIO unit, as normal.
    //           [br]When this bit is set to '1', the PMC must force its internal version
    // of the power button 
    //               pin to '1'.  This will result in the PMC logic constantly seeing
    // the pin as de-asserted. 
    // 
    // Bits[28:28], RW, default = 0x0
    //
    UINTX pb_dis : 1;
    //
    // This field determines, while the power button remains asserted, how long the PMC
    //               will wait before initiating a global reset.
    //           [br]
    //           [br]Encoding:
    //           [br]000b - 4 seconds
    //           [br]001b - 6 seconds
    //           [br]010b - 8 seconds
    //           [br]011b - 10 seconds
    //           [br]100b - 12 seconds
    //           [br]101b - 14 seconds
    //           [br]Others - Reserved
    // 
    // Bits[31:29], RW, default = 0x0
    //
    UINTX pbop : 3;
  } Bits;
  UINTX Data;
} PM_CFG2_PMC_PCI_MMR_STRUCT;
#endif // ASM_INC

#define EN_SN_FAST_RING_PMC_PCI_MMR_REG                    0x00000040
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Note: This is the only bit that controls whether snoopreq from PCI Express is
    // routed 
    //               to FAST_RING.  The snoopreqs from all of the PCI Express controllers
    // are ORed together 
    //               and, if this bit is set to '1', any asserted snoopreq will result
    // in FAST_RING assertion. 
    //           [br]
    //           [br]Remove all other PCI Express south port enable bits in a future
    // project. 
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINTX sp_sn_fast_ring : 1;
    //
    // N/A
    // 
    // Bits[1:1], RW, default = 0x0
    //
    UINTX sp2_sn_fast_ring : 1;
    //
    // N/A
    // 
    // Bits[2:2], RW, default = 0x0
    //
    UINTX sp3_sn_fast_ring : 1;
    //
    // N/A
    // 
    // Bits[3:3], RW, default = 0x0
    //
    UINTX sp4_sn_fast_ring : 1;
    //
    // N/A
    // 
    // Bits[4:4], RW, default = 0x0
    //
    UINTX sp5_sn_fast_ring : 1;
    //
    // N/A
    // 
    // Bits[5:5], RW, default = 0x0
    //
    UINTX sp6_sn_fast_ring : 1;
    //
    // N/A
    // 
    // Bits[6:6], RW, default = 0x0
    //
    UINTX sp7_sn_fast_ring : 1;
    //
    // N/A
    // 
    // Bits[7:7], RW, default = 0x0
    //
    UINTX sp8_sn_fast_ring : 1;
    //
    // Applies to all SATA ports.
    // 
    // Bits[8:8], RW, default = 0x0
    //
    UINTX sata_sn_fast_ring : 1;
    //
    // N/A
    // 
    // Bits[9:9], RW, default = 0x0
    //
    UINTX gbe_sn_fast_ring : 1;
    //
    // N/A
    // 
    // Bits[10:10], RW, default = 0x0
    //
    UINTX lpss_sn_fast_ring : 1;
    //
    // N/A
    // 
    // Bits[11:11], RO, default = 0x0
    //
    UINTX rsvd11 : 1;
    //
    // N/A
    // 
    // Bits[12:12], RW, default = 0x0
    //
    UINTX azadsp_sn_fast_ring : 1;
    //
    // N/A
    // 
    // Bits[13:13], RW, default = 0x0
    //
    UINTX scc_sn_fast_ring : 1;
    //
    // Note: This bit is no longer used.  Remove in a future project.
    // 
    // Bits[14:14], RW, default = 0x0
    //
    UINTX vlw_sn_fast_ring : 1;
    //
    // N/A
    // 
    // Bits[15:15], RW, default = 0x0
    //
    UINTX leg_sn_fast_ring : 1;
    //
    // N/A
    // 
    // Bits[16:16], RW, default = 0x0
    //
    UINTX p2sb_sn_fast_ring : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[17:17], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 1;
    //
    // N/A
    // 
    // Bits[18:18], RW, default = 0x0
    //
    UINTX me_sn_fast_ring : 1;
    //
    // N/A
    // 
    // Bits[19:19], RW, default = 0x0
    //
    UINTX pn_sn_fast_ring : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[20:20], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 1;
    //
    // Not for EDS: This bit is a placeholder to make a late ECO easier, and should not
    // be included in the EDS unless a particular use is assigned. 
    // 
    // Bits[21:21], RW, default = 0x0
    //
    UINTX eco1_sn_fast_ring : 1;
    //
    // Not for EDS: This bit is a placeholder to make a late ECO easier, and should not
    // be included in the EDS unless a particular use is assigned. 
    // 
    // Bits[22:22], RW, default = 0x0
    //
    UINTX eco2_sn_fast_ring : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[24:23], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 2;
    //
    // N/A
    // 
    // Bits[25:25], RW, default = 0x0
    //
    UINTX thrm_sn_fast_ring : 1;
    //
    // N/A
    // 
    // Bits[26:26], RW, default = 0x0
    //
    UINTX ish_sn_fast_ring : 1;
    //
    // N/A
    // 
    // Bits[27:27], RW, default = 0x0
    //
    UINTX usbotg_sn_fast_ring : 1;
    //
    // N/A
    // 
    // Bits[28:28], RW, default = 0x0
    //
    UINTX cam_sn_fast_ring : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[30:29], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_3 : 2;
    //
    // N/A
    // 
    // Bits[31:31], RW, default = 0x0
    //
    UINTX all_sn_fast_ring : 1;
  } Bits;
  UINTX Data;
} EN_SN_FAST_RING_PMC_PCI_MMR_STRUCT;
#endif // ASM_INC

#define EN_SN_FAST_RING2_PMC_PCI_MMR_REG                   0x00000044
#ifndef ASM_INC
typedef union {
  struct {
    //
    // N/A
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINTX usb3_sn_fast_ring : 1;
    //
    // N/A
    // 
    // Bits[1:1], RO, default = 0x0
    //
    UINTX rsvd : 1;
    //
    // N/A
    // 
    // Bits[2:2], RW, default = 0x0
    //
    UINTX eva_sn_fast_ring : 1;
    //
    // N/A
    // 
    // Bits[3:3], RW, default = 0x0
    //
    UINTX sp9_sn_fast_ring : 1;
    //
    // N/A
    // 
    // Bits[4:4], RW, default = 0x0
    //
    UINTX sp10_sn_fast_ring : 1;
    //
    // N/A
    // 
    // Bits[5:5], RW, default = 0x0
    //
    UINTX sp11_sn_fast_ring : 1;
    //
    // N/A
    // 
    // Bits[6:6], RW, default = 0x0
    //
    UINTX sp12_sn_fast_ring : 1;
    //
    // N/A
    // 
    // Bits[7:7], RW, default = 0x0
    //
    UINTX sp13_sn_fast_ring : 1;
    //
    // N/A
    // 
    // Bits[8:8], RW, default = 0x0
    //
    UINTX sp14_sn_fast_ring : 1;
    //
    // N/A
    // 
    // Bits[9:9], RW, default = 0x0
    //
    UINTX sp15_sn_fast_ring : 1;
    //
    // N/A
    // 
    // Bits[10:10], RW, default = 0x0
    //
    UINTX sp16_sn_fast_ring : 1;
    //
    // N/A
    // 
    // Bits[11:11], RW, default = 0x0
    //
    UINTX sp17_sn_fast_ring : 1;
    //
    // N/A
    // 
    // Bits[12:12], RW, default = 0x0
    //
    UINTX sp18_sn_fast_ring : 1;
    //
    // N/A
    // 
    // Bits[13:13], RW, default = 0x0
    //
    UINTX sp19_sn_fast_ring : 1;
    //
    // N/A
    // 
    // Bits[14:14], RW, default = 0x0
    //
    UINTX sp20_sn_fast_ring : 1;
    //
    // N/A
    // 
    // Bits[15:15], RW, default = 0x0
    //
    UINTX espi_sn_fast_ring : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:16], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 16;
  } Bits;
  UINTX Data;
} EN_SN_FAST_RING2_PMC_PCI_MMR_STRUCT;
#endif // ASM_INC

#define EN_SN_SLOW_RING_PMC_PCI_MMR_REG                    0x00000048
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Note: This is the only bit that controls whether snoopreq from PCI Express is
    // routed 
    //               to SLOW_RING.  The snoopreqs from all of the PCI Express controllers
    // are ORed together 
    //               and, if this bit is set to '1', any asserted snoopreq will result
    // in SLOW_RING assertion. 
    //           [br]
    //           [br]Remove all other PCI Express south port enable bits in a future
    // project. 
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINTX sp_sn_slow_ring : 1;
    //
    // N/A
    // 
    // Bits[1:1], RW, default = 0x0
    //
    UINTX sp2_sn_slow_ring : 1;
    //
    // N/A
    // 
    // Bits[2:2], RW, default = 0x0
    //
    UINTX sp3_sn_slow_ring : 1;
    //
    // N/A
    // 
    // Bits[3:3], RW, default = 0x0
    //
    UINTX sp4_sn_slow_ring : 1;
    //
    // N/A
    // 
    // Bits[4:4], RW, default = 0x0
    //
    UINTX sp5_sn_slow_ring : 1;
    //
    // N/A
    // 
    // Bits[5:5], RW, default = 0x0
    //
    UINTX sp6_sn_slow_ring : 1;
    //
    // N/A
    // 
    // Bits[6:6], RW, default = 0x0
    //
    UINTX sp7_sn_slow_ring : 1;
    //
    // N/A
    // 
    // Bits[7:7], RW, default = 0x0
    //
    UINTX sp8_sn_slow_ring : 1;
    //
    // Applies to all SATA ports.
    // 
    // Bits[8:8], RW, default = 0x0
    //
    UINTX sata_sn_slow_ring : 1;
    //
    // N/A
    // 
    // Bits[9:9], RW, default = 0x0
    //
    UINTX gbe_sn_slow_ring : 1;
    //
    // N/A
    // 
    // Bits[10:10], RW, default = 0x0
    //
    UINTX lpss_sn_slow_ring : 1;
    //
    // N/A
    // 
    // Bits[11:11], RO, default = 0x0
    //
    UINTX rsvd11 : 1;
    //
    // N/A
    // 
    // Bits[12:12], RW, default = 0x0
    //
    UINTX azadsp_sn_slow_ring : 1;
    //
    // N/A
    // 
    // Bits[13:13], RW, default = 0x0
    //
    UINTX scc_sn_slow_ring : 1;
    //
    // Note: This bit is no longer used.  Remove in a future project.
    // 
    // Bits[14:14], RW, default = 0x0
    //
    UINTX vlw_sn_slow_ring : 1;
    //
    // N/A
    // 
    // Bits[15:15], RW, default = 0x0
    //
    UINTX leg_sn_slow_ring : 1;
    //
    // N/A
    // 
    // Bits[16:16], RW, default = 0x0
    //
    UINTX p2sb_sn_slow_ring : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[17:17], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 1;
    //
    // N/A
    // 
    // Bits[18:18], RW, default = 0x0
    //
    UINTX me_sn_slow_ring : 1;
    //
    // N/A
    // 
    // Bits[19:19], RW, default = 0x0
    //
    UINTX pn_sn_slow_ring : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[20:20], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 1;
    //
    // Not for EDS: This bit is a placeholder to make a late ECO easier, and should not
    // be included in the EDS unless a particular use is assigned. 
    // 
    // Bits[21:21], RW, default = 0x0
    //
    UINTX eco1_sn_slow_ring : 1;
    //
    // Not for EDS: This bit is a placeholder to make a late ECO easier, and should not
    // be included in the EDS unless a particular use is assigned. 
    // 
    // Bits[22:22], RW, default = 0x0
    //
    UINTX eco2_sn_slow_ring : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[24:23], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 2;
    //
    // N/A
    // 
    // Bits[25:25], RW, default = 0x0
    //
    UINTX thrm_sn_slow_ring : 1;
    //
    // N/A
    // 
    // Bits[26:26], RW, default = 0x0
    //
    UINTX ish_sn_slow_ring : 1;
    //
    // N/A
    // 
    // Bits[27:27], RW, default = 0x0
    //
    UINTX usbotg_sn_slow_ring : 1;
    //
    // N/A
    // 
    // Bits[28:28], RW, default = 0x0
    //
    UINTX cam_sn_slow_ring : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[30:29], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_3 : 2;
    //
    // N/A
    // 
    // Bits[31:31], RW, default = 0x0
    //
    UINTX all_sn_slow_ring : 1;
  } Bits;
  UINTX Data;
} EN_SN_SLOW_RING_PMC_PCI_MMR_STRUCT;
#endif // ASM_INC

#define EN_SN_SLOW_RING2_PMC_PCI_MMR_REG                   0x0000004C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // N/A
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINTX usb3_sn_slow_ring : 1;
    //
    // N/A
    // 
    // Bits[1:1], RO, default = 0x0
    //
    UINTX rsvd : 1;
    //
    // N/A
    // 
    // Bits[2:2], RW, default = 0x0
    //
    UINTX eva_sn_slow_ring : 1;
    //
    // N/A
    // 
    // Bits[3:3], RW, default = 0x0
    //
    UINTX sp9_sn_slow_ring : 1;
    //
    // N/A
    // 
    // Bits[4:4], RW, default = 0x0
    //
    UINTX sp10_sn_slow_ring : 1;
    //
    // N/A
    // 
    // Bits[5:5], RW, default = 0x0
    //
    UINTX sp11_sn_slow_ring : 1;
    //
    // N/A
    // 
    // Bits[6:6], RW, default = 0x0
    //
    UINTX sp12_sn_slow_ring : 1;
    //
    // N/A
    // 
    // Bits[7:7], RW, default = 0x0
    //
    UINTX sp13_sn_slow_ring : 1;
    //
    // N/A
    // 
    // Bits[8:8], RW, default = 0x0
    //
    UINTX sp14_sn_slow_ring : 1;
    //
    // N/A
    // 
    // Bits[9:9], RW, default = 0x0
    //
    UINTX sp15_sn_slow_ring : 1;
    //
    // N/A
    // 
    // Bits[10:10], RW, default = 0x0
    //
    UINTX sp16_sn_slow_ring : 1;
    //
    // N/A
    // 
    // Bits[11:11], RW, default = 0x0
    //
    UINTX sp17_sn_slow_ring : 1;
    //
    // N/A
    // 
    // Bits[12:12], RW, default = 0x0
    //
    UINTX sp18_sn_slow_ring : 1;
    //
    // N/A
    // 
    // Bits[13:13], RW, default = 0x0
    //
    UINTX sp19_sn_slow_ring : 1;
    //
    // N/A
    // 
    // Bits[14:14], RW, default = 0x0
    //
    UINTX sp20_sn_slow_ring : 1;
    //
    // N/A
    // 
    // Bits[15:15], RW, default = 0x0
    //
    UINTX espi_sn_slow_ring : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:16], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 16;
  } Bits;
  UINTX Data;
} EN_SN_SLOW_RING2_PMC_PCI_MMR_STRUCT;
#endif // ASM_INC

#define EN_SN_SA_PMC_PCI_MMR_REG                           0x00000050
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Note: This is the only bit that controls whether snoopreq from PCI Express is
    // routed 
    //               to SA.  The snoopreqs from all of the PCI Express controllers are
    // ORed together 
    //               and, if this bit is set to '1', any asserted snoopreq will result
    // in SA assertion. 
    //           [br]
    //           [br]Remove all other PCI Express south port enable bits in a future
    // project. 
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINTX sp_sn_sa : 1;
    //
    // N/A
    // 
    // Bits[1:1], RW, default = 0x0
    //
    UINTX sp2_sn_sa : 1;
    //
    // N/A
    // 
    // Bits[2:2], RW, default = 0x0
    //
    UINTX sp3_sn_sa : 1;
    //
    // N/A
    // 
    // Bits[3:3], RW, default = 0x0
    //
    UINTX sp4_sn_sa : 1;
    //
    // N/A
    // 
    // Bits[4:4], RW, default = 0x0
    //
    UINTX sp5_sn_sa : 1;
    //
    // N/A
    // 
    // Bits[5:5], RW, default = 0x0
    //
    UINTX sp6_sn_sa : 1;
    //
    // N/A
    // 
    // Bits[6:6], RW, default = 0x0
    //
    UINTX sp7_sn_sa : 1;
    //
    // N/A
    // 
    // Bits[7:7], RW, default = 0x0
    //
    UINTX sp8_sn_sa : 1;
    //
    // Applies to all SATA ports.
    // 
    // Bits[8:8], RW, default = 0x0
    //
    UINTX sata_sn_sa : 1;
    //
    // N/A
    // 
    // Bits[9:9], RW, default = 0x0
    //
    UINTX gbe_sn_sa : 1;
    //
    // N/A
    // 
    // Bits[10:10], RW, default = 0x0
    //
    UINTX lpss_sn_sa : 1;
    //
    // N/A
    // 
    // Bits[11:11], RO, default = 0x0
    //
    UINTX rsvd11 : 1;
    //
    // N/A
    // 
    // Bits[12:12], RW, default = 0x0
    //
    UINTX azadsp_sn_sa : 1;
    //
    // N/A
    // 
    // Bits[13:13], RW, default = 0x0
    //
    UINTX scc_sn_sa : 1;
    //
    // Note: This bit is no longer used.  Remove in a future project.
    // 
    // Bits[14:14], RW, default = 0x0
    //
    UINTX vlw_sn_sa : 1;
    //
    // N/A
    // 
    // Bits[15:15], RW, default = 0x0
    //
    UINTX leg_sn_sa : 1;
    //
    // N/A
    // 
    // Bits[16:16], RW, default = 0x0
    //
    UINTX p2sb_sn_sa : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[17:17], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 1;
    //
    // N/A
    // 
    // Bits[18:18], RW, default = 0x0
    //
    UINTX me_sn_sa : 1;
    //
    // N/A
    // 
    // Bits[19:19], RW, default = 0x0
    //
    UINTX pn_sn_sa : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[20:20], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 1;
    //
    // Not for EDS: This bit is a placeholder to make a late ECO easier, and should not
    // be included in the EDS unless a particular use is assigned. 
    // 
    // Bits[21:21], RW, default = 0x0
    //
    UINTX eco1_sn_sa : 1;
    //
    // Not for EDS: This bit is a placeholder to make a late ECO easier, and should not
    // be included in the EDS unless a particular use is assigned. 
    // 
    // Bits[22:22], RW, default = 0x0
    //
    UINTX eco2_sn_sa : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[24:23], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 2;
    //
    // N/A
    // 
    // Bits[25:25], RW, default = 0x0
    //
    UINTX thrm_sn_sa : 1;
    //
    // N/A
    // 
    // Bits[26:26], RW, default = 0x0
    //
    UINTX ish_sn_sa : 1;
    //
    // N/A
    // 
    // Bits[27:27], RW, default = 0x0
    //
    UINTX usbotg_sn_sa : 1;
    //
    // N/A
    // 
    // Bits[28:28], RW, default = 0x0
    //
    UINTX cam_sn_sa : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[30:29], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_3 : 2;
    //
    // N/A
    // 
    // Bits[31:31], RW, default = 0x0
    //
    UINTX all_sn_sa : 1;
  } Bits;
  UINTX Data;
} EN_SN_SA_PMC_PCI_MMR_STRUCT;
#endif // ASM_INC

#define EN_SN_SA2_PMC_PCI_MMR_REG                          0x00000054
#ifndef ASM_INC
typedef union {
  struct {
    //
    // N/A
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINTX usb3_sn_sa : 1;
    //
    // N/A
    // 
    // Bits[1:1], RO, default = 0x0
    //
    UINTX rsvd : 1;
    //
    // N/A
    // 
    // Bits[2:2], RW, default = 0x0
    //
    UINTX eva_sn_sa : 1;
    //
    // N/A
    // 
    // Bits[3:3], RW, default = 0x0
    //
    UINTX sp9_sn_sa : 1;
    //
    // N/A
    // 
    // Bits[4:4], RW, default = 0x0
    //
    UINTX sp10_sn_sa : 1;
    //
    // N/A
    // 
    // Bits[5:5], RW, default = 0x0
    //
    UINTX sp11_sn_sa : 1;
    //
    // N/A
    // 
    // Bits[6:6], RW, default = 0x0
    //
    UINTX sp12_sn_sa : 1;
    //
    // N/A
    // 
    // Bits[7:7], RW, default = 0x0
    //
    UINTX sp13_sn_sa : 1;
    //
    // N/A
    // 
    // Bits[8:8], RW, default = 0x0
    //
    UINTX sp14_sn_sa : 1;
    //
    // N/A
    // 
    // Bits[9:9], RW, default = 0x0
    //
    UINTX sp15_sn_sa : 1;
    //
    // N/A
    // 
    // Bits[10:10], RW, default = 0x0
    //
    UINTX sp16_sn_sa : 1;
    //
    // N/A
    // 
    // Bits[11:11], RW, default = 0x0
    //
    UINTX sp17_sn_sa : 1;
    //
    // N/A
    // 
    // Bits[12:12], RW, default = 0x0
    //
    UINTX sp18_sn_sa : 1;
    //
    // N/A
    // 
    // Bits[13:13], RW, default = 0x0
    //
    UINTX sp19_sn_sa : 1;
    //
    // N/A
    // 
    // Bits[14:14], RW, default = 0x0
    //
    UINTX sp20_sn_sa : 1;
    //
    // N/A
    // 
    // Bits[15:15], RW, default = 0x0
    //
    UINTX espi_sn_sa : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:16], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 16;
  } Bits;
  UINTX Data;
} EN_SN_SA2_PMC_PCI_MMR_STRUCT;
#endif // ASM_INC

#define EN_SN_SLOW_RING_CF_PMC_PCI_MMR_REG                 0x00000058
#ifndef ASM_INC
typedef union {
  struct {
    //
    // N/A
    // 
    // Bits[13:0], RO, default = 0x0
    //
    UINTX rsvd_2 : 14;
    //
    // Note: This bit is no longer used.  Remove in a future project.
    // 
    // Bits[14:14], RW, default = 0x0
    //
    UINTX vlw_sn_slow_ring_cf : 1;
    //
    // N/A
    // 
    // Bits[15:15], RW, default = 0x0
    //
    UINTX leg_sn_slow_ring_cf : 1;
    //
    // N/A
    // 
    // Bits[16:16], RW, default = 0x0
    //
    UINTX p2sb_sn_slow_ring_cf : 1;
    //
    // N/A
    // 
    // Bits[20:17], RO, default = 0x0
    //
    UINTX rsvd_1 : 4;
    //
    // Not for EDS: This bit is a placeholder to make a late ECO easier, and should not
    // be included in the EDS unless a particular use is assigned. 
    // 
    // Bits[21:21], RW, default = 0x0
    //
    UINTX eco1_sn_slow_ring_cf : 1;
    //
    // Not for EDS: This bit is a placeholder to make a late ECO easier, and should not
    // be included in the EDS unless a particular use is assigned. 
    // 
    // Bits[22:22], RW, default = 0x0
    //
    UINTX eco2_sn_slow_ring_cf : 1;
    //
    // N/A
    // 
    // Bits[31:23], RO, default = 0x0
    //
    UINTX rsvd : 9;
  } Bits;
  UINTX Data;
} EN_SN_SLOW_RING_CF_PMC_PCI_MMR_STRUCT;
#endif // ASM_INC

#define EN_SN_FAST_RING_CF_PMC_PCI_MMR_REG                 0x00000060
#ifndef ASM_INC
typedef union {
  struct {
    //
    // N/A
    // 
    // Bits[13:0], RO, default = 0x0
    //
    UINTX rsvd_2 : 14;
    //
    // Note: This bit is no longer used.  Remove in a future project.
    // 
    // Bits[14:14], RW, default = 0x0
    //
    UINTX vlw_sn_fast_ring_cf : 1;
    //
    // N/A
    // 
    // Bits[15:15], RW, default = 0x0
    //
    UINTX leg_sn_fast_ring_cf : 1;
    //
    // N/A
    // 
    // Bits[16:16], RW, default = 0x0
    //
    UINTX p2sb_sn_fast_ring_cf : 1;
    //
    // N/A
    // 
    // Bits[20:17], RO, default = 0x0
    //
    UINTX rsvd_1 : 4;
    //
    // Not for EDS: This bit is a placeholder to make a late ECO easier, and should not
    // be included in the EDS unless a particular use is assigned. 
    // 
    // Bits[21:21], RW, default = 0x0
    //
    UINTX eco1_sn_fast_ring_cf : 1;
    //
    // Not for EDS: This bit is a placeholder to make a late ECO easier, and should not
    // be included in the EDS unless a particular use is assigned. 
    // 
    // Bits[22:22], RW, default = 0x0
    //
    UINTX eco2_sn_fast_ring_cf : 1;
    //
    // N/A
    // 
    // Bits[31:23], RO, default = 0x0
    //
    UINTX rsvd : 9;
  } Bits;
  UINTX Data;
} EN_SN_FAST_RING_CF_PMC_PCI_MMR_STRUCT;
#endif // ASM_INC

#define EN_NS_SA_PMC_PCI_MMR_REG                           0x00000068
#ifndef ASM_INC
typedef union {
  struct {
    //
    // N/A
    // 
    // Bits[1:0], RO, default = 0x0
    //
    UINTX rsvd_1_0 : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[2:2], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 1;
    //
    // N/A
    // 
    // Bits[9:3], RO, default = 0x0
    //
    UINTX rsvd_9_3 : 7;
    //
    // N/A
    // 
    // Bits[10:10], RW, default = 0x0
    //
    UINTX lpss_ns_sa : 1;
    //
    // N/A
    // 
    // Bits[11:11], RO, default = 0x0
    //
    UINTX rsvd_3 : 1;
    //
    // N/A
    // 
    // Bits[12:12], RW, default = 0x0
    //
    UINTX azadsp_ns_sa : 1;
    //
    // N/A
    // 
    // Bits[13:13], RW, default = 0x0
    //
    UINTX scc_ns_sa : 1;
    //
    // N/A
    // 
    // Bits[17:14], RO, default = 0x0
    //
    UINTX rsvd_2 : 4;
    //
    // N/A
    // 
    // Bits[18:18], RW, default = 0x0
    //
    UINTX me_ns_sa : 1;
    //
    // N/A
    // 
    // Bits[20:19], RO, default = 0x0
    //
    UINTX rsvd_1 : 2;
    //
    // Not for EDS: This bit is a placeholder to make a late ECO easier, and should not
    // be included in the EDS unless a particular use is assigned. 
    // 
    // Bits[21:21], RW, default = 0x0
    //
    UINTX eco1_ns_sa : 1;
    //
    // Not for EDS: This bit is a placeholder to make a late ECO easier, and should not
    // be included in the EDS unless a particular use is assigned. 
    // 
    // Bits[22:22], RW, default = 0x0
    //
    UINTX eco2_ns_sa : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[25:23], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 3;
    //
    // N/A
    // 
    // Bits[26:26], RW, default = 0x0
    //
    UINTX ish_sn_sa : 1;
    //
    // N/A
    // 
    // Bits[31:27], RO, default = 0x0
    //
    UINTX rsvd : 5;
  } Bits;
  UINTX Data;
} EN_NS_SA_PMC_PCI_MMR_STRUCT;
#endif // ASM_INC

#define EN_CW_FAST_RING_PMC_PCI_MMR_REG                    0x00000078
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Note: This is the only bit that controls whether clockwake from PCI Express is
    // routed 
    //               to FAST_RING.  The clockwakes from all of the PCI Express controllers
    // are ORed together 
    //               and, if this bit is set to '1', any asserted clockwake will result
    // in FAST_RING assertion. 
    //           [br]
    //           [br]Remove all other PCI Express south port enable bits in a future
    // project. 
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINTX sp_cw_fast_ring : 1;
    //
    // N/A
    // 
    // Bits[1:1], RW, default = 0x0
    //
    UINTX sp2_cw_fast_ring : 1;
    //
    // N/A
    // 
    // Bits[2:2], RW, default = 0x0
    //
    UINTX sp3_cw_fast_ring : 1;
    //
    // N/A
    // 
    // Bits[3:3], RW, default = 0x0
    //
    UINTX sp4_cw_fast_ring : 1;
    //
    // N/A
    // 
    // Bits[4:4], RW, default = 0x0
    //
    UINTX sp5_cw_fast_ring : 1;
    //
    // N/A
    // 
    // Bits[5:5], RW, default = 0x0
    //
    UINTX sp6_cw_fast_ring : 1;
    //
    // N/A
    // 
    // Bits[6:6], RW, default = 0x0
    //
    UINTX sp7_cw_fast_ring : 1;
    //
    // N/A
    // 
    // Bits[7:7], RW, default = 0x0
    //
    UINTX sp8_cw_fast_ring : 1;
    //
    // Applies to all SATA ports.
    // 
    // Bits[8:8], RW, default = 0x0
    //
    UINTX sata_cw_fast_ring : 1;
    //
    // N/A
    // 
    // Bits[9:9], RW, default = 0x0
    //
    UINTX gbe_cw_fast_ring : 1;
    //
    // N/A
    // 
    // Bits[10:10], RW, default = 0x0
    //
    UINTX cam_cw_fast_ring : 1;
    //
    // N/A
    // 
    // Bits[11:11], RO, default = 0x0
    //
    UINTX rsvd11 : 1;
    //
    // N/A
    // 
    // Bits[12:12], RW, default = 0x0
    //
    UINTX az_cw_fast_ring : 1;
    //
    // N/A
    // 
    // Bits[13:13], RW, default = 0x0
    //
    UINTX usbotg_cw_fast_ring : 1;
    //
    // Note: This bit is no longer used.  Remove in a future project.
    // 
    // Bits[14:14], RW, default = 0x0
    //
    UINTX vlw_cw_fast_ring : 1;
    //
    // N/A
    // 
    // Bits[15:15], RW, default = 0x0
    //
    UINTX leg_cw_fast_ring : 1;
    //
    // N/A
    // 
    // Bits[16:16], RW, default = 0x0
    //
    UINTX p2sb_cw_fast_ring : 1;
    //
    // N/A
    // 
    // Bits[17:17], RW, default = 0x0
    //
    UINTX ish_cw_fast_ring : 1;
    //
    // N/A
    // 
    // Bits[18:18], RW, default = 0x0
    //
    UINTX me_cw_fast_ring : 1;
    //
    // N/A
    // 
    // Bits[19:19], RW, default = 0x0
    //
    UINTX pn_cw_fast_ring : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[20:20], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 1;
    //
    // Not for EDS: This bit is a placeholder to make a late ECO easier, and should not
    // be included in the EDS unless a particular use is assigned. 
    // 
    // Bits[21:21], RW, default = 0x0
    //
    UINTX eco1_cw_fast_ring : 1;
    //
    // Not for EDS: This bit is a placeholder to make a late ECO easier, and should not
    // be included in the EDS unless a particular use is assigned. 
    // 
    // Bits[22:22], RW, default = 0x0
    //
    UINTX eco2_cw_fast_ring : 1;
    //
    // N/A
    // 
    // Bits[23:23], RW, default = 0x0
    //
    UINTX hsmb_cw_fast_ring : 1;
    //
    // N/A
    // 
    // Bits[24:24], RW, default = 0x0
    //
    UINTX chap_cw_fast_ring : 1;
    //
    // N/A
    // 
    // Bits[25:25], RW, default = 0x0
    //
    UINTX thrm_cw_fast_ring : 1;
    //
    // N/A
    // 
    // Bits[26:26], RW, default = 0x0
    //
    UINTX spi_cw_fast_ring : 1;
    //
    // N/A
    // 
    // Bits[27:27], RW, default = 0x0
    //
    UINTX pmc_cw_fast_ring : 1;
    //
    // N/A
    // 
    // Bits[28:28], RW, default = 0x0
    //
    UINTX dft_cw_fast_ring : 1;
    //
    // N/A
    // 
    // Bits[29:29], RW, default = 0x0
    //
    UINTX disp_cw_fast_ring : 1;
    //
    // NOTE: the signal from the NP Unit is tied off in CPT and thus this bit has no
    // functionality. 
    // 
    // Bits[30:30], RW, default = 0x0
    //
    UINTX np_cw_fast_ring : 1;
    //
    // N/A
    // 
    // Bits[31:31], RW, default = 0x0
    //
    UINTX espi_cw_fast_ring : 1;
  } Bits;
  UINTX Data;
} EN_CW_FAST_RING_PMC_PCI_MMR_STRUCT;
#endif // ASM_INC

#define EN_CW_FAST_RING2_PMC_PCI_MMR_REG                   0x0000007C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // N/A
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINTX usb3_cw_fast_ring : 1;
    //
    // N/A
    // 
    // Bits[1:1], RW, default = 0x0
    //
    UINTX eva_cw_fast_ring : 1;
    //
    // N/A
    // 
    // Bits[4:2], RO, default = 0x0
    //
    UINTX rsvd_2 : 3;
    //
    // N/A
    // 
    // Bits[5:5], RW, default = 0x0
    //
    UINTX spa_cw_fast_ring : 1;
    //
    // N/A
    // 
    // Bits[6:6], RW, default = 0x0
    //
    UINTX spb_cw_fast_ring : 1;
    //
    // N/A
    // 
    // Bits[7:7], RW, default = 0x0
    //
    UINTX primchan_cw_fast_ring : 1;
    //
    // N/A
    // 
    // Bits[8:8], RW, default = 0x0
    //
    UINTX meio_cw_fast_ring : 1;
    //
    // N/A
    // 
    // Bits[9:9], RW, default = 0x0
    //
    UINTX spc_cw_fast_ring : 1;
    //
    // N/A
    // 
    // Bits[10:10], RW, default = 0x0
    //
    UINTX gsx_cw_fast_ring : 1;
    //
    // NOTE: the signal from the Clock Unit is tied off in CPT and thus this bit has
    // no functionality. 
    // 
    // Bits[11:11], RW, default = 0x0
    //
    UINTX ccc_cw_fast_ring : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[13:12], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
    //
    // N/A
    // 
    // Bits[14:14], RW, default = 0x0
    //
    UINTX ad_cw_fast_ring : 1;
    //
    // N/A
    // 
    // Bits[15:15], RW, default = 0x0
    //
    UINTX lpss_cw_fast_ring : 1;
    //
    // This bit covers all implemented SRCnCLKRQ# pins.
    // 
    // Bits[16:16], RW, default = 0x0
    //
    UINTX srccr_cw_fast_ring : 1;
    //
    // N/A
    // 
    // Bits[17:17], RW, default = 0x0
    //
    UINTX sp9_cw_fast_ring : 1;
    //
    // N/A
    // 
    // Bits[18:18], RW, default = 0x0
    //
    UINTX sp10_cw_fast_ring : 1;
    //
    // N/A
    // 
    // Bits[19:19], RW, default = 0x0
    //
    UINTX sp11_cw_fast_ring : 1;
    //
    // N/A
    // 
    // Bits[20:20], RW, default = 0x0
    //
    UINTX sp12_cw_fast_ring : 1;
    //
    // N/A
    // 
    // Bits[21:21], RW, default = 0x0
    //
    UINTX sp13_cw_fast_ring : 1;
    //
    // N/A
    // 
    // Bits[22:22], RW, default = 0x0
    //
    UINTX sp14_cw_fast_ring : 1;
    //
    // N/A
    // 
    // Bits[23:23], RW, default = 0x0
    //
    UINTX spd_cw_fast_ring : 1;
    //
    // N/A
    // 
    // Bits[24:24], RW, default = 0x0
    //
    UINTX spe_cw_fast_ring : 1;
    //
    // N/A
    // 
    // Bits[25:25], RW, default = 0x0
    //
    UINTX scc_cw_fast_ring : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:26], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 6;
  } Bits;
  UINTX Data;
} EN_CW_FAST_RING2_PMC_PCI_MMR_STRUCT;
#endif // ASM_INC

#define EN_CW_SLOW_RING_PMC_PCI_MMR_REG                    0x00000080
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Note: This is the only bit that controls whether clockwake from PCI Express is
    // routed 
    //               to FAST_RING.  The clockwakes from all of the PCI Express controllers
    // are ORed together 
    //               and, if this bit is set to '1', any asserted clockwake will result
    // in FAST_RING assertion. 
    //           [br]
    //           [br]Remove all other PCI Express south port enable bits in a future
    // project. 
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINTX sp_cw_slow_ring : 1;
    //
    // N/A
    // 
    // Bits[1:1], RW, default = 0x0
    //
    UINTX sp2_cw_slow_ring : 1;
    //
    // N/A
    // 
    // Bits[2:2], RW, default = 0x0
    //
    UINTX sp3_cw_slow_ring : 1;
    //
    // N/A
    // 
    // Bits[3:3], RW, default = 0x0
    //
    UINTX sp4_cw_slow_ring : 1;
    //
    // N/A
    // 
    // Bits[4:4], RW, default = 0x0
    //
    UINTX sp5_cw_slow_ring : 1;
    //
    // N/A
    // 
    // Bits[5:5], RW, default = 0x0
    //
    UINTX sp6_cw_slow_ring : 1;
    //
    // N/A
    // 
    // Bits[6:6], RW, default = 0x0
    //
    UINTX sp7_cw_slow_ring : 1;
    //
    // N/A
    // 
    // Bits[7:7], RW, default = 0x0
    //
    UINTX sp8_cw_slow_ring : 1;
    //
    // Applies to all SATA ports.
    // 
    // Bits[8:8], RW, default = 0x0
    //
    UINTX sata_cw_slow_ring : 1;
    //
    // N/A
    // 
    // Bits[9:9], RW, default = 0x0
    //
    UINTX gbe_cw_slow_ring : 1;
    //
    // N/A
    // 
    // Bits[10:10], RW, default = 0x0
    //
    UINTX cam_cw_slow_ring : 1;
    //
    // N/A
    // 
    // Bits[11:11], RO, default = 0x0
    //
    UINTX rsvd11 : 1;
    //
    // N/A
    // 
    // Bits[12:12], RW, default = 0x0
    //
    UINTX az_cw_slow_ring : 1;
    //
    // N/A
    // 
    // Bits[13:13], RW, default = 0x0
    //
    UINTX usbotg_cw_slow_ring : 1;
    //
    // Note: This bit is no longer used.  Remove in a future project.
    // 
    // Bits[14:14], RW, default = 0x0
    //
    UINTX vlw_cw_slow_ring : 1;
    //
    // N/A
    // 
    // Bits[15:15], RW, default = 0x0
    //
    UINTX leg_cw_slow_ring : 1;
    //
    // N/A
    // 
    // Bits[16:16], RW, default = 0x0
    //
    UINTX p2sb_cw_slow_ring : 1;
    //
    // N/A
    // 
    // Bits[17:17], RW, default = 0x0
    //
    UINTX ish_cw_slow_ring : 1;
    //
    // N/A
    // 
    // Bits[18:18], RW, default = 0x0
    //
    UINTX me_cw_slow_ring : 1;
    //
    // N/A
    // 
    // Bits[19:19], RW, default = 0x0
    //
    UINTX pn_cw_slow_ring : 1;
    //
    // N/A
    // 
    // Bits[20:20], RO, default = 0x0
    //
    UINTX rsvd20 : 1;
    //
    // Not for EDS: This bit is a placeholder to make a late ECO easier, and should not
    // be included in the EDS unless a particular use is assigned. 
    // 
    // Bits[21:21], RW, default = 0x0
    //
    UINTX eco1_cw_slow_ring : 1;
    //
    // Not for EDS: This bit is a placeholder to make a late ECO easier, and should not
    // be included in the EDS unless a particular use is assigned. 
    // 
    // Bits[22:22], RW, default = 0x0
    //
    UINTX eco2_cw_slow_ring : 1;
    //
    // N/A
    // 
    // Bits[23:23], RW, default = 0x0
    //
    UINTX hsmb_cw_slow_ring : 1;
    //
    // N/A
    // 
    // Bits[24:24], RW, default = 0x0
    //
    UINTX chap_cw_slow_ring : 1;
    //
    // N/A
    // 
    // Bits[25:25], RW, default = 0x0
    //
    UINTX thrm_cw_slow_ring : 1;
    //
    // N/A
    // 
    // Bits[26:26], RW, default = 0x0
    //
    UINTX spi_cw_slow_ring : 1;
    //
    // N/A
    // 
    // Bits[27:27], RW, default = 0x0
    //
    UINTX pmc_cw_slow_ring : 1;
    //
    // N/A
    // 
    // Bits[28:28], RW, default = 0x0
    //
    UINTX dft_cw_slow_ring : 1;
    //
    // N/A
    // 
    // Bits[29:29], RW, default = 0x0
    //
    UINTX disp_cw_slow_ring : 1;
    //
    // NOTE: the signal from the NP Unit is tied off in CPT and thus this bit has no
    // functionality. 
    // 
    // Bits[30:30], RW, default = 0x0
    //
    UINTX np_cw_slow_ring : 1;
    //
    // N/A
    // 
    // Bits[31:31], RW, default = 0x0
    //
    UINTX espi_cw_slow_ring : 1;
  } Bits;
  UINTX Data;
} EN_CW_SLOW_RING_PMC_PCI_MMR_STRUCT;
#endif // ASM_INC

#define EN_CW_SLOW_RING2_PMC_PCI_MMR_REG                   0x00000084
#ifndef ASM_INC
typedef union {
  struct {
    //
    // N/A
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINTX usb3_cw_slow_ring : 1;
    //
    // N/A
    // 
    // Bits[1:1], RW, default = 0x0
    //
    UINTX eva_cw_slow_ring : 1;
    //
    // N/A
    // 
    // Bits[4:2], RO, default = 0x0
    //
    UINTX rsvd_2 : 3;
    //
    // N/A
    // 
    // Bits[5:5], RW, default = 0x0
    //
    UINTX spa_cw_slow_ring : 1;
    //
    // N/A
    // 
    // Bits[6:6], RW, default = 0x0
    //
    UINTX spb_cw_slow_ring : 1;
    //
    // N/A
    // 
    // Bits[7:7], RW, default = 0x0
    //
    UINTX primchan_cw_slow_ring : 1;
    //
    // N/A
    // 
    // Bits[8:8], RW, default = 0x0
    //
    UINTX meio_cw_slow_ring : 1;
    //
    // N/A
    // 
    // Bits[9:9], RW, default = 0x0
    //
    UINTX spc_cw_slow_ring : 1;
    //
    // N/A
    // 
    // Bits[10:10], RW, default = 0x0
    //
    UINTX gsx_cw_slow_ring : 1;
    //
    // NOTE: the signal from the Clock Unit is tied off in CPT and thus this bit has
    // no functionality. 
    // 
    // Bits[11:11], RW, default = 0x0
    //
    UINTX ccc_cw_slow_ring : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[13:12], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
    //
    // N/A
    // 
    // Bits[14:14], RW, default = 0x0
    //
    UINTX ad_cw_slow_ring : 1;
    //
    // N/A
    // 
    // Bits[15:15], RW, default = 0x0
    //
    UINTX lpss_cw_slow_ring : 1;
    //
    // This bit covers all implemented SRCnCLKRQ# pins.
    // 
    // Bits[16:16], RW, default = 0x0
    //
    UINTX srccr_cw_slow_ring : 1;
    //
    // N/A
    // 
    // Bits[17:17], RW, default = 0x0
    //
    UINTX sp9_cw_slow_ring : 1;
    //
    // N/A
    // 
    // Bits[18:18], RW, default = 0x0
    //
    UINTX sp10_cw_slow_ring : 1;
    //
    // N/A
    // 
    // Bits[19:19], RW, default = 0x0
    //
    UINTX sp11_cw_slow_ring : 1;
    //
    // N/A
    // 
    // Bits[20:20], RW, default = 0x0
    //
    UINTX sp12_cw_slow_ring : 1;
    //
    // N/A
    // 
    // Bits[21:21], RW, default = 0x0
    //
    UINTX sp13_cw_slow_ring : 1;
    //
    // N/A
    // 
    // Bits[22:22], RW, default = 0x0
    //
    UINTX sp14_cw_slow_ring : 1;
    //
    // N/A
    // 
    // Bits[23:23], RW, default = 0x0
    //
    UINTX spd_cw_slow_ring : 1;
    //
    // N/A
    // 
    // Bits[24:24], RW, default = 0x0
    //
    UINTX spe_cw_slow_ring : 1;
    //
    // N/A
    // 
    // Bits[25:25], RW, default = 0x0
    //
    UINTX scc_cw_slow_ring : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:26], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 6;
  } Bits;
  UINTX Data;
} EN_CW_SLOW_RING2_PMC_PCI_MMR_STRUCT;
#endif // ASM_INC

#define EN_CW_SA_PMC_PCI_MMR_REG                           0x00000088
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Note: This is the only bit that controls whether clockwake from PCI Express is
    // routed 
    //               to FAST_RING.  The clockwakes from all of the PCI Express controllers
    // are ORed together 
    //               and, if this bit is set to '1', any asserted clockwake will result
    // in FAST_RING assertion. 
    //           [br]
    //           [br]Remove all other PCI Express south port enable bits in a future
    // project. 
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINTX sp1_cw_sa : 1;
    //
    // N/A
    // 
    // Bits[1:1], RW, default = 0x0
    //
    UINTX sp2_cw_sa : 1;
    //
    // N/A
    // 
    // Bits[2:2], RW, default = 0x0
    //
    UINTX sp3_cw_sa : 1;
    //
    // N/A
    // 
    // Bits[3:3], RW, default = 0x0
    //
    UINTX sp4_cw_sa : 1;
    //
    // N/A
    // 
    // Bits[4:4], RW, default = 0x0
    //
    UINTX sp5_cw_sa : 1;
    //
    // N/A
    // 
    // Bits[5:5], RW, default = 0x0
    //
    UINTX sp6_cw_sa : 1;
    //
    // N/A
    // 
    // Bits[6:6], RW, default = 0x0
    //
    UINTX sp7_cw_sa : 1;
    //
    // N/A
    // 
    // Bits[7:7], RW, default = 0x0
    //
    UINTX sp8_cw_sa : 1;
    //
    // Applies to all SATA ports.
    // 
    // Bits[8:8], RW, default = 0x0
    //
    UINTX sata_cw_sa : 1;
    //
    // N/A
    // 
    // Bits[9:9], RW, default = 0x0
    //
    UINTX gbe_cw_sa : 1;
    //
    // N/A
    // 
    // Bits[10:10], RW, default = 0x0
    //
    UINTX cam_cw_sa : 1;
    //
    // N/A
    // 
    // Bits[11:11], RO, default = 0x0
    //
    UINTX rsvd11 : 1;
    //
    // N/A
    // 
    // Bits[12:12], RW, default = 0x0
    //
    UINTX az_cw_sa : 1;
    //
    // N/A
    // 
    // Bits[13:13], RW, default = 0x0
    //
    UINTX usbotg_cw_sa : 1;
    //
    // Note: This bit is no longer used.  Remove in a future project.
    // 
    // Bits[14:14], RW, default = 0x0
    //
    UINTX vlw_cw_sa : 1;
    //
    // N/A
    // 
    // Bits[15:15], RW, default = 0x0
    //
    UINTX leg_cw_sa : 1;
    //
    // N/A
    // 
    // Bits[16:16], RW, default = 0x0
    //
    UINTX p2sb_cw_sa : 1;
    //
    // N/A
    // 
    // Bits[17:17], RW, default = 0x0
    //
    UINTX ish_cw_sa : 1;
    //
    // N/A
    // 
    // Bits[18:18], RW, default = 0x0
    //
    UINTX me_cw_sa : 1;
    //
    // N/A
    // 
    // Bits[19:19], RW, default = 0x0
    //
    UINTX pn_cw_sa : 1;
    //
    // N/A
    // 
    // Bits[20:20], RO, default = 0x0
    //
    UINTX rsvd20 : 1;
    //
    // Not for EDS: This bit is a placeholder to make a late ECO easier, and should not
    // be included in the EDS unless a particular use is assigned. 
    // 
    // Bits[21:21], RW, default = 0x0
    //
    UINTX eco1_cw_sa : 1;
    //
    // Not for EDS: This bit is a placeholder to make a late ECO easier, and should not
    // be included in the EDS unless a particular use is assigned. 
    // 
    // Bits[22:22], RW, default = 0x0
    //
    UINTX eco2_cw_sa : 1;
    //
    // N/A
    // 
    // Bits[23:23], RW, default = 0x0
    //
    UINTX hsmb_cw_sa : 1;
    //
    // N/A
    // 
    // Bits[24:24], RW, default = 0x0
    //
    UINTX chap_cw_sa : 1;
    //
    // N/A
    // 
    // Bits[25:25], RW, default = 0x0
    //
    UINTX thrm_cw_sa : 1;
    //
    // N/A
    // 
    // Bits[26:26], RW, default = 0x0
    //
    UINTX spi_cw_sa : 1;
    //
    // N/A
    // 
    // Bits[27:27], RW, default = 0x0
    //
    UINTX pmc_cw_sa : 1;
    //
    // N/A
    // 
    // Bits[28:28], RW, default = 0x0
    //
    UINTX dft_cw_sa : 1;
    //
    // N/A
    // 
    // Bits[29:29], RW, default = 0x0
    //
    UINTX disp_cw_sa : 1;
    //
    // NOTE: the signal from the NP Unit is tied off in CPT and thus this bit has no
    // functionality. 
    // 
    // Bits[30:30], RW, default = 0x0
    //
    UINTX np_cw_sa : 1;
    //
    // N/A
    // 
    // Bits[31:31], RW, default = 0x0
    //
    UINTX espi_cw_sa : 1;
  } Bits;
  UINTX Data;
} EN_CW_SA_PMC_PCI_MMR_STRUCT;
#endif // ASM_INC

#define EN_CW_SA2_PMC_PCI_MMR_REG                          0x0000008C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // N/A
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINTX usb3_cw_sa : 1;
    //
    // N/A
    // 
    // Bits[1:1], RW, default = 0x0
    //
    UINTX eva_cw_sa : 1;
    //
    // N/A
    // 
    // Bits[4:2], RO, default = 0x0
    //
    UINTX rsvd_2 : 3;
    //
    // N/A
    // 
    // Bits[5:5], RW, default = 0x0
    //
    UINTX spa_cw_sa : 1;
    //
    // N/A
    // 
    // Bits[6:6], RW, default = 0x0
    //
    UINTX spb_cw_sa : 1;
    //
    // N/A
    // 
    // Bits[7:7], RW, default = 0x0
    //
    UINTX primchan_cw_sa : 1;
    //
    // N/A
    // 
    // Bits[8:8], RW, default = 0x0
    //
    UINTX meio_cw_sa : 1;
    //
    // N/A
    // 
    // Bits[9:9], RW, default = 0x0
    //
    UINTX spc_cw_sa : 1;
    //
    // N/A
    // 
    // Bits[10:10], RW, default = 0x0
    //
    UINTX gsx_cw_sa : 1;
    //
    // NOTE: the signal from the Clock Unit is tied off in CPT and thus this bit has
    // no functionality. 
    // 
    // Bits[11:11], RW, default = 0x0
    //
    UINTX ccc_cw_sa : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[13:12], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
    //
    // N/A
    // 
    // Bits[14:14], RW, default = 0x0
    //
    UINTX ad_cw_sa : 1;
    //
    // N/A
    // 
    // Bits[15:15], RW, default = 0x0
    //
    UINTX lpss_cw_sa : 1;
    //
    // This bit covers all implemented SRCnCLKRQ# pins.
    // 
    // Bits[16:16], RW, default = 0x0
    //
    UINTX srccr_cw_sa : 1;
    //
    // N/A
    // 
    // Bits[17:17], RW, default = 0x0
    //
    UINTX sp9_cw_sa : 1;
    //
    // N/A
    // 
    // Bits[18:18], RW, default = 0x0
    //
    UINTX sp10_cw_sa : 1;
    //
    // N/A
    // 
    // Bits[19:19], RW, default = 0x0
    //
    UINTX sp11_cw_sa : 1;
    //
    // N/A
    // 
    // Bits[20:20], RW, default = 0x0
    //
    UINTX sp12_cw_sa : 1;
    //
    // N/A
    // 
    // Bits[21:21], RW, default = 0x0
    //
    UINTX sp13_cw_sa : 1;
    //
    // N/A
    // 
    // Bits[22:22], RW, default = 0x0
    //
    UINTX sp14_cw_sa : 1;
    //
    // N/A
    // 
    // Bits[23:23], RW, default = 0x0
    //
    UINTX spd_cw_sa : 1;
    //
    // N/A
    // 
    // Bits[24:24], RW, default = 0x0
    //
    UINTX spe_cw_sa : 1;
    //
    // N/A
    // 
    // Bits[25:25], RW, default = 0x0
    //
    UINTX scc_cw_sa : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:26], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 6;
  } Bits;
  UINTX Data;
} EN_CW_SA2_PMC_PCI_MMR_STRUCT;
#endif // ASM_INC

#define EN_CW_FAST_RING_CF_PMC_PCI_MMR_REG                 0x00000090
#ifndef ASM_INC
typedef union {
  struct {
    //
    // N/A
    // 
    // Bits[13:0], RO, default = 0x0
    //
    UINTX rsvd_2 : 14;
    //
    // Note: This bit is no longer used.  Remove in a future project.
    // 
    // Bits[14:14], RW, default = 0x0
    //
    UINTX vlw_cw_fast_ring_cf : 1;
    //
    // N/A
    // 
    // Bits[15:15], RW, default = 0x0
    //
    UINTX leg_cw_fast_ring_cf : 1;
    //
    // N/A
    // 
    // Bits[16:16], RW, default = 0x0
    //
    UINTX p2sb_cw_fast_ring_cf : 1;
    //
    // N/A
    // 
    // Bits[20:17], RO, default = 0x0
    //
    UINTX rsvd_1 : 4;
    //
    // Not for EDS: This bit is a placeholder to make a late ECO easier, and should not
    // be included in the EDS unless a particular use is assigned. 
    // 
    // Bits[21:21], RW, default = 0x0
    //
    UINTX eco1_cw_fast_ring_cf : 1;
    //
    // Not for EDS: This bit is a placeholder to make a late ECO easier, and should not
    // be included in the EDS unless a particular use is assigned. 
    // 
    // Bits[22:22], RW, default = 0x0
    //
    UINTX eco2_cw_fast_ring_cf : 1;
    //
    // N/A
    // 
    // Bits[31:23], RO, default = 0x0
    //
    UINTX rsvd : 9;
  } Bits;
  UINTX Data;
} EN_CW_FAST_RING_CF_PMC_PCI_MMR_STRUCT;
#endif // ASM_INC

#define EN_CW_SLOW_RING_CF_PMC_PCI_MMR_REG                 0x00000098
#ifndef ASM_INC
typedef union {
  struct {
    //
    // N/A
    // 
    // Bits[13:0], RO, default = 0x0
    //
    UINTX rsvd_2 : 14;
    //
    // Note: This bit is no longer used.  Remove in a future project.
    // 
    // Bits[14:14], RW, default = 0x0
    //
    UINTX vlw_cw_slow_ring_cf : 1;
    //
    // N/A
    // 
    // Bits[15:15], RW, default = 0x0
    //
    UINTX leg_cw_slow_ring_cf : 1;
    //
    // N/A
    // 
    // Bits[16:16], RW, default = 0x0
    //
    UINTX p2sb_cw_slow_ring_cf : 1;
    //
    // N/A
    // 
    // Bits[20:17], RO, default = 0x0
    //
    UINTX rsvd_1 : 4;
    //
    // Not for EDS: This bit is a placeholder to make a late ECO easier, and should not
    // be included in the EDS unless a particular use is assigned. 
    // 
    // Bits[21:21], RW, default = 0x0
    //
    UINTX eco1_cw_slow_ring_cf : 1;
    //
    // Not for EDS: This bit is a placeholder to make a late ECO easier, and should not
    // be included in the EDS unless a particular use is assigned. 
    // 
    // Bits[22:22], RW, default = 0x0
    //
    UINTX eco2_cw_slow_ring_cf : 1;
    //
    // N/A
    // 
    // Bits[31:23], RO, default = 0x0
    //
    UINTX rsvd : 9;
  } Bits;
  UINTX Data;
} EN_CW_SLOW_RING_CF_PMC_PCI_MMR_STRUCT;
#endif // ASM_INC

#define EN_PA_FAST_RING_PMC_PCI_MMR_REG                    0x000000A0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // N/A
    // 
    // Bits[7:0], RO, default = 0x0
    //
    UINTX rsvd_2 : 8;
    //
    // Applies to all SATA ports.
    // 
    // Bits[8:8], RW, default = 0x0
    //
    UINTX sata_pa_fast_ring : 1;
    //
    // N/A
    // 
    // Bits[9:9], RW, default = 0x0
    //
    UINTX ish_pa_fast_ring : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[11:10], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
    //
    // N/A
    // 
    // Bits[12:12], RW, default = 0x0
    //
    UINTX az_pa_fast_ring : 1;
    //
    // N/A
    // 
    // Bits[18:13], RO, default = 0x0
    //
    UINTX rsvd18_13 : 6;
    //
    // N/A
    // 
    // Bits[19:19], RW, default = 0x0
    //
    UINTX pn_pa_fast_ring : 1;
    //
    // N/A
    // 
    // Bits[20:20], RW, default = 0x0
    //
    UINTX bm_busy_pa_fast_ring : 1;
    //
    // Not for EDS: This bit is a placeholder to make a late ECO easier, and should not
    // be included in the EDS unless a particular use is assigned. 
    // 
    // Bits[21:21], RW, default = 0x0
    //
    UINTX eco1_pa_fast_ring : 1;
    //
    // Not for EDS: This bit is a placeholder to make a late ECO easier, and should not
    // be included in the EDS unless a particular use is assigned. 
    // 
    // Bits[22:22], RW, default = 0x0
    //
    UINTX eco2_pa_fast_ring : 1;
    //
    // N/A
    // 
    // Bits[31:23], RO, default = 0x0
    //
    UINTX rsvd : 9;
  } Bits;
  UINTX Data;
} EN_PA_FAST_RING_PMC_PCI_MMR_STRUCT;
#endif // ASM_INC

#define EN_PA_FAST_RING2_PMC_PCI_MMR_REG                   0x000000A4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // N/A
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINTX usb3_pa_fast_ring : 1;
    //
    // N/A
    // 
    // Bits[12:1], RO, default = 0x0
    //
    UINTX rsvd_1 : 12;
    //
    // N/A
    // 
    // Bits[13:13], RW, default = 0x0
    //
    UINTX xhci_ltrinf_pa_fast_ring : 1;
    //
    // N/A
    // 
    // Bits[14:14], RW, default = 0x0
    //
    UINTX ad_pa_fast_ring : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[24:15], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 10;
    //
    // N/A
    // 
    // Bits[25:25], RW, default = 0x0
    //
    UINTX scc_pa_fast_ring : 1;
    //
    // N/A
    // 
    // Bits[31:26], RO, default = 0x0
    //
    UINTX rsvd : 6;
  } Bits;
  UINTX Data;
} EN_PA_FAST_RING2_PMC_PCI_MMR_STRUCT;
#endif // ASM_INC

#define EN_PA_SLOW_RING_PMC_PCI_MMR_REG                    0x000000A8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // N/A
    // 
    // Bits[7:0], RO, default = 0x0
    //
    UINTX rsvd_2 : 8;
    //
    // Applies to all SATA ports.
    // 
    // Bits[8:8], RW, default = 0x0
    //
    UINTX sata_pa_slow_ring : 1;
    //
    // N/A
    // 
    // Bits[9:9], RW, default = 0x0
    //
    UINTX ish_pa_slow_ring : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[11:10], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
    //
    // N/A
    // 
    // Bits[12:12], RW, default = 0x0
    //
    UINTX az_pa_slow_ring : 1;
    //
    // N/A
    // 
    // Bits[18:13], RO, default = 0x0
    //
    UINTX rsvd18_13 : 6;
    //
    // N/A
    // 
    // Bits[19:19], RW, default = 0x0
    //
    UINTX pn_pa_slow_ring : 1;
    //
    // N/A
    // 
    // Bits[20:20], RW, default = 0x0
    //
    UINTX bm_busy_pa_slow_ring : 1;
    //
    // Not for EDS: This bit is a placeholder to make a late ECO easier, and should not
    // be included in the EDS unless a particular use is assigned. 
    // 
    // Bits[21:21], RW, default = 0x0
    //
    UINTX eco1_pa_slow_ring : 1;
    //
    // Not for EDS: This bit is a placeholder to make a late ECO easier, and should not
    // be included in the EDS unless a particular use is assigned. 
    // 
    // Bits[22:22], RW, default = 0x0
    //
    UINTX eco2_pa_slow_ring : 1;
    //
    // N/A
    // 
    // Bits[31:23], RO, default = 0x0
    //
    UINTX rsvd : 9;
  } Bits;
  UINTX Data;
} EN_PA_SLOW_RING_PMC_PCI_MMR_STRUCT;
#endif // ASM_INC

#define EN_PA_SLOW_RING2_PMC_PCI_MMR_REG                   0x000000AC
#ifndef ASM_INC
typedef union {
  struct {
    //
    // N/A
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINTX usb3_pa_slow_ring : 1;
    //
    // N/A
    // 
    // Bits[12:1], RO, default = 0x0
    //
    UINTX rsvd_1 : 12;
    //
    // N/A
    // 
    // Bits[13:13], RW, default = 0x0
    //
    UINTX xhci_ltrinf_pa_slow_ring : 1;
    //
    // N/A
    // 
    // Bits[14:14], RW, default = 0x0
    //
    UINTX ad_pa_slow_ring : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[24:15], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 10;
    //
    // N/A
    // 
    // Bits[25:25], RW, default = 0x0
    //
    UINTX scc_pa_slow_ring : 1;
    //
    // N/A
    // 
    // Bits[31:26], RO, default = 0x0
    //
    UINTX rsvd : 6;
  } Bits;
  UINTX Data;
} EN_PA_SLOW_RING2_PMC_PCI_MMR_STRUCT;
#endif // ASM_INC

#define EN_PA_SA_PMC_PCI_MMR_REG                           0x000000B0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // N/A
    // 
    // Bits[7:0], RO, default = 0x0
    //
    UINTX rsvd_2 : 8;
    //
    // Applies to all SATA ports.
    // 
    // Bits[8:8], RW, default = 0x0
    //
    UINTX sata_pa_sa : 1;
    //
    // N/A
    // 
    // Bits[9:9], RW, default = 0x0
    //
    UINTX ish_pa_sa : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[11:10], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
    //
    // N/A
    // 
    // Bits[12:12], RW, default = 0x0
    //
    UINTX az_pa_sa : 1;
    //
    // N/A
    // 
    // Bits[18:13], RO, default = 0x0
    //
    UINTX rsvd18_13 : 6;
    //
    // N/A
    // 
    // Bits[19:19], RW, default = 0x0
    //
    UINTX pn_pa_sa : 1;
    //
    // N/A
    // 
    // Bits[20:20], RW, default = 0x0
    //
    UINTX bm_busy_pa_sa : 1;
    //
    // Not for EDS: This bit is a placeholder to make a late ECO easier, and should not
    // be included in the EDS unless a particular use is assigned. 
    // 
    // Bits[21:21], RW, default = 0x0
    //
    UINTX eco1_pa_sa : 1;
    //
    // Not for EDS: This bit is a placeholder to make a late ECO easier, and should not
    // be included in the EDS unless a particular use is assigned. 
    // 
    // Bits[22:22], RW, default = 0x0
    //
    UINTX eco2_pa_sa : 1;
    //
    // N/A
    // 
    // Bits[31:23], RO, default = 0x0
    //
    UINTX rsvd : 9;
  } Bits;
  UINTX Data;
} EN_PA_SA_PMC_PCI_MMR_STRUCT;
#endif // ASM_INC

#define EN_PA_SA2_PMC_PCI_MMR_REG                          0x000000B4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // N/A
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINTX usb3_pa_sa : 1;
    //
    // N/A
    // 
    // Bits[12:1], RO, default = 0x0
    //
    UINTX rsvd_1 : 12;
    //
    // N/A
    // 
    // Bits[13:13], RW, default = 0x0
    //
    UINTX xhci_ltrinf_pa_sa : 1;
    //
    // N/A
    // 
    // Bits[14:14], RW, default = 0x0
    //
    UINTX ad_pa_sa : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[24:15], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 10;
    //
    // N/A
    // 
    // Bits[25:25], RW, default = 0x0
    //
    UINTX scc_pa_sa : 1;
    //
    // N/A
    // 
    // Bits[31:26], RO, default = 0x0
    //
    UINTX rsvd : 6;
  } Bits;
  UINTX Data;
} EN_PA_SA2_PMC_PCI_MMR_STRUCT;
#endif // ASM_INC

#define EN_MISC_EVENT_PMC_PCI_MMR_REG                      0x000000C0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // N/A
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINTX az_l1dis_fast_ring : 1;
    //
    // N/A
    // 
    // Bits[1:1], RW, default = 0x0
    //
    UINTX az_l1dis_sa : 1;
    //
    // N/A
    // 
    // Bits[2:2], RW, default = 0x0
    //
    UINTX az_l1dis_slow_ring : 1;
    //
    // N/A
    // 
    // Bits[3:3], RW, default = 0x0
    //
    UINTX az_l1dis_fast_ring_cf : 1;
    //
    // N/A
    // 
    // Bits[4:4], RW, default = 0x0
    //
    UINTX az_l1dis_slow_ring_cf : 1;
    //
    // N/A
    // 
    // Bits[7:5], RO, default = 0x0
    //
    UINTX rsvd7_5 : 3;
    //
    // N/A
    // 
    // Bits[8:8], RW, default = 0x0
    //
    UINTX dmi_put_sn_fast_ring : 1;
    //
    // N/A
    // 
    // Bits[9:9], RW, default = 0x0
    //
    UINTX dmi_put_sn_sa : 1;
    //
    // N/A
    // 
    // Bits[10:10], RW, default = 0x0
    //
    UINTX dmi_put_ns_fast_ring : 1;
    //
    // N/A
    // 
    // Bits[11:11], RW, default = 0x0
    //
    UINTX dmi_put_ns_sa : 1;
    //
    // N/A
    // 
    // Bits[12:12], RW, default = 0x0
    //
    UINTX dmi_put_int_fast_ring : 1;
    //
    // N/A
    // 
    // Bits[13:13], RW, default = 0x0
    //
    UINTX dmi_put_int_fast_ring_cf : 1;
    //
    // N/A
    // 
    // Bits[15:14], RO, default = 0x0
    //
    UINTX rsvd15_14 : 2;
    //
    // N/A
    // 
    // Bits[16:16], RW, default = 0x0
    //
    UINTX phold_fast_ring : 1;
    //
    // N/A
    // 
    // Bits[17:17], RW, default = 0x0
    //
    UINTX phold_sa : 1;
    //
    // N/A
    // 
    // Bits[18:18], RW, default = 0x0
    //
    UINTX phold_slow_ring : 1;
    //
    // N/A
    // 
    // Bits[19:19], RW, default = 0x0
    //
    UINTX phold_fast_ring_cf : 1;
    //
    // N/A
    // 
    // Bits[20:20], RW, default = 0x0
    //
    UINTX phold_slow_ring_cf : 1;
    //
    // N/A
    // 
    // Bits[21:21], RW, default = 0x0
    //
    UINTX bm_brk_fast_ring : 1;
    //
    // N/A
    // 
    // Bits[22:22], RW, default = 0x0
    //
    UINTX bm_brk_sa : 1;
    //
    // N/A
    // 
    // Bits[31:23], RO, default = 0x0
    //
    UINTX rsvd : 9;
  } Bits;
  UINTX Data;
} EN_MISC_EVENT_PMC_PCI_MMR_STRUCT;
#endif // ASM_INC

#define PMSYNC_TPR_CFG_PMC_PCI_MMR_REG                     0x000000C4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // This field specifies the maximum power level for reporting 00b in the PCH_POWER_STATUS
    // field over PMSYNC to the CPU.  If the PMC calculates a power level less than or
    // equal to this value, then it will report PCH_POWER_STATUS=00b to the CPU.[br]
    // This field represents power in 100mW increments, allowing power levels up to 3.1W.[br]
    // A value of 00h means that this Limit is not enabled.  In this case, the PMC will
    // not compare against this limit and will never report a state higher than this
    // state.[br] 
    // Because this is the lowest power state, a 00h value means that the power reporting
    // is disabled.  The PMC must not execute the power calculation operations thus offering
    // a low-power and low-risk option if package thermal power is manageable through
    // other mechanisms. 
    // 
    // Bits[4:0], RW/L, default = 0x0
    //
    UINTX pch2cpu_pwr0_lim : 5;
    //
    // N/A
    // 
    // Bits[7:5], RO, default = 0x0
    //
    UINTX rsvd_3 : 3;
    //
    // This field specifies the maximum power level for reporting 01b in the PCH_POWER_STATUS
    // field over PMSYNC to the CPU.  If the PMC calculates a power level less than or
    // equal to this value and greater than PCH2CPU_PWR0_LIM, then it will report PCH_POWER_STATUS=01b
    // to the CPU.[br] 
    // This field represents power in 100mW increments, allowing power levels up to 3.1W.[br]
    // A value of 00h means that this Limit is not enabled.  In this case, the PMC will
    // not compare against this limit and will never report a state higher than this
    // state. 
    // 
    // Bits[12:8], RW/L, default = 0x0
    //
    UINTX pch2cpu_pwr1_lim : 5;
    //
    // N/A
    // 
    // Bits[15:13], RO, default = 0x0
    //
    UINTX rsvd_2 : 3;
    //
    // This field specifies the maximum power level for reporting 10b in the PCH_POWER_STATUS
    // field over PMSYNC to the CPU.  If the PMC calculates a power level less than or
    // equal to this value and greater than PCH2CPU_PWR1_LIM, then it will report PCH_POWER_STATUS=10b
    // to the CPU.[br] 
    // This field represents power in 100mW increments, allowing power levels up to 3.1W.[br]
    // A value of 00h means that this Limit is not enabled.  In this case, the PMC will
    // not compare against this limit and will never report a state higher than this
    // state. 
    // 
    // Bits[20:16], RW/L, default = 0x0
    //
    UINTX pch2cpu_pwr2_lim : 5;
    //
    // N/A
    // 
    // Bits[23:21], RO, default = 0x0
    //
    UINTX rsvd_1 : 3;
    //
    // This field specifies the PCH T-State level at which the PMC asserts the Thermal
    // Throttle (PCH_THERM_STATUS) bit to the CPU.  The PMC requests thermal throttling
    // when the T-State, which is reported from the Thermal Sensor cluster, is greater
    // than or equal to this state. 
    // 
    // Bits[25:24], RW/L, default = 0x0
    //
    UINTX pch2cpu_tt_state : 2;
    //
    // When this bit is set to '1' the PCH is enabled to set the thermal throttle request
    // to the CPU using the PMSYNC PCH_THERM_STATUS bit.  When this bit is '0', the PCH-to-CPU
    // Thermal Throttling request is disabled. 
    // 
    // Bits[26:26], RW/L, default = 0x0
    //
    UINTX pch2cpu_tt_en : 1;
    //
    // N/A
    // 
    // Bits[30:27], RO, default = 0x0
    //
    UINTX rsvd : 4;
    //
    // When set to 1b, this bit prevents writes from changing the value of this 32-bit
    // register. 
    // 
    // Bits[31:31], RW/L, default = 0x0
    //
    UINTX pch2cpu_tpr_cfg_lock : 1;
  } Bits;
  UINTX Data;
} PMSYNC_TPR_CFG_PMC_PCI_MMR_STRUCT;
#endif // ASM_INC

#define PM_SYNC_MISC_CFG_PMC_PCI_MMR_REG                   0x000000C8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // When this bit is set to 1, BM_STS being at 1 will assert the FAST_RING indication.
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINTX bm_sts_fast_ring_en : 1;
    //
    // When this bit is set to 1, BM_STS being at 1 will assert the SLOW_RING indication.
    // 
    // Bits[1:1], RW, default = 0x0
    //
    UINTX bm_sts_slow_ring_en : 1;
    //
    // When this bit is set to 1, BM_STS being at 1 will assert the SA indication.
    // 
    // Bits[2:2], RW, default = 0x0
    //
    UINTX bm_sts_sa_en : 1;
    //
    // N/A
    // 
    // Bits[3:3], RO, default = 0x0
    //
    UINTX rsvd_5 : 1;
    //
    // This bit is defeatured.
    // 
    // Bits[4:4], RW/1S/V, default = 0x0
    //
    UINTX reg_9 : 1;
    //
    // This bit is defeatured.
    // 
    // Bits[5:5], RW/1S/V, default = 0x0
    //
    UINTX reg_10 : 1;
    //
    // This bit is defeatured.
    // 
    // Bits[6:6], RW, default = 0x0
    //
    UINTX reg_11 : 1;
    //
    // This bit is defeatured.
    // 
    // Bits[7:7], RW, default = 0x0
    //
    UINTX reg_12 : 1;
    //
    // There are two possible GPIOs that can be routed to the GPIO_A PM_SYNC state. 
    // This bit selects between them:[br] 
    //    0: CPU_GP_1 (default)[br]
    //    1: CPU_GP_3[br]
    // This field is not writeable when PM_SYNC_LOCK=1.
    // 
    // Bits[8:8], RW/L, default = 0x0
    //
    UINTX gpio_a_sel : 1;
    //
    // There are two possible GPIOs that can be routed to the GPIO_B PM_SYNC state. 
    // This bit selects between them:[br] 
    //    0: CPU_GP_2 (default)[br]
    //    1: CPU_GP_0[br]
    // This field is not writeable when PM_SYNC_LOCK=1.
    // 
    // Bits[9:9], RW/L, default = 0x0
    //
    UINTX gpio_b_sel : 1;
    //
    // There are two possible GPIOs that can be routed to the GPIO_C PM_SYNC state. 
    // This bit selects between them:[br] 
    //    0: CPU_GP_0 (default)[br]
    //    1: CPU_GP_1[br]
    // This field is not writeable when PM_SYNC_LOCK=1.
    // 
    // Bits[10:10], RW/L, default = 0x0
    //
    UINTX gpio_c_sel : 1;
    //
    // There are two possible GPIOs that can be routed to the GPIO_D PM_SYNC state. 
    // This bit selects between them:[br] 
    //    0: CPU_GP_3 (default)[br]
    //    1: CPU_GP_2[br]
    // This field is not writeable when PM_SYNC_LOCK=1.
    // 
    // Bits[11:11], RW/L, default = 0x0
    //
    UINTX gpio_d_sel : 1;
    //
    // N/A
    // 
    // Bits[14:12], RO, default = 0x0
    //
    UINTX rsvd_4 : 3;
    //
    // The bit is used to lock down the settings of several PM_SYNC-related configuration
    // bits.  This bit is self-locking (i.e. once written to '1', it can only be cleared
    // by host_prim_rst_b). 
    // 
    // Bits[15:15], RW/L, default = 0x0
    //
    UINTX pm_sync_lock : 1;
    //
    // N/A
    // 
    // Bits[31:16], RO, default = 0x0
    //
    UINTX rsvd : 16;
  } Bits;
  UINTX Data;
} PM_SYNC_MISC_CFG_PMC_PCI_MMR_STRUCT;
#endif // ASM_INC

#define PM_SYNC_STATE_HYS_PMC_PCI_MMR_REG                  0x000000D0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // The value programmed into this field determines how much hysteresis to apply to
    // the FAST_RING indication.  This means that once the input to the indication deasserts,
    // the actual indication will remain asserted until the hysteresis timer expires.
    //  If the input asserts again before the hysteresis timer expires, the timer will
    // be reset and only start counting again once the input deasserts.[br] 
    // This field is defined in 4 us units, with a max value of 120 us:[br]
    //   00h: 0 us of hysteresis[br]
    //   1Eh: 120 us of hysteresis[br]
    //   1Fh: Illegal - software must not program
    // 
    // Bits[4:0], RW, default = 0x0
    //
    UINTX fast_ring_hys : 5;
    //
    // See FAST_RING_HYS definition.
    // 
    // Bits[9:5], RW, default = 0x0
    //
    UINTX slow_ring_hys : 5;
    //
    // See FAST_RING_HYS definition.
    // 
    // Bits[14:10], RW, default = 0x0
    //
    UINTX sa_hys : 5;
    //
    // See FAST_RING_HYS definition.
    // 
    // Bits[19:15], RW, default = 0x0
    //
    UINTX fast_ring_cf_hys : 5;
    //
    // See FAST_RING_HYS definition.
    // 
    // Bits[24:20], RW, default = 0x0
    //
    UINTX slow_ring_cf_hys : 5;
    //
    // The value programmed into this field determines how much hysteresis to apply to
    // the PHOLD indication which feeds the various PM_SYNC states.  This means that
    // once the internal PHOLD indication deasserts, the input to the PM_SYNC logic will
    // remain asserted until the hysteresis timer expires.  If PHOLD asserts again before
    // the hysteresis timer expires, the timer will be reset and only start counting
    // again once PHOLD deasserts.[br] 
    // Encodings:[br]
    //   00b: 0 ms (default)[br]
    //   01b: 100 ms[br]
    //   10b: 200 ms[br]
    //   11b: 400 ms
    // 
    // Bits[26:25], RW, default = 0x0
    //
    UINTX phold_hys : 2;
    //
    // The value programmed into this field determines how much hysteresis to apply to
    // the BM_BREAK_EN indication which feeds the various PM_SYNC states.  This means
    // that once the internal BM_BREAK_EN indication deasserts, the input to the PM_SYNC
    // logic will remain asserted until the hysteresis timer expires.  If the BM_BREAK_EN
    // indication asserts again before the hysteresis timer expires, the timer will be
    // reset and only start counting again once the BM_BREAK_EN indication deasserts.[br]
    // Encodings:[br]
    //   00b: 0 ms (default)[br]
    //   01b: 100 ms[br]
    //   10b: 200 ms[br]
    //   11b: 400 ms
    // 
    // Bits[28:27], RW, default = 0x0
    //
    UINTX bm_brk_hys : 2;
    //
    // N/A
    // 
    // Bits[31:29], RO, default = 0x0
    //
    UINTX rsvd : 3;
  } Bits;
  UINTX Data;
} PM_SYNC_STATE_HYS_PMC_PCI_MMR_STRUCT;
#endif // ASM_INC

#define PM_SYNC_MODE_PMC_PCI_MMR_REG                       0x000000D4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Each bit of this field is associated with a single PM_SYNC message.[br]
    // When bit X is set to '1', the corresponding event is enabled to be sent over the
    // PM_SYNC pin.  I.e. if bit 6 is set to '1', event number 6 is enabled to be sent
    // over PM_SYNC.  See the [quote]PM_SYNC message numbering[quote] table for event
    // numbers.  The PM_SYNC_MSG_MODE bit will determine whether that event will be as
    // one input to an OR gate driving a level PM_SYNC pin, or as a source of message
    // generation via the serial messaging protocol on the PM_SYNC pin.  See the [quote]C-states[quote]
    // section later in this chapter for more information.[br] 
    // When this bit is a '0', the corresponding message will not be sent when in serial
    // messaging mode/the contribution to PM_SYNC will be forced to '0' in level mode.[br]
    // This field is not writeable when PM_SYNC_LOCK=1.
    // 
    // Bits[31:0], RW/L, default = 0x600004C0
    //
    UINTX pm_sync_msg_en : 32;
  } Bits;
  UINTX Data;
} PM_SYNC_MODE_PMC_PCI_MMR_STRUCT;
#endif // ASM_INC

#define SRCCR_CFG_PMC_PCI_MMR_REG                          0x000000DC
#ifndef ASM_INC
typedef union {
  struct {
    //
    // This field determines which individuation SRCnCLKRQ# pins are enabled to feed
    // the various PM_SYNC states (FAST_RING, etc.).  Note that after this initial qualification,
    // the resulting combined indication is still subject to the standard routing bits
    // to determine which (if any) PM_SYNC states will actually be asserted on behalf
    // of SRCnCLKRQ# (treated as a [quote]clock wake[quote] - see the SRCCR_CW_<state>
    // bits).[br] 
    // Each bit of this field is associated with a single SRCnCLKRQ# pin, e.g.:[br]
    //   - bit 0: SRC0CLKRQ#[br]
    //   - bit 13: SRC13CLKRQ#
    // 
    // Bits[13:0], RW, default = 0x0
    //
    UINTX en_srccr_pm_sync : 14;
    //
    // Keep reserved to support possible SRCnCLKRQ# expansion in the future (currently
    // implementing SRC[13:0]CLKRQ#). 
    // 
    // Bits[15:14], RO, default = 0x0
    //
    UINTX rsvd_15_14 : 2;
    //
    // The SRCnCLKRQ# inputs to the various PM_SYNC states (FAST_RING, etc.) are handled
    // in an edge-sensitive manner.  However, the time between a PCIe device asserting
    // its CLKREQ# to the actual resulting traffic becoming visible to the PCH could
    // be significant (much longer than the general PM_SYNC state hysteresis).  In order
    // to span this gap and prevent the CPU from popping back down to a deep C-state
    // during the interval, a dedicated hysteresis timer is provided to cover SRCnCLKRQ#.[br]
    // Note that one hysteresis timer covers all SRCnCLKRQ# pins, meaning that an asserting
    // [falling] edge on any of the pins will reload and activite the timer with a fresh
    // count.  This field is encoded with 10us granularity:[br] 
    //   00h: no hysteresis will be applied (default)[br]
    //   3Eh: 620 us of hysteresis (max allowed)[br]
    //   3Fh: illegal value (SW must not write)
    // 
    // Bits[21:16], RW, default = 0x0
    //
    UINTX srccr_hys : 6;
    //
    // N/A
    // 
    // Bits[31:22], RO, default = 0x0
    //
    UINTX rsvd : 10;
  } Bits;
  UINTX Data;
} SRCCR_CFG_PMC_PCI_MMR_STRUCT;
#endif // ASM_INC

#define PM_CFG3_PMC_PCI_MMR_REG                            0x000000E0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Not for EDS: These bits are placeholders to make a late ECO easier, and should
    // not be included in the EDS unless a particular use is assigned.[br] 
    // 
    // Bits[3:0], RW, default = 0x0
    //
    UINTX host_misc_core_cfg : 4;
    //
    // N/A
    // 
    // Bits[7:4], RO, default = 0x0
    //
    UINTX rsvd_3 : 4;
    //
    // Not for EDS: These bits are placeholders to make a late ECO easier, and should
    // not be included in the EDS unless a particular use is assigned.[br] 
    // 
    // Bits[11:8], RW, default = 0x0
    //
    UINTX host_misc_sus_cfg : 4;
    //
    // N/A
    // 
    // Bits[15:12], RO, default = 0x0
    //
    UINTX rsvd_2 : 4;
    //
    // When set to 1, PMC will keep SLP_WLAN# high in deep-Sx to enable WoWLAN.  
    // 				[br]Note:
    // 				[br](1)	This policy bit will be applied for deep-Sx entry from S3, S4 and
    // S5.  
    // 				[br](2)	This bit does not affect SLP_WLAN# behaviour in Sx after G3 or after
    // a global reset   
    // 				[br](3)	HOST_WLAN_PP_EN must be set when this bit is set.
    // 
    // Bits[16:16], RW, default = 0x0
    //
    UINTX dsx_wlan_pp_en : 1;
    //
    // This policy bit is set by Host software when it desires the wireless LAN PHY to
    // be powered in Sx power states for wakes over wireless LAN (WoWLAN).  See the SLP_WLAN#
    // sub-section later in this chapter for additional information. 
    // 
    // Bits[17:17], RW, default = 0x0
    //
    UINTX host_wlan_pp_en : 1;
    //
    // Not for EDS: These bits are placeholders to make a late ECO easier, and should
    // not be included in the EDS unless a particular use is assigned.[br] 
    // 
    // Bits[21:18], RW, default = 0x0
    //
    UINTX host_misc_dsw_cfg : 4;
    //
    // N/A
    // 
    // Bits[23:22], RO, default = 0x0
    //
    UINTX rsvd_1 : 2;
    //
    // These bits are defined as follows:
    //           [br] 27:26 - Reserved
    //           [br]
    //           [br] 25:24 - GR_PFET_DUR_ON_DEF 
    //           [br] This field determines how long the PMC will wait between allowing
    // each power gateable IP to transition to 
    //                its reset default gated/ungated state during a global reset entry.
    //  This delay is applied only to the IPs 
    //                that are on by default.
    //           [br] Encoding:
    //           [br] 00b - 1us
    //           [br] 01b - 2us
    //           [br] 10b - 5us
    //           [br] 11b - 20us
    //           [br] This field is not writeable when PMCR.PGD_LOCK=1.
    //           [br] Not for EDS: Keep this field reserved in the EDS unless it is needed
    // for a workaround 
    //           [br] 
    //           [br] Not for EDS: These bits are placeholders to make a late ECO easier,
    // and should not be included in the EDS unless a particular use is assigned.[br]
    // 
    // Bits[27:24], RW/L, default = 0x0
    //
    UINTX host_misc_rtc_cfg : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:28], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 4;
  } Bits;
  UINTX Data;
} PM_CFG3_PMC_PCI_MMR_STRUCT;
#endif // ASM_INC

#define PM_DOWN_PPB_CFG_PMC_PCI_MMR_REG                    0x000000E4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // When this bit is set, this entire register is locked.
    // 
    // Bits[0:0], RW/L, default = 0x0
    //
    UINTX ppb_cfg_lock : 1;
    //
    // 1=PMC regulates PCH power budget by initiating the respective thermal throttling
    // state as defined by bits 31:16 of this register when receiving a new PCH Power
    // Budget request from PMC FW as indicated by  NEWPCHPBREQ  and PCHPBREQ.[br] 
    // 0=PMC does not regulate the PCH power budget according to PPB to TSTATE mapping.[br]
    // Note: If Fanless IO Throttling Disable Fuse (FLESS_IO_THROT_DIS) is '1', hardware
    // will always see '0' as an output from this register. BIOS reading this register
    // should always return the correct value. 
    // 
    // Bits[1:1], RW/L, default = 0x0
    //
    UINTX ppb_tstate_en : 1;
    //
    // N/A
    // 
    // Bits[15:2], RO, default = 0x0
    //
    UINTX rsvd_15_2 : 14;
    //
    // The value in this register is the T-state requested by PMC HW when it receives
    // a PCHPBREQ value of 0 from the PMC FW.[br] 
    // 
    // Bits[17:16], RW/L, default = 0x0
    //
    UINTX ppb0_tstate : 2;
    //
    // The value in this register is the T-state requested by PMC HW when it receives
    // a PCHPBREQ value of 1 from the PMC FW. 
    // 
    // Bits[19:18], RW/L, default = 0x0
    //
    UINTX ppb1_tstate : 2;
    //
    // The value in this register is the T-state requested by PMC HW when it receives
    // a PCHPBREQ value of 2 from the PMC FW. 
    // 
    // Bits[21:20], RW/L, default = 0x0
    //
    UINTX ppb2_tstate : 2;
    //
    // The value in this register is the T-state requested by PMC HW when it receives
    // a PCHPBREQ value of 3 from the PMC FW. 
    // 
    // Bits[23:22], RW/L, default = 0x0
    //
    UINTX ppb3_tstate : 2;
    //
    // The value in this register is the T-state requested by PMC HW when it receives
    // a PCHPBREQ value of 4 from the PMC FW. 
    // 
    // Bits[25:24], RW/L, default = 0x0
    //
    UINTX ppb4_tstate : 2;
    //
    // The value in this register is the T-state requested by PMC HW when it receives
    // a PCHPBREQ value of 5 from the PMC FW. 
    // 
    // Bits[27:26], RW/L, default = 0x0
    //
    UINTX ppb5_tstate : 2;
    //
    // The value in this register is the T-state requested by PMC HW when it receives
    // a PCHPBREQ value of 6 from the PMC FW. 
    // 
    // Bits[29:28], RW/L, default = 0x0
    //
    UINTX ppb6_tstate : 2;
    //
    // The value in this register is the T-state requested by PMC HW when it receives
    // a PCHPBREQ value of 7 from the PMC FW. 
    // 
    // Bits[31:30], RW/L, default = 0x0
    //
    UINTX ppb7_tstate : 2;
  } Bits;
  UINTX Data;
} PM_DOWN_PPB_CFG_PMC_PCI_MMR_STRUCT;
#endif // ASM_INC

#define PM_CFG4_PMC_PCI_MMR_REG                            0x000000E8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // This value is used in the CPU I/O VR  ramp timer and has a 10us granularity. 
    //           [br]000h = 0us (reserved)
    //           [br]001h = 10us
    //           [br]002h = 20us
    //           [br]003h = 30us
    //           [br]...
    //           [br]1FFh = 5.1ms
    // 
    // Bits[8:0], RW, default = 0x0
    //
    UINTX cpu_iovr_ramp_dur : 9;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[11:9], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 3;
    //
    // This field determines the time from when SLP_S0# de-asserts until the CPUs VccST
    // gated rail has ramped back up after being gated in C10.  This timer starts when
    // SLP_S0# asserts and has the effect of delaying any transactions on PM_SYNC until
    // it expires. 
    // 			[br]
    // 			[br]Encoding:
    // 			[br]0h  0us (disabled)
    // 			[br]1h  30us
    // 			[br]2h  35us
    // 			[br]3h  40us
    // 			[br]...
    // 			[br]Fh  100us
    // 			[br]Note: If the VccST bit in the CPU shutdown overrides virtual register is
    // set to 1, the VccST gated domain will never be shut down (SLP_S0# will remain
    // at 1 in C10).  And so this timer will never start, allowing the PMC to send PM_SYNC
    // traffic without waiting for this timer during C10 exit. 
    // 
    // Bits[15:12], RW, default = 0x8
    //
    UINTX vccst_tmr : 4;
    //
    // This field determines how long the PMC will wait between allowing each power gateable
    // IP 
    //               to transition to its reset default gated/ungated state during a
    // global reset entry. 
    //           [br]
    //           [br]Encoding:
    //           [br]00b - 1us
    //           [br]01b - 2us
    //           [br]10b - 5us
    //           [br]11b - 20us
    //           [br]
    //           [br]Not for EDS: Keep this field reserved in the EDS unless it is needed
    // for a workaround 
    // 
    // Bits[17:16], RW/L, default = 0x2
    //
    UINTX gr_pfet_dur : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[29:18], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 12;
    //
    // If this bit is 1, dynamic power gating of the USB2 PHY SUS well is enabled.	Note:
    // This bit prevents HW from initiating power gating entry.[br]   
    // 	  However, the USB2 PHY SUS well is power gated by default while in Sx after
    // global_rst_b assertion.  So HW will not spontaneously exit power gating while
    // in Sx just because this bit is 0. 
    // 
    // Bits[30:30], RW, default = 0x0
    //
    UINTX u2_phy_pg_en : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:31], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 1;
  } Bits;
  UINTX Data;
} PM_CFG4_PMC_PCI_MMR_STRUCT;
#endif // ASM_INC

#define CPU_EPOC_PMC_PCI_MMR_REG                           0x000000EC
#ifndef ASM_INC
typedef union {
  struct {
    //
    // N/A
    // 
    // Bits[1:0], RW, default = 0x0
    //
    UINTX epoc_data_1_0 : 2;
    //
    // This bit is controlled via JTAG tap (PMC space).
    // 
    // Bits[2:2], RO/V, default = 0x0
    //
    UINTX epoc_data_2 : 1;
    //
    // N/A
    // 
    // Bits[7:3], RW, default = 0x0
    //
    UINTX epoc_data_7_3 : 5;
    //
    // These bits come from PMC soft straps reserved for straps that must be available
    // to the CPU prior to PLTRST# de-assertion. 
    // 			[br]Note: Any straps that only need to be available after OPI is up should
    // be sent as part of the strap set message from SPI instead of being reserved in
    // the PMC straps, defined in EPOC, and sent by the PMC. 
    // 
    // Bits[11:8], RO/V, default = 0x0
    //
    UINTX epoc_data_11_8 : 4;
    //
    // N/A
    // 
    // Bits[31:12], RO, default = 0x0
    //
    UINTX rsvd_31_12 : 20;
  } Bits;
  UINTX Data;
} CPU_EPOC_PMC_PCI_MMR_STRUCT;
#endif // ASM_INC

#define ADR_EN_PMC_PCI_MMR_REG                             0x000000F0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // If this bit is a '1' and the ADR_DIS fuse is a '0', PCH support for Automatic
    // DIMM Self-Refresh is enabled.  The other bits in this register determine which
    // individual reset sources will be included.[br] 
    // Note: This bit must not be set to '1' until PM_SYNC has been fully configured
    // to convey the global reset warning to the CPU. 
    // 
    // Bits[0:0], RW/V, default = 0x0
    //
    UINTX adr_feat_en : 1;
    //
    // This bit is Read Only 0.  LT RESET is never included as a source in the ADR feature.
    // 
    // Bits[1:1], RO, default = 0x0
    //
    UINTX ltreset_adr_en : 1;
    //
    // If this bit is set to '1', all PMC firmware-initiated global reset sources are
    // included in the ADR feature.  The specific sources are:[br] 
    //   - SMBUS slave unconditional power down message[br]
    //   - CF9 write or shutdown special cycle with policy set for global reset[br]
    //   - Host partition reset entry timeout[br]
    //   - Sx entry timeout[br]
    //   - any Host partition reset triggered with the [quote]Promote Host Partition
    // Reset to Global Reset[quote] policy bit set to 1[br] 
    //   - Manufacturing Test Permit (MTP) timer expiration[br]
    // Note: The default value for this bit was chosen to be '1' because any FW-handled
    // global reset source is not considered to be time-critical. 
    // 
    // Bits[2:2], RW/V, default = 0x1
    //
    UINTX pmcgbl_adr_en : 1;
    //
    // If this bit is set to '1', the CPU THERMTRIP# global reset source is included
    // in the ADR feature.[br] 
    // Note: The default value for this bit was chosen to be '0' because this reset source
    // is considered to be time-critical. 
    // 
    // Bits[3:3], RW/V, default = 0x0
    //
    UINTX cputhrm_adr_en : 1;
    //
    // If this bit is set to '1', the PCH internal thermal sensor catastrophic temperature
    // event global reset source is included in the ADR feature.[br] 
    // Note: The default value for this bit was chosen to be '0' because this reset source
    // is considered to be time-critical. 
    // 
    // Bits[4:4], RW/V, default = 0x0
    //
    UINTX pchthrm_adr_en : 1;
    //
    // If this bit is set to '1', the Power Button Override global reset source is included
    // in the ADR feature.[br] 
    // Note: The default value for this bit was chosen to be '1' because this reset source
    // is not considered to be time-critical. 
    // 
    // Bits[5:5], RW/V, default = 0x1
    //
    UINTX pbo_adr_en : 1;
    //
    // If this bit is set to '1', the ME-Initiated Power Button Override global reset
    // source is included in the ADR feature.[br] 
    // Note: The default value for this bit was chosen to be '1' because this reset source
    // is not considered to be time-critical. 
    // 
    // Bits[6:6], RW/V, default = 0x1
    //
    UINTX mepbo_adr_en : 1;
    //
    // If this bit is set to '1', the ME firmware watchdog timer global reset source
    // is included in the ADR feature.[br] 
    // Note: The default value for this bit was chosen to be '1' because this reset source
    // is not considered to be time-critical. 
    // 
    // Bits[7:7], RW/V, default = 0x1
    //
    UINTX mewdt_adr_en : 1;
    //
    // If this bit is set to '1', the ME-initiated global reset source is included in
    // the ADR feature.[br] 
    // Note: The default value for this bit was chosen to be '1' because this reset source
    // is not considered to be time-critical. 
    // 
    // Bits[8:8], RW/V, default = 0x1
    //
    UINTX megbl_adr_en : 1;
    //
    // If this bit is set to '1', the CPU thermal watchdog timer global reset source
    // is included in the ADR feature.[br] 
    // Note: The default value for this bit was chosen to be '0' because this reset source
    // can only occur prior to host_prim_rst_b deassertion, at which time the ADR_EN
    // bit will always be '0'. 
    // 
    // Bits[9:9], RW/V, default = 0x0
    //
    UINTX ctwdt_adr_en : 1;
    //
    // If this bit is set to '1', the PMC firmware watchdog timer global reset source
    // is included in the ADR feature.[br] 
    // Note: The default value for this bit was chosen to be '1' because this reset source
    // is not considered to be time-critical. 
    // 
    // Bits[10:10], RW/V, default = 0x1
    //
    UINTX pmcwdt_adr_en : 1;
    //
    // If this bit is set to '1', the ME uncorrectable SRAM error global reset source
    // is included in the ADR feature.[br] 
    // Note: The default value for this bit was chosen to be '1' because this reset source
    // is not considered to be time-critical. 
    // 
    // Bits[11:11], RW/V, default = 0x1
    //
    UINTX me_uerr_adr_en : 1;
    //
    // If this bit is set to '1', the SYS_PWROK failure global reset source is included
    // in the ADR feature.[br] 
    // Note: The default value for this bit was chosen to be '0' because this reset source
    // is considered to be time-critical. 
    // 
    // Bits[12:12], RW/V, default = 0x0
    //
    UINTX syspwr_adr_en : 1;
    //
    // If this bit is set to '1', the Over-Clocking Watchdog Timer global reset source
    // is included in the ADR feature.[br] 
    // Note: The default value for this bit was chosen to be '1' because this reset source
    // is not considered to be time-critical. 
    // 
    // Bits[13:13], RW/V, default = 0x1
    //
    UINTX ocwdt_adr_en : 1;
    //
    // If this bit is set to '1', the PMC SUS RAM parity error global reset source is
    // included in the ADR feature.[br] 
    // Note: The default value for this bit was chosen to be '0' because this reset source
    // is considered to be time-critical. 
    // 
    // Bits[14:14], RW/V, default = 0x0
    //
    UINTX pmc_parerr_adr_en : 1;
    //
    // N/A
    // 
    // Bits[27:15], RO, default = 0x0
    //
    UINTX rsvd27_15 : 13;
    //
    // If this bit is set to '1', the ADR_DIS fuse is a 0, and the ADR_FEAT_EN bit is
    // 1, PMC FW will set the ADR_RST_STS bit upon receipt of the Reset_Warn_Ack DMI
    // message. 
    // 
    // Bits[28:28], RW, default = 0x1
    //
    UINTX hpr_adr_en : 1;
    //
    // If this bit is set to '1', a Global Reset will be generated when the ADR Timer
    // expires after being triggered by the ADR GPIO selected in the ADR_GPIO_SEL field
    // and the following are true: ADR_DIS fuse is a '0 and ADR_FEAT_EN is a 1.[br] 
    // If this bit is cleared, the ADR GPIO may still be enabled to affect the PM_SYNC
    // pin, but on its own it will not trigger a Global Reset.[br] 
    // Note: Unlike the *_ADR_EN bits in this register, this enable bit is not required
    // for this source to trigger the warning to the CPU over PM_SYNC.  This bit only
    // impacts whether or not this source will actually trigger a global reset. 
    // 
    // Bits[29:29], RW, default = 0x1
    //
    UINTX adr_gpio_rst_en : 1;
    //
    // This field selects which PM_SYNC GPIO state will be a source of ADR.  This input
    // may also be a source of Global Reset based on ADR_GPIO_RST_EN..[br] 
    // Encodings:[br]
    //   - 00: GPIO_A[br]
    //   - 01: GPIO_B[br]
    //   - 10: GPIO_C[br]
    //   - 11: GPIO_D[br]
    // Programming Restriction: The PCH only supports use of CPU_GP_0 as the board-level
    // trigger for ADR.  Therefore, this field must be programmed to the PM_SYNC GPIO
    // state which is assigned to CPU_GP_0 in the PM_SYNC_MISC_CFG register (which will
    // be GPIO_B or GPIO_C). 
    // 
    // Bits[31:30], RW, default = 0x0
    //
    UINTX adr_gpio_sel : 2;
  } Bits;
  UINTX Data;
} ADR_EN_PMC_PCI_MMR_STRUCT;
#endif // ASM_INC

#define PM_SYNC_MODE_C0_PMC_PCI_MMR_REG                    0x000000F4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Each bit of this field is associated with a single PM_SYNC message.[br]
    // When bit X is set to '1', the corresponding event is enabled to be sent over the
    // PM_SYNC pin while in C0.  I.e. if bit 6 is set to '1', event number 6 is enabled
    // to be sent over PM_SYNC.  See the [quote]PM_SYNC message Numbering[quote] table
    // for event numbers.  The PM_SYNC_MSG_MODE bit will determine whether that event
    // will be as one input to an OR gate driving a level PM_SYNC pin, or as a source
    // of message generation via the serial messaging protocol on the PM_SYNC pin.  See
    // the [quote]C-states[quote] section later in this chapter for more information.[br]
    // When this bit is a '0', the corresponding message will not be sent when in serial
    // messaging mode/the contribution to PM_SYNC will be forced to '0' in level mode.[br]
    // This field is not writeable when PM_SYNC_LOCK=1.
    // 
    // Bits[31:0], RW/L, default = 0x600004C0
    //
    UINTX pm_sync_msg_c0_en : 32;
  } Bits;
  UINTX Data;
} PM_SYNC_MODE_C0_PMC_PCI_MMR_STRUCT;
#endif // ASM_INC

#define SYSTIMCT_PMC_PCI_MMR_REG                           0x000000F8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write of [quote]1[quote] to this bit triggers time capture in all components supporting
    // this feature. Hardware clears this register to indicate that time capture is complete.[br]
    // Once the bit is set to [quote]1[quote], subsequent writes of [quote]0[quote] or
    // [quote]1[quote] have no effect until the bit is cleared by hardware.[br] 
    // Please refer to the Audio Time Synchronization section for more details on Audio
    // Synchronization and for a list of consumers of the [quote]capture[quote] signal
    // from PMC.[br] 
    // Implementation note: Once the bit is written to [quote]1[quote]. hardware should
    // keep the [quote]capture[quote] signal asserted high for 16 PMC clocks, then keep
    // the signal deasserted low for another 16 PMC clocks and then clear this register
    // bit. 
    // 
    // Bits[0:0], RW/1S/V, default = 0x0
    //
    UINTX capture_now : 1;
    //
    // Reserved
    // 
    // Bits[31:1], RO, default = 0x0
    //
    UINTX rsvd : 31;
  } Bits;
  UINTX Data;
} SYSTIMCT_PMC_PCI_MMR_STRUCT;
#endif // ASM_INC

#define ACPI_TMR_CTL_PMC_PCI_MMR_REG                       0x000000FC
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Writing a 1 to this bit will clear the ACPI Timer to all 0s.  Hardware will automatically
    // clear the bit back to '0' once the timer clear operation has completed.[br] 
    // Writing a 0 to this bit has no effect.[br]
    // Implementation Note: The PCH must be capable of honoring this bit even while ACPI_TIM_DIS=1.
    // 
    // Bits[0:0], RW/1S/V, default = 0x0
    //
    UINTX acpi_tim_clr : 1;
    //
    // This bit determines whether the ACPI Timer is enabled to run.  Note that even
    // when enabled, the timer only runs during S0.[br] 
    //   - 0: ACPI Timer is enabled (default)[br]
    //   - 1: ACPI Timer is disabled (halted at the current value)
    // 
    // Bits[1:1], RW, default = 0x0
    //
    UINTX acpi_tim_dis : 1;
    //
    // N/A
    // 
    // Bits[31:2], RO, default = 0x0
    //
    UINTX rsvd : 30;
  } Bits;
  UINTX Data;
} ACPI_TMR_CTL_PMC_PCI_MMR_STRUCT;
#endif // ASM_INC

#define VR_MISC_CTL_PMC_PCI_MMR_REG                        0x00000100
#ifndef ASM_INC
typedef union {
  struct {
    //
    // SW can program this register to reflect the actual voltage of the core power rail
    // if the system is not using the PCH VID control mechanism.  The accurate voltage
    // is required for PCH power reporting.[br]000: 1.0V[br]001: 0.95V[br]010: 0.90V[br]011:
    // 0.85V[br]100-111: Reserved[br][br]The value in these bits is only used by PCH
    // HW/FW when bit 3 of this register is set.   
    // 
    // Bits[2:0], RW, default = 0x0
    //
    UINTX vidsov : 3;
    //
    // When set to 1 the bits in 2:0 are valid.
    // 
    // Bits[3:3], RW, default = 0x0
    //
    UINTX vidsoven : 1;
    //
    // Primary	Reserved (RSVD):
    // 
    // Bits[7:4], RO, default = 0x0
    //
    UINTX rsvd4 : 4;
    //
    // This field reports the core voltage ID as determined during manufacturing test
    // and blown into fuses.[br]00 = 0.95V[br]01 = 0.90V[br]10 = 0.85V[br]11 = 0.80V[br]These
    // bits are only valid when CORE_VR_ALLOWED_FUSE is 1. 
    // 
    // Bits[9:8], RO/V, default = 0x0
    //
    UINTX core_vid_fuse : 2;
    //
    // Primary	Reserved (RSVD):
    // 
    // Bits[11:10], RO, default = 0x0
    //
    UINTX rsvd3 : 2;
    //
    // This field reports the Separate Core VR[br]support fuse as determined during[br]manufacturing
    // test and blown into a fuse.[br]11  VCC_PRIM_0P85 Low Voltage Mode capability is
    // Disabled[br]0 = PCH does not support a separate core VR.[br]Core VID fuses are
    // invalid.[br]1 = PCH supports a separate core VR[br]programmed to the voltage output
    // as[br]described by the Core VID fuses. 
    // 
    // Bits[12:12], RO/V, default = 0x0
    //
    UINTX core_vr_allowed_fuse : 1;
    //
    // Primary	Reserved (RSVD):
    // 
    // Bits[15:13], RO, default = 0x0
    //
    UINTX rsvd2 : 3;
    //
    // This bit reflects the live values on the[br]VCC_PRIM_1P0 Low Voltage Mode Disable
    // fuse:[br]'1' - VCC_PRIM_1P0 Low Voltage Mode[br]capability is Disabled[br]'0'
    // - VCC_PRIM_1P0 Low Voltage Mode (0.9V)[br]capability is Enabled 
    // 
    // Bits[16:16], RO/V, default = 0x0
    //
    UINTX vcc_prim_1p0_lvmdis : 1;
    //
    // Primary	Reserved (RSVD):
    // 
    // Bits[17:17], RO, default = 0x0
    //
    UINTX rsvd1 : 1;
    //
    // This bit reflects the live values on the[br]VCC_PRIM_0P85 Low Voltage Mode Target
    // fuses:[br]11  VCC_PRIM_0P85 Low Voltage Mode capability is Disabled[br]10  0.80V[br]01
    //  0.75V[br]00  0.7V[br] 
    // 
    // Bits[19:18], RO/V, default = 0x0
    //
    UINTX vcc_prim_0p85_lvmt : 2;
    //
    // Primary	Reserved (RSVD):
    // 
    // Bits[31:20], RO, default = 0x0
    //
    UINTX rsvd : 12;
  } Bits;
  UINTX Data;
} VR_MISC_CTL_PMC_PCI_MMR_STRUCT;
#endif // ASM_INC

#define TSC_ALARM_LO_PMC_PCI_MMR_REG                       0x00000110
#ifndef ASM_INC
typedef union {
  struct {
    //
    // This field contains bits 31:0 of the last TSC alarm value received from the CPU.
    // 
    // Bits[31:0], RO/V, default = 0x0
    //
    UINTX tsc_alarm_val_lo : 32;
  } Bits;
  UINTX Data;
} TSC_ALARM_LO_PMC_PCI_MMR_STRUCT;
#endif // ASM_INC

#define TSC_ALARM_HI_PMC_PCI_MMR_REG                       0x00000114
#ifndef ASM_INC
typedef union {
  struct {
    //
    // This field contains bits 63:32 of the last TSC alarm value received from the CPU.
    // 
    // Bits[31:0], RO/V, default = 0x0
    //
    UINTX tsc_alarm_val_hi : 32;
  } Bits;
  UINTX Data;
} TSC_ALARM_HI_PMC_PCI_MMR_STRUCT;
#endif // ASM_INC

#define GPIO_CFG_PMC_PCI_MMR_REG                           0x00000120
#ifndef ASM_INC
typedef union {
  struct {
    //
    // This register assigns a specific GPIO Group to the ACPI GPE0[31:0].
    //          [br] 0h = reserved[7:0]&GPP_A[23:0]
    //          [br] 1h = reserved[7:0]&GPP_B[23:0]
    //          [br] 2h = reserved[7:0]&GPP_C[23:0]
    //          [br] 3h = reserved[7:0]&GPP_D[23:0]
    //          [br] 4h = reserved[7:0]&GPP_E[23:0]
    //          [br] 5h = reserved[7:0]&GPP_F[23:0]
    //          [br] 6h = reserved[23:0]&GPP_G[7:0]
    //          [br] 7h = reserved[20:0]&GPD[11:0]
    // 
    // Bits[2:0], RW, default = 0x2
    //
    UINTX gpe0_dw0 : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[3:3], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 1;
    //
    // This register assigns a specific GPIO Group to the ACPI GPE0[63:32].
    //          [br] 0h = reserved[7:0]&GPP_A[23:0]
    //          [br] 1h = reserved[7:0]&GPP_B[23:0]
    //          [br] 2h = reserved[7:0]&GPP_C[23:0]
    //          [br] 3h = reserved[7:0]&GPP_D[23:0]
    //          [br] 4h = reserved[7:0]&GPP_E[23:0]
    //          [br] 5h = reserved[7:0]&GPP_F[23:0]
    //          [br] 6h = reserved[23:0]&GPP_G[7:0]
    //          [br] 7h = reserved[20:0]&GPD[11:0]
    // 
    // Bits[6:4], RW, default = 0x3
    //
    UINTX gpe0_dw1 : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:7], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 1;
    //
    // This register assigns a specific GPIO Group to the ACPI GPE0[96:64].
    //          [br] 0h = reserved[7:0]&GPP_A[23:0]
    //          [br] 1h = reserved[7:0]&GPP_B[23:0]
    //          [br] 2h = reserved[7:0]&GPP_C[23:0]
    //          [br] 3h = reserved[7:0]&GPP_D[23:0]
    //          [br] 4h = reserved[7:0]&GPP_E[23:0]
    //          [br] 5h = reserved[7:0]&GPP_F[23:0]
    //          [br] 6h = reserved[23:0]&GPP_G[7:0]
    //          [br] 7h = reserved[20:0]&GPD[11:0]
    // 
    // Bits[10:8], RW, default = 0x4
    //
    UINTX gpe0_dw2 : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:11], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 21;
  } Bits;
  UINTX Data;
} GPIO_CFG_PMC_PCI_MMR_STRUCT;
#endif // ASM_INC

#define GBLRST_CAUSE0_PMC_PCI_MMR_REG                      0x00000124
#ifndef ASM_INC
typedef union {
  struct {
    //
    // N/A
    // 
    // Bits[0:0], RO, default = 0x0
    //
    UINTX rsvd_0_0 : 1;
    //
    // This bit is set to '1' by hardware when a global reset is triggered by a power
    // button override (i.e. an assertion of the PWRBTN# pin for 5 seconds). 
    // 
    // Bits[1:1], RW/1C/V, default = 0x0
    //
    UINTX pb_ovr : 1;
    //
    // This bit is set to '1' by hardware when a global reset is triggered due to an
    // uncorrectable parity error on a data read from one of the PMC SUS well register
    // files. 
    // 
    // Bits[2:2], RW/1C/V, default = 0x0
    //
    UINTX pmc_unc_err : 1;
    //
    // This bit is set to '1 by hardware when a global reset is triggered by a catastrophic
    // temperature event from the ICH internal thermal sensor. 
    // 
    // Bits[3:3], RW/1C/V, default = 0x0
    //
    UINTX ich_cat_tmp : 1;
    //
    // This bit is set to '1' by hardware when a global reset is triggered by an ME FW
    // write of '1' to GENCTL.[quote]ME-Initiated Power Button Override[quote]. 
    // 
    // Bits[4:4], RW/1C/V, default = 0x0
    //
    UINTX me_pbo : 1;
    //
    // This bit is set to '1' by hardware when a global reset is triggered by a CPU thermal
    // trip event (i.e. an assertion of the THRMTRIP# pin). 
    // 
    // Bits[5:5], RW/1C/V, default = 0x0
    //
    UINTX cpu_trip : 1;
    //
    // This bit is set to '1' by hardware when a global reset is triggered by an ME FW
    // write of 1's to both GENCTL.[quote]ME-Partition Reset[quote] and GENCTL.[quote]ME-Initiated
    // Host Reset With Power Cycle[quote] in the same write cycle (this is ME FW's method
    // of requesting a global reset). 
    // 
    // Bits[6:6], RW/1C/V, default = 0x0
    //
    UINTX me_gbl : 1;
    //
    // This bit is set to '1' by hardware when a global reset is triggered by an LTRESET#
    // assertion with LT_E2STS.LT_RESET_POLICY = 1. 
    // 
    // Bits[7:7], RW/1C/V, default = 0x0
    //
    UINTX ltrst_pol1 : 1;
    //
    // This bit is set to '1' by hardware when a global reset is triggered by the second
    // expiration of the PMC firmware watchdog timer. 
    // 
    // Bits[8:8], RW/1C/V, default = 0x0
    //
    UINTX pmc_wdt : 1;
    //
    // This bit is set to '1' by hardware when a global reset is triggered by the second
    // expiration of the ME firmware watchdog timer. 
    // 
    // Bits[9:9], RW/1C/V, default = 0x0
    //
    UINTX me_wdt : 1;
    //
    // This bit is set to '1' by hardware when a global reset is triggered by a request
    // from PMC firmware (i.e. a write of '1' to the GBLRST_CTL.TRIG_GBL bit). 
    // 
    // Bits[10:10], RW/1C/V, default = 0x0
    //
    UINTX pmc_fw : 1;
    //
    // This bit is set to '1' by hardware when a global reset is triggered by an unexpected
    // loss of PCH_PWROK.  FW arms this global reset source via GBLRST_CTL.EN_PCHPWR_FLR.
    // 
    // Bits[11:11], RW/1C/V, default = 0x0
    //
    UINTX pchpwr_flr : 1;
    //
    // This bit is set to '1' by hardware when a global reset is triggered by an unexpected
    // loss of SYS_PWROK.  FW arms this global reset source via GBLRST_CTL.EN_SYSPWR_FLR.
    // 
    // Bits[12:12], RW/1C/V, default = 0x0
    //
    UINTX syspwr_flr : 1;
    //
    // This bit is set to '1' by hardware when a global reset is triggered by an unexpected
    // loss of ASW power (i.e. a deassertion of APWROK at an unexpected time). 
    // 
    // Bits[13:13], RW/1C/V, default = 0x0
    //
    UINTX asw_flr : 1;
    //
    // N/A
    // 
    // Bits[15:14], RW/1C/V, default = 0x0
    //
    UINTX rsvd_15_14 : 2;
    //
    // This bit is set to '1' by hardware when a global reset is triggered by the expiration
    // of the CPU Thermal Runaway Watchdog Timer. 
    // 
    // Bits[16:16], RW/1C/V, default = 0x0
    //
    UINTX cpu_thrm_wdt : 1;
    //
    // This bit is set to '1' by hardware when a global reset is triggered by ME hardware
    // due to the detection of an uncorrectable ECC or parity error on a data read from
    // one of its SRAM s. 
    // 
    // Bits[17:17], RW/1C/V, default = 0x0
    //
    UINTX me_uncor_err : 1;
    //
    // This bit is set to '1' by hardware when a global reset is triggered by the assertion
    // of the GPIO assigned to ADR. 
    // 
    // Bits[18:18], RW/1C/V, default = 0x0
    //
    UINTX adr_gpio_rst : 1;
    //
    // This bit is set to '1  by hardware when a global reset is triggered by the expiration
    // of the over-clocking watchdog timer while running in a mode that does not have
    // ICC survivability impact (OC_WDT_ICCSURV=0). 
    // 
    // Bits[19:19], RW/1C/V, default = 0x0
    //
    UINTX oc_wdt_exp_no_iccsurv : 1;
    //
    // This bit is set to '1  by hardware when a global reset is triggered by the expiration
    // of the over-clocking watchdog timer while running in a mode that has ICC survivability
    // impact (OC_WDT_ICCSURV=1). 
    // 
    // Bits[20:20], RW/1C/V, default = 0x0
    //
    UINTX oc_wdt_exp_iccsurv : 1;
    //
    //  Shadow additional HW initiated GBLRST causes once they're added.
    // 
    // Bits[31:21], RO, default = 0x0
    //
    UINTX rsvd_31_21 : 11;
  } Bits;
  UINTX Data;
} GBLRST_CAUSE0_PMC_PCI_MMR_STRUCT;
#endif // ASM_INC

#define GBLRST_CAUSE1_PMC_PCI_MMR_REG                      0x00000128
#ifndef ASM_INC
typedef union {
  struct {
    //
    // If this bit is set, the cause of the previous global reset was an expiration of
    // the timer that runs during host partition resets. 
    // 
    // Bits[0:0], RW/1C/V, default = 0x0
    //
    UINTX host_reset_timeout : 1;
    //
    // If this bit is set, the cause of the previous global reset was an expiration of
    // the timer that runs during Sx entry. 
    // 
    // Bits[1:1], RW/1C/V, default = 0x0
    //
    UINTX sx_entry_timeout : 1;
    //
    // If this bit is set, the cause of the previous global reset was a host partition
    // reset that was promoted to a global reset either due to ME or host policy. 
    // 
    // Bits[2:2], RW/1C/V, default = 0x0
    //
    UINTX host_rst_prom : 1;
    //
    // If this bit is set, the cause of the previous global reset was a global reset
    // request received over the host SMBus interface. 
    // 
    // Bits[3:3], RW/1C/V, default = 0x0
    //
    UINTX hsmb_msg : 1;
    //
    // This bit is implemented in HW but currently not assigned to a usage in FW.[br]
    // Not For EDS: Leave this bit as reserved in the EDS unless it is required for a
    // workaround. 
    // 
    // Bits[4:4], RW/1C/V, default = 0x0
    //
    UINTX fw_gblrst_scratch4 : 1;
    //
    // If this bit is set, the cause of the previous global reset was ME FW setting the
    // power button override status. 
    // 
    // Bits[5:5], RW/1C/V, default = 0x0
    //
    UINTX me_set_pbo_sts : 1;
    //
    // This bit is implemented in HW but currently not assigned to a usage in FW.[br]
    // Not For EDS: Leave this bit as reserved in the EDS unless it is required for a
    // workaround. 
    // 
    // Bits[6:6], RW/1C/V, default = 0x0
    //
    UINTX fw_gblrst_scratch6 : 1;
    //
    // If this bit is set, the cause of the previous global reset was an expiration of
    // the MTP timer.[br] 
    // Not For EDS: Leave this bit as reserved in the EDS unless it is required for a
    // workaround. 
    // 
    // Bits[7:7], RW/1C/V, default = 0x0
    //
    UINTX mtp_timeout : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[15:8], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 8;
    //
    // Not For EDS: Leave this bit as reserved in the EDS unless it is required for a
    // workaround. 
    // 
    // Bits[23:16], RW/1C/V, default = 0x0
    //
    UINTX fw_gblrst_cause_1_7_0 : 8;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:24], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 8;
  } Bits;
  UINTX Data;
} GBLRST_CAUSE1_PMC_PCI_MMR_STRUCT;
#endif // ASM_INC

#define HPR_CAUSE0_PMC_PCI_MMR_REG                         0x0000012C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // N/A
    // 
    // Bits[0:0], RO, default = 0x0
    //
    UINTX rsvd_0_0 : 1;
    //
    // This bit will be set when Host software writes a value of 6h or Eh to the CF9
    // register. [br] 
    // Note: The [quote]shutdown[quote] special cycle from the CPU will also set this
    // bit. 
    // 
    // Bits[1:1], RO/V, default = 0x0
    //
    UINTX cf9_es : 1;
    //
    // Assertion of the SYS_RESET# pin after the 16 ms HW debounce.
    // 
    // Bits[2:2], RO/V, default = 0x0
    //
    UINTX sysrst_es : 1;
    //
    // LTRESET message received and the LT.RESET.POLICY bit = '0'.
    // 
    // Bits[3:3], RO/V, default = 0x0
    //
    UINTX ltrst : 1;
    //
    // N/A
    // 
    // Bits[5:4], RO, default = 0x0
    //
    UINTX rsvd_5_4 : 2;
    //
    // Host TCO watchdog timer reached zero for the second time.
    // 
    // Bits[6:6], RO/V, default = 0x0
    //
    UINTX tco_wdt : 1;
    //
    // N/A
    // 
    // Bits[7:7], RO, default = 0x0
    //
    UINTX rsvd_7_7 : 1;
    //
    // ME initiated host reset without power cycle.
    // 
    // Bits[8:8], RO/V, default = 0x0
    //
    UINTX mi_hr : 1;
    //
    // ME initiated host reset with power cycle.
    // 
    // Bits[9:9], RO/V, default = 0x0
    //
    UINTX mi_hrpc : 1;
    //
    // ME initiated host reset with power down.
    // 
    // Bits[10:10], RO/V, default = 0x0
    //
    UINTX mi_hrpd : 1;
    //
    // N/A
    // 
    // Bits[11:11], RO, default = 0x0
    //
    UINTX rsvd_11_11 : 1;
    //
    // SMBus initiated host partition reset without power cycle.
    // 
    // Bits[12:12], RO/V, default = 0x0
    //
    UINTX hsmb_hr : 1;
    //
    // SMBus initiated host partition reset with power cycle.
    // 
    // Bits[13:13], RO/V, default = 0x0
    //
    UINTX hsmb_hrpc : 1;
    //
    // Sleep entry attempted while LT secrets were present in memory.
    // 
    // Bits[14:14], RO/V, default = 0x0
    //
    UINTX lt_slperr : 1;
    //
    // N/A
    // 
    // Bits[31:15], RO, default = 0x0
    //
    UINTX rsvd_31_15 : 17;
  } Bits;
  UINTX Data;
} HPR_CAUSE0_PMC_PCI_MMR_STRUCT;
#endif // ASM_INC

#define LAT_LIM_RES_0_PMC_PCI_MMR_REG                      0x00000130
#ifndef ASM_INC
typedef union {
  struct {
    //
    // This field contains the amount of time (in 100us granularity) for the corresponding
    // 0/1/2 counter in the LATENCY_LIMIT_CONTROL register that the appropriate counter
    // is limiting the memory LTR request to the CPU.[br] 
    // 			  Note that this counter can wrap and that should not be of any concern. This
    // register will reset to 0 anytime the corresponding enable for the register transitions
    // from a 0->1.  Note that on a 1->0 transition, the counter should hold its previous
    // value 
    // 
    // Bits[31:0], RO/V, default = 0x0
    //
    UINTX llr0 : 32;
  } Bits;
  UINTX Data;
} LAT_LIM_RES_0_PMC_PCI_MMR_STRUCT;
#endif // ASM_INC

#define LAT_LIM_RES_1_PMC_PCI_MMR_REG                      0x00000134
#ifndef ASM_INC
typedef union {
  struct {
    //
    // This field contains the amount of time (in 100us granularity) for the corresponding
    // 0/1/2 counter in the LATENCY_LIMIT_CONTROL register that the appropriate counter
    // is limiting the memory LTR request to the CPU.[br] 
    // 			  Note that this counter can wrap and that should not be of any concern. This
    // register will reset to 0 anytime the corresponding enable for the register transitions
    // from a 0->1.  Note that on a 1->0 transition, the counter should hold its previous
    // value 
    // 
    // Bits[31:0], RO/V, default = 0x0
    //
    UINTX llr1 : 32;
  } Bits;
  UINTX Data;
} LAT_LIM_RES_1_PMC_PCI_MMR_STRUCT;
#endif // ASM_INC

#define LAT_LIM_RES_2_PMC_PCI_MMR_REG                      0x00000138
#ifndef ASM_INC
typedef union {
  struct {
    //
    // This field contains the amount of time (in 100us granularity) for the corresponding
    // 0/1/2 counter in the LATENCY_LIMIT_CONTROL register that the appropriate counter
    // is limiting the memory LTR request to the CPU.[br] 
    // 			  Note that this counter can wrap and that should not be of any concern. This
    // register will reset to 0 anytime the corresponding enable for the register transitions
    // from a 0->1.  Note that on a 1->0 transition, the counter should hold its previous
    // value 
    // 
    // Bits[31:0], RO/V, default = 0x0
    //
    UINTX llr2 : 32;
  } Bits;
  UINTX Data;
} LAT_LIM_RES_2_PMC_PCI_MMR_STRUCT;
#endif // ASM_INC

#define SLP_S0_RESIDENCY_PMC_PCI_MMR_REG                   0x0000013C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // This field contains the amount of time that the SLP_S0 has been asserted before.
    //  Note that this counter can wrap and that should not be of any concern.  It will
    // also count in 100us granularity 
    // 
    // Bits[31:0], RO/V, default = 0x0
    //
    UINTX residency_in_s0 : 32;
  } Bits;
  UINTX Data;
} SLP_S0_RESIDENCY_PMC_PCI_MMR_STRUCT;
#endif // ASM_INC

#define LATENCY_LIMIT_CONTROL_PMC_PCI_MMR_REG              0x00000140
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Encoding of the LTR device to be monitored[br]
    // 				TBD: Determine EncodingsEncodings:[br]
    // 					0 - SPA[br]
    // 					1 - SPB[br]
    // 					2 - SPC[br]
    // 					3 - SATA[br]
    // 					4 - GbE[br]
    // 					5 - XHCI[br]
    // 					6 - ME[br]
    // 					7 - EVA[br]
    // 					8 - AZ[br]
    // 					9 - ESPI[br]
    // 					10 - LPSS[br]
    // 					11 - SPD (for SPT-H only)[br]
    // 					12 - SPE (for SPT-H only)[br]
    // 					13 - CAM[br]
    // 					14  SCC[br]
    // 					15 - ISH
    // 
    // Bits[4:0], RW, default = 0x0
    //
    UINTX ctr0_device : 5;
    //
    // Control for counting only if EA=0[br]
    // 				0  Count always (EA=0 or 1)[br]
    // 				1  Count only if in a state where EA=0
    // 
    // Bits[5:5], RW, default = 0x0
    //
    UINTX ctr0_ea_ctl : 1;
    //
    // Control for counting only if EA=0[br]
    // 				0  Count always (EA=0 or 1)[br]
    // 				1  Count only if in a state where EA=0
    // 
    // Bits[6:6], RW, default = 0x0
    //
    UINTX ctr0_enable : 1;
    //
    // N/A
    // 
    // Bits[7:7], RO, default = 0x0
    //
    UINTX rsvd_7_7 : 1;
    //
    // Encoding of the LTR device to be monitored[br]
    // 				TBD: Determine EncodingsEncodings:[br]
    // 					0 - SPA[br]
    // 					1 - SPB[br]
    // 					2 - SPC[br]
    // 					3 - SATA[br]
    // 					4 - GbE[br]
    // 					5 - XHCI[br]
    // 					6 - ME[br]
    // 					7 - EVA[br]
    // 					8 - AZ[br]
    // 					9 - ESPI[br]
    // 					10 - LPSS[br]
    // 					11 - SPD (for SPT-H only)[br]
    // 					12 - SPE (for SPT-H only)[br]
    // 					13 - CAM[br]
    // 					14  SCC[br]
    // 					15 - ISH
    // 
    // Bits[12:8], RW, default = 0x0
    //
    UINTX ctr1_device : 5;
    //
    // Control for counting only if EA=0[br]
    // 				0  Count always (EA=0 or 1)[br]
    // 				1  Count only if in a state where EA=0
    // 
    // Bits[13:13], RW, default = 0x0
    //
    UINTX ctr1_ea_ctl : 1;
    //
    // Control for counting only if EA=0[br]
    // 				0  Count always (EA=0 or 1)[br]
    // 				1  Count only if in a state where EA=0
    // 
    // Bits[14:14], RW, default = 0x0
    //
    UINTX ctr1_enable : 1;
    //
    // N/A
    // 
    // Bits[15:15], RO, default = 0x0
    //
    UINTX rsvd_15_15 : 1;
    //
    // Encoding of the LTR device to be monitored[br]
    // 				TBD: Determine EncodingsEncodings:[br]
    // 					0 - SPA[br]
    // 					1 - SPB[br]
    // 					2 - SPC[br]
    // 					3 - SATA[br]
    // 					4 - GbE[br]
    // 					5 - XHCI[br]
    // 					6 - ME[br]
    // 					7 - EVA[br]
    // 					8 - AZ[br]
    // 					9 - ESPI[br]
    // 					10 - LPSS[br]
    // 					11 - SPD (for SPT-H only)[br]
    // 					12 - SPE (for SPT-H only)[br]
    // 					13 - CAM[br]
    // 					14  SCC[br]
    // 					15 - ISH
    // 
    // Bits[20:16], RW, default = 0x0
    //
    UINTX ctr2_device : 5;
    //
    // Control for counting only if EA=0[br]
    // 				0  Count always (EA=0 or 1)[br]
    // 				1  Count only if in a state where EA=0
    // 
    // Bits[21:21], RW, default = 0x0
    //
    UINTX ctr2_ea_ctl : 1;
    //
    // Control for counting only if EA=0[br]
    // 				0  Count always (EA=0 or 1)[br]
    // 				1  Count only if in a state where EA=0
    // 
    // Bits[22:22], RW, default = 0x0
    //
    UINTX ctr2_enable : 1;
    //
    // N/A
    // 
    // Bits[31:23], RO, default = 0x0
    //
    UINTX rsvd_31_23 : 9;
  } Bits;
  UINTX Data;
} LATENCY_LIMIT_CONTROL_PMC_PCI_MMR_STRUCT;
#endif // ASM_INC

#define MODPHY_PM_CFG1_PMC_PCI_MMR_REG                     0x00000200
#ifndef ASM_INC
typedef union {
  struct {
    //
    // This is a bit per lane that controls SUS Well Power Gating for a ModPHY lane when
    // system is in Sx.[br] 
    // 				Bit 0: Corresponds to ModPHY Lane 0[br]
    // 				Bit 1: Corresponds to ModPHY Lane 1[br]
    // 				Bit 2: Corresponds to ModPHY Lane 2[br]
    // 				:[br]
    // 				:[br]
    // 				Bit 15: Corresponds to ModPHY Lane 15[br]
    // 				For each lane:[br]
    // 				0: Lane power gating not permitted in Sx.[br]
    // 				1: Lane power gating is permitted in Sx.[br]
    // 				Note that strap information/PCIe Lane reversal information will be factored
    // by BIOS when programming these bits in the configuration registers.[br] 
    // 				For ease of PMC implementation, this field will be used to manage Sx policies
    // even in S0. In other words, the earlier restriction that BIOS does not have to
    // program this field if MLSPDDGE is 1 does not apply any more.[br] 
    // 				BIOS shall set this field appropriately for all cases.
    // 
    // Bits[15:0], RW, default = 0xFFFF
    //
    UINTX mlsxswpgp : 16;
    //
    // This is a bit per lane that controls SUS Well Power Gating for a ModPHY lane to
    // be used for S0 and S0ix use models as described above in HAS.[br] 
    // 		Bit 0: Corresponds to ModPHY Lane 0[br]
    // 		Bit 1: Corresponds to ModPHY Lane 1[br]
    // 		Bit 2: Corresponds to ModPHY Lane 2[br]
    // 		:[br]
    // 		:[br]
    // 		Bit 15: Corresponds to ModPHY Lane 15[br]
    // 		For each lane:[br]
    // 		0: Lane power gating not permitted in S0.[br]
    // 		1: Lane power gating is permitted in S0.[br]
    // 		Note that strap information/PCIe Lane reversal information will be factored
    // by BIOS when programming these bits in the configuration registers.[br] 
    // 		Note that it is illegal SW programming to have a bit location to be 1 in this
    // field and the corresponding bit position to be 0 in MLSXSWPGP 
    // 
    // Bits[31:16], RW, default = 0x0
    //
    UINTX mls0swpgp : 16;
  } Bits;
  UINTX Data;
} MODPHY_PM_CFG1_PMC_PCI_MMR_STRUCT;
#endif // ASM_INC

#define MODPHY_PM_CFG2_PMC_PCI_MMR_REG                     0x00000204
#ifndef ASM_INC
typedef union {
  struct {
    //
    // This field provides ASL code to take over SPD power gating control. If ASL code
    // sets a bit corresponding to a controller, it implies that PMC shall ignore any
    // other inputs from that controller and assume that the controller is ready for
    // SPD power gating.[br] 
    // 				0 in a bit position: Use HW interfaces for the controller to manage SPD gating/wake-up.[br]
    // 				1 in a bit position: Ignore HW interfaces for the controller, rely only on
    // MSPDRTReq field thats managed by ASL code.[br] 
    // 				Bit 0: Corresponds to PCIe Controller A, Function 0[br]
    // 				Bit 1: Corresponds to PCIe Controller A, Function 1[br]
    // 				Bit 2: Corresponds to PCIe Controller A, Function 2[br]
    // 				Bit 3: Corresponds to PCIe Controller A, Function 3[br]
    // 				Bit 4: Corresponds to PCIe Controller B, Function 0[br]
    // 				Bit 5: Corresponds to PCIe Controller B, Function 1[br]
    // 				Bit 6: Corresponds to PCIe Controller B, Function 2[br]
    // 				Bit 7: Corresponds to PCIe Controller B, Function 3[br]
    // 				Bit 8: Corresponds to PCIe Controller C, Function 0[br]
    // 				Bit 9: Corresponds to PCIe Controller C, Function 1[br]
    // 				Bit 10: Corresponds to PCIe Controller C, Function 2[br]
    // 				Bit 11: Corresponds to PCIe Controller C, Function 3[br]
    // 				Bit 12: Corresponds to SATA Controller[br]
    // 				Bit 13: Corresponds to Gbe Controller[br]
    // 				Bit 14: Corresponds to xHCI Controller[br]
    // 				Bit 15: Corresponds to xDCI Controller[br]
    // 				Bit 16: Corresponds to UFS Controller[br]
    // 				Bits[19:17]: Reserved[br]
    // 				This field is going to be used in conjunction with MSPDRTReq and MSPDRTRAck
    // fields above. If ASL code intends to over-ride HW decisions, it will set the corresponding
    // bit for a controller/function to 1 in ASLOR and use MSPDRTReq bits to power-up/power-down
    // SPD. 
    // 
    // Bits[19:0], RW, default = 0x0
    //
    UINTX aslor : 20;
    //
    // N/A
    // 
    // Bits[23:20], RO, default = 0x0
    //
    UINTX rsvd_23_20 : 4;
    //
    // This field defines the ramp time of ModPHY FET.[br]
    // 				00000b: 00us[br]
    // 				00001b: 20us[br]
    // 				00010b: 40us[br]
    // 				...[br]
    // 				00101b: 100us[br]
    // 				...[br]
    // 				11111b: 620us
    //         [br]
    //         [br]This bit is locked while PM_SYNC_MISC_CFG.PM_SYNC_LOCK = '1'
    // 
    // Bits[28:24], RW/L, default = 0x5
    //
    UINTX efrt : 5;
    //
    // This bit enables PMC dynamic control of ModPHY external FET. When this bit is
    // 0 and MLSPDDGE is 1, PMC goes through all of the ModPHY power gating flows except
    // that the external FET is not turned off.[br] 
    // 				This bit is being provided primarily to prevent External FET gating during
    // EXI debug 
    // 
    // Bits[29:29], RW, default = 0x0
    //
    UINTX emfc : 1;
    //
    // When this bit is set to 1, ModPHY Lane SUS Well Dynamic Gating is enabled.[br]
    // 				ModPHY lane SPD is managed using the variables defined in section 6.1.2.4
    // (PMC SUS Power Gating Interfaces).[br] 
    // 				When this bit is 0, ModPHY Lane SUS Well Gating can still be done at a more
    // coarse level  using MLSXSWPGP and MLS0SWPGP fields. 
    // 
    // Bits[30:30], RW, default = 0x0
    //
    UINTX mlspddge : 1;
    //
    // This bit controls how PMC  should treat Gen2PLL power request for ModPHY power
    // gating flows.[br] 
    // 				0-      PMC should treat Gen2PLL request as non restore power request[br]
    // 				1-      PMC should treat Gen2PLL request as restore power request
    // 
    // Bits[31:31], RW, default = 0x0
    //
    UINTX g2pllreqctl : 1;
  } Bits;
  UINTX Data;
} MODPHY_PM_CFG2_PMC_PCI_MMR_STRUCT;
#endif // ASM_INC

#define MODPHY_PM_CFG3_PMC_PCI_MMR_REG                     0x00000208
#ifndef ASM_INC
typedef union {
  struct {
    //
    // This field represents ASL code trigger request for ModPHY SPD gating. If this
    // bit is set (to 1) for a controller, it implies that ASL code provides consent
    // for SPD to be gated for the corresponding controllers lanes.[br] 
    // 				Note that this bit could also be more statically used by BIOS to set this
    // to 1 for a controller where SPD will only be managed through other interfaces
    //  implying ASL code does not exist for a controller.[br] 
    // 				This is not a POR mode of operation if a function is enabled  ASL code will
    // exist for all controllers that are enabled. However, the controllers that are
    // not enabled (Function Disabled), this field will be statically set[br] 
    // 				by BIOS to activate ASL component in SPD gating equations.[br]
    // 				Bit 0: Corresponds to PCIe Controller A, Function 0[br]
    // 				Bit 1: Corresponds to PCIe Controller A, Function 1[br]
    // 				Bit 2: Corresponds to PCIe Controller A, Function 2[br]
    // 				Bit 3: Corresponds to PCIe Controller A, Function 3[br]
    // 				Bit 4: Corresponds to PCIe Controller B, Function 0[br]
    // 				Bit 5: Corresponds to PCIe Controller B, Function 1[br]
    // 				Bit 6: Corresponds to PCIe Controller B, Function 2[br]
    // 				Bit 7: Corresponds to PCIe Controller B, Function 3[br]
    // 				Bit 8: Corresponds to PCIe Controller C, Function 0[br]
    // 				Bit 9: Corresponds to PCIe Controller C, Function 1[br]
    // 				Bit 10: Corresponds to PCIe Controller C, Function 2[br]
    // 				Bit 11: Corresponds to PCIe Controller C, Function 3[br]
    // 				Bit 12: Corresponds to SATA Controller[br]
    // 				Bit 13: Corresponds to Gbe Controller[br]
    // 				Bit 14: Corresponds to xHCI Controller[br]
    // 				Bit 15: Corresponds to xDCI Controller[br]
    // 				Bit 16: Corresponds to UFS Controller[br]
    // 				Bits[19:17]: Reserved
    // 
    // Bits[19:0], RW, default = 0x0
    //
    UINTX mspdrtreq : 20;
    //
    // N/A
    // 
    // Bits[31:20], RO, default = 0x0
    //
    UINTX rsvd_31_20 : 12;
  } Bits;
  UINTX Data;
} MODPHY_PM_CFG3_PMC_PCI_MMR_STRUCT;
#endif // ASM_INC

#define MODPHY_PM_CFG4_PMC_PCI_MMR_REG                     0x0000020C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // This field represents the acknowledge for ASL code trigger request for ModPHY
    // SPD gating. PMC sets a bit in this field to 1 to acknowledge that it has registered
    // the corresponding MSPDRTREQ. Note that the action of setting this bit to 1 is
    // immediate  no other gating conditions are involved in this.[br] 
    // 				Actual SPD shutdown may happen later once other power gating conditions have
    // been satisfied as well.[br] 
    // 				PMC clears a bit to 0 in this field once the corresponding MSPTDRTREQ is cleared
    // by the ASL code and SPD state has been fully restored.[br] 
    // 				Bit 0: Corresponds to PCIe Controller A, Function 0[br]
    // 				Bit 1: Corresponds to PCIe Controller A, Function 1[br]
    // 				Bit 2: Corresponds to PCIe Controller A, Function 2[br]
    // 				Bit 3: Corresponds to PCIe Controller A, Function 3[br]
    // 				Bit 4: Corresponds to PCIe Controller B, Function 0[br]
    // 				Bit 5: Corresponds to PCIe Controller B, Function 1[br]
    // 				Bit 6: Corresponds to PCIe Controller B, Function 2[br]
    // 				Bit 7: Corresponds to PCIe Controller B, Function 3[br]
    // 				Bit 8: Corresponds to PCIe Controller C, Function 0[br]
    // 				Bit 9: Corresponds to PCIe Controller C, Function 1[br]
    // 				Bit 10: Corresponds to PCIe Controller C, Function 2[br]
    // 				Bit 11: Corresponds to PCIe Controller C, Function 3[br]
    // 				Bit 12: Corresponds to SATA Controller[br]
    // 				Bit 13: Corresponds to Gbe Controller[br]
    // 				Bit 14: Corresponds to xHCI Controller[br]
    // 				Bit 15: Corresponds to xDCI Controller[br]
    // 				Bit 16: Corresponds to UFS Controller[br]
    // 				Bits[19:17]: Reserved
    // 
    // Bits[19:0], RO/V, default = 0x0
    //
    UINTX mspdrtrack : 20;
    //
    // N/A
    // 
    // Bits[31:20], RO, default = 0x0
    //
    UINTX rsvd_31_20 : 12;
  } Bits;
  UINTX Data;
} MODPHY_PM_CFG4_PMC_PCI_MMR_STRUCT;
#endif // ASM_INC

#define MODPHY_PM_CFG5_PMC_PCI_MMR_REG                     0x00000210
#ifndef ASM_INC
typedef union {
  struct {
    //
    // This is a bit per lane that controls SUS Well Power Gating for a ModPHY lane when
    // system is in Sx.[br] 
    // 				Bit 0: Corresponds to ModPHY Lane 0[br]
    // 				Bit 1: Corresponds to ModPHY Lane 1[br]
    // 				Bit 2: Corresponds to ModPHY Lane 2[br]
    // 				:[br]
    // 				:[br]
    // 				Bit 15: Corresponds to ModPHY Lane 15[br]
    // 				For each lane:[br]
    // 				0: Lane power gating not permitted in Sx.[br]
    // 				1: Lane power gating is permitted in Sx.[br]
    // 				Note that strap information/PCIe Lane reversal information will be factored
    // by BIOS when programming these bits in the configuration registers.[br] 
    // 				For ease of PMC implementation, this field will be used to manage Sx policies
    // even in S0. In other words, the earlier restriction that BIOS does not have to
    // program this field if MLSPDDGE is 1 does not apply any more.[br] 
    // 				BIOS shall set this field appropriately for all cases.
    // 
    // Bits[3:0], RW, default = 0xF
    //
    UINTX mlsxswpgp_19_16 : 4;
    //
    // This is a bit per lane that controls SUS Well Power Gating for a ModPHY lane to
    // be used for S0 and S0ix use models as described above in HAS.[br] 
    // 		Bit 0: Corresponds to ModPHY Lane 0[br]
    // 		Bit 1: Corresponds to ModPHY Lane 1[br]
    // 		Bit 2: Corresponds to ModPHY Lane 2[br]
    // 		:[br]
    // 		:[br]
    // 		Bit 15: Corresponds to ModPHY Lane 15[br]
    // 		For each lane:[br]
    // 		0: Lane power gating not permitted in S0.[br]
    // 		1: Lane power gating is permitted in S0.[br]
    // 		Note that strap information/PCIe Lane reversal information will be factored
    // by BIOS when programming these bits in the configuration registers.[br] 
    // 		Note that it is illegal SW programming to have a bit location to be 1 in this
    // field and the corresponding bit position to be 0 in MLSXSWPGP 
    // 
    // Bits[7:4], RW, default = 0x0
    //
    UINTX mls0swpgp_19_16 : 4;
    //
    // N/A
    // 
    // Bits[31:8], RO, default = 0x0
    //
    UINTX rsvd_31_8 : 24;
  } Bits;
  UINTX Data;
} MODPHY_PM_CFG5_PMC_PCI_MMR_STRUCT;
#endif // ASM_INC

#define PMRSPDMD_OVR1_PMC_PCI_MMR_REG                      0x00000300
#ifndef ASM_INC
typedef union {
  struct {
    //
    // N/A
    // 
    // Bits[0:0], RO, default = 0x0
    //
    UINTX rsvd_pm_msg_ovr : 1;
    //
    // Contributes to or overrides the corresponding field in all PM_Rsp / PM_Dmd messages.
    //  See PMRSPDMD_OVR_CTL.SL_FORCE bit description for handling details.  Needs to
    // be set in conjunciton with SL_SCALE_OVR. 
    // 
    // Bits[3:1], RW, default = 0x7
    //
    UINTX sl_scale_ovr : 3;
    //
    // Contributes to or overrides the corresponding field in all PM_Rsp / PM_Dmd messages.
    //  See PMRSPDMD_OVR_CTL.NL_FORCE bit description for handling details.  Needs to
    // be set in conjunciton with SL_OVR. 
    // 
    // Bits[6:4], RW, default = 0x7
    //
    UINTX nl_scale_ovr : 3;
    //
    // May be used to override the corresponding field in all PM_Rsp / PM_Dmd messages.
    //  See PMRSPDMD_OVR_CTL.EA_OVR_EN bit description for handling details. 
    // 
    // Bits[7:7], RW, default = 0x0
    //
    UINTX ea_ovr : 1;
    //
    // May be used to override the corresponding field in all PM_Rsp / PM_Dmd messages.
    //  See PMRSPDMD_OVR_CTL.CF_OVR_EN bit description for handling details. 
    // 
    // Bits[8:8], RW, default = 0x0
    //
    UINTX cf_ovr : 1;
    //
    // May be used to override the corresponding field in all PM_Rsp / PM_Dmd messages.
    //  See PMRSPDMD_OVR_CTL.VNN_OFF_OVR_EN bit description for handling details. 
    // 
    // Bits[9:9], RW, default = 0x0
    //
    UINTX vnn_off_ovr : 1;
    //
    // May be used to override the corresponding field in all PM_Rsp / PM_Dmd messages.
    //  See PMRSPDMD_OVR_CTL.FO_OVR_EN bit description for handling details. 
    // 
    // Bits[10:10], RW, default = 0x0
    //
    UINTX fs_ovr : 1;
    //
    // Contributes to or overrides the corresponding field in all PM_Rsp / PM_Dmd messages.
    //  See PMRSPDMD_OVR_CTL.SL_FORCE bit description for handling details.  Needs to
    // be set in conjunciton with SL_SCALE_OVR. 
    // 
    // Bits[20:11], RW, default = 0x3FF
    //
    UINTX sl_ovr : 10;
    //
    // Contributes to or overrides the corresponding field in all PM_Rsp / PM_Dmd messages.
    //  See PMRSPDMD_OVR_CTL.NL_FORCE bit description for handling details.  Needs to
    // be set in conjunciton with SL_SCALE_OVR. 
    // 
    // Bits[30:21], RW, default = 0x3FF
    //
    UINTX nl_ovr : 10;
    //
    // N/A
    // 
    // Bits[31:31], RO, default = 0x0
    //
    UINTX rsvd31 : 1;
  } Bits;
  UINTX Data;
} PMRSPDMD_OVR1_PMC_PCI_MMR_STRUCT;
#endif // ASM_INC

#define PMRSPDMD_OVR2_PMC_PCI_MMR_REG                      0x00000304
#ifndef ASM_INC
typedef union {
  struct {
    //
    // May be used to override the corresponding field in all PM_Rsp / PM_Dmd messages.
    //  See PMRSPDMD_OVR_CTL.MDID_OVR_EN bit description for handling details. 
    // 
    // Bits[5:0], RW, default = 0x0
    //
    UINTX mdid_ovr_8_3 : 6;
    //
    // Overrides the corresponding field in all PM_Rsp / PM_Dmd messages.  See PMRSPDMD_OVR_CTL.TNTE_OVR_EN
    // bit description for handling details. 
    // 
    // Bits[31:6], RW, default = 0x0
    //
    UINTX tnte_ovr : 26;
  } Bits;
  UINTX Data;
} PMRSPDMD_OVR2_PMC_PCI_MMR_STRUCT;
#endif // ASM_INC

#define PMRSPDMD_OVR_CTL_PMC_PCI_MMR_REG                   0x00000308
#ifndef ASM_INC
typedef union {
  struct {
    //
    // 0 = Include the PMRSPDMD_OVR1.VNN_OFF_OVR value in the latency coalescing calculations
    // like the LTR for any other device[br] 
    // 1 = Ignore the latency coalescing calculations and populate the VNN_OFF_OVR field
    // in all PM_Rsp / PM_Dmd messages directly from PMRSPDMD_OVR1.VNN_OFF_OVR 
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINTX vnn_off_ovr_en : 1;
    //
    // 0 = Include the PMRSPDMD_OVR1.SL_OVR value in the latency coalescing calculations
    // like the LTR for any other device[br] 
    // 1 = Ignore the latency coalescing calculations and populate the SL field in all
    // PM_Rsp / PM_Dmd messages directly from PMRSPDMD_OVR1.SL_OVR 
    // 
    // Bits[1:1], RW, default = 0x0
    //
    UINTX sl_force : 1;
    //
    // 0 = Include the PMRSPDMD_OVR1.NL_OVR value in the latency coalescing calculations
    // like the LTR for any other device[br] 
    // 1 = Ignore the latency coalescing calculations and populate the NL field in all
    // PM_Rsp / PM_Dmd messages directly from PMRSPDMD_OVR1.NL_OVR 
    // 
    // Bits[2:2], RW, default = 0x0
    //
    UINTX nl_force : 1;
    //
    // 0 = Populate the Forced slowdown in all PM_Rsp / PM_Dmd messages based on the
    // forced slowdown value received in the last PM_Req message from the CPU[br] 
    // 1 = Populate the FS field in all PM_Rsp / PM_Dmd messages directly from PMRSPDMD_OVR2.FS_OVR
    // 
    // Bits[3:3], RW, default = 0x0
    //
    UINTX fs_ovr_en : 1;
    //
    // 0 = Populate the EA field in all PM_Rsp / PM_Dmd messages based on the EA value
    // received in the last PM_Req message from the CPU[br] 
    // 1 = Populate the EA field in all PM_Rsp / PM_Dmd messages directly from PMRSPDMD_OVR2.EA_OVR
    // 
    // Bits[4:4], RW, default = 0x0
    //
    UINTX ea_ovr_en : 1;
    //
    // 0 = Populate the CF field in all PM_Rsp / PM_Dmd messages based on the CF value
    // received in the last PM_Req message from the CPU[br] 
    // 1 = Populate the CF field in all PM_Rsp / PM_Dmd messages directly from PMRSPDMD_OVR2.CF_OVR
    // 
    // Bits[5:5], RW, default = 0x0
    //
    UINTX cf_ovr_en : 1;
    //
    // 0 = Populate the MDID field in all PM_Rsp / PM_Dmd messages based on the MDID
    // value received in the last PM_Req message from the CPU[br] 
    // 1 = Populate the MDID field in all PM_Rsp / PM_Dmd messages directly from PMRSPDMD_OVR2.MDID_OVR
    // 
    // Bits[6:6], RW, default = 0x0
    //
    UINTX mdid_ovr_en : 1;
    //
    // 0 = Load the PCH TNTE timer in the PMC based on values provided by the HPET block[br]
    // 1 = Ignore the TNTE values from HPET and load the PCH TNTE timer from the value
    // in the PMRSPDMD_OVR2.TNTE_OVR field.[br] 
    // The actual load of this self-decrementing timer will occur when a write is detected
    // to the PMRSPDMD_OVR2 register while TNTE_OVR_EN=1, so if software wants to perform
    // a TNTE override the flow would be:[br] 
    //   - Write to PMRSPDMD_OVR_CTL register setting TNTE_OVR_EN to '1'[br]
    //   - Write to PMRSPDMD_OVR2 register with the desired value in the TNTE_OVR field[br]
    //       --> PCH TNTE timer will be loaded here and then start decrementing[br]
    //       --> Note that this action will not directly trigger a PM_Dmd message[br]
    //   - Write to PMRSPDMD_OVR_CTL register clearing TNTE_OVR_EN to '0'[br]
    //       --> Avoids accidental PCH TNTE timer loads in the future[br]
    //       --> If a PM_Dmd is desired, software could also write a '1' to FORCE_PM_DMD
    // at this point 
    // 
    // Bits[7:7], RW, default = 0x0
    //
    UINTX tnte_ovr_en : 1;
    //
    // N/A
    // 
    // Bits[30:8], RO, default = 0x0
    //
    UINTX rsvd : 23;
    //
    // When this bit is written to '1', the PMC will enqueue one PM_Dmd message as long
    // as it is enabled to send in the current C-state (according to C0_PM_DMD_EN and
    // CX_PM_DMD_EN). Note that there may be a delay before the cycle actually appears
    // on DMI (due to clock gating, arbitration, etc). 
    // 
    // Bits[31:31], WO, default = 0x0
    //
    UINTX force_pm_dmd : 1;
  } Bits;
  UINTX Data;
} PMRSPDMD_OVR_CTL_PMC_PCI_MMR_STRUCT;
#endif // ASM_INC

#define LTR_IGN_PMC_PCI_MMR_REG                            0x0000030C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // N/A
    // 
    // Bits[0:0], RO, default = 0x0
    //
    UINTX rsvd0 : 1;
    //
    // When this bit is set to '1' the PMC will ignore the LTR value reported by PCIE0
    // when performing latency coalescing. 
    // 
    // Bits[1:1], RW, default = 0x0
    //
    UINTX ign_pcie0 : 1;
    //
    // When this bit is set to '1' the PMC will ignore the LTR value reported by PCIE1
    // when performing latency coalescing. 
    // 
    // Bits[2:2], RW, default = 0x0
    //
    UINTX ign_pcie1 : 1;
    //
    // When this bit is set to '1' the PMC will ignore the LTR value reported by XHCI
    // when performing latency coalescing. 
    // 
    // Bits[3:3], RW, default = 0x0
    //
    UINTX ign_xhci : 1;
    //
    // When this bit is set to '1' the PMC will ignore the LTR value reported by SATA0
    // when performing latency coalescing. 
    // 
    // Bits[4:4], RW, default = 0x0
    //
    UINTX ign_sata0 : 1;
    //
    // When this bit is set to '1' the PMC will ignore the LTR value reported by SATA1
    // when performing latency coalescing. 
    // 
    // Bits[5:5], RW, default = 0x0
    //
    UINTX ign_sata1 : 1;
    //
    // When this bit is set to '1' the PMC will ignore the LTR value reported by SCC
    // when performing latency coalescing. 
    // 
    // Bits[6:6], RW, default = 0x0
    //
    UINTX ign_scc : 1;
    //
    // When this bit is set to '1' the PMC will ignore the LTR value reported by ESPISPI
    // when performing latency coalescing. 
    // 
    // Bits[7:7], RW, default = 0x0
    //
    UINTX ign_espispi : 1;
    //
    // When this bit is set to '1' the PMC will ignore the LTR value reported by MAC0
    // when performing latency coalescing. 
    // 
    // Bits[8:8], RW, default = 0x0
    //
    UINTX ign_mac0 : 1;
    //
    // When this bit is set to '1' the PMC will ignore the LTR value reported by MAC1
    // when performing latency coalescing. 
    // 
    // Bits[9:9], RW, default = 0x0
    //
    UINTX ign_mac1 : 1;
    //
    // When this bit is set to '1' the PMC will ignore the LTR value reported by CSME
    // when performing latency coalescing. 
    // 
    // Bits[10:10], RW, default = 0x0
    //
    UINTX ign_csme : 1;
    //
    // When this bit is set to '1' the PMC will ignore the LTR value reported by PCIe
    // controller IE when performing latency coalescing. 
    // 
    // Bits[11:11], RW, default = 0x0
    //
    UINTX ign_ie : 1;
    //
    // When this bit is set to '1' the PMC will ignore the LTR value reported by PCIe
    // controller XHCI when performing latency coalescing. 
    // 
    // Bits[12:12], RW, default = 0x0
    //
    UINTX ign_xhci_iosfp : 1;
    //
    // N/A
    // 
    // Bits[31:13], RO, default = 0x0
    //
    UINTX rsvd31_13 : 19;
  } Bits;
  UINTX Data;
} LTR_IGN_PMC_PCI_MMR_STRUCT;
#endif // ASM_INC

#define OBFF_CFG_PMC_PCI_MMR_REG                           0x00000314
#ifndef ASM_INC
typedef union {
  struct {
    //
    // When set to '1', the PMC will drive the OBFF protocol on the external PCIe WAKE#
    // pin.  When this bit is a '0', the PMC will leave the WAKE# pin output driver tri-stated
    // (so that it can be monitored as an input without interferance from the PCH).[br]
    // Programming Restriction: This bit may only be modified during boot (before the
    // first C-state has been entered).  Changing the value of this bit during runtime
    // may lead to undefined behavior.[br] 
    // Note: If CPPM Disable Fuse Fuse is 1, this register will always read 0 and is
    // Read-only. 
    // 
    // Bits[0:0], RW/V, default = 0x0
    //
    UINTX ext_obff_en : 1;
    //
    // When set to '1', the PMC will drive the OBFF protocol on the internal obff[1:0]
    // vector which is part of the IOSF spec.  When this bit is a '0', the PMC will leave
    // obff[1:0] parked at 11b (CPU ACTIVE).[br] 
    // Programming Restriction: This bit may only be modified during boot (before the
    // first C-state has been entered).  Changing the value of this bit during runtime
    // may lead to undefined behavior.[br] 
    // Note: If CPPM Disable Fuse Fuse is 1, this register will always read 0 and is
    // Read-only. 
    // 
    // Bits[1:1], RW/V, default = 0x0
    //
    UINTX int_obff_en : 1;
    //
    // When this bit is set to '1', the PMC will include the MEM CLOSED state when driving
    // the internal OBFF protocol on obff[1:0].  This will attempt to align PCH traffic
    // during C0.  There is no equivalent state in the external OBFF protocol on the
    // WAKE# pin - when the internal state is MEM CLOSED the PMC will report CPU ACTIVE
    // externaly.[br] 
    // When this bit is a '0', the PMC will always report CPU ACTIVE while in C0 on both
    // the internal and external OBFF signals, regardless of the state of PCH internal
    // traffic.[br] 
    // Note: If CPPM Disable Fuse Fuse is 1, this register will always read 0 and is
    // Read-only. 
    // 
    // Bits[2:2], RW/V, default = 0x1
    //
    UINTX mc_state_en : 1;
    //
    // When this bit is set to '1', upon receiving a PM_Req w/EA=0 the PMC will inject
    // a 2us delay before transitioning the OBFF state from C0 (CPU ACTIVE or MEM CLOSED)
    // to Cx (OBFF or IDLE).[br] 
    // When this bit is a '0' the PMC will transition the OBFF state as soon as possible
    // (no injected delay).[br] 
    // Note: Regardless of the state of this bit, the PMC will not inject any extra delay
    // in the OBFF state transition when a PM_Req w/EA=1 is received.[br] 
    // Not For EDS: This is meant as a back-up mode, so this policy bit should not be
    // exposed in the EDS unless a usage is found for it. 
    // 
    // Bits[3:3], RW, default = 0x0
    //
    UINTX cx_obff_ent_del : 1;
    //
    // This bit enables the client mode OBFF logic to move out of CPU Active. It can
    // be enabled/disabled dynamically during run time, however, the values in OBFF_POLICY_TYPE,
    // INT_OBFF_EN, and EXT_OBFF_EN must be valid before this bit is set to one.[br]
    // If OBFF_POLICY_TYPE = 00b (client) and CL_OBFF_EN = 0b:[br]
    //   - Wait for any pending OBFF transitions to complete and then park in CPU Active[br]
    // If OBFF_POLICY_TYPE = 00b (client) and CL_OBFF_EN = 1b, the client OBFF polices
    // will control the OBFF state.[br] 
    // If OBFF_POLICY_TYPE != 00b, CL_OBFF_EN has no effect.[br]
    // Note: This bit does not have any effect on the EVA vs. PMC obff[1:0] state muxing.
    // 
    // Bits[4:4], RW, default = 0x0
    //
    UINTX cl_obff_en : 1;
    //
    // N/A
    // 
    // Bits[7:5], RO, default = 0x0
    //
    UINTX rsvd : 3;
    //
    // When set to '1', the FAST_RING PM_SYNC state is enabled to assert the internal
    // traffic indication used to determine the OBFF state. 
    // 
    // Bits[8:8], RW, default = 0x0
    //
    UINTX fast_ring_obff_en : 1;
    //
    // When set to '1', the SA PM_SYNC state is enabled to assert the internal traffic
    // indication used to determine the OBFF state. 
    // 
    // Bits[9:9], RW, default = 0x0
    //
    UINTX sa_obff_en : 1;
    //
    // When set to '1', the SLOW_RING PM_SYNC state is enabled to assert the internal
    // traffic indication used to determine the OBFF state. 
    // 
    // Bits[10:10], RW, default = 0x0
    //
    UINTX slow_ring_obff_en : 1;
    //
    // N/A
    // 
    // Bits[12:11], RO, default = 0x0
    //
    UINTX rsvd12_11 : 2;
    //
    // When set to '1', the FAST_RING_CF PM_SYNC state is enabled to assert the internal
    // traffic indication used to determine the OBFF state. 
    // 
    // Bits[13:13], RW, default = 0x0
    //
    UINTX fast_ring_cf_obff_en : 1;
    //
    // When set to '1', the SLOW_RING_CF PM_SYNC state is enabled to assert the internal
    // traffic indication used to determine the OBFF state. 
    // 
    // Bits[14:14], RW, default = 0x0
    //
    UINTX slow_ring_cf_obff_en : 1;
    //
    // N/A
    // 
    // Bits[15:15], RO, default = 0x0
    //
    UINTX rsvd15 : 1;
    //
    // Determines the amount of hysteresis to apply when transitioning the OBFF state
    // from OBFF to IDLE or CPU ACTIVE to MEM CLOSED (if enabled).  This field is defined
    // in 8 usec units:[br] 
    //   00h: no hysteresis[br]
    //   FFh: 2040 usec
    // 
    // Bits[23:16], RW, default = 0x0
    //
    UINTX obff_hys : 8;
    //
    // Determines the amount of time to mask traffic from the OBFF control logic after
    // a transition into the OBFF state (from any other state).  The traffic mask will
    // also be invoked upon entering the CPU ACTIVE state if the MEM CLOSED state is
    // enabled.  If the PCH is not configured to support MEM CLOSED then this traffic
    // mask is not used in CPU ACTIVE.[br] 
    // This field is defined in 8 usec units and has an accuracy of +/- 8usec:[br]
    //   00h: no forced idle traffic masking[br]
    //   FFh: 2040 usec[br]
    // Programming Restriction: TRAFFIC_MASK must either be disabled (00h) or programmed
    // to something larger than OBFF_HYS. See OBFF section for details on intended usage
    // model. 
    // 
    // Bits[31:24], RW, default = 0x0
    //
    UINTX traffic_mask : 8;
  } Bits;
  UINTX Data;
} OBFF_CFG_PMC_PCI_MMR_STRUCT;
#endif // ASM_INC

#define CPPMVRIC_PMC_PCI_MMR_REG                           0x0000031C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // This value is used in the SLP_S0# exit timer and has a 10us granularity.[br]
    // 000h = 0us (reserved)[br]
    // 001h = 10us[br]
    // 002h = 20us[br]
    // 003h = 30us[br]
    // [br]
    // 1FFh = 5.1ms
    // 
    // Bits[8:0], RW, default = 0x0
    //
    UINTX slp_s0_exit_lat : 9;
    //
    // 000 = 2us[br]
    // 001 = 4us[br]
    // 010 = 10us[br]
    // 011 = 26us[br]
    // 100 = 50us[br]
    // 101 = 100us[br]
    // 110 = 500us[br]
    // 111 = 1ms[br]
    // Implementation Note: These encodings are defined as even numbers in order to ease
    // the HW operations that use them. 
    // 
    // Bits[11:9], RW, default = 0x0
    //
    UINTX slp_s0_min_asst_wdth : 3;
    //
    // 0 = SLP_S0# assertion requires the Camera pipe controller to be in D3[br]
    // 1 = SLP_S0# assertion does not require the Camera pipe controller to be in D3
    // 
    // Bits[12:12], RW, default = 0x0
    //
    UINTX campd3qdis : 1;
    //
    // 0 = high speed ring oscillator (>24MHz) clocks are allowed to run when SLP_S0#=0
    //           [br]1 = high speed ring oscillator (>24MHz) clocks are not allowed to
    // run when SLP_S0#=0. 
    //                   PMC must prevent ungating of these clock domains while SLP_S0#=0.
    // 
    // Bits[13:13], RW, default = 0x0
    //
    UINTX slps0lven : 1;
    //
    // 0 = SLP_S0# assertion requires the Storage controller to be in D3
    //           [br]1 = SLP_S0# assertion does not require the Storage controller to
    // be in D3 
    // 
    // Bits[14:14], RW, default = 0x0
    //
    UINTX sccd3qdis : 1;
    //
    // 0 = SLP_S0# HW functionality is disabled[br]
    // 1 = SLP_S0# HW functionality is enabled.[br]
    // When GSLPS0EN = 0, SLP_S0# is always driven to 1 except if being overridden by
    // PMC FW (via the SLP_S0_OVR & SLP_S0_VAL bits defined in chap. 32).[br] 
    // Note: If CPPM Disable Fuse Fuse is 1, this register will always read 0 and is
    // Read-only. 
    // 
    // Bits[15:15], RW/V, default = 0x0
    //
    UINTX gslps0en : 1;
    //
    // Each bit in this register deterimes whether the corresponding PCIe clock request
    // pin (SRC[bit #]CLKRQ#) is enabled as a VR Idle break event / entry inhibitor.[br]
    // For example, if CLKRQ_VRI_EN[0] = '1'  then SRC0CLKRQ# must be a '1' in order
    // for SLP_S0# to be asserted and if SRC0CLKRQ# goes to '0' then it will cause SLP_S0#
    // to be deasserted.  On the other hand, if CLKRQ_VRI_EN[0] = '0' then the state
    // of SRC0CLKRQ# has no impact on SLP_S0#. 
    // 
    // Bits[21:16], RW, default = 0x0
    //
    UINTX clkrq_vri_en : 6;
    //
    // 0 = SLP_S0# assertion requires the 24MHz Crystal Oscillator to be shutdown.  Once
    // SLP_S0# is asserted, the Crystal oscillator should be kept off until PMC notifies
    // it is allowed to be re-enabled.[br] 
    // 1 = SLP_S0# assertion does not require the 24MHz Crystal to be shutdown.
    // 
    // Bits[22:22], RW, default = 0x0
    //
    UINTX xtalsdqdis : 1;
    //
    // 0 = PMC HW does not block ME and modphy Power from being restored upon being requested
    // to do so while SLP_S0# assertion conditions are met and until VR idle mode exit
    // timer expires after SLP_S0# de-assertion.[br] 
    // 1 = PMC HW blocks ME and modphy Power from being restored upon being requested
    // to do so while SLP_S0# assertion conditions are met and until VR idle mode exit
    // timer expires after SLP_S0# de-assertion. 
    // 
    // Bits[23:23], RW, default = 0x0
    //
    UINTX pugben : 1;
    //
    // 0 = SLP_S0# de-assertion/assertion rules follow non-ULT behavior.[br]
    // 1 = SLP_S0# de-assertion/assertion rules follow ULT behavior for connected standby.[br]
    // This bit when set enables new logic for SLP_S0# control added in LPT-LP.  If cleared
    // the behavior of SLP_S0# is the same as LPT-H.[br] 
    // Not for EDS: Intel Reserved test mode bit
    // 
    // Bits[24:24], RW, default = 0x1
    //
    UINTX csslps0en : 1;
    //
    // 0 = PMC HW never blocks ICLK PLL from being re-enabled during a dynamic ICC PLL
    // shutdown event.[br] 
    // 1 = PMC HW blocks ICLK PLL from being re-enabled for any reason following a dynamic
    // ICC PLL shutdown event while SLP_S0# assertion conditions are met and until VR
    // idle mode exit timer expires after SLP_S0# de-assertion. 
    // 
    // Bits[25:25], RW, default = 0x0
    //
    UINTX iccpllwbe : 1;
    //
    // 0 = SLP_S0# assertion requires the thermal sensor to be disabled[br]
    // 1 = SLP_S0# assertion does not require the thermal sensor to be disabled
    // 
    // Bits[26:26], RW, default = 0x0
    //
    UINTX tsdqdis : 1;
    //
    // 0 = SLP_S0# assertion requires LPIO controllers to be in D3[br]
    // 1 = SLP_S0# assertion does not require LPIO controllers to be in D3
    // 
    // Bits[27:27], RW, default = 0x0
    //
    UINTX lpiod3qdis : 1;
    //
    // 0 = SLP_S0# assertion requires the XHCI controller to be in D3[br]
    // 1 = SLP_S0# assertion does not require the XHCI controller to be in D3
    // 
    // Bits[28:28], RW, default = 0x0
    //
    UINTX xhcid3qdis : 1;
    //
    // 0 = SLP_S0# assertion requires the Audio DSP controller to be in D3[br]
    // 1 = SLP_S0# assertion does not require the Audio DSP controller to be in D3
    // 
    // Bits[29:29], RW, default = 0x0
    //
    UINTX adspd3qdis : 1;
    //
    // 0 = SLP_S0# assertion requires GbE LAN to be disconnected[br]
    // 1 = SLP_S0# assertion does not require GbE LAN to be disconnected
    // 
    // Bits[30:30], RW, default = 0x0
    //
    UINTX gbediscqdis : 1;
    //
    // 0 = SLP_S0# assertion requires CSME to be power gated[br]
    // 1 = SLP_S0# assertion does not require CSME to be power gated
    // 
    // Bits[31:31], RW, default = 0x0
    //
    UINTX mepgqdis : 1;
  } Bits;
  UINTX Data;
} CPPMVRIC_PMC_PCI_MMR_STRUCT;
#endif // ASM_INC

#define CPPM_MISC_CFG_PMC_PCI_MMR_REG                      0x00000320
#ifndef ASM_INC
typedef union {
  struct {
    //
    // When this bit is set to '1' and the CPU is in a Cx state, the PMC will generate
    // a PM_Dmd message upstream on DMI whenever one of the data fields changes.[br]
    // When this bit is a '0' the PMC will not send PM_Dmd in Cx.
    // 
    // Bits[0:0], RW, default = 0x1
    //
    UINTX cx_pm_dmd_en : 1;
    //
    // When this bit is set to '1' and the CPU is in a C0 state, the PMC will generate
    // a PM_Dmd message upstream on DMI whenever one of the data fields changes.[br]
    // When this bit is a '0' the PMC will not send PM_Dmd in C0.
    // 
    // Bits[1:1], RW, default = 0x0
    //
    UINTX c0_pm_dmd_en : 1;
    //
    // This policy bit selects the LTR communication mechanism for XHCI.[br]
    // When this bit is a '0' (default), XHCI will use the standard LTR message on IOSF
    // SBI.  PMC must log and honor the values contained in that message.[br] 
    // When this bit is a '1', PMC's behavior reverts to the legacy mode which involved
    // a sideband wire to select between [quote]infinite[quote] LTR (no requirement)
    // and the value programmed in the LTR_XHCI_ACTIVE register.[br] 
    // Note: The value reported in the LTR_XHCI register is dependent on the XHCI_LTR_POL
    // setting (IOSF SBI message contents if '0', value dictated by sideband wire if
    // '1').  However, the IGN_XHCI bit will mask out XHCI's LTR contribution regardless
    // of the XHCI_LTR_POL setting.[br] 
    // Programming Restriction: This bit may only be modified during boot (before the
    // first C-state has been entered).  Changing the value of this bit during runtime
    // may lead to undefined behavior. 
    // 
    // Bits[2:2], RW, default = 0x0
    //
    UINTX xhci_ltr_pol : 1;
    //
    // N/A
    // 
    // Bits[7:3], RO, default = 0x0
    //
    UINTX rsvd : 5;
    //
    // The value in this field determines the meaning of the upper few encodings of the
    // latency-related fields in the PM_REQ/RSP/DMD messages between the PCH and the
    // CPU.  See the [quote]PM_Req / PM_Rsp / PM_Dmd Message Data[quote] section for
    // details.[br] 
    // The granularity for this field matches that of the PM_REQ/RSP/DMD messages, although
    // this field is wider:[br] 
    //     latency = 2 * (value-1) us[br]
    // Note that for practical purposes, the value must be at least 1020us.  For example:[br]
    //     - 000000-0001FEh: illegal[br]
    //     - 0001FFh: 1020us (default)[br]
    // ...[br]
    //     - 0005DDh: 3ms[br]
    // ...[br]
    // Note: The format for this field (24 bits, 2us granularity) was chosen to ease
    // the implementation - it is not an architectural requirement. 
    // 
    // Bits[31:8], RW, default = 0x1FF
    //
    UINTX max_cpumsg_ltr : 24;
  } Bits;
  UINTX Data;
} CPPM_MISC_CFG_PMC_PCI_MMR_STRUCT;
#endif // ASM_INC

#define CPPM_CG_POL1A_PMC_PCI_MMR_REG                      0x00000324
#ifndef ASM_INC
typedef union {
  struct {
    //
    // When CPPM is enabled as a qualifier for shutting down clock source group 1, the
    // current PLT/ASLT (which LT is based on config) must be greater than or equal to
    // the value programmed in this field in order for shutdown to be allowed. If the
    // current PLT/ASLT is less than the value in this field then the PMC will block
    // shutdown.[br] 
    //                 The format of this field matches the NL, and SL fields of the
    // PM_Req/Rsp/Dmd messages on DMI. 
    // 
    // Bits[8:0], RW, default = 0x0
    //
    UINTX ltr_g1_thresh : 9;
    //
    // N/A
    // 
    // Bits[15:9], RO, default = 0x0
    //
    UINTX rsvd15_9 : 7;
    //
    // N/A
    // 
    // Bits[24:16], RO, default = 0x0
    //
    UINTX rsvd_g1 : 9;
    //
    // N/A
    // 
    // Bits[28:25], RO, default = 0x0
    //
    UINTX rsvd28_25 : 4;
    //
    // When the CPPM qualifier is enabled, the value of LT_G1_SEL determines whether
    // ASLT or PLT is used for the comparison against LTR_G1_THRESH.[br] 
    //                 Encoding:[br]
    //                 0 : ASLT[br]
    //                 1 : PLT
    // 
    // Bits[29:29], RW, default = 0x0
    //
    UINTX lt_g1_sel : 1;
    //
    // When this bit is set to '1', the CPPM-related qualifiers (specifically, PLT, IRT,
    // and TNTE) are enabled as required conditions to be met in order for the PMC to
    // indicate that clock source group 1 shutdown is allowed.[br] 
    //                 When this bit is a '0' the above qualifiers do not affect PMC's
    // input to shutdown. 
    // 
    // Bits[30:30], RW, default = 0x0
    //
    UINTX cppm_g1_qual : 1;
    //
    // N/A
    // 
    // Bits[31:31], RO, default = 0x0
    //
    UINTX rsvd_31 : 1;
  } Bits;
  UINTX Data;
} CPPM_CG_POL1A_PMC_PCI_MMR_STRUCT;
#endif // ASM_INC

#define CPPM_CG_POL1B_PMC_PCI_MMR_REG                      0x00000328
#ifndef ASM_INC
typedef union {
  struct {
    //
    // When CPPM is enabled as a qualifier for shutting down clock source group 1, the
    // current TNTE must be greater than or equal to the value programmed in this field
    // in order for shutdown to be allowed. If the current TNTE is less than the value
    // in this field then the PMC will block shutdown.[br] 
    //                 Note: If the clock source is already shutdown when the current
    // TNTE falls below the value in this field then the PMC must trigger a pre-wake
    // so that the clock is available when TNTE expires.[br] 
    //                 The format of this field matches the TNTE field of the PM_Req/Rsp/Dmd
    // messages on DMI. 
    // 
    // Bits[25:0], RW, default = 0x0
    //
    UINTX tnte_g1_pre_wake : 26;
    //
    // N/A
    // 
    // Bits[31:26], RO, default = 0x0
    //
    UINTX rsvd31_17 : 6;
  } Bits;
  UINTX Data;
} CPPM_CG_POL1B_PMC_PCI_MMR_STRUCT;
#endif // ASM_INC

#define LTR_XHCI_ACTIVE_PMC_PCI_MMR_REG                    0x0000032C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // The values programmed into this register will be used as XHCI's contribution to
    // PCH LTR when XHCI is indicating to the PMC that it is in the active state.  The
    // format of this register matches the data payload of the LTR IOSF SBI message -
    // see the IOSF spec or the LTR section later in this chapter.[br] 
    // Implementation Note: This register will not have the functionality described above
    // unless DCN# 3241302 (XHCI C-State Interaction) gets approved. 
    // 
    // Bits[31:0], RW, default = 0x0
    //
    UINTX ltr_xhci_active : 32;
  } Bits;
  UINTX Data;
} LTR_XHCI_ACTIVE_PMC_PCI_MMR_STRUCT;
#endif // ASM_INC

#define CPPM_SRVR_CFG1_PMC_PCI_MMR_REG                     0x00000330
#ifndef ASM_INC
typedef union {
  struct {
    //
    // This field specifies how long the PMC should wait after exiting S0ix (i.e. transitioning
    // to the CPU ACTIVE state) before returning to S0ix (i.e. transitioning to the OBFF
    // or IDLE state).[br] 
    // The format of this field is intentionally made to match the MDAP_VALUE field.
    //  Therefore, the value in this field is defined in 10 usec units:[br] 
    //   0x1FFFF - 1.31 sec[br]
    //   0x00000 - 0us
    // 
    // Bits[16:0], RW, default = 0x0
    //
    UINTX s0ix_re_del : 17;
    //
    // N/A
    // 
    // Bits[27:17], RO, default = 0x0
    //
    UINTX rsvd : 11;
    //
    // This bit determines how the internal OBFF signals (obff[1:0]) are driven, essentially
    // acting as a mux select between normal PMC control and control from the EVA side
    // of the PCH.  This bit has no effect on the external OBFF protocol driven on the
    // WAKE# pin.[br] 
    // When this bit is a '1', signals from the EVA will be directly passed along to
    // drive obff[1:0].  A possible usage model of this configuration would be in the
    // [quote]non-legacy[quote] PCH in a multi-PCH platform, where the legacy PCH is
    // responsible for controlling the OBFF state of the entire platform.[br] 
    // When this bit is a '0', the PMC controls obff[1:0] as normal based on its own
    // internal logic. 
    // 
    // Bits[28:28], RW, default = 0x0
    //
    UINTX eva_obff_ctl : 1;
    //
    // When this bit is set to '1', the PMC will send a PM_INFO message on IOSF SBI to
    // the EVA upon receipt of each PM_Req message on DMI with EA=0.[br] 
    // When this bit is a '0', the PMC will not send the PM_INFO message.
    // 
    // Bits[29:29], RW, default = 0x0
    //
    UINTX send_pm_info : 1;
    //
    // This field indicates the current policy for controlling OBFF:[br]
    //   00b: Client Policy (traffic-based) (Only available if Server Disable Fuse 3
    // is set to 1)[br] 
    //   11b: Server Policy (timer-based) (Available only if Feature Disable Fuse 3 is
    // set to 0)[br] 
    //   Others: Reserved[br]
    // Programming Restriction: This bit may only be modified during boot (before the
    // first C-state has been entered).  Changing the value of this bit during runtime
    // may lead to undefined behavior.[br] 
    // Note:  If Server Feature Disable Fuse 3 is '1', this register will always read
    // '00b' and is Read-only. 
    // 
    // Bits[31:30], RW/V, default = 0x0
    //
    UINTX obff_policy_type : 2;
  } Bits;
  UINTX Data;
} CPPM_SRVR_CFG1_PMC_PCI_MMR_STRUCT;
#endif // ASM_INC

#define LAST_PM_INFO_PMC_PCI_MMR_REG                       0x00000338
#ifndef ASM_INC
typedef union {
  struct {
    //
    // The format of this field is intentionally made to match the TNTE field of the
    // PM_Req/Rsp/Dmd messages on DMI.  Therefore, the value in this field is defined
    // in 10 usec units:[br] 
    //   0x1FFFF - 1.309 sec[br]
    //   0x00000 - Disabled
    // 
    // Bits[16:0], RO/V, default = 0x0
    //
    UINTX piw_value : 17;
    //
    // This bit indicates whether the PIW field in this PM_INFO message is valid.[br]
    // 0 - Not Valid[br]
    // 1 - Valid[br]
    // Implementation Note: This bit of the PM_INFO message is hard-wired to 1 on the
    // PMC side. 
    // 
    // Bits[17:17], RO/V, default = 0x0
    //
    UINTX piw_valid : 1;
    //
    // The format of this field is intentionally made to match the IRT field of the PM_Req/Rsp/Dmd
    // messages on DMI.  Therefore, the value in this field is defined in 2 usec units:[br]
    //   0x1FF - 1020uS and [quote]over[quote][br]
    //   0x000 - Disabled
    // 
    // Bits[26:18], RO/V, default = 0x0
    //
    UINTX mdtl_value : 9;
    //
    // This bit indicates whether the MDTL field in this PM_INFO message is valid.[br]
    // 0 - Not Valid[br]
    // 1 - Valid[br]
    // Implementation Note: This bit of the PM_INFO message is hard-wired to 1 on the
    // PMC side. 
    // 
    // Bits[27:27], RO/V, default = 0x0
    //
    UINTX mdtl_valid : 1;
    //
    // N/A
    // 
    // Bits[31:28], RO, default = 0x0
    //
    UINTX rsvd : 4;
  } Bits;
  UINTX Data;
} LAST_PM_INFO_PMC_PCI_MMR_STRUCT;
#endif // ASM_INC

#define CPPM_CG_POL2A_PMC_PCI_MMR_REG                      0x00000340
#ifndef ASM_INC
typedef union {
  struct {
    //
    // When CPPM is enabled as a qualifier for shutting down clock source group 2, the
    // current PLT/ASLT (which LT is based on config) must be greater than or equal to
    // the value programmed in this field in order for shutdown to be allowed. If the
    // current PLT/ASLT is less than the value in this field then the PMC will block
    // shutdown.[br] 
    //                 The format of this field matches the NL and SL fields of the PM_Req/Rsp/Dmd
    // messages on DMI. 
    // 
    // Bits[8:0], RW, default = 0x0
    //
    UINTX ltr_g2_thresh : 9;
    //
    // N/A
    // 
    // Bits[15:9], RO, default = 0x0
    //
    UINTX rsvd_1 : 7;
    //
    // N/A
    // 
    // Bits[24:16], RO, default = 0x0
    //
    UINTX rsvd_g2 : 9;
    //
    // N/A
    // 
    // Bits[28:25], RO, default = 0x0
    //
    UINTX rsvd_28_25 : 4;
    //
    // When the CPPM qualifier is enabled, the value of LT_G2_SEL determines whether
    // ASLT or PLT is used for the comparison against LTR_G2_THRESH.[br] 
    //                 Encoding:[br]
    //                 0 : ASLT[br]
    //                 1 : PLT
    // 
    // Bits[29:29], RW, default = 0x0
    //
    UINTX lt_g2_sel : 1;
    //
    // When this bit is set to '1', the CPPM-related qualifiers (specifically, PLT, IRT,
    // and TNTE) are enabled as required conditions to be met in order for the PMC to
    // indicate that clock source Group 2 shutdown is allowed.[br] 
    //                 When this bit is a '0' the above qualifiers do not affect PMC's
    // input to shutdown. 
    // 
    // Bits[30:30], RW, default = 0x0
    //
    UINTX cppm_g2_qual : 1;
    //
    // N/A
    // 
    // Bits[31:31], RO, default = 0x0
    //
    UINTX rsvd : 1;
  } Bits;
  UINTX Data;
} CPPM_CG_POL2A_PMC_PCI_MMR_STRUCT;
#endif // ASM_INC

#define CPPM_CG_POL2B_PMC_PCI_MMR_REG                      0x00000344
#ifndef ASM_INC
typedef union {
  struct {
    //
    // When CPPM is enabled as a qualifier for shutting down clock source group 2, the
    // current TNTE must be greater than or equal to the value programmed in this field
    // in order for shutdown to be allowed. If the current TNTE is less than the value
    // in this field then the PMC will block shutdown.[br] 
    //                 Note: If the clock source is already shutdown when the current
    // TNTE falls below the value in this field then the PMC must trigger a pre-wake
    // so that the clock is available when TNTE expires.[br] 
    //                 The format of this field matches the TNTE field of the PM_Req/Rsp/Dmd
    // messages on DMI. 
    // 
    // Bits[25:0], RW, default = 0x0
    //
    UINTX tnte_g2_pre_wake : 26;
    //
    // N/A
    // 
    // Bits[31:26], RO, default = 0x0
    //
    UINTX rsvd : 6;
  } Bits;
  UINTX Data;
} CPPM_CG_POL2B_PMC_PCI_MMR_STRUCT;
#endif // ASM_INC

#define CPPMVRIC2_PMC_PCI_MMR_REG                          0x0000034C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Each bit in this register determines whether the corresponding PCIe clock request
    // pin (SRC[bit #]CLKRQ#) is enabled as a VR Idle break event / entry inhibitor.[br]
    // 
    // For example, if CLKRQ_VRI_EN[0] = '1'  then SRC0CLKRQ# must be a '1' in order
    // for SLP_S0# to be asserted and if SRC0CLKRQ# goes to '0' then it will cause SLP_S0#
    // to be deasserted.  On the other hand, if CLKRQ_VRI_EN[0] = '0' then the state
    // of SRC0CLKRQ# has no impact on SLP_S0#.[br] 
    // 
    // Note: These bits are only applicable on SPT-H.
    // 
    // 
    // Bits[9:0], RW, default = 0x0
    //
    UINTX clkrq_vri_en : 10;
    //
    // This value is used to determine when to release the [quote]hold off[quote] of
    // the 
    //       IsCLK Crystal Oscillator upon detection of a SLP_S0# de-assertion event.
    //  It has a 10us granularity.[br] 
    // 00h = 0us[br]
    // 01h = 10us[br]
    // 02h = 20us[br]
    // ...[br]
    // 3Fh = 630us[br]
    // Note: the value programmed in this register should match the time needed to adjust
    // the VR output to the nominal value (if margined while SLP_S0# was asserted), not
    // for the full VR light load mode exit.  i.e. the ~50mV VR ramp time. 
    // 
    // Bits[15:10], RW, default = 0x0
    //
    UINTX xtal_reen_time : 6;
    //
    // 0 = 1V IO Voltage margining is not supported.  PMC does not notify the Ring Oscillator
    // circuit prior to asserting or de-asserting SLP_S0#. 
    //           [br]1 = 1V IO Voltage margining is supported.  PMC notifies the Ring
    // Oscillator circuit prior to asserting or de-asserting SLP_S0#. 
    // 		  [br]This bit is Not for EDS and is a reserved Intel test mode.
    // 		  [br]It is to be used only in conjunction with the ROSC mode in which the ROSC
    // clock output is ungated during voltage transition and recalibration window. 
    // 
    // Bits[16:16], RW, default = 0x0
    //
    UINTX io_volt_margin_en : 1;
    //
    // 0 = SLP_S0# assertion requires the CPU to be in a C10 state.
    // 			[br]1 = SLP_S0# assertion does not require the CPU to be in a C10 state.
    // 
    // Bits[17:17], RW, default = 0x0
    //
    UINTX cpuc10qdis : 1;
    //
    // 0 = SLP_S0# assertion requires the IsCLK PLL to be shut down.
    // 			[br]1 = SLP_S0# assertion does not require the IsCLK PLL to be shut down.
    // 
    // Bits[18:18], RW, default = 0x0
    //
    UINTX iccpllsdqdis : 1;
    //
    // 0 = SLP_S0# assertion requires the Audio PLL to be shut down.
    // 			[br]1 = SLP_S0# assertion does not require the Audio PLL to be shut down.
    // 
    // Bits[19:19], RW, default = 0x0
    //
    UINTX apllsdqdis : 1;
    //
    // 0 = SLP_S0# assertion requires the USB2 PLL to be shut down.
    // 			[br]1 = SLP_S0# assertion does not require the USB2 PLL to be shut down.
    // 
    // Bits[20:20], RW, default = 0x0
    //
    UINTX usb2pllsdqdis : 1;
    //
    // 0 = SLP_S0# assertion requires all lanes of the ModPHY Core Power Domain to be
    // gated. 
    // 			[br]1 = SLP_S0# assertion does not require all lanes of the ModPHY Core Power
    // Domain to be gated. 
    // 
    // Bits[21:21], RW, default = 0x0
    //
    UINTX mphycpgqdis : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[28:22], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 7;
    //
    // 0 = SLP_S0# assertion requires the USB Device controller to be in D3
    //           [br]1 = SLP_S0# assertion does not require the USB Device controller
    // to be in D3 
    // 
    // Bits[29:29], RW, default = 0x0
    //
    UINTX usbdevd3qdis : 1;
    //
    // 0 = SLP_S0# assertion requires the SATA controller to be in D3
    //           [br]1 = SLP_S0# assertion does not require the SATA controller to be
    // in D3 
    // 
    // Bits[30:30], RW, default = 0x0
    //
    UINTX satad3qdis : 1;
    //
    // 0 = SLP_S0# assertion requires all PCIe ports and their controllers to allow for
    // Low Voltage mode entry. 
    //           [br]1 = SLP_S0# assertion does not require all PCIe ports and their
    // controllers to allow for Low Voltage mode entry 
    // 
    // Bits[31:31], RW, default = 0x0
    //
    UINTX pcielvqdis : 1;
  } Bits;
  UINTX Data;
} CPPMVRIC2_PMC_PCI_MMR_STRUCT;
#endif // ASM_INC

#define CUR_PLT_PMC_PCI_MMR_REG                            0x00000350
#ifndef ASM_INC
typedef union {
  struct {
    //
    // SL portion of the current PLT.  Matches the format of the corresponding field
    // in the PM_* DMI messages - see the [quote]PM_Req / PM_Rsp / PM_Dmd Message Data[quote]
    // section later in this chapter. 
    // 
    // Bits[8:0], RO/V, default = 0x0
    //
    UINTX plt_sl : 9;
    //
    // Reserved PLT Latency
    // 
    // Bits[17:9], RO, default = 0x0
    //
    UINTX rsvd_plt : 9;
    //
    // NL portion of the current PLT.  Matches the format of the corresponding field
    // in the PM_* DMI messages - see the [quote]PM_Req / PM_Rsp / PM_Dmd Message Data[quote]
    // section later in this chapter. 
    // 
    // Bits[26:18], RO/V, default = 0x0
    //
    UINTX plt_nl : 9;
    //
    // N/A
    // 
    // Bits[31:27], RO, default = 0x0
    //
    UINTX rsvd : 5;
  } Bits;
  UINTX Data;
} CUR_PLT_PMC_PCI_MMR_STRUCT;
#endif // ASM_INC

#define CUR_ASLT_PMC_PCI_MMR_REG                           0x00000354
#ifndef ASM_INC
typedef union {
  struct {
    //
    // SL portion of the current ASLT.  Matches the format of the corresponding field
    // in the PM_* DMI messages - see the [quote]PM_Req / PM_Rsp / PM_Dmd Message Data[quote]
    // section later in this chapter. 
    // 
    // Bits[8:0], RO/V, default = 0x1FF
    //
    UINTX aslt_sl : 9;
    //
    // N/A
    // 
    // Bits[17:9], RO, default = 0x1FF
    //
    UINTX rsvd_aslt : 9;
    //
    // NL portion of the current ASLT.  Matches the format of the corresponding field
    // in the PM_* DMI messages - see the [quote]PM_Req / PM_Rsp / PM_Dmd Message Data[quote]
    // section later in this chapter. 
    // 
    // Bits[26:18], RO/V, default = 0x1FF
    //
    UINTX aslt_nl : 9;
    //
    // N/A
    // 
    // Bits[31:27], RO, default = 0x0
    //
    UINTX rsvd : 5;
  } Bits;
  UINTX Data;
} CUR_ASLT_PMC_PCI_MMR_STRUCT;
#endif // ASM_INC

#define LAST_PMRSPDMD1_PMC_PCI_MMR_REG                     0x00000358
#ifndef ASM_INC
typedef union {
  struct {
    //
    // N/A
    // 
    // Bits[0:0], RO, default = 0x0
    //
    UINTX rsvd_last_val1 : 1;
    //
    // Use in conjunction with LAST_SL bit field
    // 
    // Bits[3:1], RO/V, default = 0x7
    //
    UINTX last_scale_sl : 3;
    //
    // Use in conjunction with LAST_NL bit field
    // 
    // Bits[6:4], RO/V, default = 0x7
    //
    UINTX last_scale_nl : 3;
    //
    // N/A
    // 
    // Bits[7:7], RO/V, default = 0x1
    //
    UINTX last_ea : 1;
    //
    // N/A
    // 
    // Bits[8:8], RO/V, default = 0x0
    //
    UINTX last_cf : 1;
    //
    // N/A
    // 
    // Bits[9:9], RO/V, default = 0x0
    //
    UINTX last_vnn_off : 1;
    //
    // N/A
    // 
    // Bits[10:10], RO/V, default = 0x0
    //
    UINTX last_fs : 1;
    //
    // Use in conjunction with LAST_SCALE_SL bit field
    // 
    // Bits[20:11], RO/V, default = 0x3FF
    //
    UINTX last_sl : 10;
    //
    // Use in conjunction with LAST_SCALE_NL bit field
    // 
    // Bits[30:21], RO/V, default = 0x3FF
    //
    UINTX last_nl : 10;
    //
    // N/A
    // 
    // Bits[31:31], RO/V, default = 0x0
    //
    UINTX rsvd31 : 1;
  } Bits;
  UINTX Data;
} LAST_PMRSPDMD1_PMC_PCI_MMR_STRUCT;
#endif // ASM_INC

#define LAST_PMRSPDMD2_PMC_PCI_MMR_REG                     0x0000035C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // N/A
    // 
    // Bits[3:0], RO/V, default = 0x0
    //
    UINTX last_sl_id : 4;
    //
    // N/A
    // 
    // Bits[7:4], RO/V, default = 0x0
    //
    UINTX last_nl_id : 4;
    //
    // N/A
    // 
    // Bits[31:8], RO/V, default = 0x0
    //
    UINTX last_tnte : 24;
  } Bits;
  UINTX Data;
} LAST_PMRSPDMD2_PMC_PCI_MMR_STRUCT;
#endif // ASM_INC

#define LTR_PCIE0_PMC_PCI_MMR_REG                          0x00000360
#ifndef ASM_INC
typedef union {
  struct {
    //
    // The format of this register matches the data payload of the LTR IOSF SBI message
    // - see the IOSF spec or the LTR section later in this chapter. 
    // 
    // Bits[31:0], RO/V, default = 0x0
    //
    UINTX ltr_pcie0 : 32;
  } Bits;
  UINTX Data;
} LTR_PCIE0_PMC_PCI_MMR_STRUCT;
#endif // ASM_INC

#define LTR_PCIE1_PMC_PCI_MMR_REG                          0x00000364
#ifndef ASM_INC
typedef union {
  struct {
    //
    // The format of this register matches the data payload of the LTR IOSF SBI message
    // - see the IOSF spec or the LTR section later in this chapter. 
    // 
    // Bits[31:0], RO/V, default = 0x0
    //
    UINTX ltr_pcie1 : 32;
  } Bits;
  UINTX Data;
} LTR_PCIE1_PMC_PCI_MMR_STRUCT;
#endif // ASM_INC

#define LTR_XHCI_PMC_PCI_MMR_REG                           0x00000368
#ifndef ASM_INC
typedef union {
  struct {
    //
    // The format of this register matches the data payload of the LTR IOSF SBI message
    // - see the IOSF spec or the LTR section later in this chapter. 
    // 
    // Bits[31:0], RO/V, default = 0x0
    //
    UINTX ltr_xhci : 32;
  } Bits;
  UINTX Data;
} LTR_XHCI_PMC_PCI_MMR_STRUCT;
#endif // ASM_INC

#define LTR_SATA0_PMC_PCI_MMR_REG                          0x0000036C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // The format of this register matches the data payload of the LTR IOSF SBI message
    // - see the IOSF spec or the LTR section later in this chapter. 
    // 
    // Bits[31:0], RO/V, default = 0x0
    //
    UINTX ltr_sata0 : 32;
  } Bits;
  UINTX Data;
} LTR_SATA0_PMC_PCI_MMR_STRUCT;
#endif // ASM_INC

#define LTR_SATA1_PMC_PCI_MMR_REG                          0x00000370
#ifndef ASM_INC
typedef union {
  struct {
    //
    // The format of this register matches the data payload of the LTR IOSF SBI message
    // - see the IOSF spec or the LTR section later in this chapter. 
    // 
    // Bits[31:0], RO/V, default = 0x0
    //
    UINTX ltr_sata1 : 32;
  } Bits;
  UINTX Data;
} LTR_SATA1_PMC_PCI_MMR_STRUCT;
#endif // ASM_INC

#define LTR_SCC_PMC_PCI_MMR_REG                            0x00000378
#ifndef ASM_INC
typedef union {
  struct {
    //
    // The format of this register matches the data payload of the LTR IOSF SBI message
    // - see the IOSF spec or the LTR section later in this chapter. 
    // 
    // Bits[31:0], RO/V, default = 0x0
    //
    UINTX ltr_scc : 32;
  } Bits;
  UINTX Data;
} LTR_SCC_PMC_PCI_MMR_STRUCT;
#endif // ASM_INC

#define LTR_ESPISPI_PMC_PCI_MMR_REG                        0x0000037C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // The format of this register matches the data payload of the LTR IOSF SBI message
    // - see the IOSF spec or the LTR section later in this chapter. 
    // 
    // Bits[31:0], RO/V, default = 0x0
    //
    UINTX ltr_espispi : 32;
  } Bits;
  UINTX Data;
} LTR_ESPISPI_PMC_PCI_MMR_STRUCT;
#endif // ASM_INC

#define LTR_MAC0_PMC_PCI_MMR_REG                           0x00000380
#ifndef ASM_INC
typedef union {
  struct {
    //
    // The format of this register matches the data payload of the LTR IOSF SBI message
    // - see the IOSF spec or the LTR section later in this chapter. 
    // 
    // Bits[31:0], RO/V, default = 0x0
    //
    UINTX ltr_mac0 : 32;
  } Bits;
  UINTX Data;
} LTR_MAC0_PMC_PCI_MMR_STRUCT;
#endif // ASM_INC

#define LTR_MAC1_PMC_PCI_MMR_REG                           0x00000384
#ifndef ASM_INC
typedef union {
  struct {
    //
    // The format of this register matches the data payload of the LTR IOSF SBI message
    // - see the IOSF spec or the LTR section later in this chapter. 
    // 
    // Bits[31:0], RO/V, default = 0x0
    //
    UINTX ltr_mac1 : 32;
  } Bits;
  UINTX Data;
} LTR_MAC1_PMC_PCI_MMR_STRUCT;
#endif // ASM_INC

#define LTR_ME_PMC_PCI_MMR_REG                             0x00000388
#ifndef ASM_INC
typedef union {
  struct {
    //
    // The format of this register matches the data payload of the LTR IOSF SBI message
    // - see the IOSF spec or the LTR section later in this chapter. 
    // 
    // Bits[31:0], RO/V, default = 0x0
    //
    UINTX ltr_me : 32;
  } Bits;
  UINTX Data;
} LTR_ME_PMC_PCI_MMR_STRUCT;
#endif // ASM_INC

#define LTR_IE_PMC_PCI_MMR_REG                             0x0000038C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // The format of this register matches the data payload of the LTR IOSF SBI message
    // - see the IOSF spec or the LTR section later in this chapter. 
    // 
    // Bits[31:0], RO/V, default = 0x0
    //
    UINTX ltr_ie : 32;
  } Bits;
  UINTX Data;
} LTR_IE_PMC_PCI_MMR_STRUCT;
#endif // ASM_INC

#define LTR_XHCI_IOSFP_PMC_PCI_MMR_REG                     0x00000390
#ifndef ASM_INC
typedef union {
  struct {
    //
    // The format of this register matches the data payload of the LTR IOSF SBI message
    // - see the IOSF spec or the LTR section later in this chapter. 
    // 
    // Bits[31:0], RO/V, default = 0x0
    //
    UINTX ltr_xhci_iosfp : 32;
  } Bits;
  UINTX Data;
} LTR_XHCI_IOSFP_PMC_PCI_MMR_STRUCT;
#endif // ASM_INC

#define LTR_RSVD1_PMC_PCI_MMR_REG                          0x00000394
#ifndef ASM_INC
typedef union {
  struct {
    //
    // The format of this register matches the data payload of the LTR IOSF SBI message
    // - see the IOSF spec or the LTR section later in this chapter. 
    // 
    // Bits[31:0], RO/V, default = 0x0
    //
    UINTX ltr_rsvd1 : 32;
  } Bits;
  UINTX Data;
} LTR_RSVD1_PMC_PCI_MMR_STRUCT;
#endif // ASM_INC

#define LTR_RSVD2_PMC_PCI_MMR_REG                          0x00000398
#ifndef ASM_INC
typedef union {
  struct {
    //
    // The format of this register matches the data payload of the LTR IOSF SBI message
    // - see the IOSF RSVD2c or the LTR section later in this chapter. 
    // 
    // Bits[31:0], RO/V, default = 0x0
    //
    UINTX ltr_rsvd2 : 32;
  } Bits;
  UINTX Data;
} LTR_RSVD2_PMC_PCI_MMR_STRUCT;
#endif // ASM_INC

#define CPPM_CG_POL3A_PMC_PCI_MMR_REG                      0x000003A8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // When CPPM is enabled as a qualifier for shutting down clock source group 3, the
    // current PLT/ASLT (which LT is based on config) must be greater than or equal to
    // the value programmed in this field in order for shutdown to be allowed.[br] 
    //                 If the current PLT/ASLT is less than the value in this field then
    // the PMC will block shutdown. 
    // 
    // Bits[8:0], RW, default = 0x0
    //
    UINTX ltr_g3_thresh : 9;
    //
    // N/A
    // 
    // Bits[15:9], RO, default = 0x0
    //
    UINTX rsvd_15_9 : 7;
    //
    // N/A
    // 
    // Bits[24:16], RO, default = 0x0
    //
    UINTX rsvd_g3 : 9;
    //
    // N/A
    // 
    // Bits[28:25], RO, default = 0x0
    //
    UINTX rsvd_28_25 : 4;
    //
    // When the CPPM qualifier is enabled, the value of LT_G3_SEL determines whether
    // ASLT or PLT is used for the comparison against LTR_G3_THRESH.[br] 
    //                 Encoding:[br]
    //                 0 : ASLT[br]
    //                 1 : PLT
    // 
    // Bits[29:29], RW, default = 0x0
    //
    UINTX lt_g3_sel : 1;
    //
    // When this bit is set to '1', the CPPM-related qualifiers (specifically, PLT, IRT,
    // and TNTE) are enabled as required conditions to be met in order for the PMC to
    // indicate that clock source Group 3 shutdown is allowed.[br] 
    //                 When this bit is a '0' the above qualifiers do not affect PMC's
    // input to shutdown. 
    // 
    // Bits[30:30], RW, default = 0x0
    //
    UINTX cppm_g3_qual : 1;
    //
    // N/A
    // 
    // Bits[31:31], RO, default = 0x0
    //
    UINTX rsvd_31 : 1;
  } Bits;
  UINTX Data;
} CPPM_CG_POL3A_PMC_PCI_MMR_STRUCT;
#endif // ASM_INC

#define CPPM_CG_POL3B_PMC_PCI_MMR_REG                      0x000003AC
#ifndef ASM_INC
typedef union {
  struct {
    //
    // When CPPM is enabled as a qualifier for shutting down clock source group 3, the
    // current TNTE must be greater than or equal to the value programmed in this field
    // in order for shutdown to be allowed. If the current TNTE is less than the value
    // in this field then the PMC will block shutdown.[br] 
    //                 Note: If the clock source is already shutdown when the current
    // TNTE falls below the value in this field then the PMC must trigger a pre-wake
    // so that the clock is available when TNTE expires.[br] 
    //                 The format of this field matches the TNTE field of the PM_Req/Rsp/Dmd
    // messages on DMI. 
    // 
    // Bits[25:0], RW, default = 0x0
    //
    UINTX tnte_g3_pre_wake : 26;
    //
    // N/A
    // 
    // Bits[31:26], RO, default = 0x0
    //
    UINTX rsvd31_17 : 6;
  } Bits;
  UINTX Data;
} CPPM_CG_POL3B_PMC_PCI_MMR_STRUCT;
#endif // ASM_INC

#define PM_SYNC_DATA_0_PMC_PCI_MMR_REG                     0x000003B0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // This field contains bits 31:0 of the last PM_SYNC message sent by the PMC.
    // 
    // Bits[31:0], RO/V, default = 0x0
    //
    UINTX pm_sync_data_val_0 : 32;
  } Bits;
  UINTX Data;
} PM_SYNC_DATA_0_PMC_PCI_MMR_STRUCT;
#endif // ASM_INC

#define PM_SYNC_DATA_1_PMC_PCI_MMR_REG                     0x000003B4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // This field contains bits 63:32 of the last PM_SYNC message sent by the PMC.
    // 
    // Bits[31:0], RO/V, default = 0x0
    //
    UINTX pm_sync_data_val_1 : 32;
  } Bits;
  UINTX Data;
} PM_SYNC_DATA_1_PMC_PCI_MMR_STRUCT;
#endif // ASM_INC

#define PM_SYNC_DATA_2_PMC_PCI_MMR_REG                     0x000003B8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // This field contains bits 95:64 of the last PM_SYNC message sent by the PMC.
    // 
    // Bits[31:0], RO/V, default = 0x0
    //
    UINTX pm_sync_data_val_2 : 32;
  } Bits;
  UINTX Data;
} PM_SYNC_DATA_2_PMC_PCI_MMR_STRUCT;
#endif // ASM_INC

#define PM_DOWN_DATA_0_PMC_PCI_MMR_REG                     0x000003C0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // This field contains bits 31:0 of the last PM_DOWN message received from the CPU.
    // 
    // Bits[31:0], RO/V, default = 0x0
    //
    UINTX pm_down_data_val_0 : 32;
  } Bits;
  UINTX Data;
} PM_DOWN_DATA_0_PMC_PCI_MMR_STRUCT;
#endif // ASM_INC

#define PM_DOWN_DATA_1_PMC_PCI_MMR_REG                     0x000003C4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // This field contains bits 63:32 of the last PM_DOWN message received from the CPU.
    // 
    // Bits[31:0], RO/V, default = 0x0
    //
    UINTX pm_down_data_val_1 : 32;
  } Bits;
  UINTX Data;
} PM_DOWN_DATA_1_PMC_PCI_MMR_STRUCT;
#endif // ASM_INC

#define PM_DOWN_DATA_2_PMC_PCI_MMR_REG                     0x000003C8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // This field contains bits 87:64 of the last PM_DOWN message received from the CPU.
    // 
    // Bits[23:0], RO/V, default = 0x0
    //
    UINTX pm_down_data_val_2 : 24;
    //
    // N/A
    // 
    // Bits[31:24], RO, default = 0x0
    //
    UINTX rsvd_31_24 : 8;
  } Bits;
  UINTX Data;
} PM_DOWN_DATA_2_PMC_PCI_MMR_STRUCT;
#endif // ASM_INC

#define CPPMFALIGNCTL_1_PMC_PCI_MMR_REG                    0x000003D0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Upon the event that all conditions are satisfied for PCH Forced Alignment, a timer
    // is started. 
    //               Any wake event occurring before the timer expires causes the timer
    // to reset to FAIDLEWAIT value. 
    //           [br]
    //           [br]Once the timer expires and there are no wake events, the Force Alignment
    // mechanism can be invoked. 
    //           [br]
    //           [br]00h: 0us
    //           [br]01h: 1us
    //           [br]...
    //           [br]FFh: 255us
    // 
    // Bits[7:0], RW/L, default = 0x5
    //
    UINTX faidlewait : 8;
    //
    // PKG Cx state must be greater than or equal to MINCXSAFA
    //           [br]00: C0
    //           [br]01: C2
    //           [br]10: C3
    //           [br]11: C6
    // 
    // Bits[9:8], RW/L, default = 0x2
    //
    UINTX mincxsafa : 2;
    //
    // 1 = the CSME (CSE PG domain) does not have to be power gated to allow PCH Force
    // Alignment mechanism. 
    //           [br]0 = the CSME (CSE PG domain) does have to be power gated to allow
    // PCH Force Alignment mechanism. 
    // 
    // Bits[10:10], RW/L, default = 0x0
    //
    UINTX facsmepgqdis : 1;
    //
    // 1 = Upon entering forced alignment PSF stall, PMC blocks the backbone PLL from
    //               re-enabling due to normal wake events.  This block is released at
    // the wake timer expiration. 
    //           [br]0 = PMC does not block the backbone PLL from re-enabling during
    // forced alignment PSF stall. 
    // 
    // Bits[11:11], RW/L, default = 0x0
    //
    UINTX dpllrdfa : 1;
    //
    // 1 = PMC exits forced alignment PSF stall when TNTE < TNTE_G1_PRE_WAKE
    //           [br]0 = PMC does not exit forced alignment PSF stall when TNTE < TNTE_PRE_G1_WAKE
    // 
    // Bits[12:12], RW/L, default = 0x0
    //
    UINTX fag1tntepwen : 1;
    //
    // 1 = PMC exits forced alignment PSF stall when TNTE < TNTE_G2_PRE_WAKE
    //           [br]0 = PMC does not exit forced alignment PSF stall when TNTE < TNTE_PRE_G2_WAKE
    // 
    // Bits[13:13], RW/L, default = 0x1
    //
    UINTX fag2tntepwen : 1;
    //
    // N/A
    // 
    // Bits[15:14], RO, default = 0x0
    //
    UINTX rsvd : 2;
    //
    // 00h: 0us
    //           [br]01h:1us
    //           [br]...
    //           [br]3Fh:63us
    //           [br]
    //           [br]Note: this should be programmed to be the worst case PKG C2 memory
    // access latency 
    //           (ie time to receive first data packet back from system memory) including
    // CPU + PCH delays. 
    // 
    // Bits[21:16], RW/L, default = 0x0
    //
    UINTX cpupkgc2lat : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[29:22], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 8;
    //
    // When set this bit locks bits 30 through 0 of this register.
    // 
    // Bits[30:30], RW/L, default = 0x0
    //
    UINTX cppmfactllock : 1;
    //
    // 1 = PMC allows stalling of the backbone and preventing CPU wakes (via PM_SYNC
    // messages) 
    //                   when PCH idle (FAIDLEWAIT and FACSMEPGQDIS) and Cx requirements
    // (CPUPKGC2LAT) are 
    //                   met.  It ceases the stall when the maximum wake time point is
    // met. 
    //           [br]0 = PMC does not allow stalling of the backbone.
    //           [br]
    //           [br]*Note this bit can be programmed dynamically by system SW.
    // 
    // Bits[31:31], RW, default = 0x0
    //
    UINTX cppmfaen : 1;
  } Bits;
  UINTX Data;
} CPPMFALIGNCTL_1_PMC_PCI_MMR_STRUCT;
#endif // ASM_INC

#define CPPM_MPG_POL1A_PMC_PCI_MMR_REG                     0x000003E0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // When CPPM is enabled as a qualifier for shutting down the modPHY, the current
    // PLT/ASLT (which LT is based on config) must be greater than or equal to the value
    // programmed in this field in order for shutdown to be allowed. If the current PLT/ASLT
    // is less than the value in this field then the PMC will block shutdown.[br] 
    //                 The format of this field matches the NL and SL fields of the PM_Req/Rsp/Dmd
    // messages on DMI. 
    // 
    // Bits[8:0], RW, default = 0x0
    //
    UINTX ltr_mphy_thresh : 9;
    //
    // N/A
    // 
    // Bits[28:9], RO, default = 0x0
    //
    UINTX rsvd_28_9 : 20;
    //
    // When the CPPM qualifier is enabled, the value of LT_MPHY_SEL determines whether
    // ASLT or PLT is used for the comparison against LTR_MPHY_THRESH.[br] 
    //                 Encoding:[br]
    //                 0 : ASLT[br]
    //                 1 : PLT
    // 
    // Bits[29:29], RW, default = 0x0
    //
    UINTX lt_mphy_sel : 1;
    //
    // When this bit is set to '1', the CPPM-related qualifiers (specifically, PLT and
    // TNTE) are enabled as required conditions to be met in order for the PMC to indicate
    // that modPHY shutdown is allowed.[br] 
    //                 When this bit is a '0' the above qualifiers do not affect PMC's
    // input to shutdown. 
    // 
    // Bits[30:30], RW, default = 0x0
    //
    UINTX cppm_mphy_qual : 1;
    //
    // N/A
    // 
    // Bits[31:31], RO, default = 0x0
    //
    UINTX rsvd_31_31 : 1;
  } Bits;
  UINTX Data;
} CPPM_MPG_POL1A_PMC_PCI_MMR_STRUCT;
#endif // ASM_INC

#define CPPM_MPG_POL1B_PMC_PCI_MMR_REG                     0x000003E4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // When CPPM is enabled as a qualifier for shutting down modPHY, the current TNTE
    // must be greater than or equal to the value programmed in this field in order for
    // shutdown to be allowed. If the current TNTE is less than the value in this field
    // then the PMC will block shutdown.[br] 
    //                 Note: If the modPHY is already shutdown when the current TNTE
    // falls below the value in this field then the PMC must trigger a pre-wake so that
    // the modPHY (and associated PLLs) is available when TNTE expires.[br] 
    //                 The format of this field matches the TNTE field of the PM_Req/Rsp/Dmd
    // messages on DMI. 
    // 
    // Bits[25:0], RW, default = 0x0
    //
    UINTX tnte_mphy_pre_wake : 26;
    //
    // N/A
    // 
    // Bits[31:26], RO, default = 0x0
    //
    UINTX rsvd_31_26 : 6;
  } Bits;
  UINTX Data;
} CPPM_MPG_POL1B_PMC_PCI_MMR_STRUCT;
#endif // ASM_INC

#define CS_SD_CTL1_PMC_PCI_MMR_REG                         0x000003E8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // See CS1_CTL_CTL; controls mapping of dynamic shutdown comparators to clock source
    // 1. 
    // 
    // Bits[2:0], RW, default = 0x0
    //
    UINTX cs1_ctl_cfg : 3;
    //
    // N/A
    // 
    // Bits[4:3], RO, default = 0x0
    //
    UINTX rsvd_4_3 : 2;
    //
    // See CS1_CTL_CTL; controls mapping of dynamic shutdown comparators to clock source
    // 2. 
    // 
    // Bits[7:5], RW, default = 0x0
    //
    UINTX cs2_ctl_cfg : 3;
    //
    // N/A
    // 
    // Bits[9:8], RO, default = 0x0
    //
    UINTX rsvd_9_8 : 2;
    //
    // See CS1_CTL_CTL; controls mapping of dynamic shutdown comparators to clock source
    // 3. 
    // 
    // Bits[12:10], RW, default = 0x0
    //
    UINTX cs3_ctl_cfg : 3;
    //
    // N/A
    // 
    // Bits[14:13], RO, default = 0x0
    //
    UINTX rsvd_14_13 : 2;
    //
    // See CS1_CTL_CTL; controls mapping of dynamic shutdown comparators to clock source
    // 4. 
    // 
    // Bits[17:15], RW, default = 0x0
    //
    UINTX cs4_ctl_cfg : 3;
    //
    // N/A
    // 
    // Bits[19:18], RO, default = 0x0
    //
    UINTX rsvd_19_18 : 2;
    //
    // See CS1_CTL_CTL; controls mapping of dynamic shutdown comparators to clock source
    // 5. 
    // 
    // Bits[22:20], RW, default = 0x0
    //
    UINTX cs5_ctl_cfg : 3;
    //
    // N/A
    // 
    // Bits[31:23], RO, default = 0x0
    //
    UINTX rsvd_31_16 : 9;
  } Bits;
  UINTX Data;
} CS_SD_CTL1_PMC_PCI_MMR_STRUCT;
#endif // ASM_INC

#define CS_SD_CTL2_PMC_PCI_MMR_REG                         0x000003EC
#ifndef ASM_INC
typedef union {
  struct {
    //
    // When this bit is set to 1, the PLLOFFOK signal for clock source 1 will always
    // be 0 while EA is 1.  This bit takes precedence over the CPPM dynamic qualifiers.
    //  So if this bit is 1 and EA is 0, PLLOFFOK will be 0 even if the dynamic qualifiers
    // are satisfied.[br] 
    //                 Note: The static BIOS and PMC overrides, if enabled, will force
    // PLLOFFOK to 0 or 1 regardless of how this bit is programmed.[br] 
    //                 See chapter 16.4 for details on the clock source mapping.
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINTX cs1_ea_en : 1;
    //
    // See CS1_EA_EN; controls application of EA value to shutting down clock source
    // 2. 
    // 
    // Bits[1:1], RW, default = 0x0
    //
    UINTX cs2_ea_en : 1;
    //
    // See CS1_EA_EN; controls application of EA value to shutting down clock source
    // 3. 
    // 
    // Bits[2:2], RW, default = 0x0
    //
    UINTX cs3_ea_en : 1;
    //
    // See CS1_EA_EN; controls application of EA value to shutting down clock source
    // 4. 
    // 
    // Bits[3:3], RW, default = 0x0
    //
    UINTX cs4_ea_en : 1;
    //
    // See CS1_EA_EN; controls application of EA value to shutting down clock source
    // 5. 
    // 
    // Bits[4:4], RW, default = 0x0
    //
    UINTX cs5_ea_en : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[14:5], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 10;
    //
    // N/A
    // 
    // Bits[15:15], RO, default = 0x0
    //
    UINTX rsvd_15_15 : 1;
    //
    // See CS1_OVR_EN; when CS1_OVR_EN = 1, CS1_OVR_VAL will be driven on the PLLOFFOK
    // signal for clock source 1. 
    // 
    // Bits[16:16], RW, default = 0x0
    //
    UINTX cs1_ovr_en : 1;
    //
    // See CS1_OVR_EN; when CS2_OVR_EN = 1, CS2_OVR_VAL will be driven on the PLLOFFOK
    // signal for clock source 2. 
    // 
    // Bits[17:17], RW, default = 0x0
    //
    UINTX cs2_ovr_en : 1;
    //
    // See CS1_OVR_EN; when CS3_OVR_EN = 1, CS3_OVR_VAL will be driven on the PLLOFFOK
    // signal for clock source 3. 
    // 
    // Bits[18:18], RW, default = 0x0
    //
    UINTX cs3_ovr_en : 1;
    //
    // See CS1_OVR_EN; when CS4_OVR_EN = 1, CS4_OVR_VAL will be driven on the PLLOFFOK
    // signal for clock source 4. 
    // 
    // Bits[19:19], RW, default = 0x0
    //
    UINTX cs4_ovr_en : 1;
    //
    // See CS1_OVR_EN; when CS5_OVR_EN = 1, CS5_OVR_VAL will be driven on the PLLOFFOK
    // signal for clock source 5. 
    // 
    // Bits[20:20], RW, default = 0x0
    //
    UINTX cs5_ovr_en : 1;
    //
    // N/A
    // 
    // Bits[23:21], RO, default = 0x0
    //
    UINTX rsvd_23_21 : 3;
    //
    // See CS1_OVR_VAL; when CS1_OVR_EN = 1, CS5_OVR_VAL will be driven on the PLLOFFOK
    // signal for clock source 1. 
    // 
    // Bits[24:24], RW, default = 0x0
    //
    UINTX cs1_ovr_val : 1;
    //
    // See CS1_OVR_VAL; when CS2_OVR_EN = 1, CS5_OVR_VAL will be driven on the PLLOFFOK
    // signal for clock source 2. 
    // 
    // Bits[25:25], RW, default = 0x0
    //
    UINTX cs2_ovr_val : 1;
    //
    // See CS1_OVR_VAL; when CS3_OVR_EN = 1, CS5_OVR_VAL will be driven on the PLLOFFOK
    // signal for clock source 3. 
    // 
    // Bits[26:26], RW, default = 0x0
    //
    UINTX cs3_ovr_val : 1;
    //
    // See CS1_OVR_VAL; when CS4_OVR_EN = 1, CS5_OVR_VAL will be driven on the PLLOFFOK
    // signal for clock source 4. 
    // 
    // Bits[27:27], RW, default = 0x0
    //
    UINTX cs4_ovr_val : 1;
    //
    // See CS1_OVR_VAL; when CS5_OVR_EN = 1, CS5_OVR_VAL will be driven on the PLLOFFOK
    // signal for clock source 5. 
    // 
    // Bits[28:28], RW, default = 0x0
    //
    UINTX cs5_ovr_val : 1;
    //
    // N/A
    // 
    // Bits[31:29], RO, default = 0x0
    //
    UINTX rsvd_31_29 : 3;
  } Bits;
  UINTX Data;
} CS_SD_CTL2_PMC_PCI_MMR_STRUCT;
#endif // ASM_INC

#define PPAMR0_PMC_PCI_MMR_REG                             0x00000500
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Agent assigned to Priority 0 (refer to Chapter 32 for the mapping of Agent IDs
    // to Power-gating domains). 
    // 
    // Bits[5:0], RW/L, default = 0x0
    //
    UINTX mapid_pri0 : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:6], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
    //
    // Agent assigned to Priority 1 (refer to Chapter 32 for the mapping of Agent IDs
    // to Power-gating domains). 
    // 
    // Bits[13:8], RW/L, default = 0x1
    //
    UINTX mapid_pri1 : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[15:14], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 2;
    //
    // Agent assigned to Priority 2 (refer to Chapter 32 for the mapping of Agent IDs
    // to Power-gating domains). 
    // 
    // Bits[21:16], RW/L, default = 0x2
    //
    UINTX mapid_pri2 : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:22], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 2;
    //
    // Agent assigned to Priority 3 (refer to Chapter 32 for the mapping of Agent IDs
    // to Power-gating domains). 
    // 
    // Bits[29:24], RW/L, default = 0x3
    //
    UINTX mapid_pri3 : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:30], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_3 : 2;
  } Bits;
  UINTX Data;
} PPAMR0_PMC_PCI_MMR_STRUCT;
#endif // ASM_INC

#define PPAMR1_PMC_PCI_MMR_REG                             0x00000504
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Agent assigned to Priority 4 (refer to Chapter 32 for the mapping of Agent IDs
    // to Power-gating domains). 
    // 
    // Bits[5:0], RW/L, default = 0x4
    //
    UINTX mapid_pri4 : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:6], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
    //
    // Agent assigned to Priority 5 (refer to Chapter 32 for the mapping of Agent IDs
    // to Power-gating domains). 
    // 
    // Bits[13:8], RW/L, default = 0x5
    //
    UINTX mapid_pri5 : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[15:14], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 2;
    //
    // Agent assigned to Priority 6 (refer to Chapter 32 for the mapping of Agent IDs
    // to Power-gating domains). 
    // 
    // Bits[21:16], RW/L, default = 0x6
    //
    UINTX mapid_pri6 : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:22], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 2;
    //
    // Agent assigned to Priority 7 (refer to Chapter 32 for the mapping of Agent IDs
    // to Power-gating domains). 
    // 
    // Bits[29:24], RW/L, default = 0x7
    //
    UINTX mapid_pri7 : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:30], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_3 : 2;
  } Bits;
  UINTX Data;
} PPAMR1_PMC_PCI_MMR_STRUCT;
#endif // ASM_INC

#define PPAMR2_PMC_PCI_MMR_REG                             0x00000508
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Agent assigned to Priority 8 (refer to Chapter 32 for the mapping of Agent IDs
    // to Power-gating domains). 
    // 
    // Bits[5:0], RW/L, default = 0x8
    //
    UINTX mapid_pri8 : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:6], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
    //
    // Agent assigned to Priority 9 (refer to Chapter 32 for the mapping of Agent IDs
    // to Power-gating domains). 
    // 
    // Bits[13:8], RW/L, default = 0x9
    //
    UINTX mapid_pri9 : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[15:14], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 2;
    //
    // Agent assigned to Priority 10 (refer to Chapter 32 for the mapping of Agent IDs
    // to Power-gating domains). 
    // 
    // Bits[21:16], RW/L, default = 0xA
    //
    UINTX mapid_pri10 : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:22], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 2;
    //
    // Agent assigned to Priority 11 (refer to Chapter 32 for the mapping of Agent IDs
    // to Power-gating domains). 
    // 
    // Bits[29:24], RW/L, default = 0xB
    //
    UINTX mapid_pri11 : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:30], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_3 : 2;
  } Bits;
  UINTX Data;
} PPAMR2_PMC_PCI_MMR_STRUCT;
#endif // ASM_INC

#define PPAMR3_PMC_PCI_MMR_REG                             0x0000050C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Agent assigned to Priority 12 (refer to Chapter 32 for the mapping of Agent IDs
    // to Power-gating domains). 
    // 
    // Bits[5:0], RW/L, default = 0xC
    //
    UINTX mapid_pri12 : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:6], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
    //
    // Agent assigned to Priority 13 (refer to Chapter 32 for the mapping of Agent IDs
    // to Power-gating domains). 
    // 
    // Bits[13:8], RW/L, default = 0xD
    //
    UINTX mapid_pri13 : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[15:14], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 2;
    //
    // Agent assigned to Priority 14 (refer to Chapter 32 for the mapping of Agent IDs
    // to Power-gating domains). 
    // 
    // Bits[21:16], RW/L, default = 0xE
    //
    UINTX mapid_pri14 : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:22], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 2;
    //
    // Agent assigned to Priority 15 (refer to Chapter 32 for the mapping of Agent IDs
    // to Power-gating domains). 
    // 
    // Bits[29:24], RW/L, default = 0xF
    //
    UINTX mapid_pri15 : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:30], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_3 : 2;
  } Bits;
  UINTX Data;
} PPAMR3_PMC_PCI_MMR_STRUCT;
#endif // ASM_INC

#define PPAMR4_PMC_PCI_MMR_REG                             0x00000510
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Agent assigned to Priority 16 (refer to Chapter 32 for the mapping of Agent IDs
    // to Power-gating domains). 
    // 
    // Bits[5:0], RW/L, default = 0x10
    //
    UINTX mapid_pri16 : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:6], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
    //
    // Agent assigned to Priority 17 (refer to Chapter 32 for the mapping of Agent IDs
    // to Power-gating domains). 
    // 
    // Bits[13:8], RW/L, default = 0x11
    //
    UINTX mapid_pri17 : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[15:14], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 2;
    //
    // Agent assigned to Priority 18 (refer to Chapter 32 for the mapping of Agent IDs
    // to Power-gating domains). 
    // 
    // Bits[21:16], RW/L, default = 0x12
    //
    UINTX mapid_pri18 : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:22], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 2;
    //
    // Agent assigned to Priority 19 (refer to Chapter 32 for the mapping of Agent IDs
    // to Power-gating domains). 
    // 
    // Bits[29:24], RW/L, default = 0x13
    //
    UINTX mapid_pri19 : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:30], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_3 : 2;
  } Bits;
  UINTX Data;
} PPAMR4_PMC_PCI_MMR_STRUCT;
#endif // ASM_INC

#define PPAMR5_PMC_PCI_MMR_REG                             0x00000514
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Agent assigned to Priority 20 (refer to Chapter 32 for the mapping of Agent IDs
    // to Power-gating domains). 
    // 
    // Bits[5:0], RW/L, default = 0x14
    //
    UINTX mapid_pri20 : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:6], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
    //
    // Agent assigned to Priority 21 (refer to Chapter 32 for the mapping of Agent IDs
    // to Power-gating domains). 
    // 
    // Bits[13:8], RW/L, default = 0x15
    //
    UINTX mapid_pri21 : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[15:14], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 2;
    //
    // Agent assigned to Priority 22 (refer to Chapter 32 for the mapping of Agent IDs
    // to Power-gating domains). 
    // 
    // Bits[21:16], RW/L, default = 0x16
    //
    UINTX mapid_pri22 : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:22], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 2;
    //
    // Agent assigned to Priority 23 (refer to Chapter 32 for the mapping of Agent IDs
    // to Power-gating domains). 
    // 
    // Bits[29:24], RW/L, default = 0x17
    //
    UINTX mapid_pri23 : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:30], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_3 : 2;
  } Bits;
  UINTX Data;
} PPAMR5_PMC_PCI_MMR_STRUCT;
#endif // ASM_INC

#define PPAMR6_PMC_PCI_MMR_REG                             0x00000518
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Agent assigned to Priority 24 (refer to Chapter 32 for the mapping of Agent IDs
    // to Power-gating domains). 
    // 
    // Bits[5:0], RW/L, default = 0x18
    //
    UINTX mapid_pri24 : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:6], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
    //
    // Agent assigned to Priority 25 (refer to Chapter 32 for the mapping of Agent IDs
    // to Power-gating domains). 
    // 
    // Bits[13:8], RW/L, default = 0x19
    //
    UINTX mapid_pri25 : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[15:14], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 2;
    //
    // Agent assigned to Priority 26 (refer to Chapter 32 for the mapping of Agent IDs
    // to Power-gating domains). 
    // 
    // Bits[21:16], RW/L, default = 0x1A
    //
    UINTX mapid_pri26 : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:22], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 2;
    //
    // Agent assigned to Priority 27 (refer to Chapter 32 for the mapping of Agent IDs
    // to Power-gating domains). 
    // 
    // Bits[29:24], RW/L, default = 0x1B
    //
    UINTX mapid_pri27 : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:30], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_3 : 2;
  } Bits;
  UINTX Data;
} PPAMR6_PMC_PCI_MMR_STRUCT;
#endif // ASM_INC

#define PPAMR7_PMC_PCI_MMR_REG                             0x0000051C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Agent assigned to Priority 28 (refer to Chapter 32 for the mapping of Agent IDs
    // to Power-gating domains). 
    // 
    // Bits[5:0], RW/L, default = 0x1C
    //
    UINTX mapid_pri28 : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:6], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
    //
    // Agent assigned to Priority 29 (refer to Chapter 32 for the mapping of Agent IDs
    // to Power-gating domains). 
    // 
    // Bits[13:8], RW/L, default = 0x1D
    //
    UINTX mapid_pri29 : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[15:14], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 2;
    //
    // Agent assigned to Priority 30 (refer to Chapter 32 for the mapping of Agent IDs
    // to Power-gating domains). 
    // 
    // Bits[21:16], RW/L, default = 0x1E
    //
    UINTX mapid_pri30 : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:22], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 2;
    //
    // Agent assigned to Priority 31 (refer to Chapter 32 for the mapping of Agent IDs
    // to Power-gating domains). 
    // 
    // Bits[29:24], RW/L, default = 0x1F
    //
    UINTX mapid_pri31 : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:30], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_3 : 2;
  } Bits;
  UINTX Data;
} PPAMR7_PMC_PCI_MMR_STRUCT;
#endif // ASM_INC

#define PPAMR8_PMC_PCI_MMR_REG                             0x00000520
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Agent assigned to Priority 32 (refer to Chapter 32 for the mapping of Agent IDs
    // to Power-gating domains). 
    // 
    // Bits[5:0], RW/L, default = 0x20
    //
    UINTX mapid_pri32 : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:6], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
    //
    // Agent assigned to Priority 33 (refer to Chapter 32 for the mapping of Agent IDs
    // to Power-gating domains). 
    // 
    // Bits[13:8], RW/L, default = 0x21
    //
    UINTX mapid_pri33 : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[15:14], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 2;
    //
    // Agent assigned to Priority 34 (refer to Chapter 32 for the mapping of Agent IDs
    // to Power-gating domains). 
    // 
    // Bits[21:16], RW/L, default = 0x22
    //
    UINTX mapid_pri34 : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:22], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 2;
    //
    // Agent assigned to Priority 35 (refer to Chapter 32 for the mapping of Agent IDs
    // to Power-gating domains). 
    // 
    // Bits[29:24], RW/L, default = 0x23
    //
    UINTX mapid_pri35 : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:30], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_3 : 2;
  } Bits;
  UINTX Data;
} PPAMR8_PMC_PCI_MMR_STRUCT;
#endif // ASM_INC

#define PPAMR9_PMC_PCI_MMR_REG                             0x00000524
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Agent assigned to Priority 36 (refer to Chapter 32 for the mapping of Agent IDs
    // to Power-gating domains). 
    // 
    // Bits[5:0], RW/L, default = 0x24
    //
    UINTX mapid_pri36 : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:6], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
    //
    // Agent assigned to Priority 37 (refer to Chapter 32 for the mapping of Agent IDs
    // to Power-gating domains). 
    // 
    // Bits[13:8], RW/L, default = 0x25
    //
    UINTX mapid_pri37 : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[15:14], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 2;
    //
    // Agent assigned to Priority 38 (refer to Chapter 32 for the mapping of Agent IDs
    // to Power-gating domains). 
    // 
    // Bits[21:16], RW/L, default = 0x26
    //
    UINTX mapid_pri38 : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:22], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 2;
    //
    // Agent assigned to Priority 39 (refer to Chapter 32 for the mapping of Agent IDs
    // to Power-gating domains). 
    // 
    // Bits[29:24], RW/L, default = 0x27
    //
    UINTX mapid_pri39 : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:30], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_3 : 2;
  } Bits;
  UINTX Data;
} PPAMR9_PMC_PCI_MMR_STRUCT;
#endif // ASM_INC

#define PPAMR10_PMC_PCI_MMR_REG                            0x00000528
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Agent assigned to Priority 40 (refer to Chapter 32 for the mapping of Agent IDs
    // to Power-gating domains). 
    // 
    // Bits[5:0], RW/L, default = 0x28
    //
    UINTX mapid_pri40 : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:6], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
    //
    // Agent assigned to Priority 41 (refer to Chapter 32 for the mapping of Agent IDs
    // to Power-gating domains). 
    // 
    // Bits[13:8], RW/L, default = 0x29
    //
    UINTX mapid_pri41 : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[15:14], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 2;
    //
    // Agent assigned to Priority 42 (refer to Chapter 32 for the mapping of Agent IDs
    // to Power-gating domains). 
    // 
    // Bits[21:16], RW/L, default = 0x2A
    //
    UINTX mapid_pri42 : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:22], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 2;
    //
    // Agent assigned to Priority 43 (refer to Chapter 32 for the mapping of Agent IDs
    // to Power-gating domains). 
    // 
    // Bits[29:24], RW/L, default = 0x2B
    //
    UINTX mapid_pri43 : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:30], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_3 : 2;
  } Bits;
  UINTX Data;
} PPAMR10_PMC_PCI_MMR_STRUCT;
#endif // ASM_INC

#define PPAMR11_PMC_PCI_MMR_REG                            0x0000052C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Agent assigned to Priority 44 (refer to Chapter 32 for the mapping of Agent IDs
    // to Power-gating domains). 
    // 
    // Bits[5:0], RW/L, default = 0x2C
    //
    UINTX mapid_pri44 : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:6], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
    //
    // Agent assigned to Priority 45 (refer to Chapter 32 for the mapping of Agent IDs
    // to Power-gating domains). 
    // 
    // Bits[13:8], RW/L, default = 0x2D
    //
    UINTX mapid_pri45 : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[15:14], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 2;
    //
    // Agent assigned to Priority 46 (refer to Chapter 32 for the mapping of Agent IDs
    // to Power-gating domains). 
    // 
    // Bits[21:16], RW/L, default = 0x2E
    //
    UINTX mapid_pri46 : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:22], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 2;
    //
    // Agent assigned to Priority 47 (refer to Chapter 32 for the mapping of Agent IDs
    // to Power-gating domains). 
    // 
    // Bits[29:24], RW/L, default = 0x2F
    //
    UINTX mapid_pri47 : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:30], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_3 : 2;
  } Bits;
  UINTX Data;
} PPAMR11_PMC_PCI_MMR_STRUCT;
#endif // ASM_INC

#define PPAMR12_PMC_PCI_MMR_REG                            0x00000530
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Agent assigned to Priority 48 (refer to Chapter 32 for the mapping of Agent IDs
    // to Power-gating domains). 
    // 
    // Bits[5:0], RW/L, default = 0x30
    //
    UINTX mapid_pri48 : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:6], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
    //
    // Agent assigned to Priority 49 (refer to Chapter 32 for the mapping of Agent IDs
    // to Power-gating domains). 
    // 
    // Bits[13:8], RW/L, default = 0x31
    //
    UINTX mapid_pri49 : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[15:14], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 2;
    //
    // Agent assigned to Priority 50 (refer to Chapter 32 for the mapping of Agent IDs
    // to Power-gating domains). 
    // 
    // Bits[21:16], RW/L, default = 0x32
    //
    UINTX mapid_pri50 : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:22], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 2;
    //
    // Agent assigned to Priority 51 (refer to Chapter 32 for the mapping of Agent IDs
    // to Power-gating domains). 
    // 
    // Bits[29:24], RW/L, default = 0x33
    //
    UINTX mapid_pri51 : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:30], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_3 : 2;
  } Bits;
  UINTX Data;
} PPAMR12_PMC_PCI_MMR_STRUCT;
#endif // ASM_INC

#define PPAMR13_PMC_PCI_MMR_REG                            0x00000534
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Agent assigned to Priority 52 (refer to Chapter 32 for the mapping of Agent IDs
    // to Power-gating domains). 
    // 
    // Bits[5:0], RW/L, default = 0x34
    //
    UINTX mapid_pri52 : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:6], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
    //
    // Agent assigned to Priority 53 (refer to Chapter 32 for the mapping of Agent IDs
    // to Power-gating domains). 
    // 
    // Bits[13:8], RW/L, default = 0x35
    //
    UINTX mapid_pri53 : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[15:14], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 2;
    //
    // Agent assigned to Priority 54 (refer to Chapter 32 for the mapping of Agent IDs
    // to Power-gating domains). 
    // 
    // Bits[21:16], RW/L, default = 0x36
    //
    UINTX mapid_pri54 : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:22], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 2;
    //
    // Agent assigned to Priority 55 (refer to Chapter 32 for the mapping of Agent IDs
    // to Power-gating domains). 
    // 
    // Bits[29:24], RW/L, default = 0x37
    //
    UINTX mapid_pri55 : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:30], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_3 : 2;
  } Bits;
  UINTX Data;
} PPAMR13_PMC_PCI_MMR_STRUCT;
#endif // ASM_INC

#define PPAMR14_PMC_PCI_MMR_REG                            0x00000538
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Agent assigned to Priority 56 (refer to Chapter 32 for the mapping of Agent IDs
    // to Power-gating domains). 
    // 
    // Bits[5:0], RW/L, default = 0x38
    //
    UINTX mapid_pri56 : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:6], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
    //
    // Agent assigned to Priority 57 (refer to Chapter 32 for the mapping of Agent IDs
    // to Power-gating domains). 
    // 
    // Bits[13:8], RW/L, default = 0x39
    //
    UINTX mapid_pri57 : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[15:14], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 2;
    //
    // Agent assigned to Priority 58 (refer to Chapter 32 for the mapping of Agent IDs
    // to Power-gating domains). 
    // 
    // Bits[21:16], RW/L, default = 0x3A
    //
    UINTX mapid_pri58 : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:22], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 2;
    //
    // Agent assigned to Priority 59 (refer to Chapter 32 for the mapping of Agent IDs
    // to Power-gating domains). 
    // 
    // Bits[29:24], RW/L, default = 0x3B
    //
    UINTX mapid_pri59 : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:30], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_3 : 2;
  } Bits;
  UINTX Data;
} PPAMR14_PMC_PCI_MMR_STRUCT;
#endif // ASM_INC

#define PPAMR15_PMC_PCI_MMR_REG                            0x0000053C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Agent assigned to Priority 60 (refer to Chapter 32 for the mapping of Agent IDs
    // to Power-gating domains). 
    // 
    // Bits[5:0], RW/L, default = 0x3C
    //
    UINTX mapid_pri60 : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:6], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
    //
    // Agent assigned to Priority 61 (refer to Chapter 32 for the mapping of Agent IDs
    // to Power-gating domains). 
    // 
    // Bits[13:8], RW/L, default = 0x3D
    //
    UINTX mapid_pri61 : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[15:14], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 2;
    //
    // Agent assigned to Priority 62 (refer to Chapter 32 for the mapping of Agent IDs
    // to Power-gating domains). 
    // 
    // Bits[21:16], RW/L, default = 0x3E
    //
    UINTX mapid_pri62 : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:22], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 2;
    //
    // Agent assigned to Priority 63 (refer to Chapter 32 for the mapping of Agent IDs
    // to Power-gating domains). 
    // 
    // Bits[29:24], RW/L, default = 0x3F
    //
    UINTX mapid_pri63 : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:30], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_3 : 2;
  } Bits;
  UINTX Data;
} PPAMR15_PMC_PCI_MMR_STRUCT;
#endif // ASM_INC

#define PPASR0_PMC_PCI_MMR_REG                             0x00000580
#ifndef ASM_INC
typedef union {
  struct {
    //
    // This indicates the current status of the pmc_ip_pg_ack_b signal, corresponding
    // to Agent ID [n].[br] 
    // 0: IP may be power gated (pg_ack_b asserted)[br]
    // 1: IP may not be power gated (pg_ack_b deasserted)
    // 
    // Bits[0:0], RO/V, default = 0x0
    //
    UINTX agt0_pg_ack_sts : 1;
    //
    // Please see PPASR0.AGT0_PG_ACK_STS for details.
    // 
    // Bits[1:1], RO/V, default = 0x0
    //
    UINTX agt1_pg_ack_sts : 1;
    //
    // Please see PPASR0.AGT0_PG_ACK_STS for details.
    // 
    // Bits[2:2], RO/V, default = 0x0
    //
    UINTX agt2_pg_ack_sts : 1;
    //
    // Please see PPASR0.AGT0_PG_ACK_STS for details.
    // 
    // Bits[3:3], RO/V, default = 0x0
    //
    UINTX agt3_pg_ack_sts : 1;
    //
    // Please see PPASR0.AGT0_PG_ACK_STS for details.
    // 
    // Bits[4:4], RO/V, default = 0x0
    //
    UINTX agt4_pg_ack_sts : 1;
    //
    // Please see PPASR0.AGT0_PG_ACK_STS for details.
    // 
    // Bits[5:5], RO/V, default = 0x0
    //
    UINTX agt5_pg_ack_sts : 1;
    //
    // Please see PPASR0.AGT0_PG_ACK_STS for details.
    // 
    // Bits[6:6], RO/V, default = 0x0
    //
    UINTX agt6_pg_ack_sts : 1;
    //
    // Please see PPASR0.AGT0_PG_ACK_STS for details.
    // 
    // Bits[7:7], RO/V, default = 0x0
    //
    UINTX agt7_pg_ack_sts : 1;
    //
    // Please see PPASR0.AGT0_PG_ACK_STS for details.
    // 
    // Bits[8:8], RO/V, default = 0x0
    //
    UINTX agt8_pg_ack_sts : 1;
    //
    // Please see PPASR0.AGT0_PG_ACK_STS for details.
    // 
    // Bits[9:9], RO/V, default = 0x0
    //
    UINTX agt9_pg_ack_sts : 1;
    //
    // Please see PPASR0.AGT0_PG_ACK_STS for details.
    // 
    // Bits[10:10], RO/V, default = 0x0
    //
    UINTX agt10_pg_ack_sts : 1;
    //
    // Please see PPASR0.AGT0_PG_ACK_STS for details.
    // 
    // Bits[11:11], RO/V, default = 0x0
    //
    UINTX agt11_pg_ack_sts : 1;
    //
    // Please see PPASR0.AGT0_PG_ACK_STS for details.
    // 
    // Bits[12:12], RO/V, default = 0x0
    //
    UINTX agt12_pg_ack_sts : 1;
    //
    // Please see PPASR0.AGT0_PG_ACK_STS for details.
    // 
    // Bits[13:13], RO/V, default = 0x0
    //
    UINTX agt13_pg_ack_sts : 1;
    //
    // Please see PPASR0.AGT0_PG_ACK_STS for details.
    // 
    // Bits[14:14], RO/V, default = 0x0
    //
    UINTX agt14_pg_ack_sts : 1;
    //
    // Please see PPASR0.AGT0_PG_ACK_STS for details.
    // 
    // Bits[15:15], RO/V, default = 0x0
    //
    UINTX agt15_pg_ack_sts : 1;
    //
    // Please see PPASR0.AGT0_PG_ACK_STS for details.
    // 
    // Bits[16:16], RO/V, default = 0x0
    //
    UINTX agt16_pg_ack_sts : 1;
    //
    // Please see PPASR0.AGT0_PG_ACK_STS for details.
    // 
    // Bits[17:17], RO/V, default = 0x0
    //
    UINTX agt17_pg_ack_sts : 1;
    //
    // Please see PPASR0.AGT0_PG_ACK_STS for details.
    // 
    // Bits[18:18], RO/V, default = 0x0
    //
    UINTX agt18_pg_ack_sts : 1;
    //
    // Please see PPASR0.AGT0_PG_ACK_STS for details.
    // 
    // Bits[19:19], RO/V, default = 0x0
    //
    UINTX agt19_pg_ack_sts : 1;
    //
    // Please see PPASR0.AGT0_PG_ACK_STS for details.
    // 
    // Bits[20:20], RO/V, default = 0x0
    //
    UINTX agt20_pg_ack_sts : 1;
    //
    // Please see PPASR0.AGT0_PG_ACK_STS for details.
    // 
    // Bits[21:21], RO/V, default = 0x0
    //
    UINTX agt21_pg_ack_sts : 1;
    //
    // Please see PPASR0.AGT0_PG_ACK_STS for details.
    // 
    // Bits[22:22], RO/V, default = 0x0
    //
    UINTX agt22_pg_ack_sts : 1;
    //
    // Please see PPASR0.AGT0_PG_ACK_STS for details.
    // 
    // Bits[23:23], RO/V, default = 0x0
    //
    UINTX agt23_pg_ack_sts : 1;
    //
    // Please see PPASR0.AGT0_PG_ACK_STS for details.
    // 
    // Bits[24:24], RO/V, default = 0x0
    //
    UINTX agt24_pg_ack_sts : 1;
    //
    // Please see PPASR0.AGT0_PG_ACK_STS for details.
    // 
    // Bits[25:25], RO/V, default = 0x0
    //
    UINTX agt25_pg_ack_sts : 1;
    //
    // Please see PPASR0.AGT0_PG_ACK_STS for details.
    // 
    // Bits[26:26], RO/V, default = 0x0
    //
    UINTX agt26_pg_ack_sts : 1;
    //
    // Please see PPASR0.AGT0_PG_ACK_STS for details.
    // 
    // Bits[27:27], RO/V, default = 0x0
    //
    UINTX agt27_pg_ack_sts : 1;
    //
    // Please see PPASR0.AGT0_PG_ACK_STS for details.
    // 
    // Bits[28:28], RO/V, default = 0x0
    //
    UINTX agt28_pg_ack_sts : 1;
    //
    // Please see PPASR0.AGT0_PG_ACK_STS for details.
    // 
    // Bits[29:29], RO/V, default = 0x0
    //
    UINTX agt29_pg_ack_sts : 1;
    //
    // Please see PPASR0.AGT0_PG_ACK_STS for details.
    // 
    // Bits[30:30], RO/V, default = 0x0
    //
    UINTX agt30_pg_ack_sts : 1;
    //
    // Please see PPASR0.AGT0_PG_ACK_STS for details.
    // 
    // Bits[31:31], RO/V, default = 0x0
    //
    UINTX agt31_pg_ack_sts : 1;
  } Bits;
  UINTX Data;
} PPASR0_PMC_PCI_MMR_STRUCT;
#endif // ASM_INC

#define PPASR1_PMC_PCI_MMR_REG                             0x00000584
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Please see PPASR0.AGT0_PG_ACK_STS for details.
    // 
    // Bits[0:0], RO/V, default = 0x0
    //
    UINTX agt32_pg_ack_sts : 1;
    //
    // Please see PPASR0.AGT0_PG_ACK_STS for details.
    // 
    // Bits[1:1], RO/V, default = 0x0
    //
    UINTX agt33_pg_ack_sts : 1;
    //
    // Please see PPASR0.AGT0_PG_ACK_STS for details.
    // 
    // Bits[2:2], RO/V, default = 0x0
    //
    UINTX agt34_pg_ack_sts : 1;
    //
    // Please see PPASR0.AGT0_PG_ACK_STS for details.
    // 
    // Bits[3:3], RO/V, default = 0x0
    //
    UINTX agt35_pg_ack_sts : 1;
    //
    // Please see PPASR0.AGT0_PG_ACK_STS for details.
    // 
    // Bits[4:4], RO/V, default = 0x0
    //
    UINTX agt36_pg_ack_sts : 1;
    //
    // Please see PPASR0.AGT0_PG_ACK_STS for details.
    // 
    // Bits[5:5], RO/V, default = 0x0
    //
    UINTX agt37_pg_ack_sts : 1;
    //
    // Please see PPASR0.AGT0_PG_ACK_STS for details.
    // 
    // Bits[6:6], RO/V, default = 0x0
    //
    UINTX agt38_pg_ack_sts : 1;
    //
    // Please see PPASR0.AGT0_PG_ACK_STS for details.
    // 
    // Bits[7:7], RO/V, default = 0x0
    //
    UINTX agt39_pg_ack_sts : 1;
    //
    // Please see PPASR0.AGT0_PG_ACK_STS for details.
    // 
    // Bits[8:8], RO/V, default = 0x0
    //
    UINTX agt40_pg_ack_sts : 1;
    //
    // Please see PPASR0.AGT0_PG_ACK_STS for details.
    // 
    // Bits[9:9], RO/V, default = 0x0
    //
    UINTX agt41_pg_ack_sts : 1;
    //
    // Please see PPASR0.AGT0_PG_ACK_STS for details.
    // 
    // Bits[10:10], RO/V, default = 0x0
    //
    UINTX agt42_pg_ack_sts : 1;
    //
    // Please see PPASR0.AGT0_PG_ACK_STS for details.
    // 
    // Bits[11:11], RO/V, default = 0x0
    //
    UINTX agt43_pg_ack_sts : 1;
    //
    // Please see PPASR0.AGT0_PG_ACK_STS for details.
    // 
    // Bits[12:12], RO/V, default = 0x0
    //
    UINTX agt44_pg_ack_sts : 1;
    //
    // Please see PPASR0.AGT0_PG_ACK_STS for details.
    // 
    // Bits[13:13], RO/V, default = 0x0
    //
    UINTX agt45_pg_ack_sts : 1;
    //
    // Please see PPASR0.AGT0_PG_ACK_STS for details.
    // 
    // Bits[14:14], RO/V, default = 0x0
    //
    UINTX agt46_pg_ack_sts : 1;
    //
    // Please see PPASR0.AGT0_PG_ACK_STS for details.
    // 
    // Bits[15:15], RO/V, default = 0x0
    //
    UINTX agt47_pg_ack_sts : 1;
    //
    // Please see PPASR0.AGT0_PG_ACK_STS for details.
    // 
    // Bits[16:16], RO/V, default = 0x0
    //
    UINTX agt48_pg_ack_sts : 1;
    //
    // Please see PPASR0.AGT0_PG_ACK_STS for details.
    // 
    // Bits[17:17], RO/V, default = 0x0
    //
    UINTX agt49_pg_ack_sts : 1;
    //
    // Please see PPASR0.AGT0_PG_ACK_STS for details.
    // 
    // Bits[18:18], RO/V, default = 0x0
    //
    UINTX agt50_pg_ack_sts : 1;
    //
    // Please see PPASR0.AGT0_PG_ACK_STS for details.
    // 
    // Bits[19:19], RO/V, default = 0x0
    //
    UINTX agt51_pg_ack_sts : 1;
    //
    // Please see PPASR0.AGT0_PG_ACK_STS for details.
    // 
    // Bits[20:20], RO/V, default = 0x0
    //
    UINTX agt52_pg_ack_sts : 1;
    //
    // Please see PPASR0.AGT0_PG_ACK_STS for details.
    // 
    // Bits[21:21], RO/V, default = 0x0
    //
    UINTX agt53_pg_ack_sts : 1;
    //
    // Please see PPASR0.AGT0_PG_ACK_STS for details.
    // 
    // Bits[22:22], RO/V, default = 0x0
    //
    UINTX agt54_pg_ack_sts : 1;
    //
    // Please see PPASR0.AGT0_PG_ACK_STS for details.
    // 
    // Bits[23:23], RO/V, default = 0x0
    //
    UINTX agt55_pg_ack_sts : 1;
    //
    // Please see PPASR0.AGT0_PG_ACK_STS for details.
    // 
    // Bits[24:24], RO/V, default = 0x0
    //
    UINTX agt56_pg_ack_sts : 1;
    //
    // Please see PPASR0.AGT0_PG_ACK_STS for details.
    // 
    // Bits[25:25], RO/V, default = 0x0
    //
    UINTX agt57_pg_ack_sts : 1;
    //
    // Please see PPASR0.AGT0_PG_ACK_STS for details.
    // 
    // Bits[26:26], RO/V, default = 0x0
    //
    UINTX agt58_pg_ack_sts : 1;
    //
    // Please see PPASR0.AGT0_PG_ACK_STS for details.
    // 
    // Bits[27:27], RO/V, default = 0x0
    //
    UINTX agt59_pg_ack_sts : 1;
    //
    // Please see PPASR0.AGT0_PG_ACK_STS for details.
    // 
    // Bits[28:28], RO/V, default = 0x0
    //
    UINTX agt60_pg_ack_sts : 1;
    //
    // Please see PPASR0.AGT0_PG_ACK_STS for details.
    // 
    // Bits[29:29], RO/V, default = 0x0
    //
    UINTX agt61_pg_ack_sts : 1;
    //
    // Please see PPASR0.AGT0_PG_ACK_STS for details.
    // 
    // Bits[30:30], RO/V, default = 0x0
    //
    UINTX agt62_pg_ack_sts : 1;
    //
    // Please see PPASR0.AGT0_PG_ACK_STS for details.
    // 
    // Bits[31:31], RO/V, default = 0x0
    //
    UINTX agt63_pg_ack_sts : 1;
  } Bits;
  UINTX Data;
} PPASR1_PMC_PCI_MMR_STRUCT;
#endif // ASM_INC

#define PPFEAR0_PMC_PCI_MMR_REG                            0x00000590
#ifndef ASM_INC
typedef union {
  struct {
    //
    // This is the value of the corresponding agent's fet_en_ack_b indication.
    //           [br]0 - PFET is turned ON
    //           [br]1 - PFET is turned OFF
    // 
    // Bits[0:0], RO/V, default = 0x0
    //
    UINTX agt0_pfet_en_ack_sts : 1;
    //
    // Please see PPFEAR0.AGT0_PFET_EN_ACK_STS for details.
    // 
    // Bits[1:1], RO/V, default = 0x0
    //
    UINTX agt1_pfet_en_ack_sts : 1;
    //
    // Please see PPFEAR0.AGT0_PFET_EN_ACK_STS for details.
    // 
    // Bits[2:2], RO/V, default = 0x0
    //
    UINTX agt2_pfet_en_ack_sts : 1;
    //
    // Please see PPFEAR0.AGT0_PFET_EN_ACK_STS for details.
    // 
    // Bits[3:3], RO/V, default = 0x0
    //
    UINTX agt3_pfet_en_ack_sts : 1;
    //
    // Please see PPFEAR0.AGT0_PFET_EN_ACK_STS for details.
    // 
    // Bits[4:4], RO/V, default = 0x0
    //
    UINTX agt4_pfet_en_ack_sts : 1;
    //
    // Please see PPFEAR0.AGT0_PFET_EN_ACK_STS for details.
    // 
    // Bits[5:5], RO/V, default = 0x0
    //
    UINTX agt5_pfet_en_ack_sts : 1;
    //
    // Please see PPFEAR0.AGT0_PFET_EN_ACK_STS for details.
    // 
    // Bits[6:6], RO/V, default = 0x0
    //
    UINTX agt6_pfet_en_ack_sts : 1;
    //
    // Please see PPFEAR0.AGT0_PFET_EN_ACK_STS for details.
    // 
    // Bits[7:7], RO/V, default = 0x0
    //
    UINTX agt7_pfet_en_ack_sts : 1;
    //
    // Please see PPFEAR0.AGT0_PFET_EN_ACK_STS for details.
    // 
    // Bits[8:8], RO/V, default = 0x0
    //
    UINTX agt8_pfet_en_ack_sts : 1;
    //
    // Please see PPFEAR0.AGT0_PFET_EN_ACK_STS for details.
    // 
    // Bits[9:9], RO/V, default = 0x0
    //
    UINTX agt9_pfet_en_ack_sts : 1;
    //
    // Please see PPFEAR0.AGT0_PFET_EN_ACK_STS for details.
    // 
    // Bits[10:10], RO/V, default = 0x0
    //
    UINTX agt10_pfet_en_ack_sts : 1;
    //
    // Please see PPFEAR0.AGT0_PFET_EN_ACK_STS for details.
    // 
    // Bits[11:11], RO/V, default = 0x0
    //
    UINTX agt11_pfet_en_ack_sts : 1;
    //
    // Please see PPFEAR0.AGT0_PFET_EN_ACK_STS for details.
    // 
    // Bits[12:12], RO/V, default = 0x0
    //
    UINTX agt12_pfet_en_ack_sts : 1;
    //
    // Please see PPFEAR0.AGT0_PFET_EN_ACK_STS for details.
    // 
    // Bits[13:13], RO/V, default = 0x0
    //
    UINTX agt13_pfet_en_ack_sts : 1;
    //
    // Please see PPFEAR0.AGT0_PFET_EN_ACK_STS for details.
    // 
    // Bits[14:14], RO/V, default = 0x0
    //
    UINTX agt14_pfet_en_ack_sts : 1;
    //
    // Please see PPFEAR0.AGT0_PFET_EN_ACK_STS for details.
    // 
    // Bits[15:15], RO/V, default = 0x0
    //
    UINTX agt15_pfet_en_ack_sts : 1;
    //
    // Please see PPFEAR0.AGT0_PFET_EN_ACK_STS for details.
    // 
    // Bits[16:16], RO/V, default = 0x0
    //
    UINTX agt16_pfet_en_ack_sts : 1;
    //
    // Please see PPFEAR0.AGT0_PFET_EN_ACK_STS for details.
    // 
    // Bits[17:17], RO/V, default = 0x0
    //
    UINTX agt17_pfet_en_ack_sts : 1;
    //
    // Please see PPFEAR0.AGT0_PFET_EN_ACK_STS for details.
    // 
    // Bits[18:18], RO/V, default = 0x0
    //
    UINTX agt18_pfet_en_ack_sts : 1;
    //
    // Please see PPFEAR0.AGT0_PFET_EN_ACK_STS for details.
    // 
    // Bits[19:19], RO/V, default = 0x0
    //
    UINTX agt19_pfet_en_ack_sts : 1;
    //
    // Please see PPFEAR0.AGT0_PFET_EN_ACK_STS for details.
    // 
    // Bits[20:20], RO/V, default = 0x0
    //
    UINTX agt20_pfet_en_ack_sts : 1;
    //
    // Please see PPFEAR0.AGT0_PFET_EN_ACK_STS for details.
    // 
    // Bits[21:21], RO/V, default = 0x0
    //
    UINTX agt21_pfet_en_ack_sts : 1;
    //
    // Please see PPFEAR0.AGT0_PFET_EN_ACK_STS for details.
    // 
    // Bits[22:22], RO/V, default = 0x0
    //
    UINTX agt22_pfet_en_ack_sts : 1;
    //
    // Please see PPFEAR0.AGT0_PFET_EN_ACK_STS for details.
    // 
    // Bits[23:23], RO/V, default = 0x0
    //
    UINTX agt23_pfet_en_ack_sts : 1;
    //
    // Please see PPFEAR0.AGT0_PFET_EN_ACK_STS for details.
    // 
    // Bits[24:24], RO/V, default = 0x0
    //
    UINTX agt24_pfet_en_ack_sts : 1;
    //
    // Please see PPFEAR0.AGT0_PFET_EN_ACK_STS for details.
    // 
    // Bits[25:25], RO/V, default = 0x0
    //
    UINTX agt25_pfet_en_ack_sts : 1;
    //
    // Please see PPFEAR0.AGT0_PFET_EN_ACK_STS for details.
    // 
    // Bits[26:26], RO/V, default = 0x0
    //
    UINTX agt26_pfet_en_ack_sts : 1;
    //
    // Please see PPFEAR0.AGT0_PFET_EN_ACK_STS for details.
    // 
    // Bits[27:27], RO/V, default = 0x0
    //
    UINTX agt27_pfet_en_ack_sts : 1;
    //
    // Please see PPFEAR0.AGT0_PFET_EN_ACK_STS for details.
    // 
    // Bits[28:28], RO/V, default = 0x0
    //
    UINTX agt28_pfet_en_ack_sts : 1;
    //
    // Please see PPFEAR0.AGT0_PFET_EN_ACK_STS for details.
    // 
    // Bits[29:29], RO/V, default = 0x0
    //
    UINTX agt29_pfet_en_ack_sts : 1;
    //
    // Please see PPFEAR0.AGT0_PFET_EN_ACK_STS for details.
    // 
    // Bits[30:30], RO/V, default = 0x0
    //
    UINTX agt30_pfet_en_ack_sts : 1;
    //
    // Please see PPFEAR0.AGT0_PFET_EN_ACK_STS for details.
    // 
    // Bits[31:31], RO/V, default = 0x0
    //
    UINTX agt31_pfet_en_ack_sts : 1;
  } Bits;
  UINTX Data;
} PPFEAR0_PMC_PCI_MMR_STRUCT;
#endif // ASM_INC

#define PPFEAR1_PMC_PCI_MMR_REG                            0x00000594
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Please see PPFEAR0.AGT0_PFET_EN_ACK_STS for details.
    // 
    // Bits[0:0], RO/V, default = 0x0
    //
    UINTX agt32_pfet_en_ack_sts : 1;
    //
    // Please see PPFEAR0.AGT0_PFET_EN_ACK_STS for details.
    // 
    // Bits[1:1], RO/V, default = 0x0
    //
    UINTX agt33_pfet_en_ack_sts : 1;
    //
    // Please see PPFEAR0.AGT0_PFET_EN_ACK_STS for details.
    // 
    // Bits[2:2], RO/V, default = 0x0
    //
    UINTX agt34_pfet_en_ack_sts : 1;
    //
    // Please see PPFEAR0.AGT0_PFET_EN_ACK_STS for details.
    // 
    // Bits[3:3], RO/V, default = 0x0
    //
    UINTX agt35_pfet_en_ack_sts : 1;
    //
    // Please see PPFEAR0.AGT0_PFET_EN_ACK_STS for details.
    // 
    // Bits[4:4], RO/V, default = 0x0
    //
    UINTX agt36_pfet_en_ack_sts : 1;
    //
    // Please see PPFEAR0.AGT0_PFET_EN_ACK_STS for details.
    // 
    // Bits[5:5], RO/V, default = 0x0
    //
    UINTX agt37_pfet_en_ack_sts : 1;
    //
    // Please see PPFEAR0.AGT0_PFET_EN_ACK_STS for details.
    // 
    // Bits[6:6], RO/V, default = 0x0
    //
    UINTX agt38_pfet_en_ack_sts : 1;
    //
    // Please see PPFEAR0.AGT0_PFET_EN_ACK_STS for details.
    // 
    // Bits[7:7], RO/V, default = 0x0
    //
    UINTX agt39_pfet_en_ack_sts : 1;
    //
    // Please see PPFEAR0.AGT0_PFET_EN_ACK_STS for details.
    // 
    // Bits[8:8], RO/V, default = 0x0
    //
    UINTX agt40_pfet_en_ack_sts : 1;
    //
    // Please see PPFEAR0.AGT0_PFET_EN_ACK_STS for details.
    // 
    // Bits[9:9], RO/V, default = 0x0
    //
    UINTX agt41_pfet_en_ack_sts : 1;
    //
    // Please see PPFEAR0.AGT0_PFET_EN_ACK_STS for details.
    // 
    // Bits[10:10], RO/V, default = 0x0
    //
    UINTX agt42_pfet_en_ack_sts : 1;
    //
    // Please see PPFEAR0.AGT0_PFET_EN_ACK_STS for details.
    // 
    // Bits[11:11], RO/V, default = 0x0
    //
    UINTX agt43_pfet_en_ack_sts : 1;
    //
    // Please see PPFEAR0.AGT0_PFET_EN_ACK_STS for details.
    // 
    // Bits[12:12], RO/V, default = 0x0
    //
    UINTX agt44_pfet_en_ack_sts : 1;
    //
    // Please see PPFEAR0.AGT0_PFET_EN_ACK_STS for details.
    // 
    // Bits[13:13], RO/V, default = 0x0
    //
    UINTX agt45_pfet_en_ack_sts : 1;
    //
    // Please see PPFEAR0.AGT0_PFET_EN_ACK_STS for details.
    // 
    // Bits[14:14], RO/V, default = 0x0
    //
    UINTX agt46_pfet_en_ack_sts : 1;
    //
    // Please see PPFEAR0.AGT0_PFET_EN_ACK_STS for details.
    // 
    // Bits[15:15], RO/V, default = 0x0
    //
    UINTX agt47_pfet_en_ack_sts : 1;
    //
    // Please see PPFEAR0.AGT0_PFET_EN_ACK_STS for details.
    // 
    // Bits[16:16], RO/V, default = 0x0
    //
    UINTX agt48_pfet_en_ack_sts : 1;
    //
    // Please see PPFEAR0.AGT0_PFET_EN_ACK_STS for details.
    // 
    // Bits[17:17], RO/V, default = 0x0
    //
    UINTX agt49_pfet_en_ack_sts : 1;
    //
    // Please see PPFEAR0.AGT0_PFET_EN_ACK_STS for details.
    // 
    // Bits[18:18], RO/V, default = 0x0
    //
    UINTX agt50_pfet_en_ack_sts : 1;
    //
    // Please see PPFEAR0.AGT0_PFET_EN_ACK_STS for details.
    // 
    // Bits[19:19], RO/V, default = 0x0
    //
    UINTX agt51_pfet_en_ack_sts : 1;
    //
    // Please see PPFEAR0.AGT0_PFET_EN_ACK_STS for details.
    // 
    // Bits[20:20], RO/V, default = 0x0
    //
    UINTX agt52_pfet_en_ack_sts : 1;
    //
    // Please see PPFEAR0.AGT0_PFET_EN_ACK_STS for details.
    // 
    // Bits[21:21], RO/V, default = 0x0
    //
    UINTX agt53_pfet_en_ack_sts : 1;
    //
    // Please see PPFEAR0.AGT0_PFET_EN_ACK_STS for details.
    // 
    // Bits[22:22], RO/V, default = 0x0
    //
    UINTX agt54_pfet_en_ack_sts : 1;
    //
    // Please see PPFEAR0.AGT0_PFET_EN_ACK_STS for details.
    // 
    // Bits[23:23], RO/V, default = 0x0
    //
    UINTX agt55_pfet_en_ack_sts : 1;
    //
    // Please see PPFEAR0.AGT0_PFET_EN_ACK_STS for details.
    // 
    // Bits[24:24], RO/V, default = 0x0
    //
    UINTX agt56_pfet_en_ack_sts : 1;
    //
    // Please see PPFEAR0.AGT0_PFET_EN_ACK_STS for details.
    // 
    // Bits[25:25], RO/V, default = 0x0
    //
    UINTX agt57_pfet_en_ack_sts : 1;
    //
    // Please see PPFEAR0.AGT0_PFET_EN_ACK_STS for details.
    // 
    // Bits[26:26], RO/V, default = 0x0
    //
    UINTX agt58_pfet_en_ack_sts : 1;
    //
    // Please see PPFEAR0.AGT0_PFET_EN_ACK_STS for details.
    // 
    // Bits[27:27], RO/V, default = 0x0
    //
    UINTX agt59_pfet_en_ack_sts : 1;
    //
    // Please see PPFEAR0.AGT0_PFET_EN_ACK_STS for details.
    // 
    // Bits[28:28], RO/V, default = 0x0
    //
    UINTX agt60_pfet_en_ack_sts : 1;
    //
    // Please see PPFEAR0.AGT0_PFET_EN_ACK_STS for details.
    // 
    // Bits[29:29], RO/V, default = 0x0
    //
    UINTX agt61_pfet_en_ack_sts : 1;
    //
    // Please see PPFEAR0.AGT0_PFET_EN_ACK_STS for details.
    // 
    // Bits[30:30], RO/V, default = 0x0
    //
    UINTX agt62_pfet_en_ack_sts : 1;
    //
    // Please see PPFEAR0.AGT0_PFET_EN_ACK_STS for details.
    // 
    // Bits[31:31], RO/V, default = 0x0
    //
    UINTX agt63_pfet_en_ack_sts : 1;
  } Bits;
  UINTX Data;
} PPFEAR1_PMC_PCI_MMR_STRUCT;
#endif // ASM_INC

#define PGLSR0_PMC_PCI_MMR_REG                             0x000005A0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // When power gating, this is the minimum time required between the assertion of
    // an Agent's 
    //               pmc_ip_pg_ack_b before the deassertion of the Agent's (logical)
    // pmc_ip_pfet_en_b. 
    //           [br]
    //           [br]The latency is based on the value configured in this field according
    // to the table below: 
    //           [br]0x0: 33ns
    //           [br]0x1: 66ns
    //           [br]0x2: 100ns
    //           [br]0x3: 133ns
    //           [br]0x4: 200ns
    //           [br]0x5: 266ns
    //           [br]0x6: 400ns
    //           [br]0x7: 533ns
    //           [br]0x8: 800ns
    //           [br]0x9: 1066ns
    //           [br]0xA: 1333ns
    //           [br]0xB: 1600ns
    //           [br]0xC: 1866ns
    //           [br]0xD: 2133ns
    //           [br]0xE: 2666ns
    //           [br]0xF: 3200ns
    //           [br]
    //           [br]NOTE: the complementary Latency value for PG exit (minimum time
    // between assertion of 
    //               ip_pmc_pfet_en_ack_b and de-assertion of pmc_ip_pg_ack_b is defined
    // in the PUGLSR* registers (one 
    //               separate configurable value per PGD). 
    // 
    // Bits[3:0], RW/L, default = 0x6
    //
    UINTX pg_pgack_pfeten_ltcy : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:4], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 4;
    //
    // When power gating, this is the minimum time required between seeing an Agent's
    //               ip_pmc_pfet_en_ack_b signal deassert before starting to handle another
    // Power Gate/Ungate request. 
    //           [br]For latency times corresponding to the programmed value, refer to
    // PGLSR.PG_ACK_PFETEN_LTCY. 
    // 
    // Bits[11:8], RW/L, default = 0x6
    //
    UINTX pg_stall_ltcy : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:12], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 12;
    //
    // When power ungating, this is the minimum time required between the deassertion
    // of an Agent's pmc_ip_pg_ack_b signal before starting to handle another Power Gate/Ungate
    // request.[br] 
    // For latency times corresponding to the programmed value, refer to PGLSR.PG_ACK_PFETEN_LTCY.
    // 
    // Bits[27:24], RW/L, default = 0x6
    //
    UINTX pug_stall_ltcy : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:28], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 4;
  } Bits;
  UINTX Data;
} PGLSR0_PMC_PCI_MMR_STRUCT;
#endif // ASM_INC

#define PMCR_PMC_PCI_MMR_REG                               0x000005B0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // This control lock bit, once set, will prevent any host software writes from affecting
    // the values of the following PGD group of registers:[br] 
    // PPAMR*[br]
    // PGLSR0[br]
    // PMCR[br]
    // PUGLSR*[br]
    // The lock bit once set, can be reset only on PLTRST# assertion.[br]
    // Note: If Power Gating Disable Fuse is 1, this register will always read 1 and
    // is Read-only.[br] 
    // 
    // Bits[0:0], RW/L, default = 0x0
    //
    UINTX pgd_lock : 1;
    //
    // N/A
    // 
    // Bits[31:1], RO, default = 0x0
    //
    UINTX rsvd31_1 : 31;
  } Bits;
  UINTX Data;
} PMCR_PMC_PCI_MMR_STRUCT;
#endif // ASM_INC

#define PSCR_PMC_PCI_MMR_REG                               0x000005B4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // This register has been defeatured.
    //               [br]
    //               [br]Indicates which Agent is configured to have PG Statistics collection.
    // The statistics information in PPSR register refers to the PGD with this Agent
    // ID. 
    // 
    // Bits[5:0], RW, default = 0x0
    //
    UINTX pg_stat_agtid : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:6], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
    //
    // This register has been defeatured.
    //               [br]
    //               [br]The statistics collection for the PGD configured for statistics
    // collection is enabled when this bit is set. Otherwise, HW will not update the
    // statistics information in PPSR registers. This enable allows s/w to gain exclusive
    // access to the statistics information. For e.g., s/w can clear the enable bit,
    // clear the statistics information and then set the enable bit for a fixed amount
    // of time, before clearing it again. This will allow s/w to capture statistics over
    // a given time interval.[br] 
    // 0 (default): Statistics collection is disabled (no HW updates).[br]
    // 1: Statistics collection is enabled (HW updates will now start happening to the
    // PPSR). 
    // 
    // Bits[8:8], RW, default = 0x0
    //
    UINTX pg_stat_en : 1;
    //
    // This register has been defeatured.
    //               [br]
    //               [br]This field defines if the Power-Gated time unit (interval at
    // which the statistics counters are incremented) is 100us (Micro mode) or 1ms (Macro
    // mode)[br] 
    // 0: Macro mode (default)[br]
    // 1: Micro Mode
    // 
    // Bits[9:9], RW, default = 0x0
    //
    UINTX pg_stat_incr_mode : 1;
    //
    // This register has been defeatured.
    //               [br]
    //               [br]This field defines if the Statistic counter increments when
    // the Agent's pmc_ip_pg_ack_b is asserted, or when the corresponding pmc_ip_pfet_en_b
    // is deasserted.[br] 
    // 0: Increment when pmc_ip_pg_ack_b asserted (default)[br]
    // 1: Increment when pmc_ip_pfet_en_b is deasserted
    // 
    // Bits[10:10], RW, default = 0x0
    //
    UINTX pg_stat_sts_mode : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:11], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 21;
  } Bits;
  UINTX Data;
} PSCR_PMC_PCI_MMR_STRUCT;
#endif // ASM_INC

#define PPSR_PMC_PCI_MMR_REG                               0x000005B8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // This register has been defeatured.
    //               [br]
    //               [br]This indicates the time that the PGD mapped for statistics per
    // PSCR has been power-gated since the last clearing of this field. Time is counted
    // in increments as specified in the Statistics mode field of PSCR register.[br]
    // Range is from[br]
    // 0x0000: 0 (x time unit - see Statistics Mode for applicable time unit)[br]
    // 0x0001: 1 time units[br]
    // 0x0002: 2 time units[br]
    // . . . .[br]
    //  . . . .[br]
    // 0x7FFF: 32,767 time units[br]
    // For example for a time unit of 1ms, this will track time up to 32.7 seconds before
    // wrapping over.[br] 
    // For time unit of 100us, this will track time up to 3.27 seconds before wrapping
    // over.[br] 
    // This field can be modified by both software and hardware. Hardware updates happen
    // when the corresponding Power-gating statistics collection enable bit is set. Software
    // can read this field or clear it through writing 1 s (all 1s). It is recommended
    // that software writes to clear this field happen only when the corresponding enable
    // bit is cleared.[br] 
    // The hardware updates are cumulative - only increments when the increment timer
    // tick happens AND PGD is power gated. If the statistics collection is continuously
    // enabled, this field may wrap over several times.[br] 
    // If the PGD is power-gated for time durations smaller than the time unit, the timer
    // may not increment at all. 
    // 
    // Bits[14:0], RW/1C/V, default = 0x0
    //
    UINTX pg_stat_pwrgate_time : 15;
    //
    // This register has been defeatured.
    //               [br]
    //               [br]If the Power-Gated Time counter overflows, this bit will be
    // set. Once set, it can only be cleared by software write of 1 or reset. 
    // 
    // Bits[15:15], RW/1C/V, default = 0x0
    //
    UINTX pg_stat_ovrflw : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:16], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 16;
  } Bits;
  UINTX Data;
} PPSR_PMC_PCI_MMR_STRUCT;
#endif // ASM_INC

#define PUGLSR0_PMC_PCI_MMR_REG                            0x000005C0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // This is the minimum time required between the assertion of the corresponding agent's
    //               fet_en_ack_b to the deassertion of the agent's pg_ack_b.
    //           [br]
    //           [br]Note that the assertion of fet_en_ack_b is meant to indicate that
    // the PFET is turned 
    //               on. This latency value is intended to provide additional delay for
    // settling of power rails. 
    //           [br]
    //           [br]The latency value is based on the value configured in this field
    // as per the table given below: 
    //           [br]0x0: 33ns (no delay)
    //           [br]0x1: 266ns
    //           [br]0x2: 1066ns
    //           [br]0x3: 2133ns
    // 
    // Bits[1:0], RW/L, default = 0x0
    //
    UINTX agt0_pwrungate_ltcy : 2;
    //
    // Refer to PUGLSR0.AGT0_PWRUNGATE_LTCY.
    // 
    // Bits[3:2], RW/L, default = 0x0
    //
    UINTX agt1_pwrungate_ltcy : 2;
    //
    // Refer to PUGLSR0.AGT0_PWRUNGATE_LTCY.
    // 
    // Bits[5:4], RW/L, default = 0x0
    //
    UINTX agt2_pwrungate_ltcy : 2;
    //
    // Refer to PUGLSR0.AGT0_PWRUNGATE_LTCY.
    // 
    // Bits[7:6], RW/L, default = 0x0
    //
    UINTX agt3_pwrungate_ltcy : 2;
    //
    // Refer to PUGLSR0.AGT0_PWRUNGATE_LTCY.
    // 
    // Bits[9:8], RW/L, default = 0x0
    //
    UINTX agt4_pwrungate_ltcy : 2;
    //
    // Refer to PUGLSR0.AGT0_PWRUNGATE_LTCY.
    // 
    // Bits[11:10], RW/L, default = 0x0
    //
    UINTX agt5_pwrungate_ltcy : 2;
    //
    // Refer to PUGLSR0.AGT0_PWRUNGATE_LTCY.
    // 
    // Bits[13:12], RW/L, default = 0x0
    //
    UINTX agt6_pwrungate_ltcy : 2;
    //
    // Refer to PUGLSR0.AGT0_PWRUNGATE_LTCY.
    // 
    // Bits[15:14], RW/L, default = 0x0
    //
    UINTX agt7_pwrungate_ltcy : 2;
    //
    // Refer to PUGLSR0.AGT0_PWRUNGATE_LTCY.
    // 
    // Bits[17:16], RW/L, default = 0x0
    //
    UINTX agt8_pwrungate_ltcy : 2;
    //
    // Refer to PUGLSR0.AGT0_PWRUNGATE_LTCY.
    // 
    // Bits[19:18], RW/L, default = 0x0
    //
    UINTX agt9_pwrungate_ltcy : 2;
    //
    // Refer to PUGLSR0.AGT0_PWRUNGATE_LTCY.
    // 
    // Bits[21:20], RW/L, default = 0x0
    //
    UINTX agt10_pwrungate_ltcy : 2;
    //
    // Refer to PUGLSR0.AGT0_PWRUNGATE_LTCY.
    // 
    // Bits[23:22], RW/L, default = 0x0
    //
    UINTX agt11_pwrungate_ltcy : 2;
    //
    // Refer to PUGLSR0.AGT0_PWRUNGATE_LTCY.
    // 
    // Bits[25:24], RW/L, default = 0x0
    //
    UINTX agt12_pwrungate_ltcy : 2;
    //
    // Reserved
    // 
    // Bits[27:26], RO, default = 0x0
    //
    UINTX agt13_pwrungate_ltcy : 2;
    //
    // Refer to PUGLSR0.AGT0_PWRUNGATE_LTCY.
    // 
    // Bits[29:28], RW/L, default = 0x0
    //
    UINTX agt14_pwrungate_ltcy : 2;
    //
    // Refer to PUGLSR0.AGT0_PWRUNGATE_LTCY.
    // 
    // Bits[31:30], RW/L, default = 0x0
    //
    UINTX agt15_pwrungate_ltcy : 2;
  } Bits;
  UINTX Data;
} PUGLSR0_PMC_PCI_MMR_STRUCT;
#endif // ASM_INC

#define PUGLSR1_PMC_PCI_MMR_REG                            0x000005C4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Refer to PUGLSR0.AGT0_PWRUNGATE_LTCY.
    // 
    // Bits[1:0], RW/L, default = 0x0
    //
    UINTX agt16_pwrungate_ltcy : 2;
    //
    // Refer to PUGLSR0.AGT0_PWRUNGATE_LTCY.
    // 
    // Bits[3:2], RW/L, default = 0x0
    //
    UINTX agt17_pwrungate_ltcy : 2;
    //
    // Refer to PUGLSR0.AGT0_PWRUNGATE_LTCY.
    // 
    // Bits[5:4], RW/L, default = 0x0
    //
    UINTX agt18_pwrungate_ltcy : 2;
    //
    // Refer to PUGLSR0.AGT0_PWRUNGATE_LTCY.
    // 
    // Bits[7:6], RW/L, default = 0x0
    //
    UINTX agt19_pwrungate_ltcy : 2;
    //
    // Refer to PUGLSR0.AGT0_PWRUNGATE_LTCY.
    // 
    // Bits[9:8], RW/L, default = 0x0
    //
    UINTX agt20_pwrungate_ltcy : 2;
    //
    // Refer to PUGLSR0.AGT0_PWRUNGATE_LTCY.
    // 
    // Bits[11:10], RW/L, default = 0x0
    //
    UINTX agt21_pwrungate_ltcy : 2;
    //
    // Refer to PUGLSR0.AGT0_PWRUNGATE_LTCY.
    // 
    // Bits[13:12], RW/L, default = 0x0
    //
    UINTX agt22_pwrungate_ltcy : 2;
    //
    // Refer to PUGLSR0.AGT0_PWRUNGATE_LTCY.
    // 
    // Bits[15:14], RW/L, default = 0x0
    //
    UINTX agt23_pwrungate_ltcy : 2;
    //
    // Reserved
    // 
    // Bits[17:16], RO, default = 0x0
    //
    UINTX agt24_pwrungate_ltcy : 2;
    //
    // Refer to PUGLSR0.AGT0_PWRUNGATE_LTCY.
    // 
    // Bits[19:18], RW/L, default = 0x0
    //
    UINTX agt25_pwrungate_ltcy : 2;
    //
    // Refer to PUGLSR0.AGT0_PWRUNGATE_LTCY.
    // 
    // Bits[21:20], RW/L, default = 0x0
    //
    UINTX agt26_pwrungate_ltcy : 2;
    //
    // Refer to PUGLSR0.AGT0_PWRUNGATE_LTCY.
    // 
    // Bits[23:22], RW/L, default = 0x0
    //
    UINTX agt27_pwrungate_ltcy : 2;
    //
    // Refer to PUGLSR0.AGT0_PWRUNGATE_LTCY.
    // 
    // Bits[25:24], RW/L, default = 0x0
    //
    UINTX agt28_pwrungate_ltcy : 2;
    //
    // Refer to PUGLSR0.AGT0_PWRUNGATE_LTCY.
    // 
    // Bits[27:26], RW/L, default = 0x0
    //
    UINTX agt29_pwrungate_ltcy : 2;
    //
    // Refer to PUGLSR0.AGT0_PWRUNGATE_LTCY.
    // 
    // Bits[29:28], RW/L, default = 0x0
    //
    UINTX agt30_pwrungate_ltcy : 2;
    //
    // Refer to PUGLSR0.AGT0_PWRUNGATE_LTCY.
    // 
    // Bits[31:30], RW/L, default = 0x0
    //
    UINTX agt31_pwrungate_ltcy : 2;
  } Bits;
  UINTX Data;
} PUGLSR1_PMC_PCI_MMR_STRUCT;
#endif // ASM_INC

#define PUGLSR2_PMC_PCI_MMR_REG                            0x000005C8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Refer to PUGLSR0.AGT0_PWRUNGATE_LTCY.
    // 
    // Bits[1:0], RW/L, default = 0x0
    //
    UINTX agt32_pwrungate_ltcy : 2;
    //
    // Refer to PUGLSR0.AGT0_PWRUNGATE_LTCY.
    // 
    // Bits[3:2], RW/L, default = 0x0
    //
    UINTX agt33_pwrungate_ltcy : 2;
    //
    // Refer to PUGLSR0.AGT0_PWRUNGATE_LTCY.
    // 
    // Bits[5:4], RW/L, default = 0x0
    //
    UINTX agt34_pwrungate_ltcy : 2;
    //
    // Refer to PUGLSR0.AGT0_PWRUNGATE_LTCY.
    // 
    // Bits[7:6], RW/L, default = 0x0
    //
    UINTX agt35_pwrungate_ltcy : 2;
    //
    // Refer to PUGLSR0.AGT0_PWRUNGATE_LTCY.
    // 
    // Bits[9:8], RW/L, default = 0x0
    //
    UINTX agt36_pwrungate_ltcy : 2;
    //
    // Refer to PUGLSR0.AGT0_PWRUNGATE_LTCY.
    // 
    // Bits[11:10], RW/L, default = 0x0
    //
    UINTX agt37_pwrungate_ltcy : 2;
    //
    // Refer to PUGLSR0.AGT0_PWRUNGATE_LTCY.
    // 
    // Bits[13:12], RW/L, default = 0x0
    //
    UINTX agt38_pwrungate_ltcy : 2;
    //
    // Refer to PUGLSR0.AGT0_PWRUNGATE_LTCY.
    // 
    // Bits[15:14], RW/L, default = 0x0
    //
    UINTX agt39_pwrungate_ltcy : 2;
    //
    // Refer to PUGLSR0.AGT0_PWRUNGATE_LTCY.
    // 
    // Bits[17:16], RW/L, default = 0x0
    //
    UINTX agt40_pwrungate_ltcy : 2;
    //
    // Refer to PUGLSR0.AGT0_PWRUNGATE_LTCY.
    // 
    // Bits[19:18], RW/L, default = 0x0
    //
    UINTX agt41_pwrungate_ltcy : 2;
    //
    // Refer to PUGLSR0.AGT0_PWRUNGATE_LTCY.
    // 
    // Bits[21:20], RW/L, default = 0x0
    //
    UINTX agt42_pwrungate_ltcy : 2;
    //
    // Refer to PUGLSR0.AGT0_PWRUNGATE_LTCY.
    // 
    // Bits[23:22], RW/L, default = 0x0
    //
    UINTX agt43_pwrungate_ltcy : 2;
    //
    // Refer to PUGLSR0.AGT0_PWRUNGATE_LTCY.
    // 
    // Bits[25:24], RW/L, default = 0x0
    //
    UINTX agt44_pwrungate_ltcy : 2;
    //
    // Refer to PUGLSR0.AGT0_PWRUNGATE_LTCY.
    // 
    // Bits[27:26], RW/L, default = 0x0
    //
    UINTX agt45_pwrungate_ltcy : 2;
    //
    // Reserved
    // 
    // Bits[29:28], RO, default = 0x0
    //
    UINTX agt46_pwrungate_ltcy : 2;
    //
    // Refer to PUGLSR0.AGT0_PWRUNGATE_LTCY.
    // 
    // Bits[31:30], RW/L, default = 0x0
    //
    UINTX agt47_pwrungate_ltcy : 2;
  } Bits;
  UINTX Data;
} PUGLSR2_PMC_PCI_MMR_STRUCT;
#endif // ASM_INC

#define PUGLSR3_PMC_PCI_MMR_REG                            0x000005CC
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Refer to PUGLSR0.AGT0_PWRUNGATE_LTCY.
    // 
    // Bits[1:0], RW/L, default = 0x0
    //
    UINTX agt48_pwrungate_ltcy : 2;
    //
    // Refer to PUGLSR0.AGT0_PWRUNGATE_LTCY.
    // 
    // Bits[3:2], RW/L, default = 0x0
    //
    UINTX agt49_pwrungate_ltcy : 2;
    //
    // Refer to PUGLSR0.AGT0_PWRUNGATE_LTCY.
    // 
    // Bits[5:4], RW/L, default = 0x0
    //
    UINTX agt50_pwrungate_ltcy : 2;
    //
    // Reserved
    // 
    // Bits[7:6], RO, default = 0x0
    //
    UINTX agt51_pwrungate_ltcy : 2;
    //
    // Reserved
    // 
    // Bits[9:8], RO, default = 0x0
    //
    UINTX agt52_pwrungate_ltcy : 2;
    //
    // Reserved
    // 
    // Bits[11:10], RO, default = 0x0
    //
    UINTX agt53_pwrungate_ltcy : 2;
    //
    // Reserved
    // 
    // Bits[13:12], RO, default = 0x0
    //
    UINTX agt54_pwrungate_ltcy : 2;
    //
    // Reserved
    // 
    // Bits[15:14], RO, default = 0x0
    //
    UINTX agt55_pwrungate_ltcy : 2;
    //
    // Reserved
    // 
    // Bits[17:16], RO, default = 0x0
    //
    UINTX agt56_pwrungate_ltcy : 2;
    //
    // Reserved
    // 
    // Bits[19:18], RO, default = 0x0
    //
    UINTX agt57_pwrungate_ltcy : 2;
    //
    // Reserved
    // 
    // Bits[21:20], RO, default = 0x0
    //
    UINTX agt58_pwrungate_ltcy : 2;
    //
    // Reserved
    // 
    // Bits[23:22], RO, default = 0x0
    //
    UINTX agt59_pwrungate_ltcy : 2;
    //
    // Reserved
    // 
    // Bits[25:24], RO, default = 0x0
    //
    UINTX agt60_pwrungate_ltcy : 2;
    //
    // Reserved
    // 
    // Bits[27:26], RO, default = 0x0
    //
    UINTX agt61_pwrungate_ltcy : 2;
    //
    // Reserved
    // 
    // Bits[29:28], RO, default = 0x0
    //
    UINTX agt62_pwrungate_ltcy : 2;
    //
    // Reserved
    // 
    // Bits[31:30], RO, default = 0x0
    //
    UINTX agt63_pwrungate_ltcy : 2;
  } Bits;
  UINTX Data;
} PUGLSR3_PMC_PCI_MMR_STRUCT;
#endif // ASM_INC

#define HSWPGCR1_PMC_PCI_MMR_REG                           0x000005D0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // 0: DFX PGD is not requested to power-gate - DFX logic (including NPK, VISA, TAP2IOSFSB)
    //               remains active and available for use. 
    //           [br]1: DFX PGD is requested to power-gate by PMC (expectation is that
    // DFX power-gates itself 
    //               as soon as it is idle, and then remains power-gated in IP-Accessible
    // PG state) 
    //           [br]
    //           [br]NOT for EDS: 
    //           [br]Note: The inverted version of this bit controls the pmc_dfx_sw_pg_req_b
    // (active low) 
    //               signal. Therefore, when the bit has a value of '0', the signal is
    // driven to a value of 
    //               '1' and vice versa. 
    //           [br]Also, this signal is subject to override by PMC FW/PMC JTAG. This
    // is enabled through the 
    //               PG_SW_PG_REQ_* registers in PMC XRAM space (also, the DFX Agent
    // ID is listed in the table 
    //               [quote]Mapping of PCH SIP Power-gated domains to Agent IDs[quote]
    // in Cspec Ch 32). 
    // 
    // Bits[0:0], RW/L, default = 0x0
    //
    UINTX dfx_sw_pg_ctrl : 1;
    //
    // N/A
    // 
    // Bits[30:1], RO, default = 0x0
    //
    UINTX rsvd : 30;
    //
    // 0: All other bits in this register are RW (can be set or cleared). 
    //           [br]1: All bits in this register are locked (including this bit). 
    //           [br]
    //           [br]Note: BIOS is expected to always write to this bit before handing
    // off control to the OS, 
    //               even if it has not changed any of the values in this register. This
    // is because this Lock 
    //               bit resets on platform reset, and needs to be set on every boot
    // to S0 (to prevent any 
    //               post-BIOS s/w from accessing or updating bits in this register).
    // 
    // Bits[31:31], RW/L, default = 0x0
    //
    UINTX sw_pg_ctrl_lock : 1;
  } Bits;
  UINTX Data;
} HSWPGCR1_PMC_PCI_MMR_STRUCT;
#endif // ASM_INC

#define PPRSR0_PMC_PCI_MMR_REG                             0x000005E0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // This indicates the current status of the ip_pmc_pg_req_b signal, corresponding
    // to Agent ID [n].[br] 
    // 0: Agent is requesting to be power-gated[br]
    // 1: Agent is requesting to be powered-on
    // 
    // Bits[0:0], RO/V, default = 0x0
    //
    UINTX agt0_pg_req_sts : 1;
    //
    // Please see PPRSR0.AGT0_PG_REQ_STS for details.
    // 
    // Bits[1:1], RO/V, default = 0x0
    //
    UINTX agt1_pg_req_sts : 1;
    //
    // Please see PPRSR0.AGT0_PG_REQ_STS for details.
    // 
    // Bits[2:2], RO/V, default = 0x0
    //
    UINTX agt2_pg_req_sts : 1;
    //
    // Please see PPRSR0.AGT0_PG_REQ_STS for details.
    // 
    // Bits[3:3], RO/V, default = 0x0
    //
    UINTX agt3_pg_req_sts : 1;
    //
    // Please see PPRSR0.AGT0_PG_REQ_STS for details.
    // 
    // Bits[4:4], RO/V, default = 0x0
    //
    UINTX agt4_pg_req_sts : 1;
    //
    // Please see PPRSR0.AGT0_PG_REQ_STS for details.
    // 
    // Bits[5:5], RO/V, default = 0x0
    //
    UINTX agt5_pg_req_sts : 1;
    //
    // Please see PPRSR0.AGT0_PG_REQ_STS for details.
    // 
    // Bits[6:6], RO/V, default = 0x0
    //
    UINTX agt6_pg_req_sts : 1;
    //
    // Please see PPRSR0.AGT0_PG_REQ_STS for details.
    // 
    // Bits[7:7], RO/V, default = 0x0
    //
    UINTX agt7_pg_req_sts : 1;
    //
    // Please see PPRSR0.AGT0_PG_REQ_STS for details.
    // 
    // Bits[8:8], RO/V, default = 0x0
    //
    UINTX agt8_pg_req_sts : 1;
    //
    // Please see PPRSR0.AGT0_PG_REQ_STS for details.
    // 
    // Bits[9:9], RO/V, default = 0x0
    //
    UINTX agt9_pg_req_sts : 1;
    //
    // Please see PPRSR0.AGT0_PG_REQ_STS for details.
    // 
    // Bits[10:10], RO/V, default = 0x0
    //
    UINTX agt10_pg_req_sts : 1;
    //
    // Please see PPRSR0.AGT0_PG_REQ_STS for details.
    // 
    // Bits[11:11], RO/V, default = 0x0
    //
    UINTX agt11_pg_req_sts : 1;
    //
    // Please see PPRSR0.AGT0_PG_REQ_STS for details.
    // 
    // Bits[12:12], RO/V, default = 0x0
    //
    UINTX agt12_pg_req_sts : 1;
    //
    // Please see PPRSR0.AGT0_PG_REQ_STS for details.
    // 
    // Bits[13:13], RO/V, default = 0x0
    //
    UINTX agt13_pg_req_sts : 1;
    //
    // Please see PPRSR0.AGT0_PG_REQ_STS for details.
    // 
    // Bits[14:14], RO/V, default = 0x0
    //
    UINTX agt14_pg_req_sts : 1;
    //
    // Please see PPRSR0.AGT0_PG_REQ_STS for details.
    // 
    // Bits[15:15], RO/V, default = 0x0
    //
    UINTX agt15_pg_req_sts : 1;
    //
    // Please see PPRSR0.AGT0_PG_REQ_STS for details.
    // 
    // Bits[16:16], RO/V, default = 0x0
    //
    UINTX agt16_pg_req_sts : 1;
    //
    // Please see PPRSR0.AGT0_PG_REQ_STS for details.
    // 
    // Bits[17:17], RO/V, default = 0x0
    //
    UINTX agt17_pg_req_sts : 1;
    //
    // Please see PPRSR0.AGT0_PG_REQ_STS for details.
    // 
    // Bits[18:18], RO/V, default = 0x0
    //
    UINTX agt18_pg_req_sts : 1;
    //
    // Please see PPRSR0.AGT0_PG_REQ_STS for details.
    // 
    // Bits[19:19], RO/V, default = 0x0
    //
    UINTX agt19_pg_req_sts : 1;
    //
    // Please see PPRSR0.AGT0_PG_REQ_STS for details.
    // 
    // Bits[20:20], RO/V, default = 0x0
    //
    UINTX agt20_pg_req_sts : 1;
    //
    // Please see PPRSR0.AGT0_PG_REQ_STS for details.
    // 
    // Bits[21:21], RO/V, default = 0x0
    //
    UINTX agt21_pg_req_sts : 1;
    //
    // Please see PPRSR0.AGT0_PG_REQ_STS for details.
    // 
    // Bits[22:22], RO/V, default = 0x0
    //
    UINTX agt22_pg_req_sts : 1;
    //
    // Please see PPRSR0.AGT0_PG_REQ_STS for details.
    // 
    // Bits[23:23], RO/V, default = 0x0
    //
    UINTX agt23_pg_req_sts : 1;
    //
    // Please see PPRSR0.AGT0_PG_REQ_STS for details.
    // 
    // Bits[24:24], RO/V, default = 0x0
    //
    UINTX agt24_pg_req_sts : 1;
    //
    // Please see PPRSR0.AGT0_PG_REQ_STS for details.
    // 
    // Bits[25:25], RO/V, default = 0x0
    //
    UINTX agt25_pg_req_sts : 1;
    //
    // Please see PPRSR0.AGT0_PG_REQ_STS for details.
    // 
    // Bits[26:26], RO/V, default = 0x0
    //
    UINTX agt26_pg_req_sts : 1;
    //
    // Please see PPRSR0.AGT0_PG_REQ_STS for details.
    // 
    // Bits[27:27], RO/V, default = 0x0
    //
    UINTX agt27_pg_req_sts : 1;
    //
    // Please see PPRSR0.AGT0_PG_REQ_STS for details.
    // 
    // Bits[28:28], RO/V, default = 0x0
    //
    UINTX agt28_pg_req_sts : 1;
    //
    // Please see PPRSR0.AGT0_PG_REQ_STS for details.
    // 
    // Bits[29:29], RO/V, default = 0x0
    //
    UINTX agt29_pg_req_sts : 1;
    //
    // Please see PPRSR0.AGT0_PG_REQ_STS for details.
    // 
    // Bits[30:30], RO/V, default = 0x0
    //
    UINTX agt30_pg_req_sts : 1;
    //
    // Please see PPRSR0.AGT0_PG_REQ_STS for details.
    // 
    // Bits[31:31], RO/V, default = 0x0
    //
    UINTX agt31_pg_req_sts : 1;
  } Bits;
  UINTX Data;
} PPRSR0_PMC_PCI_MMR_STRUCT;
#endif // ASM_INC

#define PPRSR1_PMC_PCI_MMR_REG                             0x000005E4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Please see PPRSR0.AGT0_PG_REQ_STS for details.
    // 
    // Bits[0:0], RO/V, default = 0x0
    //
    UINTX agt32_pg_req_sts : 1;
    //
    // Please see PPRSR0.AGT0_PG_REQ_STS for details.
    // 
    // Bits[1:1], RO/V, default = 0x0
    //
    UINTX agt33_pg_req_sts : 1;
    //
    // Please see PPRSR0.AGT0_PG_REQ_STS for details.
    // 
    // Bits[2:2], RO/V, default = 0x0
    //
    UINTX agt34_pg_req_sts : 1;
    //
    // Please see PPRSR0.AGT0_PG_REQ_STS for details.
    // 
    // Bits[3:3], RO/V, default = 0x0
    //
    UINTX agt35_pg_req_sts : 1;
    //
    // Please see PPRSR0.AGT0_PG_REQ_STS for details.
    // 
    // Bits[4:4], RO/V, default = 0x0
    //
    UINTX agt36_pg_req_sts : 1;
    //
    // Please see PPRSR0.AGT0_PG_REQ_STS for details.
    // 
    // Bits[5:5], RO/V, default = 0x0
    //
    UINTX agt37_pg_req_sts : 1;
    //
    // Please see PPRSR0.AGT0_PG_REQ_STS for details.
    // 
    // Bits[6:6], RO/V, default = 0x0
    //
    UINTX agt38_pg_req_sts : 1;
    //
    // Please see PPRSR0.AGT0_PG_REQ_STS for details.
    // 
    // Bits[7:7], RO/V, default = 0x0
    //
    UINTX agt39_pg_req_sts : 1;
    //
    // Please see PPRSR0.AGT0_PG_REQ_STS for details.
    // 
    // Bits[8:8], RO/V, default = 0x0
    //
    UINTX agt40_pg_req_sts : 1;
    //
    // Please see PPRSR0.AGT0_PG_REQ_STS for details.
    // 
    // Bits[9:9], RO/V, default = 0x0
    //
    UINTX agt41_pg_req_sts : 1;
    //
    // Please see PPRSR0.AGT0_PG_REQ_STS for details.
    // 
    // Bits[10:10], RO/V, default = 0x0
    //
    UINTX agt42_pg_req_sts : 1;
    //
    // Please see PPRSR0.AGT0_PG_REQ_STS for details.
    // 
    // Bits[11:11], RO/V, default = 0x0
    //
    UINTX agt43_pg_req_sts : 1;
    //
    // Please see PPRSR0.AGT0_PG_REQ_STS for details.
    // 
    // Bits[12:12], RO/V, default = 0x0
    //
    UINTX agt44_pg_req_sts : 1;
    //
    // Please see PPRSR0.AGT0_PG_REQ_STS for details.
    // 
    // Bits[13:13], RO/V, default = 0x0
    //
    UINTX agt45_pg_req_sts : 1;
    //
    // Please see PPRSR0.AGT0_PG_REQ_STS for details.
    // 
    // Bits[14:14], RO/V, default = 0x0
    //
    UINTX agt46_pg_req_sts : 1;
    //
    // Please see PPRSR0.AGT0_PG_REQ_STS for details.
    // 
    // Bits[15:15], RO/V, default = 0x0
    //
    UINTX agt47_pg_req_sts : 1;
    //
    // Please see PPRSR0.AGT0_PG_REQ_STS for details.
    // 
    // Bits[16:16], RO/V, default = 0x0
    //
    UINTX agt48_pg_req_sts : 1;
    //
    // Please see PPRSR0.AGT0_PG_REQ_STS for details.
    // 
    // Bits[17:17], RO/V, default = 0x0
    //
    UINTX agt49_pg_req_sts : 1;
    //
    // Please see PPRSR0.AGT0_PG_REQ_STS for details.
    // 
    // Bits[18:18], RO/V, default = 0x0
    //
    UINTX agt50_pg_req_sts : 1;
    //
    // Please see PPRSR0.AGT0_PG_REQ_STS for details.
    // 
    // Bits[19:19], RO/V, default = 0x0
    //
    UINTX agt51_pg_req_sts : 1;
    //
    // Please see PPRSR0.AGT0_PG_REQ_STS for details.
    // 
    // Bits[20:20], RO/V, default = 0x0
    //
    UINTX agt52_pg_req_sts : 1;
    //
    // Please see PPRSR0.AGT0_PG_REQ_STS for details.
    // 
    // Bits[21:21], RO/V, default = 0x0
    //
    UINTX agt53_pg_req_sts : 1;
    //
    // Please see PPRSR0.AGT0_PG_REQ_STS for details.
    // 
    // Bits[22:22], RO/V, default = 0x0
    //
    UINTX agt54_pg_req_sts : 1;
    //
    // Please see PPRSR0.AGT0_PG_REQ_STS for details.
    // 
    // Bits[23:23], RO/V, default = 0x0
    //
    UINTX agt55_pg_req_sts : 1;
    //
    // Please see PPRSR0.AGT0_PG_REQ_STS for details.
    // 
    // Bits[24:24], RO/V, default = 0x0
    //
    UINTX agt56_pg_req_sts : 1;
    //
    // Please see PPRSR0.AGT0_PG_REQ_STS for details.
    // 
    // Bits[25:25], RO/V, default = 0x0
    //
    UINTX agt57_pg_req_sts : 1;
    //
    // Please see PPRSR0.AGT0_PG_REQ_STS for details.
    // 
    // Bits[26:26], RO/V, default = 0x0
    //
    UINTX agt58_pg_req_sts : 1;
    //
    // Please see PPRSR0.AGT0_PG_REQ_STS for details.
    // 
    // Bits[27:27], RO/V, default = 0x0
    //
    UINTX agt59_pg_req_sts : 1;
    //
    // Please see PPRSR0.AGT0_PG_REQ_STS for details.
    // 
    // Bits[28:28], RO/V, default = 0x0
    //
    UINTX agt60_pg_req_sts : 1;
    //
    // Please see PPRSR0.AGT0_PG_REQ_STS for details.
    // 
    // Bits[29:29], RO/V, default = 0x0
    //
    UINTX agt61_pg_req_sts : 1;
    //
    // Please see PPRSR0.AGT0_PG_REQ_STS for details.
    // 
    // Bits[30:30], RO/V, default = 0x0
    //
    UINTX agt62_pg_req_sts : 1;
    //
    // Please see PPRSR0.AGT0_PG_REQ_STS for details.
    // 
    // Bits[31:31], RO/V, default = 0x0
    //
    UINTX agt63_pg_req_sts : 1;
  } Bits;
  UINTX Data;
} PPRSR1_PMC_PCI_MMR_STRUCT;
#endif // ASM_INC

#define FAB_PG_CTL_PSF_PMC_PCI_MMR_REG                     0x00000600
#ifndef ASM_INC
typedef union {
  struct {
    //
    // This is the minimum time that a PSF segment needs to be continuously idle before
    //               it is requested to power-gate by PMC (this value is applicable to
    // all PSF segments).  
    //           [br]
    //           [br]0h: 1us
    //           [br]1h: 2us
    //           [br]2h: 8us
    //           [br]3h: 16us
    //           [br]4h: 32us
    //           [br]5h: 64us
    //           [br]6h: 128us
    //           [br]All others: Reserved.
    // 
    // Bits[3:0], RW, default = 0x2
    //
    UINTX psf_pg_hyst_val : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[5:4], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
    //
    // When Pkg C-state is enabled as a qualifier for PSF PG (through CX_QUAL_EN_PSF
    //               field of this register), PKG Cx state (as captured in TBD register)
    // must be deeper 
    //               than or equal to this value in order to enable PSF Power-gating
    // (this value is 
    //               applicable to all PSF segments).
    //           [br]
    //           [br]0h: C0
    //           [br]1h: C2
    //           [br]2h: C3
    //           [br]3h: C6
    //           [br]4h: C7
    //           [br]5h: C8
    //           [br]6h: C10
    //           [br]All others: Reserved.
    //           [br]
    //           [br]NOTE: In Sx system states, the current CPU package C-state value
    // is assumed to 
    //               be the deepest possible package C-state value (C10).
    // 
    // Bits[10:6], RW, default = 0x3
    //
    UINTX min_cx_psf_pg : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[12:11], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 2;
    //
    // When CPPM is enabled as a qualifier for the PSF PG (through PSF_PG_CPPM_QUAL_EN
    //               field of this register), the current PLT (as captured in CUR_PLT
    // register, offset 
    //               0x350) must be greater than or equal to the value programmed in
    // this field in 
    //               order for the PSF PG to be enabled. If the current PLT is less than
    // the value 
    //               in this field, the PSF PG is not allowed. 
    //           [br]
    //           [br]Note that even if CPPM is enabled and the value of current PLT is
    // greater than 
    //               this value, there may be other conditions that prevent PSF PG from
    // being triggered by PMC.  
    //           [br]
    //           [br]The format of this field matches the NL and SL of the PM_Req/Rsp/Dmd
    // messages on DMI. 
    // 
    // Bits[21:13], RW, default = 0x0
    //
    UINTX psf_pg_plt_thresh : 9;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[28:22], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 7;
    //
    // When this bit is set to '1', CPU Package C-state (as reflected in TBD register)
    //               must be equal to or deeper than the value programmed in the MIN_CX_PSF_PG
    // field of 
    //               this register as a necessary condition to allow PSF power-gating.
    //  
    //           [br]
    //           [br]Note: please refer to other qualifier bits in this register to comprehend
    // all 
    //               necessary conditions for PSF power-gating. Also, this qualifier
    // is applicable to 
    //               all PSF segments.
    //           [br]
    //           [br]NOT for EDS -- Note: the default value of this bit is '1' - which
    // helps support 
    //               the case that when BIOS tries to configure these policies, the fabric
    // segments 
    //               are ungated - so validation may only focus on scenarios where configuration
    // happens 
    //               only when PSF segments are ungated (so, no config change when PSF
    // segments are in PG state). 
    // 
    // Bits[29:29], RW, default = 0x1
    //
    UINTX cx_qual_en_psf : 1;
    //
    // When this bit is set to '1', Current PLT (as reflected in CUR_PLT register,
    //               offset 0x350) should be greater than or equal to the value in PSF_PG_PLT_THRESH
    //               field of this register as a necessary condition to allow PSF power-gating.
    //           [br]
    //           [br]Note: please refer to other qualifier bits in this register to comprehend
    // all 
    //               necessary conditions for PSF power-gating. Also, this qualifier
    // is applicable to 
    //               all PSF segments.
    // 
    // Bits[30:30], RW, default = 0x0
    //
    UINTX cppm_qual_en_psf : 1;
    //
    // When this bit is set to '1', all PSF segments need to be in Idle state as one
    // of 
    //               the necessary conditions to allow PSF power-gating.
    //           [br]
    //           [br]Note: please refer to other qualifier bits in this register to comprehend
    // all 
    //               necessary conditions for PSF power-gating. Also, this qualifier
    // is applicable 
    //               to all PSF segments.
    // 
    // Bits[31:31], RW, default = 0x0
    //
    UINTX all_psf_idle_qual_en_psf : 1;
  } Bits;
  UINTX Data;
} FAB_PG_CTL_PSF_PMC_PCI_MMR_STRUCT;
#endif // ASM_INC

#define FAB_PG_CTL_SBR_PMC_PCI_MMR_REG                     0x00000604
#ifndef ASM_INC
typedef union {
  struct {
    //
    // This is the minimum time that a IOSF-SB router needs to be continuously idle before
    //               it is requested to power-gate by PMC (this value is applicable to
    // all IOSF-SB routers).  
    //           [br]
    //           [br]0h: 1us
    //           [br]1h: 2us
    //           [br]2h: 8us
    //           [br]3h: 16us
    //           [br]4h: 32us
    //           [br]5h: 64us
    //           [br]6h: 128us
    //           [br]All others: Reserved.
    // 
    // Bits[3:0], RW, default = 0x2
    //
    UINTX sbr_pg_hyst_val : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[5:4], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
    //
    // When Pkg C-state is enabled as a qualifier for SBR PG (through CX_QUAL_EN_SBR
    //               field of this register), PKG Cx state (as captured in TBD register)
    // must be deeper 
    //               than or equal to this value in order to enable IOSF-SB router Power-gating
    // (this value is 
    //               applicable to all IOSF-SB routers).
    //           [br]
    //           [br]0h: C0
    //           [br]1h: C2
    //           [br]2h: C3
    //           [br]3h: C6
    //           [br]4h: C7
    //           [br]5h: C8
    //           [br]6h: C10
    //           [br]All others: Reserved.
    //           [br]
    //           [br]NOTE: In Sx system states, the current CPU package C-state value
    // is assumed to 
    //               be the deepest possible package C-state value (C10).
    // 
    // Bits[10:6], RW, default = 0x3
    //
    UINTX min_cx_sbr_pg : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[12:11], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 2;
    //
    // When CPPM is enabled as a qualifier for the IOSF-SB router power-gating (through
    // SBR_PG_CPPM_QUAL_EN 
    //               field of this register), the current PLT (as captured in CUR_PLT
    // register, offset 
    //               0x350) must be greater than or equal to the value programmed in
    // this field in 
    //               order for the SBR PG to be enabled. If the current PLT is less than
    // the value 
    //               in this field, the SBR PG is not allowed. 
    //           [br]
    //           [br]Note that even if CPPM is enabled and the value of current PLT is
    // greater than 
    //               this value, there may be other conditions that prevent SBR PG from
    // being triggered by PMC.  
    //           [br]
    //           [br]The format of this field matches the NL and SL of the PM_Req/Rsp/Dmd
    // messages on DMI. 
    // 
    // Bits[21:13], RW, default = 0x0
    //
    UINTX sbr_pg_plt_thresh : 9;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[28:22], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 7;
    //
    // When this bit is set to '1', CPU Package C-state (as reflected in TBD register)
    //               must be equal to or deeper than the value programmed in the MIN_CX_SBR_PG
    // field of 
    //               this register as a necessary condition to allow SBR power-gating.
    //  
    //           [br]
    //           [br]Note: please refer to other qualifier bits in this register to comprehend
    // all 
    //               necessary conditions for IOSF-SB router power-gating. Also, this
    // qualifier is applicable to 
    //               all IOSF-SB routers.
    //           [br]
    //           [br]NOT for EDS -- Note: the default value of this bit is '1' - which
    // helps support 
    //               the case that when BIOS tries to configure these policies, the IOSF-SB
    // routers 
    //               are ungated - so validation may only focus on scenarios where configuration
    // happens 
    //               only when IOSF-SB routers are ungated (so, no config change when
    // IOSF-SB routers are in PG state). 
    // 
    // Bits[29:29], RW, default = 0x1
    //
    UINTX cx_qual_en_sbr : 1;
    //
    // When this bit is set to '1', Current PLT (as reflected in CUR_PLT register,
    //               offset 0x350) should be greater than or equal to the value in SBR_PG_PLT_THRESH
    //               field of this register as a necessary condition to allow IOSF-SB
    // router power-gating. 
    //           [br]
    //           [br]Note: please refer to other qualifier bits in this register to comprehend
    // all 
    //               necessary conditions for IOSF-SB router power-gating. Also, this
    // qualifier is applicable to 
    //               all IOSF-SB routers.
    // 
    // Bits[30:30], RW, default = 0x0
    //
    UINTX cppm_qual_en_sbr : 1;
    //
    // When this bit is set to '1', all IOSF-SB Routers need to be in Idle state as one
    // of 
    //               the necessary conditions to allow IOSF-SB router power-gating.
    //           [br]
    //           [br]Note: please refer to other qualifier bits in this register to comprehend
    // all 
    //               necessary conditions for IOSF-SB router power-gating. Also, this
    // qualifier is applicable 
    //               to all IOSF-SB routers.
    // 
    // Bits[31:31], RW, default = 0x0
    //
    UINTX all_sbr_idle_qual_en_sbr : 1;
  } Bits;
  UINTX Data;
} FAB_PG_CTL_SBR_PMC_PCI_MMR_STRUCT;
#endif // ASM_INC

#define ST_PG_FDIS_PMC_1_PMC_PCI_MMR_REG                   0x00000620
#ifndef ASM_INC
typedef union {
  struct {
    //
    // BIOS is required to set this bit when GBE function is configured to be function
    // disabled.  
    // 
    // Bits[0:0], RW/L, default = 0x0
    //
    UINTX gbe_fdis_pmc : 1;
    //
    // N/A
    // 
    // Bits[4:1], RO, default = 0x0
    //
    UINTX rsvd_4_1 : 4;
    //
    // BIOS is required to set this bit when ISH function is configured to be function
    // disabled.  
    // 
    // Bits[5:5], RW/L, default = 0x0
    //
    UINTX ish_fdis_pmc : 1;
    //
    // BIOS is required to set this bit when Camera function is configured to be function
    // disabled.  
    // 
    // Bits[6:6], RW/L, default = 0x0
    //
    UINTX cam_fdis_pmc : 1;
    //
    // N/A
    // 
    // Bits[30:7], RO, default = 0x0
    //
    UINTX rsvd_30_16 : 24;
    //
    //  Lock control for all ST_PG_FDIS_PMC_* and NST_PG_FDIS_* registers (also self-locks
    // when written to 1). 
    // 
    // Bits[31:31], RW/L, default = 0x0
    //
    UINTX st_fdis_lk : 1;
  } Bits;
  UINTX Data;
} ST_PG_FDIS_PMC_1_PMC_PCI_MMR_STRUCT;
#endif // ASM_INC

#define ST_PG_FDIS_PMC_2_PMC_PCI_MMR_REG                   0x00000624
#ifndef ASM_INC
typedef union {
  struct {
    //
    // BIOS is required to set this bit when this LPSS Device (single function) is configured
    // to be function disabled.  
    // 
    // Bits[0:0], RW/L, default = 0x0
    //
    UINTX lpss_i2c0_fdis_pmc : 1;
    //
    // N/A
    // 
    // Bits[23:1], RO, default = 0x0
    //
    UINTX rsvd_23_1 : 23;
    //
    // N/A
    // 
    // Bits[31:24], RO, default = 0x0
    //
    UINTX rsvd_31_24 : 8;
  } Bits;
  UINTX Data;
} ST_PG_FDIS_PMC_2_PMC_PCI_MMR_STRUCT;
#endif // ASM_INC

#define NST_PG_FDIS_1_PMC_PCI_MMR_REG                      0x00000628
#ifndef ASM_INC
typedef union {
  struct {
    //
    // BIOS is required to set this bit when this IP block (single logical function)
    // is configured to be function disabled.  
    // 
    // Bits[0:0], RW/L, default = 0x0
    //
    UINTX xhci_fdis_pmc : 1;
    //
    // N/A
    // 
    // Bits[1:1], RO, default = 0x0
    //
    UINTX rsvd : 1;
    //
    // BIOS is required to set this bit when this PCIE port (single function) is configured
    // to be function disabled.  
    // 
    // Bits[2:2], RW/L, default = 0x0
    //
    UINTX pcie_a0_fdis_pmc : 1;
    //
    // BIOS is required to set this bit when this PCIE port (single function) is configured
    // to be function disabled.  
    // 
    // Bits[3:3], RW/L, default = 0x0
    //
    UINTX pcie_a1_fdis_pmc : 1;
    //
    // BIOS is required to set this bit when this PCIE port (single function) is configured
    // to be function disabled.  
    // 
    // Bits[4:4], RW/L, default = 0x0
    //
    UINTX pcie_a2_fdis_pmc : 1;
    //
    // BIOS is required to set this bit when this PCIE port (single function) is configured
    // to be function disabled.  
    // 
    // Bits[5:5], RW/L, default = 0x0
    //
    UINTX pcie_a3_fdis_pmc : 1;
    //
    // BIOS is required to set this bit when this PCIE port (single function) is configured
    // to be function disabled.  
    // 
    // Bits[6:6], RW/L, default = 0x0
    //
    UINTX pcie_b0_fdis_pmc : 1;
    //
    // BIOS is required to set this bit when this PCIE port (single function) is configured
    // to be function disabled.  
    // 
    // Bits[7:7], RW/L, default = 0x0
    //
    UINTX pcie_b1_fdis_pmc : 1;
    //
    // BIOS is required to set this bit when this PCIE port (single function) is configured
    // to be function disabled.  
    // 
    // Bits[8:8], RW/L, default = 0x0
    //
    UINTX pcie_b2_fdis_pmc : 1;
    //
    // BIOS is required to set this bit when this PCIE port (single function) is configured
    // to be function disabled.  
    // 
    // Bits[9:9], RW/L, default = 0x0
    //
    UINTX pcie_b3_fdis_pmc : 1;
    //
    // BIOS is required to set this bit when this PCIE port (single function) is configured
    // to be function disabled.  
    // 
    // Bits[10:10], RW/L, default = 0x0
    //
    UINTX pcie_c0_fdis_pmc : 1;
    //
    // BIOS is required to set this bit when this PCIE port (single function) is configured
    // to be function disabled.  
    // 
    // Bits[11:11], RW/L, default = 0x0
    //
    UINTX pcie_c1_fdis_pmc : 1;
    //
    // BIOS is required to set this bit when this PCIE port (single function) is configured
    // to be function disabled.  
    // 
    // Bits[12:12], RW/L, default = 0x0
    //
    UINTX pcie_c2_fdis_pmc : 1;
    //
    // BIOS is required to set this bit when this PCIE port (single function) is configured
    // to be function disabled.  
    // 
    // Bits[13:13], RW/L, default = 0x0
    //
    UINTX pcie_c3_fdis_pmc : 1;
    //
    // N/A
    // 
    // Bits[21:14], RO, default = 0x0
    //
    UINTX rsvd_21_14 : 8;
    //
    // BIOS is required to set this bit when the SATA controller (single function) is
    // configured to be function disabled.  
    // 
    // Bits[22:22], RW/L, default = 0x0
    //
    UINTX st_fdis_pmc : 1;
    //
    // BIOS is required to set this bit when this IP block (single function) is configured
    // to be function disabled.  
    // 
    // Bits[23:23], RW/L, default = 0x0
    //
    UINTX adsp_fdis_pmc : 1;
    //
    // BIOS is required to set this bit when this IP block (single function) is configured
    // to be function disabled.  
    // 
    // Bits[24:24], RW/L, default = 0x0
    //
    UINTX lpc_fdis_pmc : 1;
    //
    // BIOS is required to set this bit when this IP block (single function) is configured
    // to be function disabled.  
    // 
    // Bits[25:25], RW/L, default = 0x0
    //
    UINTX smb_fdis_pmc : 1;
    //
    // N/A
    // 
    // Bits[31:26], RO, default = 0x0
    //
    UINTX rsvd_31_26 : 6;
  } Bits;
  UINTX Data;
} NST_PG_FDIS_1_PMC_PCI_MMR_STRUCT;
#endif // ASM_INC

#define N_STPG_FUSE_SS_DIS_RD_1_PMC_PCI_MMR_REG            0x00000640
#ifndef ASM_INC
typedef union {
  struct {
    //
    // XHCI fuse disable placeholder  TBD if this information is used by PMC due to specific
    // XHCI requirements.  
    // 
    // Bits[0:0], RO/V, default = 0x0
    //
    UINTX xhci_fuse_dis : 1;
    //
    // N/A
    // 
    // Bits[1:1], RO, default = 0x0
    //
    UINTX rsvd : 1;
    //
    // RO bit indicating if this PCIE port (single function) is fuse disabled. 
    // 
    // Bits[2:2], RO/V, default = 0x0
    //
    UINTX pcie_a0_fuse_dis : 1;
    //
    // RO bit indicating if this PCIE port (single function) is fuse disabled. 
    // 
    // Bits[3:3], RO/V, default = 0x0
    //
    UINTX pcie_a1_fuse_dis : 1;
    //
    // RO bit indicating if this PCIE port (single function) is fuse disabled. 
    // 
    // Bits[4:4], RO/V, default = 0x0
    //
    UINTX pcie_a2_fuse_dis : 1;
    //
    // RO bit indicating if this PCIE port (single function) is fuse disabled. 
    // 
    // Bits[5:5], RO/V, default = 0x0
    //
    UINTX pcie_a3_fuse_dis : 1;
    //
    // RO bit indicating if this PCIE port (single function) is fuse disabled. 
    // 
    // Bits[6:6], RO/V, default = 0x0
    //
    UINTX pcie_b0_fuse_dis : 1;
    //
    // RO bit indicating if this PCIE port (single function) is fuse disabled. 
    // 
    // Bits[7:7], RO/V, default = 0x0
    //
    UINTX pcie_b1_fuse_dis : 1;
    //
    // RO bit indicating if this PCIE port (single function) is fuse disabled. 
    // 
    // Bits[8:8], RO/V, default = 0x0
    //
    UINTX pcie_b2_fuse_dis : 1;
    //
    // RO bit indicating if this PCIE port (single function) is fuse disabled. 
    // 
    // Bits[9:9], RO/V, default = 0x0
    //
    UINTX pcie_b3_fuse_dis : 1;
    //
    // RO bit indicating if this PCIE port (single function) is fuse disabled. 
    // 
    // Bits[10:10], RO/V, default = 0x0
    //
    UINTX pcie_c0_fuse_dis : 1;
    //
    // RO bit indicating if this PCIE port (single function) is fuse disabled. 
    // 
    // Bits[11:11], RO/V, default = 0x0
    //
    UINTX pcie_c1_fuse_dis : 1;
    //
    // RO bit indicating if this PCIE port (single function) is fuse disabled. 
    // 
    // Bits[12:12], RO/V, default = 0x0
    //
    UINTX pcie_c2_fuse_dis : 1;
    //
    // RO bit indicating if this PCIE port (single function) is fuse disabled. 
    // 
    // Bits[13:13], RO/V, default = 0x0
    //
    UINTX pcie_c3_fuse_dis : 1;
    //
    // N/A
    // 
    // Bits[21:14], RO, default = 0x0
    //
    UINTX rsvd_21_14 : 8;
    //
    // N/A
    // 
    // Bits[31:22], RO, default = 0x0
    //
    UINTX rsvd_31_22 : 10;
  } Bits;
  UINTX Data;
} N_STPG_FUSE_SS_DIS_RD_1_PMC_PCI_MMR_STRUCT;
#endif // ASM_INC

#define STPG_FUSE_SS_DIS_RD_2_PMC_PCI_MMR_REG              0x00000644
#ifndef ASM_INC
typedef union {
  struct {
    //
    // RO bit indicating if GBE function is disabled through fuse or Soft strap.
    // 
    // Bits[0:0], RO/V, default = 0x0
    //
    UINTX gbe_fuse_ss_dis : 1;
    //
    // RO bit indicating if ISH function is disabled through fuse or soft strap.
    // 
    // Bits[1:1], RO/V, default = 0x0
    //
    UINTX ish_fuse_ss_dis : 1;
    //
    // RO bit indicating if Camera function is disabled through fuse/soft strap.
    // 
    // Bits[2:2], RO/V, default = 0x0
    //
    UINTX cam_fuse_ss_dis : 1;
    //
    // RO bit indicating if 2D function is disabled through fuse/soft strap.
    // 
    // Bits[3:3], RO/V, default = 0x0
    //
    UINTX p2d_fuse_ss_dis : 1;
    //
    // RO bit indicating if SCC function is disabled through fuse/soft strap.
    // 
    // Bits[4:4], RO/V, default = 0x0
    //
    UINTX scc_fuse_ss_dis : 1;
    //
    // RO bit indicating if FLIS function is disabled through fuse/soft strap.
    // 
    // Bits[5:5], RO/V, default = 0x0
    //
    UINTX flis_fuse_ss_dis : 1;
    //
    // RO bit indicating if LPSS function is disabled through fuse/soft strap.
    // 
    // Bits[6:6], RO/V, default = 0x0
    //
    UINTX lpss_fuse_ss_dis : 1;
    //
    // RO bit indicating if NPK function is disabled through fuse/soft strap.
    // 
    // Bits[7:7], RO/V, default = 0x0
    //
    UINTX npk_fuse_ss_dis : 1;
    //
    // RO bit indicating if ITSS function is disabled through fuse/soft strap.
    // 
    // Bits[8:8], RO/V, default = 0x0
    //
    UINTX itss_fuse_ss_dis : 1;
    //
    // RO bit indicating if SMB function is disabled through fuse/soft strap.
    // 
    // Bits[9:9], RO/V, default = 0x0
    //
    UINTX smb_fuse_ss_dis : 1;
    //
    // RO bit indicating if TRSB function is disabled through fuse/soft strap.
    // 
    // Bits[10:10], RO/V, default = 0x0
    //
    UINTX trsb_fuse_ss_dis : 1;
    //
    // RO bit indicating if P2S function is disabled through fuse/soft strap.
    // 
    // Bits[11:11], RO/V, default = 0x0
    //
    UINTX p2s_fuse_ss_dis : 1;
    //
    // RO bit indicating if RTC function is disabled through fuse/soft strap.
    // 
    // Bits[12:12], RO/V, default = 0x0
    //
    UINTX rtc_fuse_ss_dis : 1;
    //
    // RO bit indicating if LPC function is disabled through fuse/soft strap.
    // 
    // Bits[13:13], RO/V, default = 0x0
    //
    UINTX lpc_fuse_ss_dis : 1;
    //
    // RO bit indicating if ICC function is disabled through fuse/soft strap.
    // 
    // Bits[14:14], RO/V, default = 0x0
    //
    UINTX icc_fuse_ss_dis : 1;
    //
    // RO bit indicating if SATA function is disabled through fuse/soft strap.
    // 
    // Bits[15:15], RO/V, default = 0x0
    //
    UINTX sata_fuse_ss_dis : 1;
    //
    // RO bit indicating if DSP function is disabled through fuse/soft strap.
    // 
    // Bits[16:16], RO/V, default = 0x0
    //
    UINTX dsp_fuse_ss_dis : 1;
    //
    // RO bit indicating if FIA function is disabled through fuse/soft strap.
    // 
    // Bits[17:17], RO/V, default = 0x0
    //
    UINTX fia_fuse_ss_dis : 1;
    //
    // RO bit indicating if XHCI function is disabled through soft strap.
    //           [br]Note: This is intended for use only as a debug tool (to work around
    //               any issues related to XHCI in reset/boot/Sx entry flows), since
    // disabling 
    //               XHCI prevents ModPhy power-gating on the lanes driven by the XHCI
    // controller. 
    //               The corresponding XHCI disable fuse bit is located in N_STPG_FUSE_SS_DIS_RD_1
    // register. 
    // 
    // Bits[18:18], RO/V, default = 0x0
    //
    UINTX xhci_ss_dis : 1;
    //
    // RO bit indicating if OTG function is disabled through fuse/soft strap.
    // 
    // Bits[19:19], RO/V, default = 0x0
    //
    UINTX otg_fuse_ss_dis : 1;
    //
    // RO bit indicating if DMI function is disabled through fuse/soft strap.
    // 
    // Bits[20:20], RO/V, default = 0x0
    //
    UINTX dmi_fuse_ss_dis : 1;
    //
    // RO bit indicating if PSTH function is disabled through fuse/soft strap.
    // 
    // Bits[21:21], RO/V, default = 0x0
    //
    UINTX psth_fuse_ss_dis : 1;
    //
    // RO bit indicating if ESPISPI function is disabled through fuse/soft strap. 
    //           [br]NOTE: It is not necessary that ESPISPI is power-gated if this bit
    // is set, however, at 
    //               least PMC skips all reset/boot related interactions with ESPI/SPI
    // in this case. 
    // 
    // Bits[22:22], RO/V, default = 0x0
    //
    UINTX espispi_fuse_ss_dis : 1;
    //
    // RO bit indicating if SPA function is disabled through soft strap.
    //           [br]Note: Each port within this function has individual disable fuse
    // - listed in 
    //               N_STPG_FUSE_SS_DIS_RD_1 register  that does not contribute to static
    // power gating. 
    // 
    // Bits[23:23], RO/V, default = 0x0
    //
    UINTX spa_ss_dis : 1;
    //
    // RO bit indicating if SPB function is disabled through fuse/soft strap.
    //           [br]Note: Each port within this function has individual disable fuse
    // - listed in 
    //               N_STPG_FUSE_SS_DIS_RD_1 register  that does not contribute to static
    // power gating. 
    // 
    // Bits[24:24], RO/V, default = 0x0
    //
    UINTX spb_ss_dis : 1;
    //
    // RO bit indicating if SPC function is disabled through soft strap.
    //           [br]Note: Each port within this function has individual disable fuse
    // - listed in  
    //               N_STPG_FUSE_SS_DIS_RD_1 register  that does not contribute to static
    // power gating. 
    // 
    // Bits[25:25], RO/V, default = 0x0
    //
    UINTX spc_ss_dis : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:26], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 6;
  } Bits;
  UINTX Data;
} STPG_FUSE_SS_DIS_RD_2_PMC_PCI_MMR_STRUCT;
#endif // ASM_INC

#define STPG_FUSE_SS_DIS_RD_3_PMC_PCI_MMR_REG              0x00000648
#ifndef ASM_INC
typedef union {
  struct {
    //
    // RO bit indicating if PNCRB function is disabled through fuse or Soft strap.
    // 
    // Bits[0:0], RO/V, default = 0x0
    //
    UINTX pncrb_fuse_ss_dis : 1;
    //
    // RO bit indicating if PNCRA1 function is disabled through fuse or Soft strap.
    // 
    // Bits[1:1], RO/V, default = 0x0
    //
    UINTX pncra1_fuse_ss_dis : 1;
    //
    // RO bit indicating if PNCRA2 function is disabled through fuse or Soft strap.
    // 
    // Bits[2:2], RO/V, default = 0x0
    //
    UINTX pncra2_fuse_ss_dis : 1;
    //
    // RO bit indicating if PNCRA3 function is disabled through fuse or Soft strap.
    // 
    // Bits[3:3], RO/V, default = 0x0
    //
    UINTX pncra3_fuse_ss_dis : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:4], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 28;
  } Bits;
  UINTX Data;
} STPG_FUSE_SS_DIS_RD_3_PMC_PCI_MMR_STRUCT;
#endif // ASM_INC


#endif // _PMC_PCI_MMR_H_
