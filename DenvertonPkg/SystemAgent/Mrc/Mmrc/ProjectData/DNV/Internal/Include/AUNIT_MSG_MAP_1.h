/** @file
  File name:    AUNIT_MSG_MAP_1.h
  Input File:   DNV_MRC.xlsx

  THIS FILE IS AUTO-GENERATED BY THE MSP TOOL. DO NOT CHANGE THIS CODE.

  If edits are needed in this file, they must be done via the MSP tool.

  If there is additional project-specific data required by the MSP, it
  can be placed in AUNIT_MSG_MAP_1.h, which is used for non-tool-generated
  data

  Includes register defines specific to a project.

  Copyright (c) 2005-2018 Intel Corporation. All rights reserved
  This software and associated documentation (if any) is furnished
  under a license and may only be used or copied in accordance
  with the terms of the license. Except as permitted by such
  license, no part of this software or documentation may be
  reproduced, stored in a retrieval system, or transmitted in any
  form or by any means without the express written consent of
  Intel Corporation.
**/
#ifndef _AUNIT_MSG_MAP_1_H_
#define _AUNIT_MSG_MAP_1_H_

#include "DataTypes.h"

#if USE_64_BIT_VARIABLES
#define UINTX UINT64
#else
#define UINTX UINT32
#endif

#define A_CR_P_U_CODERDWR_CP_AUNIT_MSG_MAP_1_REG           0x00004F00
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Bit vector used to determine which agents are allowed access to the A-Unit CREG
    // based on the value from the agents 6 bit SAI field. This register is selfreferential
    // the access policy provided applies to access to the control register itself. 
    // 
    // Bits[63:0], RW, default = 0x40001000202
    //
    UINTX p_u_coderdwr_cp : 64;
  } Bits;
  UINTX Data;
} A_CR_P_U_CODERDWR_CP_AUNIT_MSG_MAP_1_STRUCT;
#endif // ASM_INC

#define A_CR_P_U_CODERDWR_RAC_AUNIT_MSG_MAP_1_REG          0x00004F08
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Bit vector used to determine which agents are allowed Rd access to the A-Unit
    // CREG based on the value from the agents 6 bit SAI field. 
    // 
    // Bits[63:0], RW, default = 0x40001000202
    //
    UINTX p_u_coderdwr_rac : 64;
  } Bits;
  UINTX Data;
} A_CR_P_U_CODERDWR_RAC_AUNIT_MSG_MAP_1_STRUCT;
#endif // ASM_INC

#define A_CR_P_U_CODERDWR_WAC_AUNIT_MSG_MAP_1_REG          0x00004F10
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Bit vector used to determine which agents are allowed Wr access to the A-Unit
    // CREG based on the value from the agents 6 bit SAI field. 
    // 
    // Bits[63:0], RW, default = 0x400010C0202
    //
    UINTX p_u_coderdwr_wac : 64;
  } Bits;
  UINTX Data;
} A_CR_P_U_CODERDWR_WAC_AUNIT_MSG_MAP_1_STRUCT;
#endif // ASM_INC

#define A_CR_IA_UNTRUSTED_CP_AUNIT_MSG_MAP_1_REG           0x00004F18
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Bit vector used to determine which agents are allowed access to the A-Unit DFX
    // Registers based on the value from the agents 6 bit SAI field. This register is
    // selfreferential the access policy provided applies to access to the control register
    // itself. 
    // 
    // Bits[63:0], RW, default = 0xC0061010202
    //
    UINTX ia_untrusted_cp : 64;
  } Bits;
  UINTX Data;
} A_CR_IA_UNTRUSTED_CP_AUNIT_MSG_MAP_1_STRUCT;
#endif // ASM_INC

#define A_CR_IA_UNTRUSTED_RAC_AUNIT_MSG_MAP_1_REG          0x00004F20
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Bit vector used to determine which agents are allowed Rd access to the A-Unit
    // DFX Register based on the value from the agents 6 bit SAI field. 
    // 
    // Bits[63:0], RW, default = 0x80000C0063010217
    //
    UINTX ia_untrusted_rac : 64;
  } Bits;
  UINTX Data;
} A_CR_IA_UNTRUSTED_RAC_AUNIT_MSG_MAP_1_STRUCT;
#endif // ASM_INC

#define A_CR_IA_UNTRUSTED_WAC_AUNIT_MSG_MAP_1_REG          0x00004F28
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Bit vector used to determine which agents are allowed Wr access to the A-Unit
    // IA_UNTRUSTED_ registers based on the value from the agents 6 bit SAI field. 
    // 
    // Bits[63:0], RW, default = 0xC0061000217
    //
    UINTX ia_untrusted_wac : 64;
  } Bits;
  UINTX Data;
} A_CR_IA_UNTRUSTED_WAC_AUNIT_MSG_MAP_1_STRUCT;
#endif // ASM_INC

#define A_CR_BIOSWR_CP_AUNIT_MSG_MAP_1_REG                 0x00004F30
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Bit vector used to determine which agents are allowed access to the A-Unit BIOSWR
    // Registers based on the value from the agents 6 bit SAI field. This register is
    // selfreferential the access policy provided applies to access to the control register
    // itself. 
    // 
    // Bits[63:0], RW, default = 0xC0061010202
    //
    UINTX bioswr_cp : 64;
  } Bits;
  UINTX Data;
} A_CR_BIOSWR_CP_AUNIT_MSG_MAP_1_STRUCT;
#endif // ASM_INC

#define A_CR_BIOSWR_RAC_AUNIT_MSG_MAP_1_REG                0x00004F38
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Bit vector used to determine which agents are allowed Rd access to the A-Unit
    // BIOSWR Register based on the value from the agents 6 bit SAI field. 
    // 
    // Bits[63:0], RW, default = 0x80000C0063010217
    //
    UINTX bioswr_rac : 64;
  } Bits;
  UINTX Data;
} A_CR_BIOSWR_RAC_AUNIT_MSG_MAP_1_STRUCT;
#endif // ASM_INC

#define A_CR_BIOSWR_WAC_AUNIT_MSG_MAP_1_REG                0x00004F40
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Bit vector used to determine which agents are allowed Wr access to the A-Unit
    // BIOSWR registers based on the value from the agents 6 bit SAI field. 
    // 
    // Bits[63:0], RW, default = 0xC0061000212
    //
    UINTX bioswr_wac : 64;
  } Bits;
  UINTX Data;
} A_CR_BIOSWR_WAC_AUNIT_MSG_MAP_1_STRUCT;
#endif // ASM_INC

#define A_CR_IMRGLOBAL_BM_CP_AUNIT_MSG_MAP_1_REG           0x00004F48
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Bit vector used to determine which agents are allowed access to the A-Unit IMRGLOBAL_BM
    // Registers based on the value from the agents 6 bit SAI field. This register is
    // selfreferential the access policy provided applies to access to the control register
    // itself. 
    // 
    // Bits[63:0], RW, default = 0xC0061010202
    //
    UINTX imrglobal_bm_cp : 64;
  } Bits;
  UINTX Data;
} A_CR_IMRGLOBAL_BM_CP_AUNIT_MSG_MAP_1_STRUCT;
#endif // ASM_INC

#define A_CR_IMRGLOBAL_BM_RAC_AUNIT_MSG_MAP_1_REG          0x00004F50
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Bit vector used to determine which agents are allowed Rd access to the A-Unit
    // IMRGLOBAL_BM Register based on the value from the agents 6 bit SAI field. 
    // 
    // Bits[63:0], RO, default = 0xFFFFFFFFFFFFFFFF
    //
    UINTX imrglobal_bm_rac : 64;
  } Bits;
  UINTX Data;
} A_CR_IMRGLOBAL_BM_RAC_AUNIT_MSG_MAP_1_STRUCT;
#endif // ASM_INC

#define A_CR_IMRGLOBAL_BM_WAC_AUNIT_MSG_MAP_1_REG          0x00004F58
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Bit vector used to determine which agents are allowed Wr access to the A-Unit
    // IMRGLOBAL_BM registers based on the value from the agents 6 bit SAI field. 
    // 
    // Bits[63:0], RW, default = 0xC0061010202
    //
    UINTX imrglobal_bm_wac : 64;
  } Bits;
  UINTX Data;
} A_CR_IMRGLOBAL_BM_WAC_AUNIT_MSG_MAP_1_STRUCT;
#endif // ASM_INC

#define A_CR_PTAS_CP_AUNIT_MSG_MAP_1_REG                   0x00004F60
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Bit vector used to determine which agents are allowed access to the Aunit CREG
    // based on the value from the agents 6 bit SAI field. This register is selfreferential
    // the access policy provided applies to access to the control register itself. 
    // 
    // Bits[63:0], RO, default = 0x0
    //
    UINTX ptas_cp : 64;
  } Bits;
  UINTX Data;
} A_CR_PTAS_CP_AUNIT_MSG_MAP_1_STRUCT;
#endif // ASM_INC

#define A_CR_PTAS_RAC_AUNIT_MSG_MAP_1_REG                  0x00004F68
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Bit vector used to determine which agents are allowed Rd access to the Aunit CREG
    // based on the value from the agents 6 bit SAI field. 
    // 
    // Bits[63:0], RO, default = 0xFFFFFFFFFFFFFFFF
    //
    UINTX ptas_rac : 64;
  } Bits;
  UINTX Data;
} A_CR_PTAS_RAC_AUNIT_MSG_MAP_1_STRUCT;
#endif // ASM_INC

#define A_CR_PTAS_WAC_AUNIT_MSG_MAP_1_REG                  0x00004F70
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Bit vector used to determine which agents are allowed Wr access to the Aunit CREG
    // based on the value from the agents 6 bit SAI field. 
    // 
    // Bits[63:0], RO, default = 0x400210C0202
    //
    UINTX ptas_wac : 64;
  } Bits;
  UINTX Data;
} A_CR_PTAS_WAC_AUNIT_MSG_MAP_1_STRUCT;
#endif // ASM_INC

#define A_CR_MCI_STATUS_AUNIT_MSG_MAP_1_REG                0x00004F80
#ifndef ASM_INC
typedef union {
  struct {
    //
    // N/A
    // 
    // Bits[15:0], RW/V, default = 0x0
    //
    UINTX mca_err_code : 16;
    //
    // N/A
    // 
    // Bits[31:16], RW/V, default = 0x0
    //
    UINTX model_specific_err_code : 16;
    //
    // N/A
    // 
    // Bits[37:32], RW/V, default = 0x0
    //
    UINTX other : 6;
    //
    // N/A
    // 
    // Bits[52:38], RW/V, default = 0x0
    //
    UINTX cerr_cnt : 15;
    //
    // Threshold-based error status.
    // 
    // Bits[54:53], RW/V, default = 0x0
    //
    UINTX thrsh : 2;
    //
    // AR (recovery action required for UCR error).
    // 
    // Bits[55:55], RW/V, default = 0x0
    //
    UINTX ar : 1;
    //
    // S (signaling an uncorr recoverable (UCR) error).
    // 
    // Bits[56:56], RW/V, default = 0x0
    //
    UINTX s : 1;
    //
    // When set, indicates the state of the processor might have been corrupted. 
    // 	  [p]When clear, indicates the error did not affect the processor state.[/p]
    // 
    // Bits[57:57], RW/V, default = 0x0
    //
    UINTX pcc : 1;
    //
    // ADDRV (mci_addr is valid).
    // 
    // Bits[58:58], RW/V, default = 0x0
    //
    UINTX addrv : 1;
    //
    // MISCV (mci_misc is valid).
    // 
    // Bits[59:59], RW/V, default = 0x0
    //
    UINTX miscv : 1;
    //
    // Error reporting has been enabled by the MCI_CTL register.
    // 
    // Bits[60:60], RW/V, default = 0x0
    //
    UINTX en : 1;
    //
    // Indicates that an uncorrected error was received by the A-Unit.
    // 
    // Bits[61:61], RW/V, default = 0x0
    //
    UINTX uc : 1;
    //
    // Error Overflow (OVER): Indicates a second error was received while the MCI_Status
    // Valid bit as set. 
    // 
    // Bits[62:62], RW/V, default = 0x0
    //
    UINTX ovflw : 1;
    //
    // MCI_Status Valid (VAL): When set, indicates the information on the IA32_MCI_Status
    // register is valid. Software is responsible for clearing the VAL flag. 
    // 
    // Bits[63:63], RW/V, default = 0x0
    //
    UINTX valid : 1;
  } Bits;
  UINTX Data;
} A_CR_MCI_STATUS_AUNIT_MSG_MAP_1_STRUCT;
#endif // ASM_INC

#define A_CR_MCI_CTL_AUNIT_MSG_MAP_1_REG                   0x00004F88
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Illegal/Unsupported posted opcode received from iosf.
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINTX illegal_posted_opcode : 1;
    //
    // An incorrect/illegal sai was received with an upstream posted transaction.
    // 
    // Bits[1:1], RW, default = 0x0
    //
    UINTX bad_sai_posted : 1;
    //
    // Illegal/Unsupported non-posted opcode received from iosf.
    // 
    // Bits[2:2], RW, default = 0x0
    //
    UINTX illegal_nonposted_opcode : 1;
    //
    // An incorrect/illegal sai was received with an upstream non-posted transaction.
    // 
    // Bits[3:3], RW, default = 0x0
    //
    UINTX bad_sai_nonposted : 1;
    //
    // Received a CmplLck completion from iosf.
    // 
    // Bits[4:4], RW, default = 0x0
    //
    UINTX received_lk_cmpl : 1;
    //
    // An incorrect/illegal sai was received with an upstream completion transaction.
    // 
    // Bits[5:5], RW, default = 0x0
    //
    UINTX bad_sai_cmpl : 1;
    //
    // reserved for future use
    // 
    // Bits[6:6], RO, default = 0x0
    //
    UINTX undefined5 : 1;
    //
    // A device that is not support to set the AT bit set it to an illegal value
    // 
    // Bits[7:7], RW, default = 0x0
    //
    UINTX at_translated_illegal_device : 1;
    //
    // A malformed/illegal MSI was received in the upstream direction
    // 
    // Bits[8:8], RW, default = 0x0
    //
    UINTX illegal_msi : 1;
    //
    // A transaction was received with a guest physical address that was too large
    // 
    // Bits[9:9], RW, default = 0x0
    //
    UINTX gpa_overflow : 1;
    //
    // An MSI was received with reserved bits set
    // 
    // Bits[10:10], RW, default = 0x0
    //
    UINTX msi_rsvd_set : 1;
    //
    // reserved for future use
    // 
    // Bits[11:11], RO, default = 0x0
    //
    UINTX undefined0 : 1;
    //
    // reserved for future use
    // 
    // Bits[12:12], RO, default = 0x0
    //
    UINTX undefined1 : 1;
    //
    // reserved for future use
    // 
    // Bits[13:13], RO, default = 0x0
    //
    UINTX undefined2 : 1;
    //
    // reserved for future use
    // 
    // Bits[14:14], RO, default = 0x0
    //
    UINTX undefined3 : 1;
    //
    // reserved for future use
    // 
    // Bits[15:15], RO, default = 0x0
    //
    UINTX undefined4 : 1;
    //
    // iosf upstream cmd parity error detected
    // 
    // Bits[16:16], RW, default = 0x0
    //
    UINTX iosf_upstream_cmd_par_err : 1;
    //
    // iosf upstream data parity error detected
    // 
    // Bits[17:17], RW, default = 0x0
    //
    UINTX iosf_upstream_data_par_err : 1;
    //
    // upstream cmd buffer parity error detected
    // 
    // Bits[18:18], RW, default = 0x0
    //
    UINTX upstream_cmd_buffer_par_err : 1;
    //
    // downstream data buffer parity error detected
    // 
    // Bits[19:19], RW, default = 0x0
    //
    UINTX downstream_data_buffer_par_err : 1;
    //
    // downstream cmd buffer parity error detected
    // 
    // Bits[20:20], RW, default = 0x0
    //
    UINTX downstream_cmd_buffer_par_err : 1;
    //
    // IOMMU level 2 page walk data parity error
    // 
    // Bits[21:21], RW, default = 0x0
    //
    UINTX iommu_data_l2_par_err : 1;
    //
    // IOMMU level 3 page walk data parity error
    // 
    // Bits[22:22], RW, default = 0x0
    //
    UINTX iommu_data_l3_par_err : 1;
    //
    // IOMMU level 4 page walk data parity error
    // 
    // Bits[23:23], RW, default = 0x0
    //
    UINTX iommu_data_l4_par_err : 1;
    //
    // IOMMU context cache data parity error
    // 
    // Bits[24:24], RW, default = 0x0
    //
    UINTX iommu_data_cc_par_err : 1;
    //
    // IOMMU IOTLB data parity error
    // 
    // Bits[25:25], RW, default = 0x0
    //
    UINTX iommu_data_iotlb_par_err : 1;
    //
    // reserved for future use
    // 
    // Bits[26:26], RO, default = 0x0
    //
    UINTX undefined26 : 1;
    //
    // reserved for future use
    // 
    // Bits[27:27], RO, default = 0x0
    //
    UINTX undefined27 : 1;
    //
    // reserved for future use
    // 
    // Bits[28:28], RO, default = 0x0
    //
    UINTX undefined28 : 1;
    //
    // reserved for future use
    // 
    // Bits[29:29], RO, default = 0x0
    //
    UINTX undefined29 : 1;
    //
    // reserved for future use
    // 
    // Bits[30:30], RO, default = 0x0
    //
    UINTX undefined30 : 1;
    //
    // reserved for future use
    // 
    // Bits[31:31], RO, default = 0x0
    //
    UINTX undefined31 : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[63:32], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 32;
  } Bits;
  UINTX Data;
} A_CR_MCI_CTL_AUNIT_MSG_MAP_1_STRUCT;
#endif // ASM_INC

#define A_CR_MCI_CTL2_AUNIT_MSG_MAP_1_REG                  0x00004F90
#ifndef ASM_INC
typedef union {
  struct {
    //
    // MCI_CTL2 threshold value for CMCI.
    // 
    // Bits[14:0], RW, default = 0x0
    //
    UINTX threshold : 15;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[29:15], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 15;
    //
    // MCI_CTL2 enable for CMCI.
    // 
    // Bits[30:30], RW, default = 0x0
    //
    UINTX enable : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[63:31], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 33;
  } Bits;
  UINTX Data;
} A_CR_MCI_CTL2_AUNIT_MSG_MAP_1_STRUCT;
#endif // ASM_INC

#define A_CR_MCI_ADDR_AUNIT_MSG_MAP_1_REG                  0x00004F98
#ifndef ASM_INC
typedef union {
  struct {
    //
    // MCI_ADDR: Address associated with the MCI_STS register if addrv==1.  This is the
    // GPA. 
    // 
    // Bits[63:0], RW/V, default = 0x0
    //
    UINTX address : 64;
  } Bits;
  UINTX Data;
} A_CR_MCI_ADDR_AUNIT_MSG_MAP_1_STRUCT;
#endif // ASM_INC

#define A_CR_UPCMD_ENTRY_DIS_AUNIT_MSG_MAP_1_REG           0x00004FA0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Each bit in this register controls whether the 4 entries starting at 4*bitnum
    // will be used in upcmd   0-used.  1-disabled 
    // 
    // Bits[16:0], RW, default = 0x0
    //
    UINTX entry_disable : 17;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[63:17], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 47;
  } Bits;
  UINTX Data;
} A_CR_UPCMD_ENTRY_DIS_AUNIT_MSG_MAP_1_STRUCT;
#endif // ASM_INC

#define A_CR_UPDATA_ENTRY_DIS_AUNIT_MSG_MAP_1_REG          0x00004FA8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Each bit in this register controls whether the 4 entries starting at 4*bitnum
    // will be used in updata   0-used.  1-disabled 
    // 
    // Bits[15:0], RW, default = 0x0
    //
    UINTX entry_disable : 16;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[63:16], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 48;
  } Bits;
  UINTX Data;
} A_CR_UPDATA_ENTRY_DIS_AUNIT_MSG_MAP_1_STRUCT;
#endif // ASM_INC

#define A_CR_GZLQ_ENTRY_DIS_AUNIT_MSG_MAP_1_REG            0x00004FB0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Each bit in this register controls whether the 4 entries starting at 4*bitnum
    // will be used in gazelle queue  0-used.  1-disabled 
    // 
    // Bits[22:0], RW, default = 0x0
    //
    UINTX entry_disable : 23;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[63:23], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 41;
  } Bits;
  UINTX Data;
} A_CR_GZLQ_ENTRY_DIS_AUNIT_MSG_MAP_1_STRUCT;
#endif // ASM_INC

#define A_CR_DNCMDDATA_ENTRY_DIS_AUNIT_MSG_MAP_1_REG       0x00004FB8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Each bit in this register controls whether the 4 entries starting at 4*bitnum
    // will be used in DnCmd/Data.  0-used.  1-disabled 
    // 
    // Bits[9:0], RW, default = 0x0
    //
    UINTX entry_disable : 10;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[63:10], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 54;
  } Bits;
  UINTX Data;
} A_CR_DNCMDDATA_ENTRY_DIS_AUNIT_MSG_MAP_1_STRUCT;
#endif // ASM_INC


#endif // _AUNIT_MSG_MAP_1_H_
