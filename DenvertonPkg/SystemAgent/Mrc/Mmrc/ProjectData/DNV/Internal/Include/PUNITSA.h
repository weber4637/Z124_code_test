/** @file
  File name:    PUNITSA.h
  Input File:   DNV_MRC.xlsx

  THIS FILE IS AUTO-GENERATED BY THE MSP TOOL. DO NOT CHANGE THIS CODE.

  If edits are needed in this file, they must be done via the MSP tool.

  If there is additional project-specific data required by the MSP, it
  can be placed in PUNITSA.h, which is used for non-tool-generated
  data

  Includes register defines specific to a project.

  Copyright (c) 2005-2018 Intel Corporation. All rights reserved
  This software and associated documentation (if any) is furnished
  under a license and may only be used or copied in accordance
  with the terms of the license. Except as permitted by such
  license, no part of this software or documentation may be
  reproduced, stored in a retrieval system, or transmitted in any
  form or by any means without the express written consent of
  Intel Corporation.
**/
#ifndef _PUNITSA_H_
#define _PUNITSA_H_

#include "DataTypes.h"

#if USE_64_BIT_VARIABLES
#define UINTX UINT64
#else
#define UINTX UINT32
#endif

#define DDR_RAPL_LIMIT_MISC_PUNITSA_REG                    0x00007040
#ifndef ASM_INC
typedef union {
  struct {
    //
    // 
    // 
    // Bits[63:0], RW, default = 0x0
    //
    UINTX data : 64;
  } Bits;
  UINTX Data;
} DDR_RAPL_LIMIT_MISC_PUNITSA_STRUCT;
#endif // ASM_INC

#define P_CR_PWR_LIMIT_MISC_0_0_0_MCHBAR_PUNITSA_REG       0x00007014
#ifndef ASM_INC
typedef union {
  struct {
    //
    // HW Fuse populated.  FUSE.PN_POWER_OF_SKU: Package Power of SKU.
    // 
    // Bits[14:0], RO/V, default = 0x0
    //
    UINTX pn_power_of_sku : 15;
    //
    // HW fuse populated. FUSE.PBM_MINIMAL_TAU_ALLOWED: Minimal Tau Time window allowed.
    // 
    // Bits[21:15], RO/V, default = 0x0
    //
    UINTX pbm_minimal_tau_allowed : 7;
    //
    // Reserved
    // 
    // Bits[31:22], RO, default = 0x0
    //
    UINTX reserved : 10;
  } Bits;
  UINTX Data;
} P_CR_PWR_LIMIT_MISC_0_0_0_MCHBAR_PUNITSA_STRUCT;
#endif // ASM_INC

#define P_CR_CAPABILITY_ID_0_0_0_MCHBAR_PUNITSA_REG        0x00007018
#ifndef ASM_INC
typedef union {
  struct {
    //
    // HW Fuse populated. FUSE.FUSE_THERMAL_PROFILE of the part.  Definition TBD.
    // 
    // Bits[1:0], RO/V, default = 0x0
    //
    UINTX fuse_thermal_profile : 2;
    //
    // Reserved
    // 
    // Bits[31:2], RO, default = 0x0
    //
    UINTX reserved : 30;
  } Bits;
  UINTX Data;
} P_CR_CAPABILITY_ID_0_0_0_MCHBAR_PUNITSA_STRUCT;
#endif // ASM_INC

#define P_CR_MC_BIOS_REQ_0_0_0_MCHBAR_PUNITSA_REG          0x00007020
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[5:0], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 6;
    //
    // BIOS set VDDQ Voltage: 0: DDR3 Memory Technology (Pcode set VDDQ = 1.35V); 1:
    // DDR4 Memory Technology  (Pcode sets VDDQ = 1.25V); 
    // 
    // Bits[6:6], RW, default = 0x0
    //
    UINTX ddr_type_voltage : 1;
    //
    // Reserved - Future data bits for fastpath action or status indication.
    // 
    // Bits[11:7], RW, default = 0x0
    //
    UINTX rsvd2 : 5;
    //
    // BIOS writes this value indicates if memory channel 1 has device attached or not.
    //  1'b1 = 1 or 2 DIMMs populated. 
    // 
    // Bits[12:12], RW, default = 0x0
    //
    UINTX ch0_enabled : 1;
    //
    // BIOS writes this value indicates if memory channel 1 has device attached or not.
    //  1'b1 = 1 or 2 DIMMs populated. 
    // 
    // Bits[13:13], RW, default = 0x0
    //
    UINTX ch1_enabled : 1;
    //
    // BIOS writes this value indicates
    // 
    // Bits[14:14], RW, default = 0x0
    //
    UINTX ch0_dimms : 1;
    //
    // BIOS writes this value indicates
    // 
    // Bits[15:15], RW, default = 0x0
    //
    UINTX ch1_dimms : 1;
    //
    // Reserved - Future data bits for fastpath action or status indication.
    // 
    // Bits[18:16], RW, default = 0x0
    //
    UINTX rsvd1 : 3;
    //
    // BIOS programs this bit after DUNIT and DDRIO configuration is completeFuture data
    // bits for fastpath action or status indication. 
    // 
    // Bits[19:19], RW, default = 0x0
    //
    UINTX mem_init_done : 1;
    //
    // Reserved - Future data bits for fastpath action or status indication.
    // 
    // Bits[30:20], RW, default = 0x0
    //
    UINTX rsvd0 : 11;
    //
    // This bit indicates that the BIOS request is pending.  BIOS sets this bit together
    // with a command in the lower bits of this register.  Firmware may only clear this
    // bit after the BIOS request has been served or observed. 
    // 
    // Bits[31:31], RW, default = 0x0
    //
    UINTX run_busy : 1;
  } Bits;
  UINTX Data;
} P_CR_MC_BIOS_REQ_0_0_0_MCHBAR_PUNITSA_STRUCT;
#endif // ASM_INC

#define P_CR_MCA_ERROR_SRC_0_0_0_MCHBAR_PUNITSA_REG        0x0000702C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Undefined - reserved for future use.
    // 
    // Bits[7:0], RW, default = 0x0
    //
    UINTX reserved : 8;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[28:8], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 21;
    //
    // Asserted by HW on MCERR assertion.
    // 
    // Bits[29:29], RW/V, default = 0x0
    //
    UINTX mcerr : 1;
    //
    // Asserted by HW on IERR assertion.
    // 
    // Bits[30:30], RW/V, default = 0x0
    //
    UINTX ierr : 1;
    //
    // Asserted by HW on IERR or MCERR assertion.
    // 
    // Bits[31:31], RW/V, default = 0x0
    //
    UINTX caterr : 1;
  } Bits;
  UINTX Data;
} P_CR_MCA_ERROR_SRC_0_0_0_MCHBAR_PUNITSA_STRUCT;
#endif // ASM_INC

#define P_CR_DDR_THERM_THRT_CTRL_0_0_0_MCHBAR_PUNITSA_REG  0x00007030
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Configurable threshold of far LPDDR memory MR4 value greater than or equal to
    // which thermal throttling is activated.  For the standard LPDDR DRAM that is only
    // capable up to Tcasemax of 85C this field should be configured to avoid DRAM to
    // exceed its Tcasemax spec. 
    //              [list]
    //              [*] Far Memory MR4 >= Threshold = Enable thermal throttling
    //              [*] Far Memory MR4 < Threshold = Disable thermal throttling
    //              [/list]
    //              
    // 
    // Bits[2:0], RW/V, default = 0x0
    //
    UINTX fm_therm_thrt_threshold : 3;
    //
    // When enabled throttling is activated if far LPDDR memory MR4 value is greater
    // than or equal to FM_THERM_THRT_THRESHOLD.  For the standard LPDDR DRAM that is
    // only capable up to Tcasemax of 85C this bit should be set to enable far LPDDR
    // throttling to keep DRAM within its Tcasemax spec. 
    // 
    // Bits[3:3], RW/V, default = 0x0
    //
    UINTX fm_therm_thrt_enable : 1;
    //
    // Configurable threshold of near Wide I/O memory MR4 value greater than or equal
    // to which thermal throttling is activated. 
    //              [list]
    //              [*] Near Memory MR4 >= Threshold = Enable thermal throttling
    //              [*] Near Memory MR4 < Threshold = Disable thermal throttling
    //              [/list]
    //              
    // 
    // Bits[6:4], RW/V, default = 0x0
    //
    UINTX nm_therm_thrt_threshold : 3;
    //
    // When set, throttling is activated if near Wide I/O memory MR4 value is greater
    // than or equal to NM_THERM_THRT_THRESHOLD 
    // 
    // Bits[7:7], RW/V, default = 0x0
    //
    UINTX nm_therm_thrt_enable : 1;
    //
    // Configure memory throttling behavior.  Policies are defined as follows:
    //          [list]
    //          [*] 0 = Thermal throttling policy uses instanous MR4 status for FM/NM_THERM_THRT_THRESHOLD
    //          [*] 1 = Thermal throttling policy uses time filtered MR4 status for FM/NM_THERM_THRT_THRESHOLD.
    //  Filtering time constant is configured in the DDR_THERM_INTERRUPT register. 
    //          [/list]
    // 
    // Bits[8:8], RW/V, default = 0x0
    //
    UINTX mem_thrt_cfg : 1;
    //
    // When set, memory traffic is throttled if near Wide-IO or far LPDDR memory MR4
    // value >= FM/NM_THERM_THRT_THRESHOLD, respectively.  Thermal throttling is achieved
    // by applying memory bandwidth clips in the memory subsystem. 
    // 
    // Bits[9:9], RW/V, default = 0x0
    //
    UINTX mem_thrt_enable : 1;
    //
    // RESERVED
    // 
    // Bits[15:10], RO, default = 0x0
    //
    UINTX reserved_0 : 6;
    //
    // DEPRECATED.
    // 
    // Bits[16:16], RW/V, default = 0x1
    //
    UINTX xltt_mem_thrt_enable : 1;
    //
    // RESERVED
    // 
    // Bits[31:17], RO, default = 0x0
    //
    UINTX reserved_1 : 15;
  } Bits;
  UINTX Data;
} P_CR_DDR_THERM_THRT_CTRL_0_0_0_MCHBAR_PUNITSA_STRUCT;
#endif // ASM_INC

#define P_CR_PACKAGE_THERM_MARGIN_0_0_0_MCHBAR_PUNITSA_REG 0x0000703C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Temperature margin in PECI temperature counts from the thermal profile specification.
    //  THERM_MARGIN is in 2's complement format (8.8 format where MSB equals 1 Sign
    // bit + 7 bits of integer temperature value and the LSB equals 8 precison bits of
    // temperature value).  A value of zero indicates the hottest CPU die temperature
    // is on the thermal profile line. A negative value indicates gap to the thermal
    // profile that platform SW should increase cooling capacity.  A sustained negative
    // value should be avoided as it may impact part reliability. 
    // 
    // Bits[15:0], RW, default = 0x0
    //
    UINTX therm_margin : 16;
    //
    // Reserved
    // 
    // Bits[31:16], RW, default = 0x0
    //
    UINTX reserved : 16;
  } Bits;
  UINTX Data;
} P_CR_PACKAGE_THERM_MARGIN_0_0_0_MCHBAR_PUNITSA_STRUCT;
#endif // ASM_INC

#define P_CR_DDR_RAPL_LIMIT_0_0_0_MCHBAR_PUNITSA_REG       0x00007040
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Power Limit[0] for DDR domain. The power units of this field are specified by
    // the PACKAGE_POWER_SKU_UNIT_MSR.PWR_UNIT. 
    // 
    // Bits[14:0], RW/L, default = 0x0
    //
    UINTX limit1_power : 15;
    //
    // Power Limit[0] enable bit for DDR domain.
    // 
    // Bits[15:15], RW/L, default = 0x0
    //
    UINTX limit1_enable : 1;
    //
    // Reserved
    // 
    // Bits[16:16], RO, default = 0x0
    //
    UINTX reserved_0 : 1;
    //
    // The Tau Exponent.  See TIME_WINDOW_X for more information.
    // 
    // Bits[21:17], RW/L, default = 0x0
    //
    UINTX limit1_time_window_y : 5;
    //
    // The time window for RAPL is expressed in a format called TAU.  TAU is specified
    // in a mantissa+exponent format.  This format is common across all RAPL interfaces
    // for TAU. 
    // 
    //       The format is specified with a 7 bit number that looks like: 
    //          XXYYYYY   (2 bits of mantissa follwed by 5 exponent)
    // 
    //       The time window corresponding to this config is calculated as:
    //          (1+ XXb / 4) * (2^YYYYYb)
    // 
    //       The value that results from this math species the time window in units that
    // are defined in PACKAGE_POWER_SKU_UNIT.TIME_UNIT MSR.  On every server product
    // we have built, this value has been 976us, which we typically treat as 1ms. 
    //       
    // 
    // Bits[23:22], RW/L, default = 0x0
    //
    UINTX limit1_time_window_x : 2;
    //
    // Reserved
    // 
    // Bits[31:24], RO, default = 0x0
    //
    UINTX reserved_1 : 8;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[62:32], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 31;
    //
    // When set this entire register becomes readonly. This bit will typically be set
    // by BIOS during boot. 
    // 
    // Bits[63:63], RW/L, default = 0x0
    //
    UINTX locked : 1;
  } Bits;
  UINTX Data;
} P_CR_DDR_RAPL_LIMIT_0_0_0_MCHBAR_PUNITSA_STRUCT;
#endif // ASM_INC

#define P_CR_DDR_ENERGY_STATUS_0_0_0_MCHBAR_PUNITSA_REG    0x00007048
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Total Joules of energy consumed by all DIMMs.  Units are proportional to Joules
    // and are defined by PACKAGE_POWER_SKU_UNIT_MSR.ENERGY_UNIT. 
    // 
    // Bits[31:0], RO/V, default = 0x0
    //
    UINTX joules : 32;
  } Bits;
  UINTX Data;
} P_CR_DDR_ENERGY_STATUS_0_0_0_MCHBAR_PUNITSA_STRUCT;
#endif // ASM_INC

#define P_CR_DDR_RAPL_PERF_STATUS_0_0_0_MCHBAR_PUNITSA_REG 0x0000704C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Bandwidth throttle duration counter due to Memory RAPL.  Sum across all channels
    // in PACKAGE_POWER_SKU_UNIT_MSR.TIME_UNIT units. This data can serve as a proxy
    // for the potential performance impacts of RAPL on memory accesses. 
    // 
    // Bits[31:0], RW, default = 0x58F0
    //
    UINTX duration : 32;
  } Bits;
  UINTX Data;
} P_CR_DDR_RAPL_PERF_STATUS_0_0_0_MCHBAR_PUNITSA_STRUCT;
#endif // ASM_INC

#define P_CR_PACKAGE_RAPL_PERF_STATUS_0_0_0_MCHBAR_PUNITSA_REG 0x00007050
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Time that any core in the IA domain is performance throttled below OS request
    // and below the base frequency (P1) because of power limits (PL1 or PL2).  Counts
    // in time units defined by PACKAGE_POWER_SKU_UNIT_MSR.TIME_UNIT 
    // 
    // Bits[31:0], RW, default = 0x0
    //
    UINTX counts : 32;
  } Bits;
  UINTX Data;
} P_CR_PACKAGE_RAPL_PERF_STATUS_0_0_0_MCHBAR_PUNITSA_STRUCT;
#endif // ASM_INC

#define P_CR_PRIMARY_PLANE_TURBO_PLCY_0_0_0_MCHBAR_PUNITSA_REG 0x00007054
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Performance priority Level for the IA Core (primary) power plane. A higher number
    // implies a higher priority. 
    // 
    // Bits[4:0], RW, default = 0x0
    //
    UINTX priptp : 5;
    //
    // Reserved
    // 
    // Bits[31:5], RO, default = 0x0
    //
    UINTX reserved_0 : 27;
  } Bits;
  UINTX Data;
} P_CR_PRIMARY_PLANE_TURBO_PLCY_0_0_0_MCHBAR_PUNITSA_STRUCT;
#endif // ASM_INC

#define P_CR_SECONDARY_PLANE_TURBO_PLCY_0_0_0_MCHBAR_PUNITSA_REG 0x00007058
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Performance priority Level for the Graphics (secondary) power plane. A higher
    // number implies a higher priority. 
    // 
    // Bits[4:0], RW, default = 0x10
    //
    UINTX secptp : 5;
    //
    // Reserved
    // 
    // Bits[31:5], RO, default = 0x0
    //
    UINTX reserved_0 : 27;
  } Bits;
  UINTX Data;
} P_CR_SECONDARY_PLANE_TURBO_PLCY_0_0_0_MCHBAR_PUNITSA_STRUCT;
#endif // ASM_INC

#define P_CR_PRIMARY_PLANE_ENERGY_STATUS_0_0_0_MCHBAR_PUNITSA_REG 0x0000705C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // [p]Contains an accumulated value of the energy consumed in the primary power plane.
    // To find the energy consumed in a given time window, sofwtare should subtract the
    // two energy readings. 
    //                  Software will have to take care of counter wrapping around when
    // it overflows.[/p] 
    //               [p]Units are proportional to Joules exact precsion is defined by
    // PACKAGE_POWER_SKU_UNIT_MSR.ENERGY_UNIT[/p] 
    // 
    // Bits[31:0], RO/V, default = 0x0
    //
    UINTX data : 32;
  } Bits;
  UINTX Data;
} P_CR_PRIMARY_PLANE_ENERGY_STATUS_0_0_0_MCHBAR_PUNITSA_STRUCT;
#endif // ASM_INC

#define P_CR_SECONDARY_PLANE_ENERGY_STATUS_0_0_0_MCHBAR_PUNITSA_REG 0x00007060
#ifndef ASM_INC
typedef union {
  struct {
    //
    // [p]Contains an accumulated value of the energy consumed in the secondary power
    // plane. To find the energy consumed in a given time window, sofwtare should subtract
    // the two energy readings.  
    //                  Software will have to take care of counter wrapping around when
    // it overflows.[/p] 
    //               [p]Units are proportional to Joules exact precsion is defined by
    // PACKAGE_POWER_SKU_UNIT_MSR.ENERGY_UNIT[/p] 
    // 
    // Bits[31:0], RO/V, default = 0x0
    //
    UINTX data : 32;
  } Bits;
  UINTX Data;
} P_CR_SECONDARY_PLANE_ENERGY_STATUS_0_0_0_MCHBAR_PUNITSA_STRUCT;
#endif // ASM_INC

#define P_CR_PACKAGE_POWER_SKU_UNIT_0_0_0_MCHBAR_PUNITSA_REG 0x00007068
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Used to define the units of power control registers such as PL1, PL2, PL3 and
    // PL4.   The actual unit value is calculated by 1 W / 2^PWR_UNIT.  The default value
    // of 8 corresponds to 3.9mW per bit. 
    // 
    // Bits[3:0], RW, default = 0x8
    //
    UINTX pwr_unit : 4;
    //
    // Reserved
    // 
    // Bits[7:4], RO, default = 0x0
    //
    UINTX reserved_0 : 4;
    //
    // Used to define the units of energy reporting registers such as PACKAGE_ENERGY_STATUS.
    //  The actual unit value is calculated by 1 J / 2^ENERGY_UNIT.  The default value
    // of 14 corresponds to ~61uJ per bit. 
    // 
    // Bits[12:8], RW, default = 0xE
    //
    UINTX energy_unit : 5;
    //
    // Reserved
    // 
    // Bits[15:13], RO, default = 0x0
    //
    UINTX reserved_1 : 3;
    //
    // Used for to define the time units in registers such as PL1, PL2, PL3 and PL4.
    //   The actual unit value is calculated by 1s / 2^TIME_UNIT.  The default value
    // of 10 corresponds to 0.977ms. 
    // 
    // Bits[19:16], RW, default = 0xA
    //
    UINTX time_unit : 4;
    //
    // Reserved
    // 
    // Bits[23:20], RO, default = 0x0
    //
    UINTX reserved_2 : 4;
    //
    // Used to define the units of amps in control registers such as VR_CURRENT_CONFIG.
    //  The actual unit value is calculated by 1A / 2^CURRENT_UNIT.  The default value
    // of 3 corresponds to 0.125A. 
    // 
    // Bits[27:24], RW, default = 0x3
    //
    UINTX current_unit : 4;
    //
    // Used to define the units of resistance for control registers that describe parameters
    // in ohms such as VR_CURRENT_CONFIG.  The actual unit value is calculated by 1mohm
    // / 2^RESISTANCE_UNIT.  The default value of 3 corresponds to 0.125mohm. 
    // 
    // Bits[31:28], RW, default = 0x3
    //
    UINTX resistance_unit : 4;
  } Bits;
  UINTX Data;
} P_CR_PACKAGE_POWER_SKU_UNIT_0_0_0_MCHBAR_PUNITSA_STRUCT;
#endif // ASM_INC

#define P_CR_PACKAGE_ENERGY_STATUS_0_0_0_MCHBAR_PUNITSA_REG 0x0000706C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // [p]Contains accumulated energy consumed by the entire CPU. This counter will wrap
    // around and keep counting when the counter overflows.[/p] 
    //               [p]Units are proportional to Joules exact precsion is defined by
    // PACKAGE_POWER_SKU_UNIT_MSR.ENERGY_UNIT[/p] 
    // 
    // Bits[31:0], RO/V, default = 0x0
    //
    UINTX data : 32;
  } Bits;
  UINTX Data;
} P_CR_PACKAGE_ENERGY_STATUS_0_0_0_MCHBAR_PUNITSA_STRUCT;
#endif // ASM_INC

#define P_CR_GT_PERF_STATUS_0_0_0_MCHBAR_PUNITSA_REG       0x00007070
#ifndef ASM_INC
typedef union {
  struct {
    //
    // RP-State Voltage GT Target Voltage in U1.7 Volts
    // 
    // Bits[7:0], RO/V, default = 0x0
    //
    UINTX rp_state_voltage : 8;
    //
    // [p]Ratio of the current RP-state, in 16.6Mhz 1xclks. When the graphics engine
    // is in RC6, this field is zeroed out.[/p] 
    //               [p]For BXT the Unslice and Slice run at the same ratio.[/p]
    // 
    // Bits[16:8], RO/V, default = 0x0
    //
    UINTX rp_state_ratio_unslice : 9;
    //
    // [p]Ratio of the current RP-state, in 16.6Mhz 1xclks. When the graphics engine
    // is in RC6, this field is zeroed out.[/p] 
    //               [p]For BXT the Unslice and Slice run at the same ratio.[/p]
    // 
    // Bits[25:17], RO/V, default = 0x0
    //
    UINTX rp_state_ratio_slice : 9;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:26], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 6;
  } Bits;
  UINTX Data;
} P_CR_GT_PERF_STATUS_0_0_0_MCHBAR_PUNITSA_STRUCT;
#endif // ASM_INC

#define P_CR_TEMPERATURE_TARGET_0_0_0_MCHBAR_PUNITSA_REG   0x00007074
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Reserved
    // 
    // Bits[7:0], RO, default = 0x0
    //
    UINTX reserved_0 : 8;
    //
    // Fan Temperature Target Offset a.k.a. TControl indicates the relative offset from
    // the the Thermal Monitor Trip Temperature at which fans should be engaged. 
    // 
    // Bits[15:8], RO/V, default = 0x0
    //
    UINTX fan_temp_target_offset : 8;
    //
    // Tjmax a.k.a. Thermal Monitor activation temperature or Prochot Temperature.  This
    // is the maximum junction temperature at which thermal throttling aka thermal monitor
    // is activated.  This temperature is the maximum temperature at which the silicon
    // is capable of operating at.  All IA core digital thermal sensor readings are reported
    // as a relative nagative offset from this reference temperature, such that a readon
    // of zero implies the cores are running at this temperature. 
    // 
    // Bits[23:16], RO/V, default = 0x5A
    //
    UINTX ref_temp : 8;
    //
    // This field allows platform software to configure the temperature at which thermal
    // monitor engages to be lower than the manufacturing configured maximum constraint.
    //  This field is programmed in 1'C units.  E.g., if the default silicon configured
    // maximum temperature is 100'C and this field is configured to 10, then the silicon
    // will engage thermal throttling algorithms at 90'C 
    // 
    // Bits[30:24], RW, default = 0x0
    //
    UINTX tj_max_tcc_offset : 7;
    //
    // Reserved
    // 
    // Bits[31:31], RO, default = 0x0
    //
    UINTX reserved_1 : 1;
  } Bits;
  UINTX Data;
} P_CR_TEMPERATURE_TARGET_0_0_0_MCHBAR_PUNITSA_STRUCT;
#endif // ASM_INC

#define P_CR_BIOS_RESET_CPL_0_0_0_MCHBAR_PUNITSA_REG       0x00007078
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Set by BIOS to indicate that all power management configurations as part of reset
    // are complete.  This must include Punit patch load done as well as all relevant
    // Punit power management register and mailbox configurations done.  Once this bit
    // is set, Punit will allow normal power management to start.  Before setting this
    // bit, P-states and C-states support is disabled.  BIOS should wait before receiving
    // the Pcode Stage0 reset complete before proceeding with any further steps. 
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINTX rst_cpl : 1;
    //
    // BIOS sets this bit when it has completed this stage, Pcode must wait for this
    // bit to be set before proceeding to the next stage.  Stage validity is product-specific
    // and this stage may not be applicable to this product. 
    // 
    // Bits[1:1], RW, default = 0x0
    //
    UINTX rst_cpl1 : 1;
    //
    // BIOS sets this bit when it has completed this stage, Pcode must wait for this
    // bit to be set before proceeding to the next stage.  Stage validity is product-specific
    // and this stage may not be applicable to this product. 
    // 
    // Bits[2:2], RW, default = 0x0
    //
    UINTX rst_cpl2 : 1;
    //
    // BIOS sets this bit when it has completed this stage, Pcode must wait for this
    // bit to be set before proceeding to the next stage.  Stage validity is product-specific
    // and this stage may not be applicable to this product. 
    // 
    // Bits[3:3], RW, default = 0x0
    //
    UINTX rst_cpl3 : 1;
    //
    // BIOS sets this bit when it has completed this stage, Pcode must wait for this
    // bit to be set before proceeding to the next stage.  Stage validity is product-specific
    // and this stage may not be applicable to this product. 
    // 
    // Bits[4:4], RW, default = 0x0
    //
    UINTX rst_cpl4 : 1;
    //
    // BIOS sets this bit when it has completed this stage, Pcode must wait for this
    // bit to be set before proceeding to the next stage.  Stage validity is product-specific
    // and this stage may not be applicable to this product. 
    // 
    // Bits[5:5], RW, default = 0x0
    //
    UINTX rst_cpl5 : 1;
    //
    // BIOS sets this bit when it has completed this stage, Pcode must wait for this
    // bit to be set before proceeding to the next stage.  Stage validity is product-specific
    // and this stage may not be applicable to this product. 
    // 
    // Bits[6:6], RW, default = 0x0
    //
    UINTX rst_cpl6 : 1;
    //
    // reset complete
    // 
    // Bits[7:7], RW, default = 0x0
    //
    UINTX rst_cpl7 : 1;
    //
    // Pcode has completed its actions in response to Stage0 BIOS Reset complete.  Between
    // BIOS Stage0 complete and pcode Stage0 complete, pcode will apply all power savings
    // configurations to PCS and will set up C_STATE_LATENCY control MSR settings for
    // IRTL management. 
    // 
    // Bits[8:8], RO/V, default = 0x0
    //
    UINTX pcode_init_done : 1;
    //
    // Pcode sets this bit when it has completed this stage, BIOS must wait for this
    // bit to be set before proceeding to the next stage.  Stage validity is product-specific
    // and this stage may not be applicable to this product. 
    // 
    // Bits[9:9], RO/V, default = 0x0
    //
    UINTX pcode_init_done1 : 1;
    //
    // Pcode sets this bit when it has completed this stage, BIOS must wait for this
    // bit to be set before proceeding to the next stage.  Stage validity is product-specific
    // and this stage may not be applicable to this product. 
    // 
    // Bits[10:10], RO/V, default = 0x0
    //
    UINTX pcode_init_done2 : 1;
    //
    // Pcode sets this bit when it has completed this stage, BIOS must wait for this
    // bit to be set before proceeding to the next stage.  Stage validity is product-specific
    // and this stage may not be applicable to this product. 
    // 
    // Bits[11:11], RO/V, default = 0x0
    //
    UINTX pcode_init_done3 : 1;
    //
    // Pcode sets this bit when it has completed this stage, BIOS must wait for this
    // bit to be set before proceeding to the next stage.  Stage validity is product-specific
    // and this stage may not be applicable to this product. 
    // 
    // Bits[12:12], RO/V, default = 0x0
    //
    UINTX pcode_init_done4 : 1;
    //
    // Pcode sets this bit when it has completed this stage, BIOS must wait for this
    // bit to be set before proceeding to the next stage.  Stage validity is product-specific
    // and this stage may not be applicable to this product. 
    // 
    // Bits[13:13], RO/V, default = 0x0
    //
    UINTX pcode_init_done5 : 1;
    //
    // Pcode sets this bit when it has completed this stage, BIOS must wait for this
    // bit to be set before proceeding to the next stage.  Stage validity is product-specific
    // and this stage may not be applicable to this product. 
    // 
    // Bits[14:14], RO/V, default = 0x0
    //
    UINTX pcode_init_done6 : 1;
    //
    // Pcode sets this bit when it has completed this stage, BIOS must wait for this
    // bit to be set before proceeding to the next stage.  Stage validity is product-specific
    // and this stage may not be applicable to this product. 
    // 
    // Bits[15:15], RO/V, default = 0x0
    //
    UINTX pcode_init_done7 : 1;
    //
    // reserved
    // 
    // Bits[31:16], RW, default = 0x0
    //
    UINTX reserved0 : 16;
  } Bits;
  UINTX Data;
} P_CR_BIOS_RESET_CPL_0_0_0_MCHBAR_PUNITSA_STRUCT;
#endif // ASM_INC

#define P_CR_BIOS_MAILBOX_DATA_0_0_0_MCHBAR_PUNITSA_REG    0x00007080
#ifndef ASM_INC
typedef union {
  struct {
    //
    // This field contains the data associated with specific commands.
    // 
    // Bits[31:0], RW/V, default = 0x0
    //
    UINTX data : 32;
  } Bits;
  UINTX Data;
} P_CR_BIOS_MAILBOX_DATA_0_0_0_MCHBAR_PUNITSA_STRUCT;
#endif // ASM_INC

#define P_CR_BIOS_MAILBOX_INTERFACE_0_0_0_MCHBAR_PUNITSA_REG 0x00007084
#ifndef ASM_INC
typedef union {
  struct {
    //
    // This field contains the SW request command or the PCODE response code depending
    // on the setting of RUN_BUSY. 
    // 
    // Bits[7:0], RW/V, default = 0x0
    //
    UINTX command : 8;
    //
    // This field is used to specify an additional parameter to extend the command when
    // needed. 
    // 
    // Bits[28:8], RW/V, default = 0x0
    //
    UINTX address : 21;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[30:29], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
    //
    // SW may write to the two mailbox registers only when RUN_BUSY is clear(0). Setting
    // RUN_BUSY to 1 will pend a Fast Path event to Pcode. After setting this bit SW
    // will poll this bit until it is cleared.  PCODE will clear RUN_BUSY after updating
    // the mailbox registers with the result and error code. 
    // 
    // Bits[31:31], RW/1S/V, default = 0x0
    //
    UINTX run_busy : 1;
  } Bits;
  UINTX Data;
} P_CR_BIOS_MAILBOX_INTERFACE_0_0_0_MCHBAR_PUNITSA_STRUCT;
#endif // ASM_INC

#define P_CR_CORE_FREQUENCY_CAPABILITIES_0_0_0_MCHBAR_PUNITSA_REG 0x00007088
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Minimum supported ratio for the IA cores. Units are 100MHz multiplied by the ratio.
    // 
    // Bits[7:0], RO/V, default = 0x0
    //
    UINTX min_supported_freq : 8;
    //
    // Firmware-calculated efficient ratio for the IA cores. Units are 100MHz multiplied
    // by the ratio. 
    // 
    // Bits[15:8], RO/V, default = 0x0
    //
    UINTX efficient_freq : 8;
    //
    // Maximum ratio for the IA cores. Units are 100MHz multiplied by the ratio.
    // 
    // Bits[23:16], RO/V, default = 0x0
    //
    UINTX max_supported_freq : 8;
    //
    // Last resolved ratio for the IA cores. Units are 100MHz multiplied by the ratio.
    // This value is updated dynamically whenever the IA core frequency changes. 
    // 
    // Bits[31:24], RO/V, default = 0x0
    //
    UINTX last_resolved_freq : 8;
  } Bits;
  UINTX Data;
} P_CR_CORE_FREQUENCY_CAPABILITIES_0_0_0_MCHBAR_PUNITSA_STRUCT;
#endif // ASM_INC

#define P_CR_GRAPHICS_FREQUENCY_CAPABILITIES_0_0_0_MCHBAR_PUNITSA_REG 0x0000708C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Minimum supported ratio for the integrated graphics engine. Units are 50MHz multiplied
    // by the ratio. 
    // 
    // Bits[7:0], RO/V, default = 0x0
    //
    UINTX min_supported_freq : 8;
    //
    // Firmware-calculated efficient ratio for the integrated graphics engine. Units
    // are 50MHz multiplied by the ratio. 
    // 
    // Bits[15:8], RO/V, default = 0x0
    //
    UINTX efficient_freq : 8;
    //
    // Maximum supported ratio for the integrated graphics engine. Units are 50MHz multiplied
    // by the ratio. 
    // 
    // Bits[23:16], RO/V, default = 0x0
    //
    UINTX max_supported_freq : 8;
    //
    // Last resolved ratio for the integrated graphics engine. Units are 50MHz multiplied
    // by the ratio. This value is updated dynamically whenever the graphics engine frequency
    // changes. 
    // 
    // Bits[31:24], RO/V, default = 0x0
    //
    UINTX last_resolved_freq : 8;
  } Bits;
  UINTX Data;
} P_CR_GRAPHICS_FREQUENCY_CAPABILITIES_0_0_0_MCHBAR_PUNITSA_STRUCT;
#endif // ASM_INC

#define P_CR_SYSTEM_AGENT_FREQUENCY_CAPABILITIES_0_0_0_MCHBAR_PUNITSA_REG 0x00007090
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Reserved
    // 
    // Bits[7:0], RO/V, default = 0x0
    //
    UINTX reserved_0 : 8;
    //
    // Reserved
    // 
    // Bits[15:8], RO/V, default = 0x0
    //
    UINTX reserved_1 : 8;
    //
    // Reserved
    // 
    // Bits[23:16], RO/V, default = 0x0
    //
    UINTX reserved_2 : 8;
    //
    // Last resolved System Agent ratio, in units of 16.666MHz.
    // 
    // Bits[31:24], RO/V, default = 0x0
    //
    UINTX last_resolved_ratio : 8;
  } Bits;
  UINTX Data;
} P_CR_SYSTEM_AGENT_FREQUENCY_CAPABILITIES_0_0_0_MCHBAR_PUNITSA_STRUCT;
#endif // ASM_INC

#define P_CR_FAR_MEMORY_FREQUENCY_CAPABILITIES_0_0_0_MCHBAR_PUNITSA_REG 0x00007094
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Reserved
    // 
    // Bits[7:0], RO/V, default = 0x0
    //
    UINTX reserved_0 : 8;
    //
    // Reserved
    // 
    // Bits[15:8], RO/V, default = 0x0
    //
    UINTX reserved_1 : 8;
    //
    // Reserved
    // 
    // Bits[23:16], RO/V, default = 0x0
    //
    UINTX reserved_2 : 8;
    //
    // This field reports out the LPDDR far memory frequency in integer multiple of 133.33MHz.
    //  This register reflects what BIOS has programmed as the default LPDDR frequency
    // in products that do not support run-time memory frequency control.  For products
    // supporting run-time memory frequency control, this field describes the last resolved
    // frequency. 
    // 
    // Bits[31:24], RO/V, default = 0x0
    //
    UINTX last_resolved_ratio : 8;
  } Bits;
  UINTX Data;
} P_CR_FAR_MEMORY_FREQUENCY_CAPABILITIES_0_0_0_MCHBAR_PUNITSA_STRUCT;
#endif // ASM_INC

#define P_CR_NEAR_MEMORY_FREQUENCY_CAPABILITIES_0_0_0_MCHBAR_PUNITSA_REG 0x00007098
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Reserved
    // 
    // Bits[7:0], RO/V, default = 0x0
    //
    UINTX reserved_0 : 8;
    //
    // Reserved
    // 
    // Bits[15:8], RO/V, default = 0x0
    //
    UINTX reserved_1 : 8;
    //
    // Reserved
    // 
    // Bits[23:16], RO/V, default = 0x0
    //
    UINTX reserved_2 : 8;
    //
    // This field reports out the Wide I/O near memory frequency in integer multiple
    // of 133.33MHz.  This register reflects what BIOS has programmed as the default
    // Wide I/O near memory frequency in products that do not support run-time memory
    // frequency control.  For products supporting run-time memory frequency control,
    // this field describes the last resolved frequency. 
    // 
    // Bits[31:24], RO/V, default = 0x0
    //
    UINTX last_resolved_ratio : 8;
  } Bits;
  UINTX Data;
} P_CR_NEAR_MEMORY_FREQUENCY_CAPABILITIES_0_0_0_MCHBAR_PUNITSA_STRUCT;
#endif // ASM_INC

#define P_CR_PACKAGE_POWER_SKU_0_0_0_MCHBAR_PUNITSA_REG    0x000070A0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // The TDP package power setting allowed for the SKU. The TDP setting is typical
    // not guaranteed.  The default value for this field is determined by fuses.  The
    // units for this value are defined in PACKAGE_POWER_SKU_MSR[PWR_UNIT]. 
    // 
    // Bits[14:0], RW, default = 0x118
    //
    UINTX pkg_tdp : 15;
    //
    // Reserved
    // 
    // Bits[15:15], RO, default = 0x0
    //
    UINTX reserved_0 : 1;
    //
    // The minimal package power setting allowed for the SKU. Lower values may not be
    // achievable by run-time RAPL PL1 and PL2 control algorithms. 
    // 
    // Bits[30:16], RW, default = 0x60
    //
    UINTX pkg_min_pwr : 15;
    //
    // Reserved
    // 
    // Bits[31:31], RO, default = 0x0
    //
    UINTX reserved_1 : 1;
    //
    // The maximal package power setting allowed for the SKU. Higher values will be clamped
    // to this value. The maximum setting is typical not guaranteed.  The default value
    // for this field is determined by fuses.  The units for this value are defined in
    // PACKAGE_POWER_SKU_MSR[PWR_UNIT]. 
    // 
    // Bits[46:32], RW, default = 0x240
    //
    UINTX pkg_max_pwr : 15;
    //
    // Reserved
    // 
    // Bits[47:47], RO, default = 0x0
    //
    UINTX reserved_2 : 1;
    //
    // The maximal time window allowed to be programmed for RAPL PL1 and PL2 controls
    // for the SKU.  Higher values will be clamped to this value.                [p]The
    // bits of this field describe parameters for a mathematical equation for time window
    // configuration.  This field is split into two sub-fields:[/p] 
    //               [list]
    //               [*] x = bits[6:5]
    //               [*] y = bits[4:0]
    //               [/list]
    //               [p]Time window equation:[/p]
    //               [b]time_window = PACKAGE_POWER_SKU_UNIT.TIME_UNIT * ((1+x/4)^y)[/b]
    // 
    // Bits[54:48], RW, default = 0x12
    //
    UINTX pkg_max_win : 7;
    //
    // Reserved
    // 
    // Bits[63:55], RO, default = 0x0
    //
    UINTX reserved_3 : 9;
  } Bits;
  UINTX Data;
} P_CR_PACKAGE_POWER_SKU_0_0_0_MCHBAR_PUNITSA_STRUCT;
#endif // ASM_INC

#define P_CR_PACKAGE_RAPL_LIMIT_0_0_0_MCHBAR_PUNITSA_REG   0x000070A8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Sets the average power usage limit of the package domain corresponding to the
    // PL1 time window. The power units of this field are specified by the PACKAGE_POWER_SKU_UNIT_MSR.PWR_UNIT.
    //  This power limit must be configured by software before it will engage.  The PL1
    // limit is most commonly associated with long time windows (1s and longer), although
    // there are no explicit constraints on what software configures. 
    // 
    // Bits[14:0], RW/L, default = 0x0
    //
    UINTX pkg_pwr_lim_1 : 15;
    //
    // Enable for Power Limit 1 (PL1).  Setting this bit activates the power limit and
    // time window defined for PL1. 
    // 
    // Bits[15:15], RW/VL, default = 0x0
    //
    UINTX pkg_pwr_lim_1_en : 1;
    //
    // Clamp mode control for PL1.
    //               [list]
    //               [*] 0 = PL1 power control is prevented from forcing P-states below
    // the base frequency / P1 for any domain in the SOC. 
    //               [*] 1 = PL1 power control will take all actions necessary to meet
    // the power target, even if that involves running at clock frequencies below the
    // base frequency / P1 level. 
    //               [/list]
    //               In order to ensure proper SOC cooling, it is generally recommended
    // that the clamp mode is always enabled. 
    // 
    // Bits[16:16], RW/VL, default = 0x0
    //
    UINTX pkg_clmp_lim_1 : 1;
    //
    // [p]Time window for Power Limit 1 (PL1).  This describes the control window of
    // the power limit.  This time window is described in an RC time constant format,
    // which means that if 1s is programmed, the power limit constraint really applies
    // at more like 5s.  The maximal time window is bounded by PACKAGE_POWER_SKU_MSR.PKG_MAX_WIN.
    // Thre is no constraint on the minimum programmable time window, however at very
    // short time windows the control algorithms may not be effective.[/p] 
    //               [p]The bits of this field describe parameters for a mathematical
    // equation for time window configuration.  This field is split into two sub-fields:[/p]
    //               [list]
    //               [*] x = bits[6:5]
    //               [*] y = bits[4:0]
    //               [/list]
    //               [p]Time window equation:[/p]
    //               [b]time_window = PACKAGE_POWER_SKU_UNIT.TIME_UNIT * ((1+x/4)^y)[/b]
    // 
    // Bits[23:17], RW/L, default = 0x0
    //
    UINTX pkg_pwr_lim_1_time : 7;
    //
    // Reserved
    // 
    // Bits[31:24], RO, default = 0x0
    //
    UINTX reserved_0 : 8;
    //
    // Sets the average power usage limit of the package domain corresponding to the
    // PL2 time window. The power units of this field are specified by the PACKAGE_POWER_SKU_UNIT_MSR.PWR_UNIT.
    //  This power limit must be configured by software before it will engage.  The PL2
    // limit is most commonly associated with long time windows (1s and longer), although
    // there are no explicit constraints on what software configures. 
    // 
    // Bits[46:32], RW/L, default = 0x0
    //
    UINTX pkg_pwr_lim_2 : 15;
    //
    // Enable for Power Limit 2 (PL2).  Setting this bit activates the power limit and
    // time window defined for PL2. 
    // 
    // Bits[47:47], RW/VL, default = 0x0
    //
    UINTX pkg_pwr_lim_2_en : 1;
    //
    // Clamp mode control for PL2.
    //               [list]
    //               [*] 0 = PL2 power control is prevented from forcing P-states below
    // the base frequency / P1 for any domain in the SOC. 
    //               [*] 1 = PL2 power control will take all actions necessary to meet
    // the power target, even if that involves running at clock frequencies below the
    // base frequency / P1 level. 
    //               [/list]
    //               In order to ensure proper SOC cooling, it is generally recommended
    // that the clamp mode is always enabled. 
    // 
    // Bits[48:48], RW/VL, default = 0x0
    //
    UINTX pkg_clmp_lim_2 : 1;
    //
    // [p]Time window for Power Limit 1 (PL2).  This describes the control window of
    // the power limit.  This time window is described in an RC time constant format,
    // which means that if 1s is programmed, the power limit constraint really applies
    // at more like 5s.  The maximal time window is bounded by PACKAGE_POWER_SKU_MSR.PKG_MAX_WIN.
    // Thre is no constraint on the minimum programmable time window, however at very
    // short time windows the control algorithms may not be effective.[/p] 
    //               [p]The bits of this field describe parameters for a mathematical
    // equation for time window configuration.  This field is split into two sub-fields:[/p]
    //               [list]
    //               [*] x = bits[6:5]
    //               [*] y = bits[4:0]
    //               [/list]
    //               [p]Time window equation:[/p]
    //               [b]time_window = PACKAGE_POWER_SKU_UNIT.TIME_UNIT * ((1+x/4)^y)[/b]
    // 
    // Bits[55:49], RW/L, default = 0x0
    //
    UINTX pkg_pwr_lim_2_time : 7;
    //
    // Reserved
    // 
    // Bits[62:56], RO, default = 0x0
    //
    UINTX reserved_1 : 7;
    //
    // When set all settings in this register are locked and are treated as Read Only.
    //  This lock control is persistent until the next reset.  This bit will typically
    // set by BIOS during boot time or resume from Sx. 
    // 
    // Bits[63:63], RW/L, default = 0x0
    //
    UINTX pkg_pwr_lim_lock : 1;
  } Bits;
  UINTX Data;
} P_CR_PACKAGE_RAPL_LIMIT_0_0_0_MCHBAR_PUNITSA_STRUCT;
#endif // ASM_INC

#define P_CR_IA_PERF_LIMIT_REASONS_0_0_0_MCHBAR_PUNITSA_REG 0x000070B0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Frequency is limited due to external PROCHOT assertion.
    // 
    // Bits[0:0], RO/V, default = 0x0
    //
    UINTX prochot_status : 1;
    //
    // Frequency is limited due to thermal excursion.
    // 
    // Bits[1:1], RO/V, default = 0x0
    //
    UINTX thermal_status : 1;
    //
    // Frequency is limited due to a package-level PL1 excursion.
    // 
    // Bits[2:2], RO/V, default = 0x0
    //
    UINTX pl1_status : 1;
    //
    // Frequency is limited due to a package-level PL2 excursion.
    // 
    // Bits[3:3], RO/V, default = 0x0
    //
    UINTX pl2_status : 1;
    //
    // Spare status bit.
    // 
    // Bits[4:4], RO/V, default = 0x0
    //
    UINTX spare4_status : 1;
    //
    // Spare status bit.
    // 
    // Bits[5:5], RO/V, default = 0x0
    //
    UINTX spare5_status : 1;
    //
    // Spare status bit.
    // 
    // Bits[6:6], RO/V, default = 0x0
    //
    UINTX spare6_status : 1;
    //
    // Frequency is limited due to Dev2 driver override.
    // 
    // Bits[7:7], RO/V, default = 0x0
    //
    UINTX dev2_status : 1;
    //
    // Frequency is limited due to Dev3 driver override.
    // 
    // Bits[8:8], RO/V, default = 0x0
    //
    UINTX dev3_status : 1;
    //
    // Frequency is limited due to autonomous utilization-based P-state control.
    // 
    // Bits[9:9], RO/V, default = 0x0
    //
    UINTX ia_utilization_status : 1;
    //
    // Frequency is limited due to a VR thermal excursion.
    // 
    // Bits[10:10], RO/V, default = 0x0
    //
    UINTX vr_thermalert_status : 1;
    //
    // Frequency is limited due to effective multi-core turbo constraints.
    // 
    // Bits[11:11], RO/V, default = 0x0
    //
    UINTX multi_core_turbo_status : 1;
    //
    // Frequency is limited due to a package-level EDP constraint.
    // 
    // Bits[12:12], RO/V, default = 0x0
    //
    UINTX edp_status : 1;
    //
    // Frequency is limited due to ratio change transition attenuation (MCT, prevents
    // frequent ratio changes due to core C-state entry/exit). 
    // 
    // Bits[13:13], RO/V, default = 0x0
    //
    UINTX mct_status : 1;
    //
    // Frequency is limited below the maximum efficiency frequency.
    // 
    // Bits[14:14], RO/V, default = 0x0
    //
    UINTX max_efficiency_freq_status : 1;
    //
    // Frequency is limited below the operating system or driver Quality-of-Service floor.
    // 
    // Bits[15:15], RO/V, default = 0x0
    //
    UINTX qos_status : 1;
    //
    // Logged indication that frequency was clamped due to PROCHOT assertion. This bit
    // is set by firmware, and is clearable by software. 
    // 
    // Bits[16:16], RW/0C/V, default = 0x0
    //
    UINTX prochot_log : 1;
    //
    // Logged indication that frequency was clamped due to a thermal excursion. This
    // bit is set by firmware, and is clearable by software. 
    // 
    // Bits[17:17], RW/0C/V, default = 0x0
    //
    UINTX thermal_log : 1;
    //
    // Logged indication that frequency was clamped due to a package-level PL1 excursion.
    // This bit is set by firmware, and is clearable by software. 
    // 
    // Bits[18:18], RW/0C/V, default = 0x0
    //
    UINTX pl1_log : 1;
    //
    // Logged indication that frequency was clamped due to a package-level PL2 excursion.
    // This bit is set by firmware, and is clearable by software. 
    // 
    // Bits[19:19], RW/0C/V, default = 0x0
    //
    UINTX pl2_log : 1;
    //
    // Spare log bit. This bit is set by firmware, and is clearable by software.
    // 
    // Bits[20:20], RW/0C/V, default = 0x0
    //
    UINTX spare4_log : 1;
    //
    // Spare log bit. This bit is set by firmware, and is clearable by software.
    // 
    // Bits[21:21], RW/0C/V, default = 0x0
    //
    UINTX spare5_log : 1;
    //
    // Spare log bit. This bit is set by firmware, and is clearable by software.
    // 
    // Bits[22:22], RW/0C/V, default = 0x0
    //
    UINTX spare6_log : 1;
    //
    // Logged indication that frequency was clamped due to a Device 2 driver override.
    // This bit is set by firmware, and is clearable by software. 
    // 
    // Bits[23:23], RW/0C/V, default = 0x0
    //
    UINTX dev2_log : 1;
    //
    // Logged indication that frequency was clamped due to a Device 3 driver override.
    // This bit is set by firmware, and is clearable by software. 
    // 
    // Bits[24:24], RW/0C/V, default = 0x0
    //
    UINTX dev3_log : 1;
    //
    // Logged indication that frequency was clamped due to the autonomous utilization-based
    // P-state control algorithm. This bit is set by firmware, and is clearable by software.
    // 
    // Bits[25:25], RW/0C/V, default = 0x0
    //
    UINTX ia_utilization_log : 1;
    //
    // Logged indication that frequency was clamped due to a voltage regulator thermal
    // excursion. This bit is set by firmware, and is clearable by software. 
    // 
    // Bits[26:26], RW/0C/V, default = 0x0
    //
    UINTX vr_thermalert_log : 1;
    //
    // Logged indication that frequency was clamped due to effective multi-core turbo
    // constraints. This bit is set by firmware, and is clearable by software. 
    // 
    // Bits[27:27], RW/0C/V, default = 0x0
    //
    UINTX multi_core_turbo_log : 1;
    //
    // Logged indication that frequency was clamped due to the package-level Electrical
    // Design Point constraint. This bit is set by firmware, and is clearable by software.
    // 
    // Bits[28:28], RW/0C/V, default = 0x0
    //
    UINTX edp_log : 1;
    //
    // Logged indication that frequency was clamped due to ratio change transition attenuation.
    // This bit is set by firmware, and is clearable by software. 
    // 
    // Bits[29:29], RW/0C/V, default = 0x0
    //
    UINTX mct_log : 1;
    //
    // Logged indication that frequency was clamped below the firmware-calculated maximum
    // efficiency frequency. This bit is set by firmware, and is clearable by software.
    // 
    // Bits[30:30], RW/0C/V, default = 0x0
    //
    UINTX max_efficiency_freq_log : 1;
    //
    // Logged indication that frequency was clamped below the software-defined quality-of-service
    // floor. This bit is set by firmware, and is clearable by software. 
    // 
    // Bits[31:31], RW/0C/V, default = 0x0
    //
    UINTX qos_log : 1;
  } Bits;
  UINTX Data;
} P_CR_IA_PERF_LIMIT_REASONS_0_0_0_MCHBAR_PUNITSA_STRUCT;
#endif // ASM_INC

#define P_CR_TELEM_IA_C0_RESIDENCY_0_0_0_MCHBAR_PUNITSA_REG 0x000070C0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // This counter measures time that any core is active in the C0 state.  This counter
    // counts at the crystal clock frequency divided by 16. 
    // 
    // Bits[31:0], RO/V, default = 0x0
    //
    UINTX data : 32;
  } Bits;
  UINTX Data;
} P_CR_TELEM_IA_C0_RESIDENCY_0_0_0_MCHBAR_PUNITSA_STRUCT;
#endif // ASM_INC

#define P_CR_TELEM_GT_C0_RESIDENCY_0_0_0_MCHBAR_PUNITSA_REG 0x000070C4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // This counter measures time that graphics is active in the C0 state.  This counter
    // counts at the crystal clock frequency divided by 16. 
    // 
    // Bits[31:0], RO/V, default = 0x0
    //
    UINTX data : 32;
  } Bits;
  UINTX Data;
} P_CR_TELEM_GT_C0_RESIDENCY_0_0_0_MCHBAR_PUNITSA_STRUCT;
#endif // ASM_INC

#define P_CR_TELEM_IUNIT_C0_RESIDENCY_0_0_0_MCHBAR_PUNITSA_REG 0x000070C8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // This counter measures time that I-unit processing system is active in the C0 state.
    //  This counter counts at the crystal clock frequency divided by 16. 
    // 
    // Bits[31:0], RO/V, default = 0x0
    //
    UINTX data : 32;
  } Bits;
  UINTX Data;
} P_CR_TELEM_IUNIT_C0_RESIDENCY_0_0_0_MCHBAR_PUNITSA_STRUCT;
#endif // ASM_INC

#define P_CR_TELEM_IA_FREQ_ACCUMULATOR_0_0_0_MCHBAR_PUNITSA_REG 0x000070CC
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Residency data
    // 
    // Bits[31:0], RO/V, default = 0x0
    //
    UINTX data : 32;
  } Bits;
  UINTX Data;
} P_CR_TELEM_IA_FREQ_ACCUMULATOR_0_0_0_MCHBAR_PUNITSA_STRUCT;
#endif // ASM_INC

#define P_CR_TELEM_GT_FREQ_ACCUMULATOR_0_0_0_MCHBAR_PUNITSA_REG 0x000070D0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // This counter integrates the current clock ratio of the domain at the same rate
    // as the corresponding C0 residency counter 
    // 
    // Bits[31:0], RO/V, default = 0x0
    //
    UINTX data : 32;
  } Bits;
  UINTX Data;
} P_CR_TELEM_GT_FREQ_ACCUMULATOR_0_0_0_MCHBAR_PUNITSA_STRUCT;
#endif // ASM_INC

#define P_CR_TELEM_IUNIT_FREQ_ACCUMULATOR_0_0_0_MCHBAR_PUNITSA_REG 0x000070D4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // This counter integrates the current clock ratio of the domain at the same rate
    // as the corresponding C0 residency counter 
    // 
    // Bits[31:0], RO/V, default = 0x0
    //
    UINTX data : 32;
  } Bits;
  UINTX Data;
} P_CR_TELEM_IUNIT_FREQ_ACCUMULATOR_0_0_0_MCHBAR_PUNITSA_STRUCT;
#endif // ASM_INC

#define P_CR_MEMHOT_THERM_STATUS_0_0_0_MCHBAR_PUNITSA_REG  0x000070D8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // 0 = MEMHOT_N pin not asserted
    //               1 = MEMHOT_N pin is asserted
    // 
    // Bits[0:0], RO/V, default = 0x0
    //
    UINTX memhot_status : 1;
    //
    // Set to 1 on MEMHOT_N pin assertion; remains set until cleared via CR write of
    // 1 value or chip reset. 
    // 
    // Bits[1:1], RW/0C/V, default = 0x0
    //
    UINTX memhot_log : 1;
    //
    // Reserved
    // 
    // Bits[31:2], RO, default = 0x0
    //
    UINTX reserved : 30;
  } Bits;
  UINTX Data;
} P_CR_MEMHOT_THERM_STATUS_0_0_0_MCHBAR_PUNITSA_STRUCT;
#endif // ASM_INC

#define P_CR_MEMHOT_THERM_CONFIG_0_0_0_MCHBAR_PUNITSA_REG  0x000070DC
#ifndef ASM_INC
typedef union {
  struct {
    //
    // 00 = MEMHOT disabled (no response to pin assertion)
    //               01 = THRT_MID
    //               10 = THRT_HI
    //               11 = THRT_CRIT
    // 
    // Bits[1:0], RW/L, default = 0x0
    //
    UINTX memhot_throt_lvl : 2;
    //
    // Reserved
    // 
    // Bits[30:2], RO, default = 0x0
    //
    UINTX reserved : 29;
    //
    // When 1, writes to other MEMHOT_THERM_CONFIG bits are not allowed
    // 
    // Bits[31:31], RW/L, default = 0x0
    //
    UINTX lock : 1;
  } Bits;
  UINTX Data;
} P_CR_MEMHOT_THERM_CONFIG_0_0_0_MCHBAR_PUNITSA_STRUCT;
#endif // ASM_INC

#define P_CR_MEM_THERM_CTRL_0_0_0_MCHBAR_PUNITSA_REG       0x00007200
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Mem_thermtrip control.
    // 	    0:  THERMTRIP is CPU thermal sensor only
    // 	    1:  THERMTRIP is CPU thermal sensor or mem_thermtrip
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINTX en_memtrip : 1;
    //
    // Memory thermal mgmt. mode:  0 = OLTT, 1 = CLTT
    // 
    // Bits[1:1], RW, default = 0x0
    //
    UINTX mem_therm_mgmt_mode : 1;
    //
    // 0 = CLTT pass-thru
    // 	    1 = CLTT over SMBus (ignore if MTM_MODE = 0)
    // 
    // Bits[2:2], RW, default = 0x0
    //
    UINTX cltt_mode : 1;
    //
    // Throttle level when OLTT is enabled, reuses CLTT throttle levels.
    // 	        00 = no throttle
    // 	        01 = THRT_MID
    // 	        10 = THRT_HI
    // 	        11 = THRT_CRIT
    // 
    // Bits[4:3], RW, default = 0x0
    //
    UINTX oltt_throt_lvl : 2;
    //
    // Set by CLTT SMBus controller when DIMM temperatures are ready to be read. This
    // bit is also used as the valid bit for the DIMM temperatures. Pcode will clear
    // this bit when initiating a new DIMM temperature read request. 
    // 
    // Bits[5:5], RO/V, default = 0x0
    //
    UINTX smbusackd_flag : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:6], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
    //
    // Temperature at which mem trip will be asserted
    // 
    // Bits[15:8], RW, default = 0x0
    //
    UINTX temp_memtrip : 8;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:16], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 16;
  } Bits;
  UINTX Data;
} P_CR_MEM_THERM_CTRL_0_0_0_MCHBAR_PUNITSA_STRUCT;
#endif // ASM_INC

#define P_CR_MEM_THERM_TEMP_CONFIG_0_0_0_MCHBAR_PUNITSA_REG 0x00007204
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Lower threshold temperature, 8.8.0ufp.  Program so TEMP_LO < TEMP_MID.
    // 
    // Bits[7:0], RW, default = 0x54
    //
    UINTX temp_lo : 8;
    //
    // Middle threshold temperature, 8.8.0ufp.  Program so TEMP_MID < TEMP_HI.
    // 
    // Bits[15:8], RW, default = 0x5D
    //
    UINTX temp_mid : 8;
    //
    // High threshold temperature, 8.8.0ufp.  Program so TEMP_HI > TEMP_MID.
    // 
    // Bits[23:16], RW, default = 0x64
    //
    UINTX temp_hi : 8;
    //
    // Negative-going threshold hysteresis value.  This value is subtracted from the
    // TEMP_* threshold values to determine the point where the asserted status for that
    // threshold will clear as temperature decreases.  TEMP_THROT_HYST must be at least
    // 1C less than the minimum delta between adjacent TEMP_* thresholds. 
    // 
    // Bits[26:24], RW, default = 0x0
    //
    UINTX temp_throt_hyst : 3;
    //
    // Reserved
    // 
    // Bits[31:27], RO, default = 0x0
    //
    UINTX reserved_0 : 5;
  } Bits;
  UINTX Data;
} P_CR_MEM_THERM_TEMP_CONFIG_0_0_0_MCHBAR_PUNITSA_STRUCT;
#endif // ASM_INC

#define P_CR_MEM_THERM_THROT_CONFIG_0_0_0_MCHBAR_PUNITSA_REG 0x00007208
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Throttle level in %BW < THRT_HI , 8.8.0ufp (default is 0% throttled)
    // 
    // Bits[7:0], RW, default = 0x0
    //
    UINTX thrt_mid : 8;
    //
    // Throttle level in %BW < THRT_CRIT, 8.8.0ufp (default is 90% throttled)
    // 
    // Bits[15:8], RW, default = 0x5A
    //
    UINTX thrt_hi : 8;
    //
    // Throttle level in %BW <= 100, 8.8.0ufp. Default is 99% throttled.
    // 
    // Bits[23:16], RW, default = 0x63
    //
    UINTX thrt_crit : 8;
    //
    // Reserved
    // 
    // Bits[31:24], RO, default = 0x0
    //
    UINTX reserved_0 : 8;
  } Bits;
  UINTX Data;
} P_CR_MEM_THERM_THROT_CONFIG_0_0_0_MCHBAR_PUNITSA_STRUCT;
#endif // ASM_INC

#define P_CR_MEM_THERM_STATUS_0_0_0_MCHBAR_PUNITSA_REG     0x0000720C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Status of channel0, DIMM0:
    // 	00 = memory temperature < TEMP_LO
    // 	01 = TEMP_LO <= mem temp < TEMP_MID
    // 	10 = TEMP_MID <= mem temp < TEMP_HI
    // 	11 = mem temp >= TEMP_HI (mem_thermtrip is asserted by P-unit logic)
    // 
    // Bits[1:0], RO/V, default = 0x0
    //
    UINTX mem_therm_status_0_0 : 2;
    //
    // Sticky bits set to highest throttle level achieved (same encoding as MEM_THERM_STATUS
    // bits)  when CLTT memory throttling is initiated by channel0, DIMM0; remains set
    // until cleared via CR write of 1 value or chip reset. 
    // 
    // Bits[3:2], RW/0C/V, default = 0x0
    //
    UINTX mem_therm_throt_log_0_0 : 2;
    //
    // Reserved
    // 
    // Bits[7:4], RO, default = 0x0
    //
    UINTX reserved_0 : 4;
    //
    // Status of channel0, DIMM1:
    // 	00 = memory temperature < TEMP_LO
    // 	01 = TEMP_LO <= mem temp < TEMP_MID
    // 	10 = TEMP_MID <= mem temp < TEMP_HI
    // 	11 = mem temp >= TEMP_HI (mem_thermtrip is asserted by P-unit logic)
    // 
    // Bits[9:8], RO/V, default = 0x0
    //
    UINTX mem_therm_status_0_1 : 2;
    //
    // Sticky bits set to highest throttle level achieved (same encoding as MEM_THERM_STATUS
    // bits)  when CLTT memory throttling is initiated by channel0, DIMM1; remains set
    // until cleared via CR write of 1 value or chip reset. 
    // 
    // Bits[11:10], RW/0C/V, default = 0x0
    //
    UINTX mem_therm_throt_log_0_1 : 2;
    //
    // Reserved
    // 
    // Bits[15:12], RO, default = 0x0
    //
    UINTX reserved_1 : 4;
    //
    // Status of channel1, DIMM0:
    // 	00 = memory temperature < TEMP_LO
    // 	01 = TEMP_LO <= mem temp < TEMP_MID
    // 	10 = TEMP_MID <= mem temp < TEMP_HI
    // 	11 = mem temp >= TEMP_HI (mem_thermtrip is asserted by P-unit logic)
    // 
    // Bits[17:16], RO/V, default = 0x0
    //
    UINTX mem_therm_status_1_0 : 2;
    //
    // Sticky bits set to highest throttle level achieved (same encoding as MEM_THERM_STATUS
    // bits)  when CLTT memory throttling is initiated by channel1, DIMM0; remains set
    // until cleared via CR write of 1 value or chip reset. 
    // 
    // Bits[19:18], RW/0C/V, default = 0x0
    //
    UINTX mem_therm_throt_log_1_0 : 2;
    //
    // Reserved
    // 
    // Bits[23:20], RO, default = 0x0
    //
    UINTX reserved_2 : 4;
    //
    // Status of channel1, DIMM1:
    // 	00 = memory temperature < TEMP_LO
    // 	01 = TEMP_LO <= mem temp < TEMP_MID
    // 	10 = TEMP_MID <= mem temp < TEMP_HI
    // 	11 = mem temp >= TEMP_HI (mem_thermtrip is asserted by P-unit logic)
    // 
    // Bits[25:24], RO/V, default = 0x0
    //
    UINTX mem_therm_status_1_1 : 2;
    //
    // Sticky bits set to highest throttle level achieved (same encoding as MEM_THERM_STATUS
    // bits)  when CLTT memory throttling is initiated by channel1, DIMM1; remains set
    // until cleared via CR write of 1 value or chip reset. 
    // 
    // Bits[27:26], RW/0C/V, default = 0x0
    //
    UINTX mem_therm_throt_log_1_1 : 2;
    //
    // Reserved
    // 
    // Bits[31:28], RO, default = 0x0
    //
    UINTX reserved_3 : 4;
  } Bits;
  UINTX Data;
} P_CR_MEM_THERM_STATUS_0_0_0_MCHBAR_PUNITSA_STRUCT;
#endif // ASM_INC

#define P_CR_MEM_THERM_INTERRUPT_0_0_0_MCHBAR_PUNITSA_REG  0x00007210
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Enable interrupt generation whenever maximum  DIMM_adj_TEMP_x_y value crosses
    // TEMP_LO (use hysteresis-adjusted value for falling temperature) 
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINTX temp_low_smi_enable : 1;
    //
    // Enable interrupt generation whenever maximum  DIMM_adj_TEMP_x_y value crosses
    // TEMP_MID (use hysteresis-adjusted value for falling temperature) 
    // 
    // Bits[1:1], RW, default = 0x0
    //
    UINTX temp_mid_smi_enable : 1;
    //
    // Enable interrupt generation whenever maximum  DIMM_adj_TEMP_x_y value crosses
    // TEMP_HI (use hysteresis-adjusted value for falling temperature) 
    // 
    // Bits[2:2], RW, default = 0x0
    //
    UINTX temp_hi_smi_enable : 1;
    //
    // Reserved
    // 
    // Bits[7:3], RO, default = 0x0
    //
    UINTX reserved_0 : 5;
    //
    // Configurable memory temperature threshold1 value for thermal interrupt generation,
    // unsigned integer U7.7.0 
    // 
    // Bits[14:8], RW, default = 0x0
    //
    UINTX mem_int_threshold1_value : 7;
    //
    // Enable thermal interrupt generation whenever maximum  DIMM_adj_TEMP_x_y value
    // crosses MEM_INT_THRESHOLD1_VALUE 
    // 
    // Bits[15:15], RW, default = 0x0
    //
    UINTX memhot_smi_enable : 1;
    //
    // Reserved
    // 
    // Bits[22:16], RW, default = 0x0
    //
    UINTX reserved_3 : 7;
    //
    // Reserved
    // 
    // Bits[23:23], RW, default = 0x0
    //
    UINTX reserved_2 : 1;
    //
    // Reserved
    // 
    // Bits[31:24], RO, default = 0x0
    //
    UINTX reserved_1 : 8;
  } Bits;
  UINTX Data;
} P_CR_MEM_THERM_INTERRUPT_0_0_0_MCHBAR_PUNITSA_STRUCT;
#endif // ASM_INC

#define P_CR_MEM_THERM_INT_STATUS_0_0_0_MCHBAR_PUNITSA_REG 0x00007214
#ifndef ASM_INC
typedef union {
  struct {
    //
    // 1:  MTM is at or above the TEMP_LO throttle state.
    // 	0:  MTM is in the unthrottled state. 
    // 
    // Bits[0:0], RO/V, default = 0x0
    //
    UINTX temp_lo_smi_status : 1;
    //
    // Set to 1 the first time TEMP_LO_SMI_STATUS is set and remains sticky until cleared
    // via software or reset. 
    // 
    // Bits[1:1], RW/0C/V, default = 0x0
    //
    UINTX temp_lo_smi_log : 1;
    //
    // 1:  MTM is at the TEMP_MID throttle state.
    // 	0:  MTM is below the TEMP_MID throttle state.
    // 
    // Bits[2:2], RO/V, default = 0x0
    //
    UINTX temp_mid_smi_status : 1;
    //
    // Set to 1 the first time TEMP_MID_SMI_STATUS is set and remains sticky until cleared
    // via software or reset. 
    // 
    // Bits[3:3], RW/0C/V, default = 0x0
    //
    UINTX temp_mid_smi_log : 1;
    //
    // 1:  MTM is at the TEMP_HI throttle state.
    // 	0:  MTM is below the TEMP_HI throttle state.
    // 
    // Bits[4:4], RO/V, default = 0x0
    //
    UINTX temp_hi_smi_status : 1;
    //
    // Set to 1 the first time TEMP_HI_SMI_STATUS is set and remains sticky until cleared
    // via software or reset. 
    // 
    // Bits[5:5], RW/0C/V, default = 0x0
    //
    UINTX temp_hi_smi_log : 1;
    //
    // Maximum  DIMM_adj_TEMP_x_y value is at or above MEM_INT_THRESHOLD1_VALUE
    // 
    // Bits[6:6], RO/V, default = 0x0
    //
    UINTX memhot_smi_status : 1;
    //
    // Set to 1 the first time MEM_INT_THRESHOLD1_STATUS is set and remains sticky until
    // cleared via software or reset. 
    // 
    // Bits[7:7], RW/0C/V, default = 0x0
    //
    UINTX memhot_smi_log : 1;
    //
    // Reserved
    // 
    // Bits[8:8], RO/V, default = 0x0
    //
    UINTX reserved_status : 1;
    //
    // Reserved
    // 
    // Bits[9:9], RW/0C/V, default = 0x0
    //
    UINTX reserved_log : 1;
    //
    // Temperature is at or above the point to cause SoC memory throttling
    // 
    // Bits[10:10], RO/V, default = 0x0
    //
    UINTX soc_mem_throttle_status : 1;
    //
    // Set to 1 the first time SOC_MEM_THROTTLE_STATUS is set and remains sticky until
    // cleared via software or reset 
    // 
    // Bits[11:11], RW/0C/V, default = 0x0
    //
    UINTX soc_mem_throttle_log : 1;
    //
    // reserved for future throttle logging
    // 
    // Bits[12:12], RO/V, default = 0x0
    //
    UINTX rsvd_throttle_status : 1;
    //
    // reserved for future throttle logging
    // 
    // Bits[13:13], RW/0C/V, default = 0x0
    //
    UINTX rsvd_throttle_log : 1;
    //
    // Reserved
    // 
    // Bits[27:14], RO, default = 0x0
    //
    UINTX reserved_0 : 14;
    //
    // Indication that the CLTT SMBUS is reset
    // 
    // Bits[28:28], RO/V, default = 0x0
    //
    UINTX cltt_smbus_reset_status : 1;
    //
    // Set to 1 the first time CLTT_SMBUS_RESET_STATUS is set and remains sticky until
    // cleared via software or reset. 
    // 
    // Bits[29:29], RW/0C/V, default = 0x0
    //
    UINTX cltt_smbus_reset_log : 1;
    //
    // Indication that the CLTT SMBUS is hung
    // 
    // Bits[30:30], RO/V, default = 0x0
    //
    UINTX cltt_smbus_hang_status : 1;
    //
    // Set to 1 the first time CLTT_SMBUS_HANG_STATUS is set and remains sticky until
    // cleared via software or reset. 
    // 
    // Bits[31:31], RW/0C/V, default = 0x0
    //
    UINTX cltt_smbus_hang_log : 1;
  } Bits;
  UINTX Data;
} P_CR_MEM_THERM_INT_STATUS_0_0_0_MCHBAR_PUNITSA_STRUCT;
#endif // ASM_INC

#define P_CR_MEM_THERM_TEMP_OFST_0_0_0_MCHBAR_PUNITSA_REG  0x00007218
#ifndef ASM_INC
typedef union {
  struct {
    //
    // 4-bit integer temperature offset value for channel0, DIMM0 TSOD.
    // 
    // Bits[4:0], RW, default = 0x0
    //
    UINTX mem_temp_ofst_ddr_0_0 : 5;
    //
    // Reserved
    // 
    // Bits[7:5], RO, default = 0x0
    //
    UINTX reserved_0 : 3;
    //
    // 4-bit integer temperature offset value for channel0, DIMM1 TSOD.
    // 
    // Bits[12:8], RW, default = 0x0
    //
    UINTX mem_temp_ofst_ddr_0_1 : 5;
    //
    // Reserved
    // 
    // Bits[15:13], RO, default = 0x0
    //
    UINTX reserved_1 : 3;
    //
    // 4-bit integer temperature offset value for channel1, DIMM0 TSOD.
    // 
    // Bits[20:16], RW, default = 0x0
    //
    UINTX mem_temp_ofst_ddr_1_0 : 5;
    //
    // Reserved
    // 
    // Bits[23:21], RO, default = 0x0
    //
    UINTX reserved_2 : 3;
    //
    // 4-bit integer temperature offset value for channel1, DIMM1 TSOD.
    // 
    // Bits[28:24], RW, default = 0x0
    //
    UINTX mem_temp_ofst_ddr_1_1 : 5;
    //
    // Reserved
    // 
    // Bits[31:29], RO, default = 0x0
    //
    UINTX reserved_3 : 3;
  } Bits;
  UINTX Data;
} P_CR_MEM_THERM_TEMP_OFST_0_0_0_MCHBAR_PUNITSA_STRUCT;
#endif // ASM_INC

#define P_CR_TELEM_NEAR_MEMORY_ACTIVE_0_0_0_MCHBAR_PUNITSA_REG 0x000070E0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // This counter measures the total time spent with near memory active, as measured
    // by any rank being in the active or active idle state.  The inverse of this counter
    // indicates the total time spent with all near memory in the self-refresh state.
    //  This counter counts at the crystal clock frequency divided by 16. 
    // 
    // Bits[63:0], RO/V, default = 0x0
    //
    UINTX data : 64;
  } Bits;
  UINTX Data;
} P_CR_TELEM_NEAR_MEMORY_ACTIVE_0_0_0_MCHBAR_PUNITSA_STRUCT;
#endif // ASM_INC

#define P_CR_TELEM_FAR_MEMORY_ACTIVE_0_0_0_MCHBAR_PUNITSA_REG 0x000070E8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // This counter measures the total time spent with far memory active, as measured
    // by any rank being in the active or active idle state.  The inverse of this counter
    // indicates the total time spent with all far memory in the self-refresh state.
    //  This counter counts at the crystal clock frequency divided by 16. 
    // 
    // Bits[63:0], RO/V, default = 0x0
    //
    UINTX data : 64;
  } Bits;
  UINTX Data;
} P_CR_TELEM_FAR_MEMORY_ACTIVE_0_0_0_MCHBAR_PUNITSA_STRUCT;
#endif // ASM_INC

#define P_CR_TURBO_ACTIVATION_RATIO_0_0_0_MCHBAR_PUNITSA_REG 0x000070F0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // The P-unit will treat any P-state request above this ratio as a request for maximum
    // turbo.  Zero is special encoding which disables the feature 
    // 
    // Bits[7:0], RW/L, default = 0x0
    //
    UINTX max_non_turbo_ratio : 8;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[30:8], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 23;
    //
    // Write to 1b to lock the setting in this register until next reset
    // 
    // Bits[31:31], RW/L, default = 0x0
    //
    UINTX turbo_activation_ratio_lock : 1;
  } Bits;
  UINTX Data;
} P_CR_TURBO_ACTIVATION_RATIO_0_0_0_MCHBAR_PUNITSA_STRUCT;
#endif // ASM_INC

#define P_CR_C2C3TT_CFG_0_0_0_MCHBAR_PUNITSA_REG           0x00007034
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Value
    // 
    // Bits[11:0], RW, default = 0x32
    //
    UINTX ppdn_init : 12;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:12], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 20;
  } Bits;
  UINTX Data;
} P_CR_C2C3TT_CFG_0_0_0_MCHBAR_PUNITSA_STRUCT;
#endif // ASM_INC

#define P_CR_DTS_CONFIG1_CFG_0_0_0_MCHBAR_PUNITSA_REG      0x00007110
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Correction Factor F  May be unlocked for select OEMs
    // 
    // Bits[12:0], RW/L, default = 0x0
    //
    UINTX f : 13;
    //
    // reserved
    // 
    // Bits[15:13], RW/L, default = 0x0
    //
    UINTX rsvd : 3;
    //
    // Scale factor C  May be unlocked for select OEMs
    // 
    // Bits[28:16], RW/L, default = 0x0
    //
    UINTX c : 13;
    //
    // Reserved
    // 
    // Bits[31:29], RW/L, default = 0x0
    //
    UINTX rsvd1 : 3;
  } Bits;
  UINTX Data;
} P_CR_DTS_CONFIG1_CFG_0_0_0_MCHBAR_PUNITSA_STRUCT;
#endif // ASM_INC

#define P_CR_DTS_CONFIG2_CFG_0_0_0_MCHBAR_PUNITSA_REG      0x00007114
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Time constant coefficient AF  May be unlocked for select OEMs
    // 
    // Bits[12:0], RW/L, default = 0x0
    //
    UINTX af : 13;
    //
    // reserved
    // 
    // Bits[15:13], RW/L, default = 0x0
    //
    UINTX rsvd : 3;
    //
    // Time constant coefficient AS  May be unlocked for select OEMs
    // 
    // Bits[28:16], RW/L, default = 0x0
    //
    UINTX as : 13;
    //
    // Reserved  be4538196 - attached to correct fuse
    // 
    // Bits[31:29], RW/L, default = 0x0
    //
    UINTX rsvd1 : 3;
  } Bits;
  UINTX Data;
} P_CR_DTS_CONFIG2_CFG_0_0_0_MCHBAR_PUNITSA_STRUCT;
#endif // ASM_INC

#define P_CR_DTS_CONFIG3_CFG_0_0_0_MCHBAR_PUNITSA_REG      0x00007118
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Offset to modify Tcontrol for DTS2.0
    // 
    // Bits[7:0], RW/L, default = 0x0
    //
    UINTX tcontrol_offset : 8;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[27:8], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 20;
    //
    // Bit that the offset was programmed.  Question -- is this  set by the user or by
    // Pcode?   
    //            [IntelRsvd]isteiner: renamed for DTS2.0 convergence[/IntelRsvd]
    // 
    // Bits[28:28], RW/L, default = 0x0
    //
    UINTX offset_programmed : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:29], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 3;
  } Bits;
  UINTX Data;
} P_CR_DTS_CONFIG3_CFG_0_0_0_MCHBAR_PUNITSA_STRUCT;
#endif // ASM_INC

#define P_CR_SOUTH_IO_PORT_STATUS3_0_0_0_MCHBAR_PUNITSA_REG 0x0000711C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Snapshot of the number of USB2 lanes for power meter.
    // 
    // Bits[3:0], RW, default = 0x0
    //
    UINTX usb2_lanes : 4;
    //
    // Snapshot of the number of USB3 lanes for power meter.
    // 
    // Bits[7:4], RW, default = 0x0
    //
    UINTX usb3_lanes : 4;
    //
    // Snapshot of the number of SATA lanes for power meter.
    // 
    // Bits[15:8], RW, default = 0x0
    //
    UINTX sata_lanes : 8;
    //
    // Snapshot of the number of PCIE lanes for power meter.
    // 
    // Bits[23:16], RW, default = 0x0
    //
    UINTX pcie_lanes : 8;
    //
    // Snapshot of the number of GBE lanes for power meter.
    // 
    // Bits[25:24], RW, default = 0x0
    //
    UINTX gbe_ports : 2;
    //
    // reserved
    // 
    // Bits[31:26], RW, default = 0x0
    //
    UINTX rsvd : 6;
  } Bits;
  UINTX Data;
} P_CR_SOUTH_IO_PORT_STATUS3_0_0_0_MCHBAR_PUNITSA_STRUCT;
#endif // ASM_INC

#define P_CR_DRAM_BIOS_INFO_0_0_0_MCHBAR_PUNITSA_REG       0x00007128
#ifndef ASM_INC
typedef union {
  struct {
    //
    // This field indicates to BIOS the Maximum supported DDR frequency for this product.
    //   Pcode populates this information from fuses.  000b => ; 001b => ; 010 => ; 
    // 
    // Bits[2:0], RW, default = 0x0
    //
    UINTX ddr_max_freq_limit : 3;
    //
    // DEPRECATED.  THIS IS NO LONGER USED.
    //           
    //           This field indicates to BIOS if one or both channels are available.
    //  Pcode populates this information from fuses. 0 => 1 Channel; 1b => 2 channels;
    // 
    // Bits[3:3], RW, default = 0x0
    //
    UINTX ddr_max_channel : 1;
    //
    // Reserved
    // 
    // Bits[7:4], RW, default = 0x0
    //
    UINTX rsvd2 : 4;
    //
    // This field indicates the current DDR IO clock frequency.  The information is read
    // from the PMC register and populated here. 
    // 
    // Bits[10:8], RW, default = 0x0
    //
    UINTX ddr_current_freq : 3;
    //
    // This field indicates to BIOS that a SPD Warm Reset has already occurred. The information
    // is read from the PMC register and written here for BIOS. 
    // 
    // Bits[11:11], RW, default = 0x0
    //
    UINTX spd_reset_status : 1;
    //
    // Reserved
    // 
    // Bits[15:12], RW, default = 0x0
    //
    UINTX rsvd1 : 4;
    //
    // This field is populated by Pcode with the current voltage of VDDQ SVID Rail.
    // 
    // Bits[23:16], RW, default = 0x0
    //
    UINTX current_vid_value : 8;
    //
    // DEPRECATED.  THIS IS NO LONGER USED.
    //           
    //           This field is populated by Pcode from soft straps in Punit Soft Strap
    // Registers. 
    // 
    // Bits[31:24], RW, default = 0x0
    //
    UINTX ddr_type_ss : 8;
  } Bits;
  UINTX Data;
} P_CR_DRAM_BIOS_INFO_0_0_0_MCHBAR_PUNITSA_STRUCT;
#endif // ASM_INC

#define P_CR_ADR_COMMAND_0_0_0_MCHBAR_PUNITSA_REG          0x0000712C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // This field indicates to Pcode to flush the L2 cache on all modules as part of
    // the ADR flow. 
    // 
    // Bits[0:0], RW/V, default = 0x0
    //
    UINTX l2_flush : 1;
    //
    // Reserved for future use.
    // 
    // Bits[7:1], RW/V, default = 0x0
    //
    UINTX undefined : 7;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:8], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 24;
  } Bits;
  UINTX Data;
} P_CR_ADR_COMMAND_0_0_0_MCHBAR_PUNITSA_STRUCT;
#endif // ASM_INC

#define P_CR_DRAM_POWER_INFO_0_0_0_MCHBAR_PUNITSA_REG      0x00007130
#ifndef ASM_INC
typedef union {
  struct {
    //
    // The Spec power alloed for DRAM.  The TDP setting is typical (not guaranteed).
    // 
    // Bits[14:0], RW/L, default = 0x118
    //
    UINTX dram_tdp : 15;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[15:15], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 1;
    //
    // The minimal power setting allowed for DRAM.  Lower values will be clamped to this
    // value.  The minimum setting is typical (not guaranteed). 
    // 
    // Bits[30:16], RW/L, default = 0x0
    //
    UINTX dram_min_pwr : 15;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:31], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 1;
    //
    // The maximal power setting allowed for DRAM.  Higher values will be clamped to
    // this value.  The maximum setting is typical (not guaranteed). 
    // 
    // Bits[46:32], RW/L, default = 0x0
    //
    UINTX dram_max_pwr : 15;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[47:47], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 1;
    //
    // The maximal time window allowed for the DRAM.  Higher values will be clamped to
    // this value.  x = PKG_MAX_WIN[54:53], y = PKG_MAX_WIN[52:48].  The timing interval
    // window is Floating Point number given by 1.x * power(2,y).  Initialized by pcode
    // at reset phase4 to FUSE_TURBO_TIME_WINDOW. 
    // 
    // Bits[54:48], RW/L, default = 0x28
    //
    UINTX dram_max_win : 7;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[62:55], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_3 : 8;
    //
    // The Spec power alloed for DRAM.  The TDP setting is typical (not guaranteed).
    // 
    // Bits[63:63], RW/L, default = 0x0
    //
    UINTX lock : 1;
  } Bits;
  UINTX Data;
} P_CR_DRAM_POWER_INFO_0_0_0_MCHBAR_PUNITSA_STRUCT;
#endif // ASM_INC

#define P_CR_PCODE_WRITE_SPARE_0_0_0_MCHBAR_PUNITSA_REG    0x00007138
#ifndef ASM_INC
typedef union {
  struct {
    //
    // spare bits for fugure use
    // 
    // Bits[31:0], RO/V, default = 0x0
    //
    UINTX spare_bits : 32;
  } Bits;
  UINTX Data;
} P_CR_PCODE_WRITE_SPARE_0_0_0_MCHBAR_PUNITSA_STRUCT;
#endif // ASM_INC

#define P_CR_PACKAGE_TEMPERATURES_0_0_0_MCHBAR_PUNITSA_REG 0x000070F4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Virtual max temperature of all IA cores in degrees C.  Reported in a signed, 2's
    // complement format with the LSB representing 1'C resolution (S8.7.0).  Raw, unfiltered
    // 
    // Bits[7:0], RO/V, default = 0x0
    //
    UINTX ia_temperature : 8;
    //
    // Graphics domain max temperature in degrees C.  Reported in a signed, 2's complement
    // format with the LSB representing 1'C resolution (S8.7.0).  Raw, unfiltered 
    // 
    // Bits[15:8], RO/V, default = 0x0
    //
    UINTX gt_temperature : 8;
    //
    // Camera domain max temperature in degrees C.  Reported in a signed, 2's complement
    // format with the LSB representing 1'C resolution (S8.7.0).  Raw, unfiltered 
    // 
    // Bits[23:16], RO/V, default = 0x0
    //
    UINTX isp_temperature : 8;
    //
    // System agent domain max temperature in degrees C.  Reported in a signed, 2's complement
    // format with the LSB representing 1'C resolution (S8.7.0).  Raw, unfiltered 
    // 
    // Bits[31:24], RO/V, default = 0x0
    //
    UINTX sa_temperature : 8;
  } Bits;
  UINTX Data;
} P_CR_PACKAGE_TEMPERATURES_0_0_0_MCHBAR_PUNITSA_STRUCT;
#endif // ASM_INC

#define P_CR_MEMSS_FREQUENCY_CAPABILITIES_0_0_0_MCHBAR_PUNITSA_REG 0x00007108
#ifndef ASM_INC
typedef union {
  struct {
    //
    // N/A
    // 
    // Bits[5:0], RW, default = 0x0
    //
    UINTX lp3_freq_low : 6;
    //
    // N/A
    // 
    // Bits[11:6], RW, default = 0x0
    //
    UINTX lp3_freq_high : 6;
    //
    // N/A
    // 
    // Bits[17:12], RW, default = 0x0
    //
    UINTX lp4_freq_low : 6;
    //
    // N/A
    // 
    // Bits[23:18], RW, default = 0x0
    //
    UINTX lp4_freq_high : 6;
    //
    // N/A
    // 
    // Bits[29:24], RW, default = 0x0
    //
    UINTX wio_freq : 6;
    //
    // N/A
    // 
    // Bits[31:30], RW, default = 0x0
    //
    UINTX num_nm_ch : 2;
  } Bits;
  UINTX Data;
} P_CR_MEMSS_FREQUENCY_CAPABILITIES_0_0_0_MCHBAR_PUNITSA_STRUCT;
#endif // ASM_INC

#define P_CR_PP1_C0_CORE_CLOCK_0_0_0_MCHBAR_PUNITSA_REG    0x00007160
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Accumulated cycles GT has been in RC0.
    // 
    // Bits[31:0], RO/V, default = 0x0
    //
    UINTX data : 32;
  } Bits;
  UINTX Data;
} P_CR_PP1_C0_CORE_CLOCK_0_0_0_MCHBAR_PUNITSA_STRUCT;
#endif // ASM_INC

#define P_CR_CORE_EXISTS_VECTOR_0_0_0_MCHBAR_PUNITSA_REG   0x00007164
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Indication of core fuse enabled status.
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINTX core0_exists : 1;
    //
    // Indication of core fuse enabled status.
    // 
    // Bits[1:1], RW, default = 0x0
    //
    UINTX core1_exists : 1;
    //
    // Indication of core fuse enabled status.
    // 
    // Bits[2:2], RW, default = 0x0
    //
    UINTX core2_exists : 1;
    //
    // Indication of core fuse enabled status.
    // 
    // Bits[3:3], RW, default = 0x0
    //
    UINTX core3_exists : 1;
    //
    // Indication of core fuse enabled status.
    // 
    // Bits[4:4], RW, default = 0x0
    //
    UINTX core4_exists : 1;
    //
    // Indication of core fuse enabled status.
    // 
    // Bits[5:5], RW, default = 0x0
    //
    UINTX core5_exists : 1;
    //
    // Indication of core fuse enabled status.
    // 
    // Bits[6:6], RW, default = 0x0
    //
    UINTX core6_exists : 1;
    //
    // Indication of core fuse enabled status.
    // 
    // Bits[7:7], RW, default = 0x0
    //
    UINTX core7_exists : 1;
    //
    // Indication of core fuse enabled status.
    // 
    // Bits[8:8], RW, default = 0x0
    //
    UINTX core8_exists : 1;
    //
    // Indication of core fuse enabled status.
    // 
    // Bits[9:9], RW, default = 0x0
    //
    UINTX core9_exists : 1;
    //
    // Indication of core fuse enabled status.
    // 
    // Bits[10:10], RW, default = 0x0
    //
    UINTX core10_exists : 1;
    //
    // Indication of core fuse enabled status.
    // 
    // Bits[11:11], RW, default = 0x0
    //
    UINTX core11_exists : 1;
    //
    // Indication of core fuse enabled status.
    // 
    // Bits[12:12], RW, default = 0x0
    //
    UINTX core12_exists : 1;
    //
    // Indication of core fuse enabled status.
    // 
    // Bits[13:13], RW, default = 0x0
    //
    UINTX core13_exists : 1;
    //
    // Indication of core fuse enabled status.
    // 
    // Bits[14:14], RW, default = 0x0
    //
    UINTX core14_exists : 1;
    //
    // Indication of core fuse enabled status.
    // 
    // Bits[15:15], RW, default = 0x0
    //
    UINTX core15_exists : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:16], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 16;
  } Bits;
  UINTX Data;
} P_CR_CORE_EXISTS_VECTOR_0_0_0_MCHBAR_PUNITSA_STRUCT;
#endif // ASM_INC

#define P_CR_CORE_DISABLE_MASK_0_0_0_MCHBAR_PUNITSA_REG    0x00007168
#ifndef ASM_INC
typedef union {
  struct {
    //
    // core0 disable mask
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINTX core0_disable_mask : 1;
    //
    // core1 disable mask
    // 
    // Bits[1:1], RW, default = 0x0
    //
    UINTX core1_disable_mask : 1;
    //
    // core2 disable mask
    // 
    // Bits[2:2], RW, default = 0x0
    //
    UINTX core2_disable_mask : 1;
    //
    // core3 disable mask
    // 
    // Bits[3:3], RW, default = 0x0
    //
    UINTX core3_disable_mask : 1;
    //
    // core4 disable mask
    // 
    // Bits[4:4], RW, default = 0x0
    //
    UINTX core4_disable_mask : 1;
    //
    // core5 disable mask
    // 
    // Bits[5:5], RW, default = 0x0
    //
    UINTX core5_disable_mask : 1;
    //
    // core6 disable mask
    // 
    // Bits[6:6], RW, default = 0x0
    //
    UINTX core6_disable_mask : 1;
    //
    // core7 disable mask
    // 
    // Bits[7:7], RW, default = 0x0
    //
    UINTX core7_disable_mask : 1;
    //
    // core8 disable mask 
    // 
    // Bits[8:8], RW, default = 0x0
    //
    UINTX core8_disable_mask : 1;
    //
    // core9 disable mask
    // 
    // Bits[9:9], RW, default = 0x0
    //
    UINTX core9_disable_mask : 1;
    //
    // core10 disable mask
    // 
    // Bits[10:10], RW, default = 0x0
    //
    UINTX core10_disable_mask : 1;
    //
    // core11 disable mask
    // 
    // Bits[11:11], RW, default = 0x0
    //
    UINTX core11_disable_mask : 1;
    //
    // core12 disable mask
    // 
    // Bits[12:12], RW, default = 0x0
    //
    UINTX core12_disable_mask : 1;
    //
    // core13 disable mask
    // 
    // Bits[13:13], RW, default = 0x0
    //
    UINTX core13_disable_mask : 1;
    //
    // core14 disable mask
    // 
    // Bits[14:14], RW, default = 0x0
    //
    UINTX core14_disable_mask : 1;
    //
    // core15 disable mask
    // 
    // Bits[15:15], RW, default = 0x0
    //
    UINTX core15_disable_mask : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:16], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 16;
  } Bits;
  UINTX Data;
} P_CR_CORE_DISABLE_MASK_0_0_0_MCHBAR_PUNITSA_STRUCT;
#endif // ASM_INC

#define P_CR_TELEMETRY_DATA0_0_0_0_MCHBAR_PUNITSA_REG      0x00007170
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Telemetry Information Data Register 0.  Exact interpretation of the data is configured
    // by software when telemetry is enabled. 
    // 
    // Bits[63:0], RW, default = 0x0
    //
    UINTX data : 64;
  } Bits;
  UINTX Data;
} P_CR_TELEMETRY_DATA0_0_0_0_MCHBAR_PUNITSA_STRUCT;
#endif // ASM_INC

#define P_CR_TELEMETRY_DATA1_0_0_0_MCHBAR_PUNITSA_REG      0x00007178
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Telemetry Information Data Register 1.  Exact interpretation of the data is configured
    // by software when telemetry is enabled. 
    // 
    // Bits[63:0], RW, default = 0x0
    //
    UINTX data : 64;
  } Bits;
  UINTX Data;
} P_CR_TELEMETRY_DATA1_0_0_0_MCHBAR_PUNITSA_STRUCT;
#endif // ASM_INC

#define P_CR_TELEMETRY_DATA2_0_0_0_MCHBAR_PUNITSA_REG      0x00007180
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Telemetry Information Data Register 2.  Exact interpretation of the data is configured
    // by software when telemetry is enabled. 
    // 
    // Bits[63:0], RW, default = 0x0
    //
    UINTX data : 64;
  } Bits;
  UINTX Data;
} P_CR_TELEMETRY_DATA2_0_0_0_MCHBAR_PUNITSA_STRUCT;
#endif // ASM_INC

#define P_CR_TELEMETRY_DATA3_0_0_0_MCHBAR_PUNITSA_REG      0x00007188
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Telemetry Information Data Register 3.  Exact interpretation of the data is configured
    // by software when telemetry is enabled. 
    // 
    // Bits[63:0], RW, default = 0x0
    //
    UINTX data : 64;
  } Bits;
  UINTX Data;
} P_CR_TELEMETRY_DATA3_0_0_0_MCHBAR_PUNITSA_STRUCT;
#endif // ASM_INC

#define P_CR_TELEMETRY_DATA4_0_0_0_MCHBAR_PUNITSA_REG      0x00007190
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Telemetry Information Data Register 4.  Exact interpretation of the data is configured
    // by software when telemetry is enabled. 
    // 
    // Bits[63:0], RW, default = 0x0
    //
    UINTX data : 64;
  } Bits;
  UINTX Data;
} P_CR_TELEMETRY_DATA4_0_0_0_MCHBAR_PUNITSA_STRUCT;
#endif // ASM_INC

#define P_CR_TELEMETRY_DATA5_0_0_0_MCHBAR_PUNITSA_REG      0x00007198
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Telemetry Information Data Register 5.  Exact interpretation of the data is configured
    // by software when telemetry is enabled. 
    // 
    // Bits[63:0], RW, default = 0x0
    //
    UINTX data : 64;
  } Bits;
  UINTX Data;
} P_CR_TELEMETRY_DATA5_0_0_0_MCHBAR_PUNITSA_STRUCT;
#endif // ASM_INC

#define P_CR_TELEMETRY_DATA6_0_0_0_MCHBAR_PUNITSA_REG      0x000071A0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Telemetry Information Data Register 6.  Exact interpretation of the data is configured
    // by software when telemetry is enabled. 
    // 
    // Bits[63:0], RW, default = 0x0
    //
    UINTX data : 64;
  } Bits;
  UINTX Data;
} P_CR_TELEMETRY_DATA6_0_0_0_MCHBAR_PUNITSA_STRUCT;
#endif // ASM_INC

#define P_CR_TELEMETRY_DATA7_0_0_0_MCHBAR_PUNITSA_REG      0x000071A8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Telemetry Information Data Register 7.  Exact interpretation of the data is configured
    // by software when telemetry is enabled. 
    // 
    // Bits[63:0], RW, default = 0x0
    //
    UINTX data : 64;
  } Bits;
  UINTX Data;
} P_CR_TELEMETRY_DATA7_0_0_0_MCHBAR_PUNITSA_STRUCT;
#endif // ASM_INC

#define P_CR_TELEMETRY_DATA8_0_0_0_MCHBAR_PUNITSA_REG      0x000071B0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Telemetry Information Data Register 8.  Exact interpretation of the data is configured
    // by software when telemetry is enabled. 
    // 
    // Bits[63:0], RW, default = 0x0
    //
    UINTX data : 64;
  } Bits;
  UINTX Data;
} P_CR_TELEMETRY_DATA8_0_0_0_MCHBAR_PUNITSA_STRUCT;
#endif // ASM_INC

#define P_CR_TELEMETRY_DATA9_0_0_0_MCHBAR_PUNITSA_REG      0x000071B8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Telemetry Information Data Register 9.  Exact interpretation of the data is configured
    // by software when telemetry is enabled. 
    // 
    // Bits[63:0], RW, default = 0x0
    //
    UINTX data : 64;
  } Bits;
  UINTX Data;
} P_CR_TELEMETRY_DATA9_0_0_0_MCHBAR_PUNITSA_STRUCT;
#endif // ASM_INC

#define P_CR_TELEMETRY_DATA10_0_0_0_MCHBAR_PUNITSA_REG     0x000071C0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Telemetry Information Data Register 10.  Exact interpretation of the data is configured
    // by software when telemetry is enabled. 
    // 
    // Bits[63:0], RW, default = 0x0
    //
    UINTX data : 64;
  } Bits;
  UINTX Data;
} P_CR_TELEMETRY_DATA10_0_0_0_MCHBAR_PUNITSA_STRUCT;
#endif // ASM_INC

#define P_CR_TELEMETRY_DATA11_0_0_0_MCHBAR_PUNITSA_REG     0x000071C8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Telemetry Information Data Register 11.  Exact interpretation of the data is configured
    // by software when telemetry is enabled. 
    // 
    // Bits[63:0], RW, default = 0x0
    //
    UINTX data : 64;
  } Bits;
  UINTX Data;
} P_CR_TELEMETRY_DATA11_0_0_0_MCHBAR_PUNITSA_STRUCT;
#endif // ASM_INC

#define P_CR_TELEMETRY_DATA12_0_0_0_MCHBAR_PUNITSA_REG     0x000071D0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Telemetry Information Data Register 12.  Exact interpretation of the data is configured
    // by software when telemetry is enabled. 
    // 
    // Bits[63:0], RW, default = 0x0
    //
    UINTX data : 64;
  } Bits;
  UINTX Data;
} P_CR_TELEMETRY_DATA12_0_0_0_MCHBAR_PUNITSA_STRUCT;
#endif // ASM_INC

#define P_CR_TELEMETRY_DATA13_0_0_0_MCHBAR_PUNITSA_REG     0x000071D8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Telemetry Information Data Register 13.  Exact interpretation of the data is configured
    // by software when telemetry is enabled. 
    // 
    // Bits[63:0], RW, default = 0x0
    //
    UINTX data : 64;
  } Bits;
  UINTX Data;
} P_CR_TELEMETRY_DATA13_0_0_0_MCHBAR_PUNITSA_STRUCT;
#endif // ASM_INC

#define P_CR_TELEMETRY_DATA14_0_0_0_MCHBAR_PUNITSA_REG     0x000071E0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Telemetry Information Data Register 14.  Exact interpretation of the data is configured
    // by software when telemetry is enabled. 
    // 
    // Bits[63:0], RW, default = 0x0
    //
    UINTX data : 64;
  } Bits;
  UINTX Data;
} P_CR_TELEMETRY_DATA14_0_0_0_MCHBAR_PUNITSA_STRUCT;
#endif // ASM_INC

#define P_CR_TELEMETRY_DATA15_0_0_0_MCHBAR_PUNITSA_REG     0x000071E8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Telemetry Information Data Register 15.  Exact interpretation of the data is configured
    // by software when telemetry is enabled. 
    // 
    // Bits[63:0], RW, default = 0x0
    //
    UINTX data : 64;
  } Bits;
  UINTX Data;
} P_CR_TELEMETRY_DATA15_0_0_0_MCHBAR_PUNITSA_STRUCT;
#endif // ASM_INC

#define P_CR_PL3_CONTROL_0_0_0_MCHBAR_PUNITSA_REG          0x000071F0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Power Limit 3 (PL3) or PAppMax power level.  Any SOC power measurement observed
    // above this level is considered as an excursion against the PL3 power limit and
    // duty cycle / time window budget.  Units of this power limit are defined by PACKAGE_POWER_SKU_UNIT_MSR.PWR_UNIT.
    // 
    // Bits[14:0], RW/L, default = 0x0
    //
    UINTX power_limit : 15;
    //
    // [list]
    //               [*]0 = disabled
    //               [*]1 = enabled
    //               [/list]
    // 
    // Bits[15:15], RW/L, default = 0x0
    //
    UINTX pl3_enable : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[16:16], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 1;
    //
    // Duration over which duty cycle control will be maintained.  The bits of this field
    // describe parameters for a mathematical equation for time window configuration.
    //   This time window is strictly adhered to, if the window described is 40ms, then
    // silicon guarantees no excursions to the programmed duty cycle within a rolling
    // 40ms window.  [p]This field is split into two sub-fields:[/p] 
    //               [list]
    //               [*] x = bits[6:5]
    //               [*] y = bits[4:0]
    //               [/list]
    //               [p]Time window equation:[/p]
    //               [b]time_window = PACKAGE_POWER_SKU_UNIT.TIME_UNIT * ((1+x/4)^y)[/b]
    // 
    // Bits[23:17], RW/L, default = 0x0
    //
    UINTX time_window : 7;
    //
    // Power limit excursion duty cycle control for PL3, describing what percentage of
    // time it is allowed for the SOC to exceed the programmed PL3 power limit.  0% implies
    // excursions are not supported ever and 100% implies excursions are always allowed
    // (effectively disabling the feature).  Units are in percentage(%).  E.g., to allow
    // for 20% excursion time and 80% PL3 power limit clamp time, program a value of
    // 14h.  Values greater than 100 (64h) are clipped to 100%. 
    // 
    // Bits[30:24], RW/L, default = 0x0
    //
    UINTX duty_cycle : 7;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:31], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 1;
    //
    // Power Limit 'PL4' or Pmax power limit in the units as described PACAKGE_POWER_SKU_UNIT
    // MSR.  The SOC guarantees it will never exceed this power limit even for very short
    // time windows. 
    // 
    // Bits[46:32], RW/L, default = 0x0
    //
    UINTX pmax : 15;
    //
    // [list]
    //               [*]0 = disabled
    //               [*]1 = enabled
    //               [/list]
    // 
    // Bits[47:47], RW/L, default = 0x0
    //
    UINTX pl4_enable : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[62:48], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 15;
    //
    // Write a 1b to lock this register until next reset.  Once locked, no further updates
    // may be written to any bits in the register. 
    // 
    // Bits[63:63], RW/L, default = 0x0
    //
    UINTX lock : 1;
  } Bits;
  UINTX Data;
} P_CR_PL3_CONTROL_0_0_0_MCHBAR_PUNITSA_STRUCT;
#endif // ASM_INC

#define P_CR_CONFIG_TDP_LEVEL1_0_0_0_MCHBAR_PUNITSA_REG    0x00007220
#ifndef ASM_INC
typedef union {
  struct {
    //
    // TDP power value (Units from PKG_POWER_SKU_UNIT)
    // 
    // Bits[14:0], RW, default = 0x0
    //
    UINTX tdp_power_value : 15;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[15:15], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 1;
    //
    // TDP ratio for this level
    // 
    // Bits[23:16], RW, default = 0x0
    //
    UINTX tdp_ratio : 8;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:24], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 8;
    //
    // Max Power of SKU
    // 
    // Bits[46:32], RW, default = 0x0
    //
    UINTX pkg_max_power : 15;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[47:47], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 1;
    //
    // Min Power of SKU (units from PKG_POWER_SKU_UNIT)
    // 
    // Bits[62:48], RW, default = 0x0
    //
    UINTX pkg_min_power : 15;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[63:63], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_3 : 1;
  } Bits;
  UINTX Data;
} P_CR_CONFIG_TDP_LEVEL1_0_0_0_MCHBAR_PUNITSA_STRUCT;
#endif // ASM_INC

#define P_CR_CONFIG_TDP_LEVEL2_0_0_0_MCHBAR_PUNITSA_REG    0x00007228
#ifndef ASM_INC
typedef union {
  struct {
    //
    // TDP power value (Units from PKG_POWER_SKU_UNIT)
    // 
    // Bits[14:0], RW, default = 0x0
    //
    UINTX tdp_power_value : 15;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[15:15], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 1;
    //
    // TDP ratio for this level
    // 
    // Bits[23:16], RW, default = 0x0
    //
    UINTX tdp_ratio : 8;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:24], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 8;
    //
    // Max Power of SKU
    // 
    // Bits[46:32], RW, default = 0x0
    //
    UINTX pkg_max_power : 15;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[47:47], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 1;
    //
    // Min Power of SKU (units from PKG_POWER_SKU_UNIT)
    // 
    // Bits[62:48], RW, default = 0x0
    //
    UINTX pkg_min_power : 15;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[63:63], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_3 : 1;
  } Bits;
  UINTX Data;
} P_CR_CONFIG_TDP_LEVEL2_0_0_0_MCHBAR_PUNITSA_STRUCT;
#endif // ASM_INC

#define P_CR_CONFIG_TDP_LEVEL3_0_0_0_MCHBAR_PUNITSA_REG    0x00007230
#ifndef ASM_INC
typedef union {
  struct {
    //
    // TDP power value (Units from PKG_POWER_SKU_UNIT)
    // 
    // Bits[14:0], RW, default = 0x0
    //
    UINTX tdp_power_value : 15;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[15:15], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 1;
    //
    // TDP ratio for this level
    // 
    // Bits[23:16], RW, default = 0x0
    //
    UINTX tdp_ratio : 8;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:24], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 8;
    //
    // Max Power of SKU
    // 
    // Bits[46:32], RW, default = 0x0
    //
    UINTX pkg_max_power : 15;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[47:47], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 1;
    //
    // Min Power of SKU (units from PKG_POWER_SKU_UNIT)
    // 
    // Bits[62:48], RW, default = 0x0
    //
    UINTX pkg_min_power : 15;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[63:63], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_3 : 1;
  } Bits;
  UINTX Data;
} P_CR_CONFIG_TDP_LEVEL3_0_0_0_MCHBAR_PUNITSA_STRUCT;
#endif // ASM_INC

#define P_CR_CONFIG_TDP_CONTROL_0_0_0_MCHBAR_PUNITSA_REG   0x00007238
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Used to select which configTDP level is desired
    // 
    // Bits[1:0], RW/L, default = 0x0
    //
    UINTX config_tdp_level : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[30:2], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 29;
    //
    // Lock this register.  BIOS should set this after selecting ConfigTDP level
    // 
    // Bits[31:31], RW/L, default = 0x0
    //
    UINTX config_tdp_lock : 1;
  } Bits;
  UINTX Data;
} P_CR_CONFIG_TDP_CONTROL_0_0_0_MCHBAR_PUNITSA_STRUCT;
#endif // ASM_INC

#define P_CR_CONFIG_TDP_NOMINAL_0_0_0_MCHBAR_PUNITSA_REG   0x0000723C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Config TDP ratio
    // 
    // Bits[7:0], RW, default = 0x0
    //
    UINTX tdp_ratio : 8;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:8], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 24;
  } Bits;
  UINTX Data;
} P_CR_CONFIG_TDP_NOMINAL_0_0_0_MCHBAR_PUNITSA_STRUCT;
#endif // ASM_INC

#define P_CR_FLEX_RATIO_0_0_0_MCHBAR_PUNITSA_REG           0x00007240
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:0], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 8;
    //
    // Desired flex ratio
    // 
    // Bits[15:8], RW, default = 0x0
    //
    UINTX flex_ratio : 8;
    //
    // FLEX_RATIO enable (note: not supported today)
    // 
    // Bits[16:16], RW, default = 0x0
    //
    UINTX enable : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:17], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 15;
  } Bits;
  UINTX Data;
} P_CR_FLEX_RATIO_0_0_0_MCHBAR_PUNITSA_STRUCT;
#endif // ASM_INC

#define P_CR_PP1_ANY_THREAD_ACTIVITY_0_0_0_MCHBAR_PUNITSA_REG 0x00007244
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Graphics Superqueue active residency counter.  Counts in 19.2MHz reference clocks.
    // 
    // Bits[31:0], RO/V, default = 0x0
    //
    UINTX superqueue_active_residency : 32;
  } Bits;
  UINTX Data;
} P_CR_PP1_ANY_THREAD_ACTIVITY_0_0_0_MCHBAR_PUNITSA_STRUCT;
#endif // ASM_INC


#endif // _PUNITSA_H_
