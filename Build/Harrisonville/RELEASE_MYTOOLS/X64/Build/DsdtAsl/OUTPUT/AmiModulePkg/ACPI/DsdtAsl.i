#undef MIN
#undef MAX
//-------- DO NOT EDIT THIS FILE --------
//
//****************************************************************************
//****************************************************************************
//**                                                                        **
//**         (C)Copyright 1985 - 2012, American Megatrends, Inc.            **
//**                                                                        **
//**                          All Rights Reserved.                          **
//**                                                                        **
//**                    5555 Oakbrook Pkwy, Norcross, GA 30092              **
//**                                                                        **
//**                          Phone (770)-246-8600                          **
//**                                                                        **
//****************************************************************************
//****************************************************************************
#include <TokenAsl.h> 
//Including AUTOGENERATED DSDT.ASL file

//-------- DO NOT EDIT THIS FILE --------
//
// FILE WAS GENERATED AUTOMATICALY USING AMISDL v7.04.0274 (四月 26 2023,16:58:30)
//
//-------- DO NOT EDIT THIS FILE --------
//****************************************************************************
//****************************************************************************
//**                                                                        **
//**         (C)Copyright 1985 - 2023, American Megatrends, Inc.            **
//**                                                                        **
//**                          All Rights Reserved.                          **
//**                                                                        **
//**                    5555 Oakbrook Pkwy, Norcross, GA 30092              **
//**                                                                        **
//**                          Phone (770)-246-8600                          **
//**                                                                        **
//****************************************************************************
//****************************************************************************
DefinitionBlock (
	"DSDT.aml",	// DSDT Table File Name
	"DSDT",	// DSDT Table Signature
	// A Revision field value greater than or equal to 2 signifies that integers
	// declared within the Definition Block are to be evaluated as 64-bit values
	0x02,	// DSDT revision.
	"ALASKA",	// OEM ID (6 byte string)
	"A M I ",	// OEM table ID  (8 byte string)
	0x01072009	// OEM version of DSDT table (8 byte Integer filled by ASL compiler)
	)
{	// BEGIN ASL SCOPE
	
	//-------- DO NOT EDIT THIS FILE --------
	//
	// FILE WAS GENERATED AUTOMATICALY USING AMISDL v7.04.0274 (四月 26 2023,16:58:30)
	//
	//-------- DO NOT EDIT THIS FILE --------
	//****************************************************************************
	//****************************************************************************
	//**                                                                        **
	//**         (C)Copyright 1985 - 2023, American Megatrends, Inc.            **
	//**                                                                        **
	//**                          All Rights Reserved.                          **
	//**                                                                        **
	//**                    5555 Oakbrook Pkwy, Norcross, GA 30092              **
	//**                                                                        **
	//**                          Phone (770)-246-8600                          **
	//**                                                                        **
	//****************************************************************************
	//****************************************************************************
	
	Name(ENTK, 0x87)	// ASL alias for SIO Config Mode Enter Value.
	Name(EXTK, 0xaa)	// ASL alias for SIO Config Mode Exit Value.
	Name(IO1B, 0xa00)	// Base Address of GPIO Controller.
	Name(IO1L, 0x10)	// Length of GPIO Controller.
	Name(IO2B, 0xa10)	// Base Address of ACPI Controller.
	Name(IO2L, 0x10)	// Length of ACPI Controller.
	Name(IO3B, 0xa20)	// Base Address of HWM Controller.
	Name(IO3L, 0x10)	// Length of HWM Controller.
	Name(SP1O, 0x4e)	// Super IO Index/Data configuration port for ASL.
	Name(KBFG, 0x0)	// Keyboard wake-up flag.
	Name(MSFG, 0x0)	// Mouse wake-up flag.
	Name(IOES, 0x0)	// It is used similar to IOST, when Device's DCAT > 0x0F , then it will be used.
	Name(LAPB, 0xfee00000)	// Local APIC Base Address
	Name(CPVD, 0x0)	// Chipset Vendor for OEM reference. 0 = Intel, 1 = AMD, 2 = VIA..
	Name(SMBS, 0xefa0)	// SMBus I/O Registes Base Address
	Name(SMBL, 0x20)	// SMBus I/O Registes Range
	Name(PMBS, 0x1800)	// ASL alias for ACPI I/O base address.
	Name(PMLN, 0x80)	// Power Management registers block length
	Name(SMIP, 0xb2)	// Token to go to ASL Name Definitions
	Name(GPLN, 0x40)	// GPIO Register Block length
	Name(APCB, 0xfec00000)	// Default I/O APIC(s) memory start address, bytes\0x0FEC00000 - default, 0 - I/O APIC's disabled
	Name(APCL, 0x1000)	// I/O APIC(s) memory decoded range, bytes\0x1000 - default,\0 - I/O APIC's not decoded 
	Name(RCRB, 0xfed1c000)	// Root Complex Base Address
	Name(RCRL, 0x4000)	// 
	Name(PM30, 0x1830)	// SMI Control Register
	Name(AERC, 0x0)	// _OSC: Advanced Error Reporting Control
	Name(ASSB, 0x0)	// ACPI Sleep State Buffer for BIOS Usage.
	Name(AOTB, 0x0)	// ACPI OS Type Buffer for BIOS Usage.
	Name(AAXB, 0x0)	// ACPI Auxiliary Buffer for BIOS Usage.
	Name(PEHP, 0x1)	// _OSC: Pci Express Native Hot Plug Control
	Name(SHPC, 0x0)	// _OSC: Standard Hot Plug Controller (SHPC) Native Hot Plug control
	Name(PEPM, 0x1)	// _OSC: Pci Express Native Power Management Events control
	Name(PEER, 0x1)	// _OSC: Pci Express Advanced Error Reporting control
	Name(PECS, 0x1)	// _OSC: Pci Express Capability Structure control
	Name(ITKE, 0x0)	// This will be overridden by the ITK module.
	Name(MBEC, 0xffff)	// EC presence (0) or abssence (0xFFFF) in system. EC declare I/O port \ 62/66, also declared as MotherBoard Resources in rmisc.asl,\ as EC's resource. To avoid conflicts redefine \ to 0 in EC mopdule, if present
	Name(PEBS, 0xe0000000)	// Pci Express Base Aliase to use in PCIeAccess.ASL
	Name(PELN, 0x10000000)	// 
	Name(CSMI, 0x61)	// 
	Name(SMIA, 0xb2)	// Add a name of smiport for asl using
	Name(SMIB, 0xb3)	// Add a name of smiport for asl using
	Name(OFST, 0x35)	// Add a name of smiport for asl using
	Name(TRST, 0x2)	// Platform transition for PPI request under O.S. 0: None 1: Shutdown 2: Reboot 3: OS Vendor Specific
	Name(TCMF, 0x0)	// TPM ASL update Variable
	Name(TMF1, 0x0)	// TPM ASL update Variable
	Name(TMF2, 0x0)	// TPM ASL update Variable
	Name(TMF3, 0x0)	// TPM ASL update Variable
	Name(TTPF, 0x1)	// 
	Name(DTPT, 0x0)	// 
	Name(TTDP, 0x0)	// 
	Name(TPMB, 0xffffffff)	// 
	Name(TPMC, 0xffffffff)	// 
	Name(TPMM, 0xfed40000)	// 
	Name(FTPM, 0xffffffff)	// 
	Name(PPIM, 0xffff0000)	// 
	Name(PPIL, 0xf0)	// 
	Name(AMDT, 0x0)	// 
	Name(TPMF, 0x0)	// 
	Name(PPIV, 0x0)	// PPI version flag
	Name(LAPL, 0x100000)	// Local APIC(s) memory decoded range, bytes\0x100000 - default,\0 - Local APIC's not decoded 
	//-------- DO NOT EDIT THIS FILE --------
	//
	// FILE WAS GENERATED AUTOMATICALY USING AMISDL v7.04.0274 (四月 26 2023,16:58:30)
	//
	//-------- DO NOT EDIT THIS FILE --------
	//****************************************************************************
	//****************************************************************************
	//**                                                                        **
	//**         (C)Copyright 1985 - 2023, American Megatrends, Inc.            **
	//**                                                                        **
	//**                          All Rights Reserved.                          **
	//**                                                                        **
	//**                    5555 Oakbrook Pkwy, Norcross, GA 30092              **
	//**                                                                        **
	//**                          Phone (770)-246-8600                          **
	//**                                                                        **
	//****************************************************************************
	//****************************************************************************

//==========================================================================
//Following objects will be added in ROOT scope (\.) of DSDT Name Space
//BEFORE PCITREE.ASL which creates _SB_ scope
//==========================================================================
	// ASL generic library objects
	//**********************************************************************
	//**********************************************************************
	//**                                                                  **
	//**        (C)Copyright 1985-2009, American Megatrends, Inc.         **
	//**                                                                  **
	//**                       All Rights Reserved.                       **
	//**                                                                  **
	//**             5555 Oakbrook Pkwy, Norcross, GA 30093               **
	//**                                                                  **
	//**                       Phone: (770)-246-8600                      **
	//**                                                                  **
	//**********************************************************************
	//**********************************************************************
	// $Header: /Alaska/BIN/Modules/ACPI/Template/Core/asllib.asl 7     9/29/09 5:06p Oleksiyy $
	//
	// $Revision: 7 $
	//
	// $Date: 9/29/09 5:06p $
	//**********************************************************************;
	//;**********************************************************************;
	//              File to be included to root ASL scope of DSDT.ASL
	//**********************************************************************;
	// 1. RRIO(4) & rDMA(3) Dummy control methods. Required when I/O Positive decoding's disabled
	// 2. Name PICM - Global Name returns current Interrupt controller mode; updated from _PIC control method
	// 3. Method _PIC(1) - Updates PICM with current Interrupt controller mode
	// 4. Method MCTH(Str1, Str2) - Compare Str1 and Str2.
	// 5. Method GPRW(Package(x,y)) Generic Wake up Control Method to detect the Max Sleep State available in ASL Name scope
	//      and Return the Package compatible with _PRW format
	// 6. Method WAKP(Package) - Return package for _WAK method
	// 7. Debug OperationRegions used to display ASL checkpoints int LED CheckPoint Card
	//----------------------------------------------------------------------
	
	
	//;<AMI_PHDR_START>
	//;------------------------------------------------------------------------
	//;
	//; Procedure:	_PIC
	//;
	//; Description:	Interrupt mode Control method, returns current Interrupt controller mode; updated from _PIC control method
	//;		OS invokes _PIC to notify ASL of current Interrupt controller mode
	//; 		_PIC Input arguments : 0-PIC mode (Default), 1-APIC mode
	//;  Input: Arg0 - Interrupt mode 
	//;  Output: Nothing
	//;
	//;-------------------------------------------------------------------------
	//;<AMI_PHDR_END>
	
		Name(PICM, 0)	// Global Name, returns current Interrupt controller mode; updated from _PIC control method
	//  OS invokes _PIC to notify ASL of current Interrupt controller mode
	// _PIC Input arguments : 0-PIC mode (Default), 1-APIC mode
		Method(_PIC, 1) { 
	#if ASL_ACPI_DBG8_ASL_SUPPORT
			if(Arg0) {
				Store(0xAA, DBG8)	// APIC
			} else {
				Store(0xAC, DBG8)	 // PIC
			}
	#endif
			Store(Arg0, PICM) 
		}
	
	//;<AMI_PHDR_START>
	//;------------------------------------------------------------------------
	//;
	//; Procedure:	OSFL
	//;
	//; Description:	OSFL object is used to detect the currently running OS
	//; Input: Nothing
	//; Output: OS type
	//; running under 0 - Win 2000
	//;               1 - Win 98/Se
	//;               2 - Win Me
	//;               3 - Linux
	//;				4 - WinXP
	//;				5 - Windows Server 2003				
	//;				6 - FreeBSD		
	//;				7 - HP-UX
	//;				8 - OpenVMS		
	//;-------------------New Values Added -----------------------------
	//;               9 - WinXP SP1
	//;              10 - WinXP SP2
	//;              11 - WinXP SP3    
	//;              12 - Vista
	//;              13 - Vista SP1
	//;              14 - Win7                 
	//;   			 15 - Win8
	//;				 16 - Win8.1
	//; 		17..n - reserved
	//;
	//;-------------------------------------------------------------------------
	//;<AMI_PHDR_END>
	
		Name(OSVR, Ones)					// Global Name, returns current OS version ID
		Method(OSFL, 0){
			if(LNotEqual(OSVR, Ones)) {Return(OSVR)}	// OS version was already detected
			if(LEqual(PICM,0)) {Store(0xAC, DBG8)}		// to indicate OS is running in ACPI PIC mode
			Store(3, OSVR)					// default - Linux
	//// Detect currently running OS
			if(CondRefOf(\_OSI,Local0))
			{
				//If(\_OSI("Linux")){Store(3, OSVR)}	// Tested on the Redhat Linux
				If(\_OSI("Windows 2001")){Store(4, OSVR)}
				If(\_OSI("Windows 2001.1")){Store(5, OSVR)}		
				If(\_OSI("FreeBSD")){Store(6, OSVR)}
				If(\_OSI("HP-UX")){Store(7, OSVR)}
				If(\_OSI("OpenVMS")){Store(8, OSVR)}
	            If(\_OSI("Windows 2001 SP1")){Store(9,OSVR)}
	            If(\_OSI("Windows 2001 SP2")){Store(10,OSVR)}
	            If(\_OSI("Windows 2001 SP3")){Store(11,OSVR)}
	            If(\_OSI("Windows 2006")){Store(12,OSVR)}
	            If(\_OSI("Windows 2006 SP1")){Store(13,OSVR)}
	            If(\_OSI("Windows 2009")){Store(14,OSVR)}
	            If(\_OSI("Windows 2012")){Store(15,OSVR)}
	            If(\_OSI("Windows 2013")){Store(16,OSVR)}
			} else {
				If(MCTH(\_OS,"Microsoft Windows NT")){Store(0, OSVR)}
				If(MCTH(\_OS,"Microsoft Windows")){Store(1, OSVR)}
				If(MCTH(\_OS,"Microsoft WindowsME: Millennium Edition")){Store(2, OSVR)}
				If(MCTH(\_OS,"Linux")){Store(3, OSVR)}	// Tested on the Redhat Linux
				If(MCTH(\_OS,"FreeBSD")){Store(6, OSVR)}
				If(MCTH(\_OS,"HP-UX")){Store(7, OSVR)}
				If(MCTH(\_OS,"OpenVMS")){Store(8, OSVR)}
			}
			Return(OSVR)
		}
	
	
	//;<AMI_PHDR_START>
	//;-------------------------------------------------------------------------
	//;
	//; Procedure:	MCTH
	//;
	//; Description:	Generic control Method. Used to compare two strings and return TRUE/FALSE result
	//;		MCTH(Str1, Str2) - Compare Str1 and Str2.
	//; Input: Arg0 - str1, Arg1 - str2
	//; Output: string comparison result
	//;        One if Str1 == Str2
	//;        Zero if Str1 != Str2
	//;-------------------------------------------------------------------------
	//;<AMI_PHDR_END>
	
		Method(MCTH, 2) {
	//1. If Length str1 < Str2 - Return (Zero)
			If(LLess(Sizeof(Arg0), Sizeof(Arg1)))
			{
				Return(Zero)
			}
	//2. Convert str1 & str2 into buffer with length of str2
			Add(Sizeof(Arg0), 1, Local0)
	// Local0 contains length of string + NULL character.
			Name(BUF0, Buffer(Local0) {})
			Name(BUF1, Buffer(Local0) {})
			Store(Arg0, BUF0)
			Store(Arg1, BUF1)
			While(Local0)
			{
				Decrement(Local0)
				If(LNotEqual(Derefof(Index(BUF0, Local0)), Derefof(Index(BUF1, Local0))))
				{ Return(Zero) }
			}
			Return(One)		// Str1 & Str2 are match
		}
	
	
	//;<AMI_PHDR_START>
	//;------------------------------------------------------------------------
	//;
	//; Procedure:	GPRW
	//;
	//; Description:	Generic Wake up Control Method ("Big brother") to detect the Max Sleep State available in ASL Name scope
	//;		and Return the Package compatible with _PRW format.
	//; Input: Arg0 =  bit offset within GPE register space device event will be triggered to
	//;        Arg1 =  Max Sleep state, device can resume the System from
	//;             If Arg1 = 0 , Update Arg1 with Max _Sx state enabled in the System
	//; Output: _PRW package
	//;
	//;-------------------------------------------------------------------------
	//;<AMI_PHDR_END>
	
		Name(PRWP, Package(){Zero, Zero})		// _PRW Package
		Method(GPRW, 2)
		{
			Store(Arg0, Index(PRWP, 0))		// copy GPE#
	// SS1-SS4 - enabled in BIOS Setup Sleep states
	                Store(ShiftLeft(SS1,1),Local0)      	// S1 ?
	                Or(Local0,ShiftLeft(SS2,2),Local0)      // S2 ?
	                Or(Local0,ShiftLeft(SS3,3),Local0)      // S3 ?
	                Or(Local0,ShiftLeft(SS4,4),Local0)      // S4 ?
	// Local0 has a bit mask of enabled Sx(1 based)
								// bit mask of enabled in BIOS Setup Sleep states(1 based)
			If(And(ShiftLeft(1, Arg1), Local0)){	// Requested wake up value (Arg1) is present in Sx list of available Sleep states
				Store(Arg1, Index(PRWP, 1))	// copy Sx#
			} Else {  				// Not available -> match Wake up value to the higher Sx state
				ShiftRight(Local0, 1, Local0)	
				If(LOr(LEqual(OSFL, 1), LEqual(OSFL, 2))) { 	// ??? Win9x
					FindSetLeftBit(Local0, Index(PRWP,1))	// Arg1 == Max Sx
				} Else { 					// ??? Win2k / XP
					FindSetRightBit(Local0, Index(PRWP,1))	// Arg1 == Min Sx
				}
			}
		Return(PRWP)
		}
	
	
	//;<AMI_PHDR_START>
	//;------------------------------------------------------------------------
	//;
	//; Procedure:	WAKP
	//;
	//; Description:	Return package for _WAK method. Contains 2 DWORDS
	//; 0 - Status
	//;           0x00000001 - wake was signaled but failed due to lack of power
	//;           0x00000002 - wake was signaled but failed due to thermal condition
	//;           other bits are reserved
	//; 1 - PSS      if non-zero, the effective S-state the Power Supply realy entered
	//; Output: _WAK return package
	//;-------------------------------------------------------------------------
	//;<AMI_PHDR_END>
	
	// Return package for _WAK method 2 DWORDS
		Name(WAKP, Package(){Zero, Zero})
	
	
	    Method(UPWP,1){
	            if(DeRefOf(Index(WAKP,0)))      // non 0 : wake up was terminated
	            {
	                Store(0, Index(WAKP,1))     
	            } else {                // wake up to be completed
	                Store(Arg0, Index(WAKP,1))  
	            }
	    }
	
	
	//--------------------------//
	// Debug output registers   //
	//--------------------------//
	
	//;<AMI_PHDR_START>
	//;------------------------------------------------------------------------
	//; Procedure:	DBG8
	//; Procedure:	DBG9
	//; Description:	Logical names for Debug ports 0x80 (byte) and 0x90(word). 
	//;		If such debug ports exist in the System, the value, stored into the Port will be displayed to LED
	//; Input: Nothing
	//; Output: Nothing
	//;-------------------------------------------------------------------------
	//;<AMI_PHDR_END>
	
	
		OperationRegion (DEB0, SystemIO, 0x80, 1)
		Field (DEB0, ByteAcc,NoLock,Preserve)
		{ DBG8,8,}
	
		OperationRegion (DEB1, SystemIO, 0x90, 2)
		Field (DEB1, WordAcc,NoLock,Preserve)
		{ DBG9,16,}
	
	//**********************************************************************
	//**********************************************************************
	//**                                                                  **
	//**        (C)Copyright 1985-2009, American Megatrends, Inc.         **
	//**                                                                  **
	//**                       All Rights Reserved.                       **
	//**                                                                  **
	//**             5555 Oakbrook Pkwy, Norcross, GA 30093               **
	//**                                                                  **
	//**                       Phone: (770)-246-8600                      **
	//**                                                                  **
	//**********************************************************************
	//**********************************************************************

	// OEM ASL file. Defines ASL Name fields to be linked to AML Exchange bufer location
	//**********************************************************************
	//**********************************************************************
	//**                                                                  **
	//**        (C)Copyright 1985-2009, American Megatrends, Inc.         **
	//**                                                                  **
	//**                       All Rights Reserved.                       **
	//**                                                                  **
	//**             5555 Oakbrook Pkwy, Norcross, GA 30093               **
	//**                                                                  **
	//**                       Phone: (770)-246-8600                      **
	//**                                                                  **
	//**********************************************************************
	//**********************************************************************
	// $Header: /Alaska/BIN/Modules/ACPI/Template/Core/AMLUPD.asl 10    10/14/10 4:59p Oleksiyy $
	//
	// $Revision: 10 $
	//
	// $Date: 10/14/10 4:59p $
	//
	//****************************************************************************
	//----------------------------------------------------------------------
	
	
	//;<AMI_THDR_START>
	//;------------------------------------------------------------------------/
	//;
	//; Name:	BIOS
	//;
	//; Type: OperationRegion
	//;
	//; Description:	Set of name objects used as an exchange buffer for BIOS to 
	//;					pass the System information to AML code
	//; 				List of mandatory Name Objects to be defined:
	//;					SS1 - SS4 - BIOS setup enabled sleep states.
	//; 				MG1B, MG1L - Non-shadowed memory range below 1Mb. Available for PCI0 bus.
	//; 				MG2B, MG2L - Memory range above available System memory. Available for PCI0 bus.
	//;
	//; Notes: Memory location and all Name values are updated in BIOS POST
	//; Referrals: AMLDATA
	//;-------------------------------------------------------------------------
	//;<AMI_THDR_END>
	
	///////////////////////////////////////////////////////////////////////////////////
	//Values are set like this to have ASL compiler reserve enough space for objects 
	///////////////////////////////////////////////////////////////////////////////////
	// Available Sleep states
	Name(SS1,1)		// is S1 enabled in setup?
	Name(SS2,0)
	Name(SS3,1)
	Name(SS4,1)
	///////////////////////////////////////////////////////////////////////////////////
	// Bit mask of statuses of IO peripheral devices, enabled in Setup
	//      0x0 - Serial A (Modem)
	//        1 - Serial B (IR)
	//        2 - LPT
	//        3 - FDD
	//----------------------------
	//        4 - SB16 Audio
	//        5 - Midi
	//        6 - Mss Audio
	//        7 - Adlib sound (FM synth)
	//----------------------------
	//        8 - Game 1 port
	//        9 - Game 2 port
	//        a - KBC 60 & 64
	//        b - EC 62 & 66
	//----------------------------
	//		  c - reserved
	//		  d	- reserved
	//        e - PS2Mouse
	//        f - reserved
	///////////////////////////////////////////////////////////////////////////////////
	Name(IOST,0xFFFF)		// Bit mask of statuses of IO peripheral devices, 
							// enabled in Setup
	///////////////////////////////////////////////////////////////////////////////////
	Name(TOPM,0xFFFFF)   	// System memory top address below 4GB, bytes
	
	///////////////////////////////////////////////////////////////////////////////////
	Name(ROMS,0xffe00000)	// Boot strap BIOS image address at top 4Gbyte
	
	///////////////////////////////////////////////////////////////////////////////////
	Name(VGAF, 0x1)         //Flag to indicate Legacy VGA Resources were clamed already
	
	//**********************************************************************
	//**********************************************************************
	//**                                                                  **
	//**        (C)Copyright 1985-2009, American Megatrends, Inc.         **
	//**                                                                  **
	//**                       All Rights Reserved.                       **
	//**                                                                  **
	//**             5555 Oakbrook Pkwy, Norcross, GA 30093               **
	//**                                                                  **
	//**                       Phone: (770)-246-8600                      **
	//**                                                                  **
	//**********************************************************************
	//**********************************************************************

	//
	// This file contains an 'Intel Peripheral Driver' and is      
	// licensed for Intel CPUs and chipsets under the terms of your
	// license agreement with Intel or your vendor.  This file may 
	// be modified by the user, subject to additional terms of the 
	// license agreement                                           
	//
	/*++
	
	// Copyright (c) 2014-2020, Intel Corporation. All rights reserved.
	// This software and associated documentation (if any) is furnished
	// under a license and may only be used or copied in accordance
	// with the terms of the license. Except as permitted by such
	// license, no part of this software or documentation may be
	// reproduced, stored in a retrieval system, or transmitted in any
	// form or by any means without the express written consent of
	// Intel Corporation.
	
	  Module Name:
	  
	    GlobalNvs.asi 
	  
	  Abstract:
	  
	    Global NVS table
	  
	--*/
	
	//
	// OS TYPE DEFINITION
	//
	#define WINDOWS_XP          0x01
	#define WINDOWS_XP_SP1      0x02
	#define WINDOWS_XP_SP2      0x04
	#define WINDOWS_2003        0x08
	#define WINDOWS_Vista       0x10
	#define WINDOWS_WIN7        0x11
	#define WINDOWS_WIN8        0x12
	#define LINUX               0xF0
	
	
	    //
	    // Global NVS Memory Block
	    //
	    OperationRegion (MNVS, SystemMemory, 0xFFFF0000, 512)
	    Field (MNVS, ByteAcc, NoLock, Preserve)
	    {
	      OSYS,  32,    // OS type
	      HPEA,  32,    // HPET Enabled
	      SMIF,   8,    // SMI Function Call (ASL to SMI via SWSMI)
	      LCKF,   8,    // Global Lock Function Call (EC Communication)
	
	      ACTT,   8,    // Active Trip Point
	      PSVT,   8,    // Passive Trip Point
	      TC1V,   8,    // Passive Trip Point TC1 Value
	      TC2V,   8,    // Passive Trip Point TC2 Value
	      TSPV,   8,    // Passive Trip Point TSP Value
	      CRTT,   8,    // Critical Trip Point
	      DTSE,   8,    // Digital Thermal Sensor Enable
	      DTS1,   8,    // Digital Thermal Sensor 1 Reading
	      DTS2,   8,    // Digital Thermal Sensor 2 Reading
	      DTSF,   8,    // DTS SMI Function Call
	
	      PPMF,   32,   // PPM Flags
	      APIC,   8,    // APIC Enabled by SBIOS (APIC Enabled = 1)
	      MPEN,   8,    // MP Capable/SBIOS Enabled (MP Enabled != 0)
	
	      ACST,   8,
	      BTST,   8,
	      PWST,   8,
	
	      TPMP,   8,    // TPM Present
	      TPME,   8,    // TPM Enabled
	      RSVD,   8,    // Reserved
	
	      MMOB,  32,    // Low MMIO Base
	      MMOL,  32,    // Low MMIO Limit
	      MMHB,  64,    // High MMIO Base
	      MMHL,  64,    // High MMIO Limit
	      TSGB,  32,    // Tseg base
	      TSSZ,  32,    // Tseg size
	      CSEN,   8,    // C State Enable
	      C6NS,   8,    // C6 No Shrink
	      C6FS,   8,    // C6 Full Shrink
	      IPEN,   8,    // IPMI enable
	      MMB0,  32,    // eMMC BAR0
	      MML0,  32,    // eMMC BAR0 Length
	      MMB1,  32,    // eMMC BAR1
	      MML1,  32,    // eMMC BAR1 Length
	      NCPU,   8,    // NCPU
	      LGCY,   8,    // Legacy/Legacy VGA /UEFI
	      U30C,   8,    // USB 3.0 Port 0 Connectivity flag
	      U30T,   8,    // USB 3.0 Port 0 Connector type
	      U30V,   8,    // USB 3.0 Port visivility
	      U30G,   8,    // USB 3.0 Port group
	      U31C,   8,    // USB 3.0 Port 1 Connectivity flag
	      U31T,   8,    // USB 3.0 Port 1 Connector type
	      U31V,   8,    // USB 3.0 Port visivility
	      U31G,   8,    // USB 3.0 Port group
	      U32C,   8,    // USB 3.0 Port 2 Connectivity flag
	      U32T,   8,    // USB 3.0 Port 2 Connector type
	      U32V,   8,    // USB 3.0 Port visivility
	      U32G,   8,    // USB 3.0 Port group
	      U33C,   8,    // USB 3.0 Port 3 Connectivity flag
	      U33T,   8,    // USB 3.0 Port 3 Connector type
	      U33V,   8,    // USB 3.0 Port visivility
	      U33G,   8,    // USB 3.0 Port group
	      U20C,   8,    // USB 2.0 Port 0 Connectivity flag
	      U20T,   8,    // USB 2.0 Port 0 Connector type
	      U20V,   8,    // USB 2.0 Port visivility
	      U20G,   8,    // USB 2.0 Port group
	      U21C,   8,    // USB 2.0 Port 1 Connectivity flag
	      U21T,   8,    // USB 2.0 Port 1 Connector type
	      U21V,   8,    // USB 2.0 Port visivility
	      U21G,   8,    // USB 2.0 Port group
	      U22C,   8,    // USB 2.0 Port 2 Connectivity flag
	      U22T,   8,    // USB 2.0 Port 2 Connector type
	      U22V,   8,    // USB 2.0 Port visivility
	      U22G,   8,    // USB 2.0 Port group
	      U23C,   8,    // USB 2.0 Port 3 Connectivity flag
	      U23T,   8,    // USB 2.0 Port 3 Connector type
	      U23V,   8,    // USB 2.0 Port visivility
	      U23G,   8,    // USB 2.0 Port group
	      HADR,   8,    // HPET Base address
	      GPST,   8,    // GPIO Status Enable
	      HUS1,   32,   // HSUart status 1
	      HUS2,   32,   // HSUart status 2
	      HUS3,   32,   // HSUart status 3
	      HUS4,   32,   // HSUart status 4
	      CPLS,   32,   // CPLD status
	      BDID,   32,   // Board ID
	    }
	
	
	/**@file
	
	@copyright
	 Copyright (c) 2013 - 2016 Intel Corporation. All rights reserved
	 This software and associated documentation (if any) is furnished
	 under a license and may only be used or copied in accordance
	 with the terms of the license. Except as permitted by the
	 license, no part of this software or documentation may be
	 reproduced, stored in a retrieval system, or transmitted in any
	 form or by any means without the express written consent of
	 Intel Corporation.
	 This file contains an 'Intel Peripheral Driver' and is uniquely
	 identified as "Intel Reference Module" and is licensed for Intel
	 CPUs and chipsets under the terms of your license agreement with
	 Intel or your vendor. This file may be modified by the user, subject
	 to additional terms of the license agreement.
	
	@par Specification Reference:
	**/
	
	  //
	  // Define PCH NVS Area operatino region.
	  //
	  
	  Name (PNVB, 0xFFFF0000)  // PCH NVS Base address
	  Name (PNVL, 0xAA55)      // PCH NVS Length
	
	  OperationRegion(PNVA,SystemMemory,PNVB,PNVL)
	  Field(PNVA,AnyAcc,Lock,Preserve)
	  {
	  Offset(0),      RCRV, 32, // Offset(0),     RC Revision
	  Offset(4),      PCHS, 16, // Offset(4),     PCH Series
	  Offset(6),      PCHG, 16, // Offset(6),     PCH Generation
	  Offset(8),      RPA1, 32, // Offset(8),     Root Port address 1
	  Offset(12),     RPA2, 32, // Offset(12),    Root Port address 2
	  Offset(16),     RPA3, 32, // Offset(16),    Root Port address 3
	  Offset(20),     RPA4, 32, // Offset(20),    Root Port address 4
	  Offset(24),     RPA5, 32, // Offset(24),    Root Port address 5
	  Offset(28),     RPA6, 32, // Offset(28),    Root Port address 6
	  Offset(32),     RPA7, 32, // Offset(32),    Root Port address 7
	  Offset(36),     RPA8, 32, // Offset(36),    Root Port address 8
	  Offset(40),     RPA9, 32, // Offset(40),    Root Port address 9
	  Offset(44),     RPAA, 32, // Offset(44),    Root Port address 10
	  Offset(48),     RPAB, 32, // Offset(48),    Root Port address 11
	  Offset(52),     RPAC, 32, // Offset(52),    Root Port address 12
	  Offset(56),     RPAD, 32, // Offset(56),    Root Port address 13
	  Offset(60),     RPAE, 32, // Offset(60),    Root Port address 14
	  Offset(64),     RPAF, 32, // Offset(64),    Root Port address 15
	  Offset(68),     RPAG, 32, // Offset(68),    Root Port address 16
	  Offset(72),     RPAH, 32, // Offset(72),    Root Port address 17
	  Offset(76),     RPAI, 32, // Offset(76),    Root Port address 18
	  Offset(80),     RPAJ, 32, // Offset(80),    Root Port address 19
	  Offset(84),     RPAK, 32, // Offset(84),    Root Port address 20
	  Offset(88),     NHLA, 32, // Offset(88),    HD-Audio NHLT ACPI address
	  Offset(92),     NHLL, 32, // Offset(92),    HD-Audio NHLT ACPI length
	  Offset(96),     ADFM, 32, // Offset(96),    HD-Audio DSP Feature Mask
	  Offset(100),    SBRG, 32, // Offset(100),   SBREG_BAR
	  Offset(104),    GPEM, 32, // Offset(104),   GPP_X to GPE_DWX mapping
	  Offset(108),    PML1, 16, // Offset(108),   PCIE LTR max snoop Latency 1
	  Offset(110),    PML2, 16, // Offset(110),   PCIE LTR max snoop Latency 2
	  Offset(112),    PML3, 16, // Offset(112),   PCIE LTR max snoop Latency 3
	  Offset(114),    PML4, 16, // Offset(114),   PCIE LTR max snoop Latency 4
	  Offset(116),    PML5, 16, // Offset(116),   PCIE LTR max snoop Latency 5
	  Offset(118),    PML6, 16, // Offset(118),   PCIE LTR max snoop Latency 6
	  Offset(120),    PML7, 16, // Offset(120),   PCIE LTR max snoop Latency 7
	  Offset(122),    PML8, 16, // Offset(122),   PCIE LTR max snoop Latency 8
	  Offset(124),    PML9, 16, // Offset(124),   PCIE LTR max snoop Latency 9
	  Offset(126),    PMLA, 16, // Offset(126),   PCIE LTR max snoop Latency 10
	  Offset(128),    PMLB, 16, // Offset(128),   PCIE LTR max snoop Latency 11
	  Offset(130),    PMLC, 16, // Offset(130),   PCIE LTR max snoop Latency 12
	  Offset(132),    PMLD, 16, // Offset(132),   PCIE LTR max snoop Latency 13
	  Offset(134),    PMLE, 16, // Offset(134),   PCIE LTR max snoop Latency 14
	  Offset(136),    PMLF, 16, // Offset(136),   PCIE LTR max snoop Latency 15
	  Offset(138),    PMLG, 16, // Offset(138),   PCIE LTR max snoop Latency 16
	  Offset(140),    PMLH, 16, // Offset(140),   PCIE LTR max snoop Latency 17
	  Offset(142),    PMLI, 16, // Offset(142),   PCIE LTR max snoop Latency 18
	  Offset(144),    PMLJ, 16, // Offset(144),   PCIE LTR max snoop Latency 19
	  Offset(146),    PMLK, 16, // Offset(146),   PCIE LTR max snoop Latency 20
	  Offset(148),    PNL1, 16, // Offset(148),   PCIE LTR max no snoop Latency 1
	  Offset(150),    PNL2, 16, // Offset(150),   PCIE LTR max no snoop Latency 2
	  Offset(152),    PNL3, 16, // Offset(152),   PCIE LTR max no snoop Latency 3
	  Offset(154),    PNL4, 16, // Offset(154),   PCIE LTR max no snoop Latency 4
	  Offset(156),    PNL5, 16, // Offset(156),   PCIE LTR max no snoop Latency 5
	  Offset(158),    PNL6, 16, // Offset(158),   PCIE LTR max no snoop Latency 6
	  Offset(160),    PNL7, 16, // Offset(160),   PCIE LTR max no snoop Latency 7
	  Offset(162),    PNL8, 16, // Offset(162),   PCIE LTR max no snoop Latency 8
	  Offset(164),    PNL9, 16, // Offset(164),   PCIE LTR max no snoop Latency 9
	  Offset(166),    PNLA, 16, // Offset(166),   PCIE LTR max no snoop Latency 10
	  Offset(168),    PNLB, 16, // Offset(168),   PCIE LTR max no snoop Latency 11
	  Offset(170),    PNLC, 16, // Offset(170),   PCIE LTR max no snoop Latency 12
	  Offset(172),    PNLD, 16, // Offset(172),   PCIE LTR max no snoop Latency 13
	  Offset(174),    PNLE, 16, // Offset(174),   PCIE LTR max no snoop Latency 14
	  Offset(176),    PNLF, 16, // Offset(176),   PCIE LTR max no snoop Latency 15
	  Offset(178),    PNLG, 16, // Offset(178),   PCIE LTR max no snoop Latency 16
	  Offset(180),    PNLH, 16, // Offset(180),   PCIE LTR max no snoop Latency 17
	  Offset(182),    PNLI, 16, // Offset(182),   PCIE LTR max no snoop Latency 18
	  Offset(184),    PNLJ, 16, // Offset(184),   PCIE LTR max no snoop Latency 19
	  Offset(186),    PNLK, 16, // Offset(186),   PCIE LTR max no snoop Latency 20
	  Offset(188),    U0C0, 32, // Offset(188),   SerialIo Hidden UART0 BAR 0
	  Offset(192),    U1C0, 32, // Offset(192),   SerialIo Hidden UART1 BAR 0
	  Offset(196),    ADPM, 32, // Offset(196),   HD-Audio DSP Post-Processing Module Mask
	  Offset(200),    XHPC, 8,  // Offset(200),   Number of HighSpeed ports implemented in XHCI controller
	  Offset(201),    XRPC, 8,  // Offset(201),   Number of USBR ports implemented in XHCI controller
	  Offset(202),    XSPC, 8,  // Offset(202),   Number of SuperSpeed ports implemented in XHCI controller
	  Offset(203),    XSPA, 8,  // Offset(203),   Address of 1st SuperSpeed port
	  Offset(204),    HPTB, 32, // Offset(204),   HPET base address
	  Offset(208),    HPTE, 8,  // Offset(208),   HPET enable
	  //110-bytes large SerialIo block
	  Offset(209),    SMD0, 8,  // Offset(209),   SerialIo controller 0 (sdma) mode (0: disabled, 1: pci, 2: acpi, 3: debug port)
	  Offset(210),    SMD1, 8,  // Offset(210),   SerialIo controller 1 (i2c0) mode (0: disabled, 1: pci, 2: acpi, 3: debug port)
	  Offset(211),    SMD2, 8,  // Offset(211),   SerialIo controller 2 (i2c1) mode (0: disabled, 1: pci, 2: acpi, 3: debug port)
	  Offset(212),    SMD3, 8,  // Offset(212),   SerialIo controller 3 (spi0) mode (0: disabled, 1: pci, 2: acpi, 3: debug port)
	  Offset(213),    SMD4, 8,  // Offset(213),   SerialIo controller 4 (spi1) mode (0: disabled, 1: pci, 2: acpi, 3: debug port)
	  Offset(214),    SMD5, 8,  // Offset(214),   SerialIo controller 5 (ua00) mode (0: disabled, 1: pci, 2: acpi, 3: debug port)
	  Offset(215),    SMD6, 8,  // Offset(215),   SerialIo controller 6 (ua01) mode (0: disabled, 1: pci, 2: acpi, 3: debug port)
	  Offset(216),    SMD7, 8,  // Offset(216),   SerialIo controller 7 (shdc) mode (0: disabled, 1: pci, 2: acpi, 3: debug port)
	  Offset(217),    SMD8, 8,  // Offset(217),   SerialIo controller 8 (shdc) mode (0: disabled, 1: pci, 2: acpi, 3: debug port)
	  Offset(218),    SMD9, 8,  // Offset(218),   SerialIo controller 9 (shdc) mode (0: disabled, 1: pci, 2: acpi, 3: debug port)
	  Offset(219),    SMDA, 8,  // Offset(219),   SerialIo controller A (shdc) mode (0: disabled, 1: pci, 2: acpi, 3: debug port)
	  Offset(220),    SIR0, 8,  // Offset(220),   SerialIo controller 0 (sdma) irq number
	  Offset(221),    SIR1, 8,  // Offset(221),   SerialIo controller 1 (i2c0) irq number
	  Offset(222),    SIR2, 8,  // Offset(222),   SerialIo controller 2 (i2c1) irq number
	  Offset(223),    SIR3, 8,  // Offset(223),   SerialIo controller 3 (spi0) irq number
	  Offset(224),    SIR4, 8,  // Offset(224),   SerialIo controller 4 (spi1) irq number
	  Offset(225),    SIR5, 8,  // Offset(225),   SerialIo controller 5 (ua00) irq number
	  Offset(226),    SIR6, 8,  // Offset(226),   SerialIo controller 6 (ua01) irq number
	  Offset(227),    SIR7, 8,  // Offset(227),   SerialIo controller 7 (shdc) irq number
	  Offset(228),    SIR8, 8,  // Offset(228),   SerialIo controller 8 (shdc) irq number
	  Offset(229),    SIR9, 8,  // Offset(229),   SerialIo controller 9 (shdc) irq number
	  Offset(230),    SIRA, 8,  // Offset(230),   SerialIo controller A (shdc) irq number
	  Offset(231),    SB00, 32, // Offset(231),   SerialIo controller 0 (sdma) BAR0
	  Offset(235),    SB01, 32, // Offset(235),   SerialIo controller 1 (i2c0) BAR0
	  Offset(239),    SB02, 32, // Offset(239),   SerialIo controller 2 (i2c1) BAR0
	  Offset(243),    SB03, 32, // Offset(243),   SerialIo controller 3 (spi0) BAR0
	  Offset(247),    SB04, 32, // Offset(247),   SerialIo controller 4 (spi1) BAR0
	  Offset(251),    SB05, 32, // Offset(251),   SerialIo controller 5 (ua00) BAR0
	  Offset(255),    SB06, 32, // Offset(255),   SerialIo controller 6 (ua01) BAR0
	  Offset(259),    SB07, 32, // Offset(259),   SerialIo controller 7 (shdc) BAR0
	  Offset(263),    SB08, 32, // Offset(263),   SerialIo controller 8 (shdc) BAR0
	  Offset(267),    SB09, 32, // Offset(267),   SerialIo controller 9 (shdc) BAR0
	  Offset(271),    SB0A, 32, // Offset(271),   SerialIo controller A (shdc) BAR0
	  Offset(275),    SB10, 32, // Offset(275),   SerialIo controller 0 (sdma) BAR1
	  Offset(279),    SB11, 32, // Offset(279),   SerialIo controller 1 (i2c0) BAR1
	  Offset(283),    SB12, 32, // Offset(283),   SerialIo controller 2 (i2c1) BAR1
	  Offset(287),    SB13, 32, // Offset(287),   SerialIo controller 3 (spi0) BAR1
	  Offset(291),    SB14, 32, // Offset(291),   SerialIo controller 4 (spi1) BAR1
	  Offset(295),    SB15, 32, // Offset(295),   SerialIo controller 5 (ua00) BAR1
	  Offset(299),    SB16, 32, // Offset(299),   SerialIo controller 6 (ua01) BAR1
	  Offset(303),    SB17, 32, // Offset(303),   SerialIo controller 7 (shdc) BAR1
	  Offset(307),    SB18, 32, // Offset(307),   SerialIo controller 8 (shdc) BAR1
	  Offset(311),    SB19, 32, // Offset(311),   SerialIo controller 9 (shdc) BAR1
	  Offset(315),    SB1A, 32, // Offset(315),   SerialIo controller A (shdc) BAR1
	  //end of SerialIo block
	  Offset(319),    GPEN, 8,  // Offset(319),   GPIO enabled
	  Offset(320),    SGIR, 8,  // Offset(320),   GPIO IRQ
	  Offset(321),    NIT1, 8,  // Offset(321),   RST PCIe Storage Cycle Router#1 Interface Type
	  Offset(322),    NIT2, 8,  // Offset(322),   RST PCIe Storage Cycle Router#2 Interface Type
	  Offset(323),    NIT3, 8,  // Offset(323),   RST PCIe Storage Cycle Router#3 Interface Type
	  Offset(324),    NPM1, 8,  // Offset(324),   RST PCIe Storage Cycle Router#1 Power Management Capability Pointer
	  Offset(325),    NPM2, 8,  // Offset(325),   RST PCIe Storage Cycle Router#2 Power Management Capability Pointer
	  Offset(326),    NPM3, 8,  // Offset(326),   RST PCIe Storage Cycle Router#3 Power Management Capability Pointer
	  Offset(327),    NPC1, 8,  // Offset(327),   RST PCIe Storage Cycle Router#1 PCIe Capabilities Pointer
	  Offset(328),    NPC2, 8,  // Offset(328),   RST PCIe Storage Cycle Router#2 PCIe Capabilities Pointer
	  Offset(329),    NPC3, 8,  // Offset(329),   RST PCIe Storage Cycle Router#3 PCIe Capabilities Pointer
	  Offset(330),    NL11, 16, // Offset(330),   RST PCIe Storage Cycle Router#1 L1SS Capability Pointer
	  Offset(332),    NL12, 16, // Offset(332),   RST PCIe Storage Cycle Router#2 L1SS Capability Pointer
	  Offset(334),    NL13, 16, // Offset(334),   RST PCIe Storage Cycle Router#3 L1SS Capability Pointer
	  Offset(336),    ND21, 8,  // Offset(336),   RST PCIe Storage Cycle Router#1 Endpoint L1SS Control Data2
	  Offset(337),    ND22, 8,  // Offset(337),   RST PCIe Storage Cycle Router#2 Endpoint L1SS Control Data2
	  Offset(338),    ND23, 8,  // Offset(338),   RST PCIe Storage Cycle Router#3 Endpoint L1SS Control Data2
	  Offset(339),    ND11, 32, // Offset(339),   RST PCIe Storage Cycle Router#1 Endpoint L1SS Control Data1
	  Offset(343),    ND12, 32, // Offset(343),   RST PCIe Storage Cycle Router#2 Endpoint L1SS Control Data1
	  Offset(347),    ND13, 32, // Offset(347),   RST PCIe Storage Cycle Router#3 Endpoint L1SS Control Data1
	  Offset(351),    NLR1, 16, // Offset(351),   RST PCIe Storage Cycle Router#1 LTR Capability Pointer
	  Offset(353),    NLR2, 16, // Offset(353),   RST PCIe Storage Cycle Router#2 LTR Capability Pointer
	  Offset(355),    NLR3, 16, // Offset(355),   RST PCIe Storage Cycle Router#3 LTR Capability Pointer
	  Offset(357),    NLD1, 32, // Offset(357),   RST PCIe Storage Cycle Router#1 Endpoint LTR Data
	  Offset(361),    NLD2, 32, // Offset(361),   RST PCIe Storage Cycle Router#2 Endpoint LTR Data
	  Offset(365),    NLD3, 32, // Offset(365),   RST PCIe Storage Cycle Router#3 Endpoint LTR Data
	  Offset(369),    NEA1, 16, // Offset(369),   RST PCIe Storage Cycle Router#1 Endpoint LCTL Data
	  Offset(371),    NEA2, 16, // Offset(371),   RST PCIe Storage Cycle Router#2 Endpoint LCTL Data
	  Offset(373),    NEA3, 16, // Offset(373),   RST PCIe Storage Cycle Router#3 Endpoint LCTL Data
	  Offset(375),    NEB1, 16, // Offset(375),   RST PCIe Storage Cycle Router#1 Endpoint DCTL Data
	  Offset(377),    NEB2, 16, // Offset(377),   RST PCIe Storage Cycle Router#2 Endpoint DCTL Data
	  Offset(379),    NEB3, 16, // Offset(379),   RST PCIe Storage Cycle Router#3 Endpoint DCTL Data
	  Offset(381),    NEC1, 16, // Offset(381),   RST PCIe Storage Cycle Router#1 Endpoint DCTL2 Data
	  Offset(383),    NEC2, 16, // Offset(383),   RST PCIe Storage Cycle Router#2 Endpoint DCTL2 Data
	  Offset(385),    NEC3, 16, // Offset(385),   RST PCIe Storage Cycle Router#3 Endpoint DCTL2 Data
	  Offset(387),    NRA1, 16, // Offset(387),   RST PCIe Storage Cycle Router#1 RootPort DCTL2 Data
	  Offset(389),    NRA2, 16, // Offset(389),   RST PCIe Storage Cycle Router#2 RootPort DCTL2 Data
	  Offset(391),    NRA3, 16, // Offset(391),   RST PCIe Storage Cycle Router#3 RootPort DCTL2 Data
	  Offset(393),    NMB1, 32, // Offset(393),   RST PCIe Storage Cycle Router#1 Endpoint unique MSI-X Table BAR
	  Offset(397),    NMB2, 32, // Offset(397),   RST PCIe Storage Cycle Router#2 Endpoint unique MSI-X Table BAR
	  Offset(401),    NMB3, 32, // Offset(401),   RST PCIe Storage Cycle Router#3 Endpoint unique MSI-X Table BAR
	  Offset(405),    NMV1, 32, // Offset(405),   RST PCIe Storage Cycle Router#1 Endpoint unique MSI-X Table BAR value
	  Offset(409),    NMV2, 32, // Offset(409),   RST PCIe Storage Cycle Router#2 Endpoint unique MSI-X Table BAR value
	  Offset(413),    NMV3, 32, // Offset(413),   RST PCIe Storage Cycle Router#3 Endpoint unique MSI-X Table BAR value
	  Offset(417),    NPB1, 32, // Offset(417),   RST PCIe Storage Cycle Router#1 Endpoint unique MSI-X PBA BAR
	  Offset(421),    NPB2, 32, // Offset(421),   RST PCIe Storage Cycle Router#2 Endpoint unique MSI-X PBA BAR
	  Offset(425),    NPB3, 32, // Offset(425),   RST PCIe Storage Cycle Router#3 Endpoint unique MSI-X PBA BAR
	  Offset(429),    NPV1, 32, // Offset(429),   RST PCIe Storage Cycle Router#1 Endpoint unique MSI-X PBA BAR value
	  Offset(433),    NPV2, 32, // Offset(433),   RST PCIe Storage Cycle Router#2 Endpoint unique MSI-X PBA BAR value
	  Offset(437),    NPV3, 32, // Offset(437),   RST PCIe Storage Cycle Router#3 Endpoint unique MSI-X PBA BAR value
	  Offset(441),    SDME, 8,  // Offset(441),   SCS SDIO Controller Mode (0: disabled, 1: pci, 2: acpi)
	  Offset(442),    SDIR, 8,  // Offset(442),   SCS SDIO Controller interrupt number
	  Offset(443),    SDB0, 32, // Offset(443),   SCS SDIO controller BAR0
	  Offset(447),    SDB1, 32, // Offset(447),   SCS SDIO controller BAR1
	  Offset(451),        , 8,  // Offset(451),   Flag indicating Exit Boot Service, to inform SMM
	  Offset(452),    SXRB, 32, // Offset(452),   Sx handler reserved MMIO base
	  Offset(456),    SXRS, 32, // Offset(456),   Sx handler reserved MMIO size
	  Offset(460),    CIOE, 8,  // Offset(460),   Cio2 Device Enabled as ACPI device
	  Offset(461),    CIOI, 8,  // Offset(461),   Cio2 Interrupt Number
	  Offset(462),    TAEN, 8,  // Offset(462),   Thermal Device Acpi mode enabled
	  Offset(463),    TIRQ, 8,  // Offset(463),   Thermal Device IRQ number
	  Offset(464),    XWMB, 64, // Offset(464),   XHCI reserved base addresss
	       
	  }

	
	    //
	    //  Processor Objects
	    //
	    Scope(\_PR)
	    {
	          Processor (CPU0, 0x01, 0x1810, 0x06) {
	              Method (_STA, 0)
	              {
	                Return (0x0F)
	              }
	          }
	
	          Processor (CPU1, 0x02, 0x1810, 0x06) {
	              Method (_STA, 0)
	              {
	                if (LGreater (NCPU, 0x01))
	                {
	                  Return (0x0F)
	                }
	                Return (0x0)
	              }
	          }
	
	          Processor (CPU2, 0x03, 0x1810, 0x06) {
	              Method (_STA, 0)
	              {
	                if (LGreater (NCPU, 0x02))
	                {
	                  Return (0x0F)
	                }
	                Return (0x0)
	              }
	          }
	
	          Processor (CPU3, 0x04, 0x1810, 0x06) {
	              Method (_STA, 0)
	              {
	                if (LGreater (NCPU, 0x03))
	                {
	                  Return (0x0F)
	                }
	                Return (0x0)
	              }
	          }
	
	          Processor (CPU4, 0x05, 0x1810, 0x06) {
	              Method (_STA, 0)
	              {
	                if (LGreater (NCPU, 0x04))
	                {
	                  Return (0x0F)
	                }
	                Return (0x0)
	              }
	          }
	
	          Processor (CPU5, 0x06, 0x1810, 0x06) {
	              Method (_STA, 0)
	              {
	                if (LGreater (NCPU, 0x05))
	                {
	                  Return (0x0F)
	                }
	                Return (0x0)
	              }
	          }
	
	          Processor (CPU6, 0x07, 0x1810, 0x06) {
	              Method (_STA, 0)
	              {
	                if (LGreater (NCPU, 0x06))
	                {
	                  Return (0x0F)
	                }
	                Return (0x0)
	              }
	          }
	
	          Processor (CPU7, 0x08, 0x1810, 0x06) {
	              Method (_STA, 0)
	              {
	                if (LGreater (NCPU, 0x07))
	                {
	                  Return (0x0F)
	                }
	                Return (0x0)
	              }
	          }
	
	          Processor (CPU8, 0x09, 0x1810, 0x06) {
	             Method (_STA, 0)
	              {
	                if (LGreater (NCPU, 0x08))
	                {
	                  Return (0x0F)
	                }
	                Return (0x0)
	              }
	          }
	
	          Processor (CPU9, 0x0A, 0x1810, 0x06) {
	              Method (_STA, 0)
	              {
	                if (LGreater (NCPU, 0x09))
	                {
	                  Return (0x0F)
	                }
	                Return (0x0)
	              }
	          }
	
	          Processor (CPUA, 0x0B, 0x1810, 0x06) {
	              Method (_STA, 0)
	              {
	                if (LGreater (NCPU, 0x0A))
	                {
	                  Return (0x0F)
	                }
	                Return (0x0)
	              }
	          }
	
	          Processor (CPUB, 0x0C, 0x1810, 0x06) {
	              Method (_STA, 0)
	              {
	                if (LGreater (NCPU, 0x0B))
	                {
	                  Return (0x0F)
	                }
	                Return (0x0)
	              }
	          }
	
	          Processor (CPUC, 0x0D, 0x1810, 0x06) {
	              Method (_STA, 0)
	              {
	                if (LGreater (NCPU, 0x0C))
	                {
	                  Return (0x0F)
	                }
	                Return (0x0)
	              }
	          }
	
	          Processor (CPUD, 0x0E, 0x1810, 0x06) {
	              Method (_STA, 0)
	              {
	                if (LGreater (NCPU, 0x0D))
	                {
	                  Return (0x0F)
	                }
	                Return (0x0)
	              }
	          }
	
	          Processor (CPUE, 0x0F, 0x1810, 0x06) {
	              Method (_STA, 0)
	              {
	                if (LGreater (NCPU, 0x0E))
	                {
	                  Return (0x0F)
	                }
	                Return (0x0)
	              }
	          }
	
	          Processor (CPUF, 0x10, 0x1810, 0x06) {
	              Method (_STA, 0)
	              {
	                if (LGreater (NCPU, 0x0F))
	                {
	                  Return (0x0F)
	                }
	                Return (0x0)
	              }
	          }
	    }



	
	//-------- DO NOT EDIT THIS FILE --------
	//
	// FILE WAS GENERATED AUTOMATICALY USING AMISDL v7.04.0274 (四月 26 2023,16:58:30)
	//
	//-------- DO NOT EDIT THIS FILE --------
	//****************************************************************************
	//****************************************************************************
	//**                                                                        **
	//**         (C)Copyright 1985 - 2023, American Megatrends, Inc.            **
	//**                                                                        **
	//**                          All Rights Reserved.                          **
	//**                                                                        **
	//**                    5555 Oakbrook Pkwy, Norcross, GA 30092              **
	//**                                                                        **
	//**                          Phone (770)-246-8600                          **
	//**                                                                        **
	//****************************************************************************
	//****************************************************************************
	//---------------------------------------------------------------------------
	// Begin System IRQ Routing Packages
	//---------------------------------------------------------------------------
	Scope(\_SB) {
	
	//---------------------------------------------------------------------------
	// List of IRQ resource buffers compatible with _PRS return format.
	//---------------------------------------------------------------------------
	// Naming legend:
	// RSxy, PRSy - name of the IRQ resource buffer to be returned by _PRS, "xy" - last two characters of IRQ Link name.
	// Note. PRSy name is generated if IRQ Link name starts from "LNK".
	// HLxy , LLxy - reference names, can be used to access bit mask of available IRQs. HL and LL stand for active High(Low) Level triggered Irq model.
	//---------------------------------------------------------------------------
		Name(RSKA, ResourceTemplate(){	// Link name: \_SB.PCI0.LPC0.LNKA
			IRQ(Level, ActiveLow, Shared, LLKA) {6,10,11,12,14,15}
		})
		Alias(RSKA,RSKB)	// Link name: \_SB.PCI0.LPC0.LNKB
		Alias(RSKA,RSKC)	// Link name: \_SB.PCI0.LPC0.LNKC
		Alias(RSKA,RSKD)	// Link name: \_SB.PCI0.LPC0.LNKD
		Alias(RSKA,RSKE)	// Link name: \_SB.PCI0.LPC0.LNKE
		Alias(RSKA,RSKF)	// Link name: \_SB.PCI0.LPC0.LNKF
		Alias(RSKA,RSKG)	// Link name: \_SB.PCI0.LPC0.LNKG
		Alias(RSKA,RSKH)	// Link name: \_SB.PCI0.LPC0.LNKH
	
		Name(PD00, Package(){
	// LpcBridge
	// PCI Express Port 0
			Package(){0x0009FFFF, 0, \_SB.PCI0.LPC0.LNKA, 0 },
	// PCI Express Port 1
			Package(){0x000AFFFF, 1, \_SB.PCI0.LPC0.LNKB, 0 },
	// PCI Express Port 2
			Package(){0x000BFFFF, 2, \_SB.PCI0.LPC0.LNKC, 0 },
	// PCI Express Port 3
			Package(){0x000CFFFF, 3, \_SB.PCI0.LPC0.LNKD, 0 },
	// PCI Express Port 4
			Package(){0x000EFFFF, 0, \_SB.PCI0.LPC0.LNKE, 0 },
	// PCI Express Port 5
			Package(){0x000FFFFF, 1, \_SB.PCI0.LPC0.LNKF, 0 },
	// PCI Express Port 6
			Package(){0x0010FFFF, 2, \_SB.PCI0.LPC0.LNKG, 0 },
	// PCI Express Port 7
			Package(){0x0011FFFF, 3, \_SB.PCI0.LPC0.LNKH, 0 },
	// SMBus Controller 1
			Package(){0x0012FFFF, 0, \_SB.PCI0.LPC0.LNKA, 0 },
	// SATA controller 0
			Package(){0x0013FFFF, 0, \_SB.PCI0.LPC0.LNKE, 0 },
	// SATA controller 1
			Package(){0x0014FFFF, 0, \_SB.PCI0.LPC0.LNKF, 0 },
	// XHCI USB controller
			Package(){0x0015FFFF, 0, \_SB.PCI0.LPC0.LNKD, 0 },
	// UART 0
			Package(){0x001AFFFF, 0, \_SB.PCI0.LPC0.LNKA, 0 },
	// UART 1
			Package(){0x001AFFFF, 1, \_SB.PCI0.LPC0.LNKB, 0 },
	// UART 2
			Package(){0x001AFFFF, 2, \_SB.PCI0.LPC0.LNKC, 0 },
	// IE HECI1
			Package(){0x001BFFFF, 0, \_SB.PCI0.LPC0.LNKA, 0 },
	// IE HECI2
			Package(){0x001BFFFF, 1, \_SB.PCI0.LPC0.LNKB, 0 },
	// IE - Keyboard and Text (KT)
			Package(){0x001BFFFF, 2, \_SB.PCI0.LPC0.LNKC, 0 },
	// IE HECI3
			Package(){0x001BFFFF, 3, \_SB.PCI0.LPC0.LNKD, 0 },
	// Global Register
			Package(){0x0004FFFF, 0, \_SB.PCI0.LPC0.LNKA, 0 },
	// RCEC
			Package(){0x0005FFFF, 0, \_SB.PCI0.LPC0.LNKH, 0 },
	// Virtual root port 2
			Package(){0x0006FFFF, 0, \_SB.PCI0.LPC0.LNKA, 0 },
	// Virtual root port 0
			Package(){0x0016FFFF, 0, \_SB.PCI0.LPC0.LNKA, 0 },
	// Virtual root port 1
			Package(){0x0017FFFF, 0, \_SB.PCI0.LPC0.LNKA, 0 },
	// ME HECI
			Package(){0x0018FFFF, 0, \_SB.PCI0.LPC0.LNKA, 0 },
	// ME HECI2
			Package(){0x0018FFFF, 1, \_SB.PCI0.LPC0.LNKB, 0 },
	// MEKT on PCH
			Package(){0x0018FFFF, 2, \_SB.PCI0.LPC0.LNKC, 0 },
	// ME HECI3
			Package(){0x0018FFFF, 3, \_SB.PCI0.LPC0.LNKD, 0 },
	// eMMC
			Package(){0x001CFFFF, 0, \_SB.PCI0.LPC0.LNKA, 0 },
	// Primary to Sideband Bridge
	// Power Management Controller
	// Legacy SMBUS Controller
			Package(){0x001FFFFF, 0, \_SB.PCI0.LPC0.LNKH, 0 },
	// SPI controller
	// Northpeak DFX
		})
		Name(AR00, Package(){
	// LpcBridge
	// PCI Express Port 0
			Package(){0x0009FFFF, 0, 0, 16 },
	// PCI Express Port 1
			Package(){0x000AFFFF, 1, 0, 17 },
	// PCI Express Port 2
			Package(){0x000BFFFF, 2, 0, 18 },
	// PCI Express Port 3
			Package(){0x000CFFFF, 3, 0, 19 },
	// PCI Express Port 4
			Package(){0x000EFFFF, 0, 0, 20 },
	// PCI Express Port 5
			Package(){0x000FFFFF, 1, 0, 21 },
	// PCI Express Port 6
			Package(){0x0010FFFF, 2, 0, 22 },
	// PCI Express Port 7
			Package(){0x0011FFFF, 3, 0, 23 },
	// SMBus Controller 1
			Package(){0x0012FFFF, 0, 0, 16 },
	// SATA controller 0
			Package(){0x0013FFFF, 0, 0, 20 },
	// SATA controller 1
			Package(){0x0014FFFF, 0, 0, 21 },
	// XHCI USB controller
			Package(){0x0015FFFF, 0, 0, 19 },
	// UART 0
			Package(){0x001AFFFF, 0, 0, 16 },
	// UART 1
			Package(){0x001AFFFF, 1, 0, 17 },
	// UART 2
			Package(){0x001AFFFF, 2, 0, 18 },
	// IE HECI1
			Package(){0x001BFFFF, 0, 0, 16 },
	// IE HECI2
			Package(){0x001BFFFF, 1, 0, 17 },
	// IE - Keyboard and Text (KT)
			Package(){0x001BFFFF, 2, 0, 18 },
	// IE HECI3
			Package(){0x001BFFFF, 3, 0, 19 },
	// Global Register
			Package(){0x0004FFFF, 0, 0, 16 },
	// RCEC
			Package(){0x0005FFFF, 0, 0, 23 },
	// Virtual root port 2
			Package(){0x0006FFFF, 0, 0, 16 },
	// Virtual root port 0
			Package(){0x0016FFFF, 0, 0, 16 },
	// Virtual root port 1
			Package(){0x0017FFFF, 0, 0, 16 },
	// ME HECI
			Package(){0x0018FFFF, 0, 0, 16 },
	// ME HECI2
			Package(){0x0018FFFF, 1, 0, 17 },
	// MEKT on PCH
			Package(){0x0018FFFF, 2, 0, 18 },
	// ME HECI3
			Package(){0x0018FFFF, 3, 0, 19 },
	// eMMC
			Package(){0x001CFFFF, 0, 0, 16 },
	// Primary to Sideband Bridge
	// Power Management Controller
	// Legacy SMBUS Controller
			Package(){0x001FFFFF, 0, 0, 23 },
	// SPI controller
	// Northpeak DFX
		})
		Name(PG03, Package(){
	// PCI Express Slot 0
			Package(){0x0000FFFF, 0, \_SB.PCI0.LPC0.LNKA, 0 },
			Package(){0x0000FFFF, 1, \_SB.PCI0.LPC0.LNKB, 0 },
			Package(){0x0000FFFF, 2, \_SB.PCI0.LPC0.LNKC, 0 },
			Package(){0x0000FFFF, 3, \_SB.PCI0.LPC0.LNKD, 0 },
		})
		Name(AG03, Package(){
	// PCI Express Slot 0
			Package(){0x0000FFFF, 0, 0, 16 },
			Package(){0x0000FFFF, 1, 0, 17 },
			Package(){0x0000FFFF, 2, 0, 18 },
			Package(){0x0000FFFF, 3, 0, 19 },
		})
		Name(PG04, Package(){
	// PCI Express Slot 1
			Package(){0x0000FFFF, 0, \_SB.PCI0.LPC0.LNKB, 0 },
			Package(){0x0000FFFF, 1, \_SB.PCI0.LPC0.LNKC, 0 },
			Package(){0x0000FFFF, 2, \_SB.PCI0.LPC0.LNKD, 0 },
			Package(){0x0000FFFF, 3, \_SB.PCI0.LPC0.LNKA, 0 },
		})
		Name(AG04, Package(){
	// PCI Express Slot 1
			Package(){0x0000FFFF, 0, 0, 17 },
			Package(){0x0000FFFF, 1, 0, 18 },
			Package(){0x0000FFFF, 2, 0, 19 },
			Package(){0x0000FFFF, 3, 0, 16 },
		})
		Name(PG06, Package(){
	// PCI Express Slot 2
			Package(){0x0000FFFF, 0, \_SB.PCI0.LPC0.LNKC, 0 },
			Package(){0x0000FFFF, 1, \_SB.PCI0.LPC0.LNKD, 0 },
			Package(){0x0000FFFF, 2, \_SB.PCI0.LPC0.LNKA, 0 },
			Package(){0x0000FFFF, 3, \_SB.PCI0.LPC0.LNKB, 0 },
		})
		Name(AG06, Package(){
	// PCI Express Slot 2
			Package(){0x0000FFFF, 0, 0, 18 },
			Package(){0x0000FFFF, 1, 0, 19 },
			Package(){0x0000FFFF, 2, 0, 16 },
			Package(){0x0000FFFF, 3, 0, 17 },
		})
		Name(PG08, Package(){
	// PCI Express Slot 3
			Package(){0x0000FFFF, 0, \_SB.PCI0.LPC0.LNKD, 0 },
			Package(){0x0000FFFF, 1, \_SB.PCI0.LPC0.LNKA, 0 },
			Package(){0x0000FFFF, 2, \_SB.PCI0.LPC0.LNKB, 0 },
			Package(){0x0000FFFF, 3, \_SB.PCI0.LPC0.LNKC, 0 },
		})
		Name(AG08, Package(){
	// PCI Express Slot 3
			Package(){0x0000FFFF, 0, 0, 19 },
			Package(){0x0000FFFF, 1, 0, 16 },
			Package(){0x0000FFFF, 2, 0, 17 },
			Package(){0x0000FFFF, 3, 0, 18 },
		})
		Name(PG0A, Package(){
	// PCI Express Slot 4
			Package(){0x0000FFFF, 0, \_SB.PCI0.LPC0.LNKE, 0 },
			Package(){0x0000FFFF, 1, \_SB.PCI0.LPC0.LNKF, 0 },
			Package(){0x0000FFFF, 2, \_SB.PCI0.LPC0.LNKG, 0 },
			Package(){0x0000FFFF, 3, \_SB.PCI0.LPC0.LNKH, 0 },
		})
		Name(AG0A, Package(){
	// PCI Express Slot 4
			Package(){0x0000FFFF, 0, 0, 20 },
			Package(){0x0000FFFF, 1, 0, 21 },
			Package(){0x0000FFFF, 2, 0, 22 },
			Package(){0x0000FFFF, 3, 0, 23 },
		})
		Name(PG0C, Package(){
	// PCI Express Slot 5
			Package(){0x0000FFFF, 0, \_SB.PCI0.LPC0.LNKF, 0 },
			Package(){0x0000FFFF, 1, \_SB.PCI0.LPC0.LNKG, 0 },
			Package(){0x0000FFFF, 2, \_SB.PCI0.LPC0.LNKH, 0 },
			Package(){0x0000FFFF, 3, \_SB.PCI0.LPC0.LNKE, 0 },
		})
		Name(AG0C, Package(){
	// PCI Express Slot 5
			Package(){0x0000FFFF, 0, 0, 21 },
			Package(){0x0000FFFF, 1, 0, 22 },
			Package(){0x0000FFFF, 2, 0, 23 },
			Package(){0x0000FFFF, 3, 0, 20 },
		})
		Name(PG0E, Package(){
	// PCI Express Slot 6
			Package(){0x0000FFFF, 0, \_SB.PCI0.LPC0.LNKG, 0 },
			Package(){0x0000FFFF, 1, \_SB.PCI0.LPC0.LNKH, 0 },
			Package(){0x0000FFFF, 2, \_SB.PCI0.LPC0.LNKE, 0 },
			Package(){0x0000FFFF, 3, \_SB.PCI0.LPC0.LNKF, 0 },
		})
		Name(AG0E, Package(){
	// PCI Express Slot 6
			Package(){0x0000FFFF, 0, 0, 22 },
			Package(){0x0000FFFF, 1, 0, 23 },
			Package(){0x0000FFFF, 2, 0, 20 },
			Package(){0x0000FFFF, 3, 0, 21 },
		})
		Name(PG10, Package(){
	// PCI Express Slot 7
			Package(){0x0000FFFF, 0, \_SB.PCI0.LPC0.LNKH, 0 },
			Package(){0x0000FFFF, 1, \_SB.PCI0.LPC0.LNKE, 0 },
			Package(){0x0000FFFF, 2, \_SB.PCI0.LPC0.LNKF, 0 },
			Package(){0x0000FFFF, 3, \_SB.PCI0.LPC0.LNKG, 0 },
		})
		Name(AG10, Package(){
	// PCI Express Slot 7
			Package(){0x0000FFFF, 0, 0, 23 },
			Package(){0x0000FFFF, 1, 0, 20 },
			Package(){0x0000FFFF, 2, 0, 21 },
			Package(){0x0000FFFF, 3, 0, 22 },
		})
		Name(PG1F, Package(){
	// Intel QuickAssist Technology
			Package(){0x0000FFFF, 0, \_SB.PCI0.LPC0.LNKA, 0 },
		})
		Name(AG1F, Package(){
	// Intel QuickAssist Technology
			Package(){0x0000FFFF, 0, 0, 16 },
		})
		Name(PG21, Package(){
	// NIC 0
			Package(){0x0000FFFF, 0, \_SB.PCI0.LPC0.LNKA, 0 },
	// NIC 1
			Package(){0x0000FFFF, 1, \_SB.PCI0.LPC0.LNKB, 0 },
	// PXE Option ROM 1
			Package(){0x0000FFFF, 2, \_SB.PCI0.LPC0.LNKD, 0 },
			Package(){0x0000FFFF, 3, \_SB.PCI0.LPC0.LNKA, 0 },
		})
		Name(AG21, Package(){
	// NIC 0
			Package(){0x0000FFFF, 0, 0, 16 },
	// NIC 1
			Package(){0x0000FFFF, 1, 0, 17 },
	// PXE Option ROM 1
			Package(){0x0000FFFF, 2, 0, 19 },
			Package(){0x0000FFFF, 3, 0, 16 },
		})
		Name(PG22, Package(){
	// NIC 2
			Package(){0x0000FFFF, 2, \_SB.PCI0.LPC0.LNKC, 0 },
	// NIC 3
			Package(){0x0000FFFF, 3, \_SB.PCI0.LPC0.LNKD, 0 },
		})
		Name(AG22, Package(){
	// NIC 2
			Package(){0x0000FFFF, 2, 0, 18 },
	// NIC 3
			Package(){0x0000FFFF, 3, 0, 19 },
		})
	
	
	} // end _SB scope
	
	//-------- DO NOT EDIT THIS FILE --------
	//
	// FILE WAS GENERATED AUTOMATICALY USING AMISDL v7.04.0274 (四月 26 2023,16:58:30)
	//
	//-------- DO NOT EDIT THIS FILE --------
	//****************************************************************************
	//****************************************************************************
	//**                                                                        **
	//**         (C)Copyright 1985 - 2023, American Megatrends, Inc.            **
	//**                                                                        **
	//**                          All Rights Reserved.                          **
	//**                                                                        **
	//**                    5555 Oakbrook Pkwy, Norcross, GA 30092              **
	//**                                                                        **
	//**                          Phone (770)-246-8600                          **
	//**                                                                        **
	//****************************************************************************
	//****************************************************************************

	
	//-------- DO NOT EDIT THIS FILE --------
	//
	// FILE WAS GENERATED AUTOMATICALY USING AMISDL v7.04.0274 (四月 26 2023,16:58:30)
	//
	//-------- DO NOT EDIT THIS FILE --------
	//****************************************************************************
	//****************************************************************************
	//**                                                                        **
	//**         (C)Copyright 1985 - 2023, American Megatrends, Inc.            **
	//**                                                                        **
	//**                          All Rights Reserved.                          **
	//**                                                                        **
	//**                    5555 Oakbrook Pkwy, Norcross, GA 30092              **
	//**                                                                        **
	//**                          Phone (770)-246-8600                          **
	//**                                                                        **
	//****************************************************************************
	//****************************************************************************
	//---------------------------------------------------------------------------
	// Begin System Bus Scope
	//---------------------------------------------------------------------------
	
	Scope(\_SB) {
	//---------------------------------------------------------------------------
	// Begin PCI tree object scope
	//---------------------------------------------------------------------------
	
		Device(PCI0) {	// PciRoot
			Name(_HID, EISAID("PNP0A08"))	// Indicates PCI Express/PCI-X Mode2 host hierarchy
			Name(_CID, EISAID("PNP0A03"))	// To support legacy OS that doesn't understand the new HID
			Name(_ADR, 0x00000000)
			Method(^BN00, 0){ return(0x0000) }	// Returns default Bus number for Peer PCI busses. Name can be overriden with control method placed directly under Device scope
			Method(_BBN, 0){ return(BN00()) }	// Bus number, optional for the Root PCI Bus
			Name(_UID, 0x0000)	// Unique Bus ID, optional
				Method(_PRT,0) {
					If(PICM) { Return(AR00) }// APIC mode
					Return (PD00) // PIC Mode
				} // end _PRT
	
	
	//---------------------------------------------------------------------------
	//Include file(s) for the device PciRoot
	//---------------------------------------------------------------------------
			/*++
			  This file contains an 'Intel Peripheral Driver' and is        
			  licensed for Intel CPUs and chipsets under the terms of your  
			  license agreement with Intel or your vendor.  This file may   
			  be modified by the user, subject to additional terms of the   
			  license agreement                                             
			--*/
			/*++
			  
			  Copyright (c)  2001 - 2016 Intel Corporation.  All rights reserved.
			
			  This software and associated documentation (if any) is furnished under 
			  a license and may only be used or copied in accordance with the terms 
			  of the license.  Except as permitted by such license, no part of this 
			  software or documentation may be reproduced, stored in a retrieval system, 
			  or transmitted in any form or by any means without the express written 
			  consent of Intel Corporation.
			
			  Module Name:
			  
			    SysBus.asi 
			  
			  Abstract:
			  
			    System devices
			  
			--*/
			
			            Name(EP_B, 0) // to store EP BAR
			            Name(MH_B, 0) // to store MCH BAR
			            Name(PC_B, 0) // to store PCIe BAR
			            Name(PC_L, 0) // to store PCIe BAR Length
			            Name(DM_B, 0) // to store DMI BAR
			
			            Method (_INI)
			            {
			                Store(WINDOWS_XP, OSYS)      // Set the default os is winxp
			                If (CondRefOf (_OSI, local0))
			                {
			                    //
			                    //_OSI is supported, so it is WinXp or Win2003Server
			                    //
			                    If (\_OSI("Windows 2001"))
			                    {
			                        Store (WINDOWS_XP, OSYS)
			                    }
			                    If (\_OSI("Windows 2001 SP1"))
			                    {
			                        Store (WINDOWS_XP_SP1, OSYS)
			                    }
			                    If (\_OSI("Windows 2001 SP2"))
			                    {
			                        Store (WINDOWS_XP_SP2, OSYS)
			                    }
			                    If (\_OSI("Windows 2001.1"))
			                    {
			                        Store (WINDOWS_2003, OSYS)
			                    }
			                    If (\_OSI("Windows 2006"))
			                    {
			                        Store (WINDOWS_Vista, OSYS)
			                    }
			                    If (\_OSI("Windows 2009"))
			                    {
			                        Store (WINDOWS_WIN7, OSYS)
			                    }
			                    If (\_OSI("Windows 2012"))
			                    {
			                        Store (WINDOWS_WIN8, OSYS)
			                    }
			                } 
			            } 
			            // Denverton AptioV override Start - EIP#221424
			            // Include ("osc.asi")              // Capabilities method           
			            // Include ("PciCrs.asi")           // PCI Resource Templates
			            // Include ("IchApic.asi")          // I/O Apic device
			            // Denverton AptioV override End - EIP#221424
			
									//
			            // Get PCIe BAR
			            //
			            Method(GPCB,0,Serialized)
			            {
			            // PCIEXBAR memory range
			            // Denverton Aptiov override start
			            // Return(FixedPcdGet64(PcdPciExpressBaseAddress))
			               Return (0xE0000000)
			            // Denverton Aptiov override end  
			            }

			/*++
			
			  Copyright (c)  2001 - 2013 Intel Corporation.  All rights reserved.
			
			  This software and associated documentation (if any) is furnished under 
			  a license and may only be used or copied in accordance with the terms 
			  of the license.  Except as permitted by such license, no part of this 
			  software or documentation may be reproduced, stored in a retrieval 
			  system, or transmitted in any form or by any means without the express 
			  written consent of Intel Corporation.
			
			  Module Name:
			
			    osc.asi
			
			  Abstract:
			
			    OSC method to be used on SB.PCI0 context
			
			--*/
			
			//Post code port 0x80
			//OperationRegion (DEB0, SystemIO, 0x80, 1)    //DBG
			//Field (DEB0, ByteAcc,NoLock,Preserve)        //DBG
			//{ DBGM, 8,}                    //DBG
			
			OperationRegion(PXCS,PCI_Config,0x40,0xC0) 
			  Field(PXCS,AnyAcc, NoLock, Preserve)
			    {      
			        Offset(0x10), // LCTL - Link Control Register
			        L0SE,   1,    // 0,   L0s Entry Enabled
			        ,   7,
			        Offset(0x12), // LSTS - Link Status Register
			        ,   13,
			        LASX,   1,    // 0,   Link Active Status
			        Offset(0x1A), // SLSTS[7:0] - Slot Status Register
			        ABPX,   1,    // 0,   Attention Button Pressed
			        ,   2,
			        PDCX,   1,    // 3,   Presence Detect Changed
			        ,   2,
			        PDSX,   1,    // 6,   Presence Detect State       
			        ,   1,
			        Offset(0x20), // RSTS - Root Status Register
			        ,   16,
			        PSPX,   1,    // 16,  PME Status
			        Offset(0x98), // MPC - Miscellaneous Port Configuration Register
			        ,   30,
			        HPEX,   1,    // 30,  Hot Plug SCI Enable
			        PMEX, 1,       // 31,    Power Management SCI Enable 
			        Offset(0x9C), // SMSCS - SMI/SCI Status Register
			        ,   30,
			        HPSX,   1,    // 30,    Hot Plug SCI Status
			        PMSX,   1     // 31,    Power Management SCI Status         
			  }
			
			   Name(SUPP,0)  // PCI _OSC Support Field value
			   Name(CTRL,0)  // PCI _OSC Control Field value
			
			
			Method(_OSC,4)
			{ // Check for proper UUID
			  If(LEqual(Arg0,ToUUID("33DB4D5B-1FF7-401C-9657-7441C03DD766")))
			  {
			    // Create DWord-adressable fields from the Capabilities Buffer
			    CreateDWordField(Arg3,0,CDW1)
			    CreateDWordField(Arg3,4,CDW2)
			    CreateDWordField(Arg3,8,CDW3)
			    
			    // Save Capabilities DWord2 & 3
			    Store(CDW2,SUPP)
			    Store(CDW3,CTRL)
			    
			    //Set Post code to verify method execution
			    //Store(0x23,DBGM)
			    
			    // Only allow native hot plug control if OS supports:
			    // * ASPM
			    // * Clock PM
			    // * MSI/MSI-X
			    If(LNotEqual(And(SUPP, 0x16), 0x16))
			    {
			      And(CTRL,0x1E,CTRL) // Mask bit 0 (and undefined bits) 
			    }
			    
			    // Always allow native PME, AER (no dependencies)
			    // Never allow SHPC (no SHPC controller in this system)
			    // Denverton AptioV Override Start - EIP#471482
			    If(LEqual(AERC, Zero))
			    {
			      And(CTRL,0x15,CTRL)
			    }
			    Else
			    {
			      And(CTRL,0x1D,CTRL)
			    }
			    // Denverton AptioV Override End - EIP#471482
			    
			    If(Not(And(CDW1,1))) // Query flag clear?
			    { 
			      // Disable GPEs for features granted native control.
			      If(And(CTRL,0x01)) // Hot plug control granted?
			      {
			        Store(0,HPEX) // clear the hot plug SCI enable bit
			        Store(1,HPSX) // clear the hot plug SCI status bit
			      }
			      
			      If(And(CTRL,0x04)) // PME control granted?
			      {
			        Store(0,PMEX) // clear the PME SCI enable bit
			        Store(1,PMSX) // clear the PME SCI status bit
			      }
			    }
				
			    If(LNotEqual(Arg1,One))
			    { // Unknown revision
			      Or(CDW1,0x08,CDW1)
			    }
			    If(LNotEqual(CDW3,CTRL))
			    { // Capabilities bits were masked
			      Or(CDW1,0x10,CDW1)
			    } // Update DWORD3 in the buffer
			    Store(CTRL,CDW3)
			    Return(Arg3)
			  }Else
			  {
			    Or(CDW1,4,CDW1) // Unrecognized UUID
			    Return(Arg3)
			  }
			} // End _OSC
			/*++
			  This file contains an 'Intel Peripheral Driver' and is        
			  licensed for Intel CPUs and chipsets under the terms of your  
			  license agreement with Intel or your vendor.  This file may   
			  be modified by the user, subject to additional terms of the   
			  license agreement                                             
			--*/
			/*++
			
			  Copyright (c)  2001 - 2016 Intel Corporation.  All rights reserved.
			
			  This software and associated documentation (if any) is furnished under 
			  a license and may only be used or copied in accordance with the terms 
			  of the license.  Except as permitted by such license, no part of this 
			  software or documentation may be reproduced, stored in a retrieval system, 
			  or transmitted in any form or by any means without the express written 
			  consent of Intel Corporation.
			
			  Module Name:
			
			    PciCrs.asi 
			
			  Abstract:
			
			    PCI resource template
			
			--*/
			
			Name(PBRS, ResourceTemplate() {
			   WORDBusNumber(            //Bus number resource (0); the bridge produces bus numbers for its subsequent buses
			      ResourceProducer,      // bit 0 of general flags is 1
			      MinFixed,              // Range is fixed
			      MaxFixed,              // Range is fixed
			      PosDecode,             // PosDecode
			      0x0000,                // Granularity
			      0x0000,                // Min
			      0x00ff,                // Max
			      0x0000,                // Translation
			      0x0100                 // Range Length = Max-Min+1
			   )   
			   
			   WORDIO(                   //Consumed-and-produced resource (all I/O below CF8)
			      ResourceProducer,      // bit 0 of general flags is 0
			      MinFixed,              // Range is fixed
			      MaxFixed,              // Range is fixed
			      PosDecode,             
			      EntireRange,
			      0x0000,                // Granularity
			      0x0000,                // Min
			      0x0cf7,                // Max
			      0x0000,                // Translation
			      0x0cf8                 // Range Length
			   )
			   
			   IO(                       //Consumed resource (CF8-CFF)
			      Decode16, 
			      0x0cf8, 
			      0xcf8, 
			      1,
			      8
			   )
			   
			   WORDIO(                   //Consumed-and-produced resource (all I/O above CFF)
			      ResourceProducer,      // bit 0 of general flags is 0
			      MinFixed,              // Range is fixed
			      MaxFixed,              // Range is fixed
			      PosDecode,             
			      EntireRange,
			      0x0000,                // Granularity
			      0x0d00,                // Min
			      0xffff,                // Max
			      0x0000,                // Translation
			      0xf300                 // Range Length
			   )
			   
			   DWORDMEMORY(              // descriptor for VGA area(0xa0000 - 0xbffff)
			      ResourceProducer,      // bit 0 of general flags is 0
			      PosDecode,
			      MinFixed,              // Range is fixed
			      MaxFixed,              // Range is Fixed
			      Cacheable,
			      ReadWrite,
			      0x00000000,            // Granularity
			      0x00000000,            // Min
			      0x00000000,            // Max
			      0x00000000,            // Translation
			      0x00000000,            // Range Length
			      ,
			      ,
			      LVGA  
			   )
			    
			   DWORDMEMORY(              // descriptor for Shadow RAM
			      ResourceProducer,       // bit 0 of general flags is 0
			      PosDecode,
			      MinFixed,               // Range is fixed
			      MaxFixed,               // Range is Fixed
			      Cacheable,
			      ReadWrite,
			      0x00000000,             // Granularity
			      0x00000000,             // Min (calculated dynamically)
			      0x00000000,             // Max (calculated dynamically)
			      0x00000000,             // Translation
			      0x00000000,             // Range Length (calculated dynamically)
			      ,
			      ,
			      OPMR 
			    )
			      
			   DWORDMemory(              // Consumed-and-produced resource for pci memory mapped memory
			      ResourceProducer,      // bit 0 of general flags is 0
			      PosDecode,             // positive Decode
			      MinFixed,              // Range is fixed
			      MaxFixed,              // Range is fixed
			      NonCacheable,
			      ReadWrite,
			      0x00000000,            // Granularity
			      0xA0000000,            // Min (calculated dynamically)
			 
			      0xDFFFFFFF,            // Max = IO Apic base address - 1
			      0x00000000,            // Translation
			      0x40000000,            // Range Length (calculated dynamically)
			      ,                      // Optional field left blank
			      ,                      // Optional field left blank
			      MEM1                   // Name declaration for this descriptor
			   )
			   
			   QWORDMemory(              // Consumed-and-produced resource(all of memory space)
			      ResourceProducer,       // bit 0 of general flags is 0
			      PosDecode,              // positive Decode
			      MinFixed,               // Range is fixed
			      MaxFixed,               // Range is fixed
			      NonCacheable,
			      ReadWrite,
			      0x00000000,             // Granularity 
			      0x00000000000,          // Min (calculated dynamically)
			      0x00000000000,          // Max (calculated dynamically)
			      0x00000000,             // Translation
			      0x00000000000,          // Range Length (calculated dynamically)
			      ,
			      ,
			      MEM2                    // Name declaration for this descriptor
			   )
			
			// Denverton AptioV Override Start - EIP#275808   
			// WA for AfuLinux issue.
			// Report the MMIO BAR of SPI and NPK device as PCI range
			
			   DWORDMemory(              // Consumed-and-produced resource for pci memory mapped memory
			      ResourceProducer,      // bit 0 of general flags is 0
			      PosDecode,             // positive Decode
			      MinFixed,              // Range is fixed
			      MaxFixed,              // Range is fixed
			      NonCacheable,
			      ReadWrite,
			      0x00000000,            // Granularity
			      0xFE010000,            // Min
			      0xFE010FFF,            // Max
			      0x00000000,            // Translation
			      0x00001000,            // 4K
			      ,                      // Optional field left blank
			      ,                      // Optional field left blank
			      SPIB           	     // Name declaration for this descriptor
			   )
			
			   //NPK CSR/Memory trace buffer
			    DWORDMemory(              // Consumed-and-produced resource for pci memory mapped memory
			      ResourceProducer,      // bit 0 of general flags is 0
			      PosDecode,             // positive Decode
			      MinFixed,              // Range is fixed
			      MaxFixed,              // Range is fixed
			      NonCacheable,
			      ReadWrite,
			      0x00000000,            // Granularity
			      0xFA000000,            // Min
			 
			      0xFA0FFFFF,            // Max
			      0x00000000,            // Translation
			      0x00100000,            // 1M
			      ,                      // Optional field left blank
			      ,                      // Optional field left blank
			      NPK1           // Name declaration for this descriptor
			   )
			   //NPK SW buffer
			   DWORDMemory(              // Consumed-and-produced resource for pci memory mapped memory
			      ResourceProducer,      // bit 0 of general flags is 0
			      PosDecode,             // positive Decode
			      MinFixed,              // Range is fixed
			      MaxFixed,              // Range is fixed
			      NonCacheable,
			      ReadWrite,
			      0x00000000,            // Granularity
			      0xFB000000,            // Min
			 
			      0xFB7FFFFF,            // Max
			      0x00000000,            // Translation
			      0x00800000,            // 8M
			      ,                      // Optional field left blank
			      ,                      // Optional field left blank
			      NPK2                  // Name declaration for this descriptor
			   )
			   //NPK RTIT buffer
			    DWORDMemory(              // Consumed-and-produced resource for pci memory mapped memory
			      ResourceProducer,      // bit 0 of general flags is 0
			      PosDecode,             // positive Decode
			      MinFixed,              // Range is fixed
			      MaxFixed,              // Range is fixed
			      NonCacheable,
			      ReadWrite,
			      0x00000000,            // Granularity
			      0xFA100000,            // Min
			 
			      0xFA1007FF,            // Max
			      0x00000000,            // Translation
			      0x00000800,            // 256K
			      ,                      // Optional field left blank
			      ,                      // Optional field left blank
			      NPK3                   // Name declaration for this descriptor
			   )
			// Denverton AptioV Override End - EIP#275808
			
			})          // end of CRES Buffer
			
			
			Method(_CRS, 0x0, Serialized)
			{
			  If(And(LGCY,0x01)) // Legacy
			  {
			    // Fix up 32-bit OPMR
			    CreateDWordField(PBRS, ^OPMR._MIN, OPMN)
			    Store(0x000c0000, OPMN)
			    CreateDWordField(PBRS, ^OPMR._MAX, OPMX)
			    Store(0x000dffff, OPMX)
			    CreateDWordField(PBRS, ^OPMR._LEN, OPLN)
			    Store(0x20000, OPLN)
			  }
			
			  If(And(LGCY,0x80)) // Legacy Video Legacy.
			  {
			    // Fix up 32-bit LVGA
			    CreateDWordField(PBRS, ^LVGA._MIN, LVMN)
			    Store(0x000a0000, LVMN)
			    CreateDWordField(PBRS, ^LVGA._MAX, LVMX)
			    Store(0x000bffff, LVMX)
			    CreateDWordField(PBRS, ^LVGA._LEN, LVLN)
			    Store(0x20000, LVLN)
			  }
			 
			  // Fix up 32-bit Memory resources
			  CreateDWordField(PBRS, ^MEM1._MIN, PMMN)
			  Store(MMOB, PMMN)
			  CreateDWordField(PBRS, ^MEM1._MAX, PMMX)
			  Store(MMOL, PMMX)
			  CreateDWordField(PBRS, ^MEM1._LEN, PMLN)
			  Add(Subtract(PMMX,PMMN),1,PMLN)
			 
			  // Fix up 64-bit Memory resources
			  If(LGreater(OSYS, WINDOWS_2003)) {
			  	If(LNot(LEqual(MMHB,Zero)))
			  	{
			    	CreateQWordField(PBRS, ^MEM2._MIN, P2MN)
			    	Store(MMHB, P2MN)
			    	CreateQWordField(PBRS, ^MEM2._MAX, P2MX)
			    	Store(MMHL, P2MX)
			    	CreateQWordField(PBRS, ^MEM2._LEN, P2LN)
			    	Add(Subtract(P2MX,P2MN),1,P2LN)
			    }
			  }
			
			  Return(PBRS)
			}
			

			/*++
			  This file contains an 'Intel Peripheral Driver' and is        
			  licensed for Intel CPUs and chipsets under the terms of your  
			  license agreement with Intel or your vendor.  This file may   
			  be modified by the user, subject to additional terms of the   
			  license agreement                                             
			--*/
			/*++
			  
			// Copyright (c) 2010, Intel Corporation. All rights reserved. 
			// This software and associated documentation (if any) is furnished
			// under a license and may only be used or copied in accordance
			// with the terms of the license. Except as permitted by such
			// license, no part of this software or documentation may be
			// reproduced, stored in a retrieval system, or transmitted in any
			// form or by any means without the express written consent of
			// Intel Corporation.
			
			  Module Name:
			  
			    TCApic.asi 
			  
			  Abstract:
			  
			    TC I/O Apic devices
			  
			--*/
			
			
			#ifndef TC_APIC_ASI
			#define TC_APIC_ASI
			
			Device(APIC)
			{
			    Name(_HID,EISAID("PNP0003"))        // APIC resources
			
			    Name(_CRS, ResourceTemplate()
			        {
			            // Denverton Aptiov override start
			            // Memory32Fixed(ReadOnly, FixedPcdGet64(PcdIoApicBaseAddress), FixedPcdGet64(PcdIoApicSpaceSize)) // IO APIC
			            Memory32Fixed(ReadOnly, 0xFEC00000, 0x1000) // IO APIC
			            // Denverton Aptiov override end
			        }
			    )
			}
			
			#endif

	
	//---------------------------------------------------------------------------
	// Begin SB Device or LPC brg object scope
	//---------------------------------------------------------------------------
			Device(LPC0) { // LpcBridge
				Name(_ADR, 0x001F0000)
	
	//---------------------------------------------------------------------------
	//Include file(s) for the device LpcBridge
	//---------------------------------------------------------------------------
				/*++
				  This file contains an 'Intel Peripheral Driver' and is        
				  licensed for Intel CPUs and chipsets under the terms of your  
				  license agreement with Intel or your vendor.  This file may   
				  be modified by the user, subject to additional terms of the   
				  license agreement                                             
				--*/
				/*++
				  
				// Copyright (c) 2015, Intel Corporation. All rights reserved. 
				// This software and associated documentation (if any) is furnished
				// under a license and may only be used or copied in accordance
				// with the terms of the license. Except as permitted by such
				// license, no part of this software or documentation may be
				// reproduced, stored in a retrieval system, or transmitted in any
				// form or by any means without the express written consent of
				// Intel Corporation.
				  
				  Module Name:
				  
				    pciirq.asi
				  
				  Abstract:
				  
				  
				--*/
				
				
				// Interrupts can be DEB8=all except 13,8,6,2,1,0
				
				//DNV_TODO: derive this address from the BAR setting rather than hard-code it.
				OperationRegion(ILBR, SystemMemory, 0xfdd03100, 0x10) 
				Field(ILBR, ByteAcc, NoLock, Preserve)
				{
				    PIRA, 8,
				    PIRB, 8,
				    PIRC, 8,
				    PIRD, 8,
				    PIRE, 8,
				    PIRF, 8,
				    PIRG, 8,
				    PIRH, 8
				}
				
				Device(LNKA)            // PCI IRQ link A
				{
				    Name(_HID,EISAID("PNP0C0F"))
				
				    Name(_UID, 1)
				
				    Method(_STA,0,NotSerialized)         
				    {
				        If(And(PIRA, 0x80)) 
				        {
				          Return(0x9)
				        }
				        Else 
				        {
				          Return(0xB)
				        }    // Don't display
				    }
				
				    Method(_DIS,0,NotSerialized)
				    {
				        Or(PIRA, 0x80, PIRA)
				    }
				
				    Method(_CRS,0,Serialized)
				    {
				        Name(BUF0,
				            ResourceTemplate()
				            {IRQ(Level,ActiveLow,Shared){0}})
				        
				                                // Define references to buffer elements
				        CreateWordField (BUF0, 0x01, IRQW)  // IRQ low
				                                // Write current settings into IRQ descriptor
				        If (And(PIRA, 0x80))
				        {
				            Store(Zero, Local0)
				        }
				        Else
				        {
				            Store(One,Local0)
				        }
				                                                        // Shift 1 by value in register 70
				        ShiftLeft(Local0,And(PIRA,0x0F),IRQW)       // Save in buffer
				        Return(BUF0)                                // Return Buf0 
				    }                                                  // End of _CRS method
				
				    Name(_PRS,
				        ResourceTemplate() 
				        {IRQ(Level,ActiveLow,Shared){6,7,10,11,12,14,15}})
				
				    Method(_SRS,1,NotSerialized)
				    {
				        CreateWordField (ARG0, 0x01, IRQW)  // IRQ low
				
				        FindSetRightBit(IRQW,Local0)          // Set IRQ
				        If (LNotEqual(IRQW,Zero)) 
				        {
				            And(Local0, 0x7F,Local0)
				            Decrement(Local0)
				        }
				        Else 
				        {
				            Or(Local0, 0x80,Local0)
				        }
				        store(Local0, PIRA)
				    }                                                  // End of _SRS Method
				}    
				
				Device(LNKB)            // PCI IRQ link B
				{
				    Name(_HID,EISAID("PNP0C0F"))
				
				    Name(_UID, 2)
				
				    Method(_STA,0,NotSerialized)         
				    {
				        If(And(PIRB, 0x80)) 
				        {
				          Return(0x9)
				        }
				        Else 
				        {
				          Return(0xB)
				        }    // Don't display
				    }
				
				    Method(_DIS,0,NotSerialized)
				    {
				        Or(PIRB, 0x80,PIRB)
				    }
				
				    Method(_CRS,0,Serialized)
				    {
				        Name(BUF0,
				            ResourceTemplate()
				            {IRQ(Level,ActiveLow,Shared){0}})
				                                                // Define references to buffer elements
				        CreateWordField (BUF0, 0x01, IRQW)  // IRQ low
				                                                // Write current settings into IRQ descriptor
				        If (And(PIRB, 0x80))
				        {
				            Store(Zero, Local0)
				        }
				        Else
				        {
				                Store(One,Local0)
				        }
				                                                            // Shift 1 by value in register 70
				        ShiftLeft(Local0,And(PIRB,0x0F),IRQW)  // Save in buffer
				        Return(BUF0)                                    // Return Buf0 
				    }                                                      // End of _CRS method
				
				    Name(_PRS,
				        ResourceTemplate() 
				        {IRQ(Level,ActiveLow,Shared){6,7,10,11,12,14,15}})
				
				    Method(_SRS,1,NotSerialized)
				    {
				        CreateWordField (ARG0, 0x01, IRQW)      // IRQ low
				
				        FindSetRightBit(IRQW,Local0)              // Set IRQ
				        If (LNotEqual(IRQW,Zero)) 
				        {
				            And(Local0, 0x7F,Local0)
				            Decrement(Local0)
				        }
				        Else 
				        {
				            Or(Local0, 0x80,Local0)
				        }
				        Store(Local0, PIRB)
				    }                                                      // End of _SRS Method
				}    
				
				Device(LNKC)                                            // PCI IRQ link C
				{
				    Name(_HID,EISAID("PNP0C0F"))
				
				    Name(_UID, 3)
				
				    Method(_STA,0,NotSerialized)         
				    {
				        If(And(PIRC, 0x80)) 
				        {
				          Return(0x9)
				        }
				        Else 
				        {
				          Return(0xB)
				        }    // Don't display
				    }
				
				    Method(_DIS,0,NotSerialized)
				    {
				        Or(PIRC, 0x80,PIRC)
				    }
				
				    Method(_CRS,0,Serialized)
				    {
				        Name(BUF0,
				            ResourceTemplate()
				            {IRQ(Level,ActiveLow,Shared){0}})
				                                                        // Define references to buffer elements
				        CreateWordField (BUF0, 0x01, IRQW)  // IRQ low
				                                                // Write current settings into IRQ descriptor
				        If (And(PIRC, 0x80))
				        {
				            Store(Zero, Local0)
				        }
				        Else
				        {
				            Store(One,Local0)
				        }                                      // Shift 1 by value in register 70
				        ShiftLeft(Local0,And(PIRC,0x0F),IRQW)  // Save in buffer
				        Return(BUF0)                                // Return Buf0 
				    }                                                  // End of _CRS method
				
				    Name(_PRS,
				        ResourceTemplate() 
				        {IRQ(Level,ActiveLow,Shared){6,7,10,11,12,14,15}})
				
				    Method(_SRS,1,NotSerialized)
				    {
				        CreateWordField (ARG0, 0x01, IRQW)  // IRQ low
				
				        FindSetRightBit(IRQW,Local0)          // Set IRQ
				        If (LNotEqual(IRQW,Zero)) 
				        {
				            And(Local0, 0x7F,Local0)
				            Decrement(Local0)
				        }
				        Else {
				            Or(Local0, 0x80,Local0)
				        }
				        Store(Local0, PIRC)
				    }                                                  // End of _SRS Method
				}    
				
				Device(LNKD)                                        // PCI IRQ link D
				{
				    Name(_HID,EISAID("PNP0C0F"))
				
				    Name(_UID, 4)
				
				    Method(_STA,0,NotSerialized)         
				    {
				        If(And(PIRD, 0x80))
				        {
				          Return(0x9)
				        }
				        Else 
				        {
				          Return(0xB)
				        }    // Don't display
				    }
				
				    Method(_DIS,0,NotSerialized)
				    {
				        Or(PIRD, 0x80,PIRD)
				    }
				
				    Method(_CRS,0,Serialized)
				    {
				        Name(BUF0,
				            ResourceTemplate()
				            {IRQ(Level,ActiveLow,Shared){0}})
				        // Define references to buffer elements
				        CreateWordField (BUF0, 0x01, IRQW)  // IRQ low
				        // Write current settings into IRQ descriptor
				        If (And(PIRD, 0x80))
				        {
				            Store(Zero, Local0)
				        }
				        Else
				        {
				            Store(One,Local0)
				        }  // Shift 1 by value in register 70
				        ShiftLeft(Local0,And(PIRD,0x0F),IRQW)  // Save in buffer
				        Return(BUF0)        // Return Buf0 
				    }                  // End of _CRS method
				
				    Name(_PRS,
				        ResourceTemplate() 
				        {IRQ(Level,ActiveLow,Shared){6,7,10,11,12,14,15}})
				
				    Method(_SRS,1,NotSerialized)
				    {
				        CreateWordField (ARG0, 0x01, IRQW)  // IRQ low
				
				        FindSetRightBit(IRQW,Local0)// Set IRQ
				        If (LNotEqual(IRQW,Zero)) 
				        {
				            And(Local0, 0x7F,Local0)
				            Decrement(Local0)
				        }
				        Else 
				        {
				            Or(Local0, 0x80,Local0)
				        }
				        Store(Local0, PIRD)
				    }                  // End of _SRS Method
				}    
				
				Device(LNKE)            // PCI IRQ link E
				{
				    Name(_HID,EISAID("PNP0C0F"))
				
				    Name(_UID, 5)
				
				    Method(_STA,0,NotSerialized)         
				    {
				        If(And(PIRE, 0x80)) 
				        {
				          Return(0x9)
				        }
				        Else 
				        {
				          Return(0xB)
				        }    // Don't display
				    }
				
				    Method(_DIS,0,NotSerialized)
				    {
				        Or(PIRE, 0x80, PIRE)
				    }
				
				    Method(_CRS,0,Serialized)
				    {
				        Name(BUF0,
				            ResourceTemplate()
				            {IRQ(Level,ActiveLow,Shared){0}})
				        
				                                // Define references to buffer elements
				        CreateWordField (BUF0, 0x01, IRQW)  // IRQ low
				                                // Write current settings into IRQ descriptor
				        If (And(PIRE, 0x80))
				        {
				            Store(Zero, Local0)
				        }
				        Else
				        {
				            Store(One,Local0)
				        }
				                                                        // Shift 1 by value in register 70
				        ShiftLeft(Local0,And(PIRE,0x0F),IRQW)       // Save in buffer
				        Return(BUF0)                                // Return Buf0 
				    }                                                  // End of _CRS method
				
				    Name(_PRS,
				        ResourceTemplate() 
				        {IRQ(Level,ActiveLow,Shared){6,7,10,11,12,14,15}})
				
				    Method(_SRS,1,NotSerialized)
				    {
				        CreateWordField (ARG0, 0x01, IRQW)  // IRQ low
				
				        FindSetRightBit(IRQW,Local0)          // Set IRQ
				        If (LNotEqual(IRQW,Zero)) 
				        {
				            And(Local0, 0x7F,Local0)
				            Decrement(Local0)
				        }
				        Else 
				        {
				            Or(Local0, 0x80,Local0)
				        }
				        store(Local0, PIRE)
				    }                                                  // End of _SRS Method
				}    
				
				Device(LNKF)            // PCI IRQ link F
				{
				    Name(_HID,EISAID("PNP0C0F"))
				
				    Name(_UID, 6)
				
				    Method(_STA,0,NotSerialized)         
				    {
				        If(And(PIRF, 0x80)) 
				        {
				          Return(0x9)
				        }
				        Else 
				        {
				          Return(0xB)
				        }    // Don't display
				    }
				
				    Method(_DIS,0,NotSerialized)
				    {
				        Or(PIRB, 0x80,PIRF)
				    }
				
				    Method(_CRS,0,Serialized)
				    {
				        Name(BUF0,
				            ResourceTemplate()
				            {IRQ(Level,ActiveLow,Shared){0}})
				                                                // Define references to buffer elements
				        CreateWordField (BUF0, 0x01, IRQW)  // IRQ low
				                                                // Write current settings into IRQ descriptor
				        If (And(PIRF, 0x80))
				        {
				            Store(Zero, Local0)
				        }
				        Else
				        {
				                Store(One,Local0)
				        }
				                                                            // Shift 1 by value in register 70
				        ShiftLeft(Local0,And(PIRF,0x0F),IRQW)  // Save in buffer
				        Return(BUF0)                                    // Return Buf0 
				    }                                                      // End of _CRS method
				
				    Name(_PRS,
				        ResourceTemplate() 
				        {IRQ(Level,ActiveLow,Shared){6,7,10,11,12,14,15}})
				
				    Method(_SRS,1,NotSerialized)
				    {
				        CreateWordField (ARG0, 0x01, IRQW)      // IRQ low
				
				        FindSetRightBit(IRQW,Local0)              // Set IRQ
				        If (LNotEqual(IRQW,Zero)) 
				        {
				            And(Local0, 0x7F,Local0)
				            Decrement(Local0)
				        }
				        Else 
				        {
				            Or(Local0, 0x80,Local0)
				        }
				        Store(Local0, PIRF)
				    }                                                      // End of _SRS Method
				}    
				
				Device(LNKG)                                            // PCI IRQ link G
				{
				    Name(_HID,EISAID("PNP0C0F"))
				
				    Name(_UID, 7)
				
				    Method(_STA,0,NotSerialized)         
				    {
				        If(And(PIRG, 0x80)) 
				        {
				          Return(0x9)
				        }
				        Else 
				        {
				          Return(0xB)
				        }    // Don't display
				    }
				
				    Method(_DIS,0,NotSerialized)
				    {
				        Or(PIRG, 0x80,PIRG)
				    }
				
				    Method(_CRS,0,Serialized)
				    {
				        Name(BUF0,
				            ResourceTemplate()
				            {IRQ(Level,ActiveLow,Shared){0}})
				                                                        // Define references to buffer elements
				        CreateWordField (BUF0, 0x01, IRQW)  // IRQ low
				                                                // Write current settings into IRQ descriptor
				        If (And(PIRG, 0x80))
				        {
				            Store(Zero, Local0)
				        }
				        Else
				        {
				            Store(One,Local0)
				        }                                      // Shift 1 by value in register 70
				        ShiftLeft(Local0,And(PIRG,0x0F),IRQW)  // Save in buffer
				        Return(BUF0)                                // Return Buf0 
				    }                                                  // End of _CRS method
				
				    Name(_PRS,
				        ResourceTemplate() 
				        {IRQ(Level,ActiveLow,Shared){6,7,10,11,12,14,15}})
				
				    Method(_SRS,1,NotSerialized)
				    {
				        CreateWordField (ARG0, 0x01, IRQW)  // IRQ low
				
				        FindSetRightBit(IRQW,Local0)          // Set IRQ
				        If (LNotEqual(IRQW,Zero)) 
				        {
				            And(Local0, 0x7F,Local0)
				            Decrement(Local0)
				        }
				        Else {
				            Or(Local0, 0x80,Local0)
				        }
				        Store(Local0, PIRG)
				    }                                                  // End of _SRS Method
				}    
				
				Device(LNKH)                                        // PCI IRQ link H
				{
				    Name(_HID,EISAID("PNP0C0F"))
				
				    Name(_UID, 8)
				
				    Method(_STA,0,NotSerialized)         
				    {
				        If(And(PIRH, 0x80))
				        {
				          Return(0x9)
				        }
				        Else 
				        {
				          Return(0xB)
				        }    // Don't display
				    }
				
				    Method(_DIS,0,NotSerialized)
				    {
				        Or(PIRH, 0x80,PIRH)
				    }
				
				    Method(_CRS,0,Serialized)
				    {
				        Name(BUF0,
				            ResourceTemplate()
				            {IRQ(Level,ActiveLow,Shared){0}})
				        // Define references to buffer elements
				        CreateWordField (BUF0, 0x01, IRQW)  // IRQ low
				        // Write current settings into IRQ descriptor
				        If (And(PIRH, 0x80))
				        {
				            Store(Zero, Local0)
				        }
				        Else
				        {
				            Store(One,Local0)
				        }  // Shift 1 by value in register 70
				        ShiftLeft(Local0,And(PIRH,0x0F),IRQW)  // Save in buffer
				        Return(BUF0)        // Return Buf0 
				    }                  // End of _CRS method
				
				    Name(_PRS,
				        ResourceTemplate() 
				        {IRQ(Level,ActiveLow,Shared){6,7,10,11,12,14,15}})
				
				    Method(_SRS,1,NotSerialized)
				    {
				        CreateWordField (ARG0, 0x01, IRQW)  // IRQ low
				
				        FindSetRightBit(IRQW,Local0)// Set IRQ
				        If (LNotEqual(IRQW,Zero)) 
				        {
				            And(Local0, 0x7F,Local0)
				            Decrement(Local0)
				        }
				        Else 
				        {
				            Or(Local0, 0x80,Local0)
				        }
				        Store(Local0, PIRH)
				    }                  // End of _SRS Method
				}    
				

				/*++
				  This file contains an 'Intel Peripheral Driver' and is
				  licensed for Intel CPUs and chipsets under the terms of your
				  license agreement with Intel or your vendor.  This file may
				  be modified by the user, subject to additional terms of the
				  license agreement
				--*/
				/*++
				
				  Copyright (c)  2015 - 2020 Intel Corporation.  All rights reserved.
				
				  This software and associated documentation (if any) is furnished under
				  a license and may only be used or copied in accordance with the terms
				  of the license.  Except as permitted by such license, no part of this
				  software or documentation may be reproduced, stored in a retrieval system,
				  or transmitted in any form or by any means without the express written
				  consent of Intel Corporation.
				
				  Module Name:
				
				    Mother.asi
				
				  Abstract:
				
				    Motherboard devices / resources.
				--*/
				#include <..\HarrisonvillePkg\Include\PlatformDefinitions.h> // Denverton AptioV Override - EIP#221424
				
				Device(GPIO)
				{
				  Name(_HID,"INTC3000")
				  Name(_CRS,ResourceTemplate() {
				 
				  Memory32Fixed(ReadWrite,0xFDC20000,0x1000,COM0)  //GPIOCOM0
				  Memory32Fixed(ReadWrite,0xFDC50000,0x1000,COM1)  //GPIOCOM1
				  Interrupt (ResourceConsumer, Level, ActiveLow, Shared) {0xE} 
				  }) 
				      
				  Method(_STA,0,NotSerialized)
				  { 
				    Return (GPST)
				  }
				}
				
				Device(HPET)	// High Precision Event Timer
				{
				  Name(_HID,EISAID("PNP0103"))
				  Name(_UID, 0)
				
				  Name(CRS0,ResourceTemplate()
				  {
				    Memory32Fixed(ReadOnly,0xFED00000,0x400,FED0)
				  })
				
				  Name(CRS1,ResourceTemplate()
				  {
				    Memory32Fixed(ReadOnly,0xFED01000,0x400,FED1)
				  })
				
				  Name(CRS2,ResourceTemplate()
				  {
				    Memory32Fixed(ReadOnly,0xFED02000,0x400,FED2)
				  })
				
				  Name(CRS3,ResourceTemplate()
				  {
				    Memory32Fixed(ReadOnly,0xFED03000,0x400,FED3)
				  })
				
				  Method(_CRS,0,Serialized)
				  {
				     Switch(HADR)
				     {
				       Case(0)
				       {
				          Return(CRS0)
				       }
				       Case(1)
				       {
				          Return(CRS1)
				       }
				       Case(2)
				       {
				          Return(CRS2)
				       }
				       Case(3)
				       {
				          Return(CRS3)
				       }
				     }
				     Return(CRS0)
				  }
				
				  Method(_STA,0)
				  {
				    // Show this Device only if the OS is WINXP or beyond.
				
				    If(LGreaterEqual(OSYS,2001)) {
				      Return(0x000F) // Enabled, do Display.
				    }
				    Else { // OS = WIN98, WINME, or WIN2000.
				      Return(0x000B) // Enabled, don't Display.
				    }
				    Return(0x0000)			// Return Nothing.
				  }
				}
				
				Device(IPIC)	// 8259 PIC
				{
				  Name(_HID,EISAID("PNP0000"))
				
				  Name(_CRS,ResourceTemplate()
				  {
				    IO(Decode16,0x20,0x20,0x01,0x02)
				    IO(Decode16,0x24,0x24,0x01,0x02)
				    IO(Decode16,0x28,0x28,0x01,0x02)
				    IO(Decode16,0x2C,0x2C,0x01,0x02)
				    IO(Decode16,0x30,0x30,0x01,0x02)
				    IO(Decode16,0x34,0x34,0x01,0x02)
				    IO(Decode16,0x38,0x38,0x01,0x02)
				    IO(Decode16,0x3C,0x3C,0x01,0x02)
				    IO(Decode16,0xA0,0xA0,0x01,0x02)
				    IO(Decode16,0xA4,0xA4,0x01,0x02)
				    IO(Decode16,0xA8,0xA8,0x01,0x02)
				    IO(Decode16,0xAC,0xAC,0x01,0x02)
				    IO(Decode16,0xB0,0xB0,0x01,0x02)
				    IO(Decode16,0xB4,0xB4,0x01,0x02)
				    IO(Decode16,0xB8,0xB8,0x01,0x02)
				    IO(Decode16,0xBC,0xBC,0x01,0x02)
				    IO(Decode16,0x4D0,0x4D0,0x01,0x02)
				    IRQNoFlags() {2}
				  })
				}
				
				//
				// Motherboard resources
				//
				Device(MCH)
				{
				  Name(_HID, EISAID("PNP0C01"))   // Hardware Device ID
				  Name(_UID, 10)			        // Unique ID
				
				  Name(MCHR, ResourceTemplate()
				  {
				    // geoSPI memory range
				    //
				   // Memory32Fixed(ReadWrite, FixedPcdGet64(PcdGeoSpiChipAddress), FixedPcdGet64(PcdGeoSpiChipSize))
				   
				      Memory32Fixed(ReadWrite, 0x1F0000, 0x10000)
				   
				    // PCIEXBAR memory range
				    // Denverton Aptiov override start
				    // Memory32Fixed(ReadOnly, FixedPcdGet64(PcdPciExpressBaseAddress), PCIEX_LENGTH)
				    Memory32Fixed(ReadOnly, 0xE0000000, PCIEX_LENGTH)
				    // Denverton Aptiov override end
				    // TSEG
				    //
				    Memory32Fixed(ReadOnly, 0x00000000, 0x00000000, TSEG)
				
				    // TRACE_HUB_USB_DCI
				    //
				    Memory32Fixed(ReadOnly, 0xFED60000, 0x1000)
				  })
				
				  Method (_CRS, 0, Serialized)
				  {
				    // Fix up 32-bit TSEG
				    //
				    CreateDWordField(MCHR, ^TSEG._BAS, TSMN)
				    Store(TSGB, TSMN)
				    CreateDWordField(MCHR, ^TSEG._LEN, TSLN)
				    Store(TSSZ, TSLN)
				    return(MCHR)
				  } // End _CRS
				}
				
				Device(LDRC)  // LPC Device Resource Consumption
				{
				  Name(_HID,EISAID("PNP0C02"))
				
				  Name(_UID, 0x31)
				
				  Name(LPCR,ResourceTemplate()
				  {
				    IO(Decode16,0x2E,0x2E,0x1,0x02)		// WPCN381U SIO Config Index + Data.
				    IO(Decode16,0x4E,0x4E,0x1,0x02)		// LPC Slot Access.
				    IO(Decode16,0x61,0x61,0x1,0x1)		// NMI Status.
				    IO(Decode16,0x63,0x63,0x1,0x1)		// Processor I/F.
				    IO(Decode16,0x65,0x65,0x1,0x1)		// Processor I/F.
				    IO(Decode16,0x67,0x67,0x1,0x1)		// Processor I/F.
				    IO(Decode16,0x70,0x70,0x1,0x1)		// NMI Enable.
				    IO(Decode16,0x80,0x80,0x1,0x1)		// Port 80h.
				    IO(Decode16,0x92,0x92,0x1,0x1)		// Processor I/F.
				    IO(Decode16,0xB2,0xB2,0x01,0x02)	// Software SMI.
				    IO(Decode16,0x680,0x680,0x1,0x20)	// 32 Byte I/O.    
				    // IO(Decode16,0x500,0x500,0x1,0xFF)	// GPIO Base.  // Denverton AptioV Override - EIP#397173
				    // BIOS ROM shadow memory range
				    Memory32Fixed(ReadOnly, 0x000E0000, 0x20000)
				
				    // BIOS flash
				    Memory32Fixed(ReadOnly,0xFF800000,0x800000)
				  })
				
				  Method (_CRS, 0, Serialized)
				  {
				    return(LPCR)
				  }// End _CRS
				}
				
				Device(RTC) // RTC
				{
				  Name(_HID,EISAID("PNP0B00"))
				
				  Name(_CRS,ResourceTemplate()
				  {
				    IO(Decode16,0x70,0x70,0x01,0x08)
				    IRQNoFlags() {8}
				  })
				}
				
				Device(TIMR)    // 8254 Timer
				{
				  Name(_HID,EISAID("PNP0100"))
				
				  Name(_CRS,ResourceTemplate()
				  {
				    IO(Decode16,0x40,0x40,0x01,0x04)
				    IO(Decode16,0x50,0x50,0x10,0x04)
				    IRQNoFlags() {0}
				  })
				}
				
				
				Device(CPLD)  //CPLD
				{
				  Name(_HID,EISAID("CPLD000"))
				
				  Method(_STA,0,Serialized)
				  {
				    Return(0x00)        //G160-004(5)       Return(CPLS)
				  }
				
				  Name(_CRS,ResourceTemplate()
				  {
				    Interrupt (ResourceConsumer, Level, ActiveLow, Exclusive) {0x33}
				  })
				}
				
				
				// Denverton AptioV override Start - EIP#434299
				// To prevent reporting of Legacy UARTs to OS, when HSUART_MODE = PCIE
				#if defined(HSUART_MODE) && (HSUART_MODE ==1)
				
				Device(IUR3) // Internal UART 1
				{
				  Name(_HID, EISAID("PNP0501"))
				
				  Name(_UID,1)
				
				  // Status Method for internal UART 1.
				
				  Method(_STA,0,Serialized)
				  {
				    Return(HUS1)
				  }
				
				  // Current Resource Setting Method for internal UART 1.
				
				   Method(_CRS,0,Serialized)
				  {
				    // Create the Buffer that stores the Resources to
				    // be returned.
				    Name(BUF0,ResourceTemplate()
				        {
				        //COM1
				        IO(Decode16,0x03F8,0x03F8,0x01,0x08)      
				        Interrupt (ResourceConsumer, Level, ActiveLow, Shared) {16}
				        }) 
				
				    Name(BUF1,ResourceTemplate()
				        {
				        //COM1
				        IO(Decode16,0x03F8,0x03F8,0x01,0x08)      
				        IRQ(Level,ActiveLow,Shared) {11}
				        })      
				        
				    If(\_OSI("Linux")){
				       Return(BUF0)
				    }
				    Else {
				        Return(BUF1)
				    }   
				  }
				}
				
				Device(IUR4) // Internal UART 2
				{
				  Name(_HID, EISAID("PNP0501"))
				  Name(_UID,2)
				  // Status Method for internal UART 2.
				  Method(_STA,0,Serialized)
				  {
				    Return(HUS2)
				  }
				  // Current Resource Setting Method for internal UART 2.
				  Method(_CRS,0,Serialized)
				  {
				    // Create the Buffer that stores the Resources to
				    // be returned.
				    Name(BUF0,ResourceTemplate()
				    {
				      //COM2
				      IO(Decode16,0x02F8,0x02F8,0x01,0x08)
				      Interrupt (ResourceConsumer, Level, ActiveLow, Shared) {17}
				    })
				  
				  Name(BUF1,ResourceTemplate()
				    {
				      //COM2
				      IO(Decode16,0x02F8,0x02F8,0x01,0x08)
				      IRQ(Level,ActiveLow,Shared) {10}   // Denverton AptioV Override - EIP#396561
				    })
				  
				    If(\_OSI("Linux")){
				       Return(BUF0)
				    }
				    Else {
				        Return(BUF1)
				    }   
				  }
				}
				
				Device(IUR5) // Internal UART 3
				{
				  Name(_HID, EISAID("PNP0501"))
				  Name(_UID,3)
				  // Status Method for internal UART 3.
				  Method(_STA,0,Serialized)
				  {
				    Return(HUS3)
				  }
				  // Current Resource Setting Method for internal UART 3.
				  Method(_CRS,0,Serialized)
				  {
				    // Create the Buffer that stores the Resources to
				    // be returned.
				    Name(BUF0,ResourceTemplate()
				    {
				      //COM3
				      IO(Decode16,0x03E8,0x03E8,0x01,0x08)
				      Interrupt (ResourceConsumer, Level, ActiveLow, Shared) {18}
				    })
				  
				  Name(BUF1,ResourceTemplate()
				    {
				      //COM3
				      IO(Decode16,0x03E8,0x03E8,0x01,0x08)
				      IRQ(Level,ActiveLow,Shared) {6}   // Denverton AptioV Override - EIP#396561
				    })
				  
				    If(\_OSI("Linux")){
				       Return(BUF0)
				    }
				    Else {
				        Return(BUF1)
				    }
				  }
				}
				#endif
				// Denverton AptioV override End - EIP#434299
				// Removing the ASL device of ME UART. Having this will show yellow bang in windows.
				/*
				Device(IUR6) // Internal UART 4
				{
				  Name(_HID, EISAID("PNP0501"))
				  Name(_UID,4)
				  // Status Method for internal UART 4.
				  Method(_STA,0,Serialized)
				  {
				    Return(HUS4)
				  }
				  // Current Resource Setting Method for internal UART 4.
				  Method(_CRS,0,Serialized)
				  {
				    // Create the Buffer that stores the Resources to
				    // be returned.
				    Name(BUF0,ResourceTemplate()
				    {
				      //COM4
				      IO(Decode16,0x02E8,0x02E8,0x01,0x08)
				      Interrupt (ResourceConsumer, Level, ActiveLow, Shared) {19}
				    })
				  
				  Name(BUF1,ResourceTemplate()
				    {
				      //COM4
				      IO(Decode16,0x02E8,0x02E8,0x01,0x08)
				      IRQ(Level,ActiveHigh,Shared) {7}
				    })
				    
				  If(\_OSI("Linux")){
				       Return(BUF0)
				    }
				    Else {
				        Return(BUF1)
				    }
				  }
				}
				*/
				// Denverton AptioV override End - EIP#288063
				
				// JTAG device 0
				//
				Device (ASD0)
				{
				  Name (_HID, EISAID ("ASD0001"))
				  Name (_UID, 0)
				
				  Method (_STA, 0, NotSerialized)
				  {
				    // Only if A21
				    //
				    If (LEqual (BDID, BIRD_KEY_BOARD_ID))
				    {
				        Return (0x0F)
				    }
				
				    Else
				    {
				        Return (0x00)
				    }
				  }
				}
				
				// JTAG device 1
				//
				Device (ASD1)
				{
				  Name (_HID, EISAID ("ASD0001"))
				  Name (_UID, 1)
				
				  Method (_STA, 0, NotSerialized)
				  {
				    // Only if A21
				    //
				    If (LEqual (BDID, BIRD_KEY_BOARD_ID))
				    {
				        Return (0x0F)
				    }
				
				    Else
				    {
				        Return (0x00)
				    }
				  }
				}
				
				// JTAG device 2
				//
				Device (ASD2)
				{
				  Name (_HID, EISAID ("ASD0001"))
				  Name (_UID, 2)
				
				  Method (_STA, 0, NotSerialized)
				  {
				    // Only if A21
				    //
				    If (LEqual (BDID, BIRD_KEY_BOARD_ID))
				    {
				        Return (0x0F)
				    }
				
				    Else
				    {
				        Return (0x00)
				    }
				  }
				}
				
				// ESPI device
				//
				Device (ESPI)
				{
				  Name (_HID, EISAID ("ASD1001"))
				  Name (_UID, 0)
				
				  Method (_STA, 0, NotSerialized)
				  {
				    // Only if A21
				    //
				    If (LEqual (BDID, BIRD_KEY_BOARD_ID))
				    {
				        Return (0x0F)
				    }
				
				    Else
				    {
				        Return (0x00)
				    }
				  }
				}
				
				// GPIO device
				//
				Device (GPDV)
				{
				  Name (_HID, EISAID ("ASD2001"))
				  Name (_UID, 0)
				
				  Method (_STA, 0, NotSerialized)
				  {
				    // Only if A21
				    //
				    If (LEqual (BDID, BIRD_KEY_BOARD_ID))
				    {
				        Return (0x0F)
				    }
				
				    Else
				    {
				        Return (0x00)
				    }
				  }
				}

				/*++
				
				Copyright (c) 1996 - 2012, Intel Corporation.
				
				This source code and any documentation accompanying it ("Material") is furnished
				under license and may only be used or copied in accordance with the terms of that
				license.  No license, express or implied, by estoppel or otherwise, to any
				intellectual property rights is granted to you by disclosure or delivery of these
				Materials.  The Materials are subject to change without notice and should not be
				construed as a commitment by Intel Corporation to market, license, sell or support
				any product or technology.  Unless otherwise provided for in the license under which
				this Material is provided, the Material is provided AS IS, with no warranties of
				any kind, express or implied, including without limitation the implied warranties
				of fitness, merchantability, or non-infringement.  Except as expressly permitted by
				the license for the Material, neither Intel Corporation nor its suppliers assumes
				any responsibility for any errors or inaccuracies that may appear herein.  Except
				as expressly permitted by the license for the Material, no part of the Material
				may be reproduced, stored in a retrieval system, transmitted in any form, or
				distributed by any means without the express written consent of Intel Corporation.
				
				
				Module Name:
				
				  IpmiOprRegions.asi
				
				Abstract:
				
				  This ASL file contains data definitions and methods to send commands
				  and return data from the BMC
				
				  The "IPMC" device is defined in this file.
				
				--*/
				
				External(IPEN)
				
				Device(IPMC)
				{
				
				    // Config DWord, modified during POST
				    // Bit definitions are the same as PPMFlags:
				    // [00]    = Plug and Play BMC Detection enabled in setup
				    // [31:01] = Reserved    = 0
				  
				    Name(ECFL, 0x80000000)
				  
				    //
				    // output:  0 for report it (LongHorn/Vista/Win2k3+SP1 with setup enable)
				    //          1 Don't report it
				
				    Name(OSNV, Ones)  // Global Name, returns current OS version ID
				
				    Method(OSNF, 0) 
				    {
				        // OS version was already detected
				        if(LNotEqual(OSNV, Ones)) 
				        {
				          Return(OSNV)
				        }
				
				        // default - Don't support IPMI OS
				        Store(1, OSNV)
				 
				        // Detect currently running OS
				        if(CondRefOf(\_OSI,Local1)) 
				        {
				          if (\_OSI("Windows 2008"))
				          {  
				             // Longhorn
				             Store( 0, OSNV)
				          }
				          if (\_OSI("Windows 2007"))
				          { 
				            // Longhorn
				            Store( 0, OSNV)
				          }
				          if (\_OSI("Windows 2006")) 
				          { 
				            // LongHorn and Vista
				            Store( 0, OSNV)
				          }
				          // Win2k3+SP1 or winxp
				          if (\_OSI("Windows 2001.1 SP1")) 
				          {
				            if (And(ECFL, 0x01)) 
				            {
				              // Report IPMI
				              Store(0, OSNV) 
				            }
				          }
				        } else {
				          Store(1, OSNV)
				        }
				
				        Return(OSNV)
				    }	// end of OSNF
				
				
				    // Return the interface specification revision
				    Method(_SRV)
				    {
				        // IPMI Specification Revision v2.0
				        Return(0x0200)                  
				    }
				
				    Method(_STA, 0) 
				    { 
				        //
				        // Check if IPMI is supported
				        //
				        If (LEqual(IPEN, 0)) {
				          Return(0)
				        }
				
				        Store (0, Local0)
				        //
				        // Windows 2003 or Longhorn
				        //
				        if(LEqual(OSNF,0)) 
				        {
				          // Device is present/enabled to decode its resources/UI/functioning
				          Store (0xF, Local0)
				        }
				
				        Return(Local0)	
				        // Bit 0 - Set if the device is present.
				        // Bit 1 - Set if the device is enabled and decoding its resources.
				        // Bit 2 - Set if the device should be shown in the UI.
				        // Bit 3 - Set if the device is functioning properly (cleared if the device failed its diagnostics).
				        // Bit 4 - Set if the battery is present.
				        // Bit 5 - Reserved (must be cleared).
				    }   // end of _STA
				
				    // Return the x86 resources consumed by BMC
				    Name(_CRS, ResourceTemplate()
				    {
				        // SMS Uses 8-bit ports 0xCA8, 0xCAC
				        IO(Decode16, 0xCA8, 0xCA8, 0, 1)
				        IO(Decode16, 0xCAC, 0xCAC, 0, 1)           
				    })
				
				    Name(_HID, "IPI0001")		        // IPMI device
				    Name(_IFT, 0x1)                 // KCS system interface type
				    Name(_STR, Unicode("IPMI_KCS"))
				
				    Name(_UID, 0)  // First interface.
				
				    // KCS SMM area
				    OperationRegion(IPMS, SystemIO, 0xCA0, 0x08)
				
				    // These are the App NetFn commands that ASL will use
				    // App Network Function (0x06), 256 possible commands
				    OperationRegion(APPN, SystemIO, 0x0600, 0x100)
				    Field(APPN, BufferAcc, NoLock, Preserve)
				    {
				        Offset(0x06),       // Skip to 0x06
				        SPWS, 8,            // 0x06 - Set ACPI Power State
				        GPWS, 8             // 0x07 - Get ACPI Power State
				    }
				
				    // Method to Set ACPI Power State
				    Method(SPWM, 2, Serialized)
				    {
				        // Create the command/response data buffer
				        Name(BUFF, Buffer (66) {})
				
				        // Header
				        CreateByteField(BUFF, 0, STAT)      // Status (Byte)
				        CreateByteField(BUFF, 1, LENG)      // Length (Byte)
				
				        // Payload
				        CreateByteField(BUFF, 2, SPST)      // System power status (Byte)
				        CreateByteField(BUFF, 3, DPST)      // Device power status (Byte)
				
				        // Set command parameters
				        Store(2, LENG)                      // Request message is 2 bytes long
				        Store(Arg0, SPST)                   // System power state
				        Store(Arg1, DPST)                   // Device power state
				
				        // Write the request (inner Store), read response (outer Store)
				        Store(Store(BUFF, SPWS), BUFF)
				
				        // Redefine buffer bytes for response data
				        CreateByteField(BUFF, 2, CMPC)          // Completion code (Byte)
				
				        // If completion code and status are both 0
				        If( LAnd ( LEqual(STAT, 0), LEqual(CMPC, 0) ) )
				        {
				            Return(0)
				        }
				
				        // Else return the completion code
				        Else
				        {
				            Return(CMPC)        
				        }
				    }
				
				    // Method to Get ACPI Power State
				    Method(GPWM, 0, Serialized)
				    {
				        // Create the command/response data buffer
				        Name(BUFF, Buffer (66) {})
				
				        // Create the buffer to hold return data
				        Name(OBUF, Buffer (3) {})
				
				        // Header
				        CreateByteField(BUFF, 0, STAT)      // Status (Byte)
				        CreateByteField(BUFF, 1, LENG)      // Length (Byte)
				
				        // Set command parameters
				        Store(0, LENG)                      // No command parameters
				
				        // Write the request (inner Store), read response (outer Store)
				        Store(Store(BUFF, GPWS), BUFF)
				
				        // Define buffer bytes for response data
				        CreateByteField(BUFF, 2, CMPC)      // Completion code (Byte)
				        CreateByteField(BUFF, 3, SPST)      // System power status (Byte)
				        CreateByteField(BUFF, 4, DPST)      // Device power status (Byte)
				
				        // Define output buffer bytes
				        CreateByteField(OBUF, 0, COMP)      // Completion code (Byte)
				        CreateByteField(OBUF, 1, SYSP)      // System power state (Byte)
				        CreateByteField(OBUF, 2, DEVP)      // Device power state (Byte)
				
				        // Copy from command/response buffer to output buffer
				        Store(CMPC, COMP)
				        Store(SPST, SYSP)
				        Store(DEVP, DPST)
				
				        // If status is not 0
				        If( LNotEqual(STAT, 0) )
				        {
				            // Store "Command response could not be provided"
				            //  as completion code
				            Store(0xCE, COMP)
				        }
				
				        // Return output buffer
				        Return(OBUF)
				
				    }
				
				} // end of  Device(IPMC)
				
				

				/*++
				  This file contains an 'Intel Peripheral Driver' and is        
				  licensed for Intel CPUs and chipsets under the terms of your  
				  license agreement with Intel or your vendor.  This file may   
				  be modified by the user, subject to additional terms of the   
				  license agreement                                             
				--*/
				//
				//  Copyright (c)  2001 - 2013 Intel Corporation.  All rights reserved.
				//
				//  This software and associated documentation (if any) is furnished under
				//  a license and may only be used or copied in accordance with the terms
				//  of the license.  Except as permitted by such license, no part of this
				//  software or documentation may be reproduced, stored in a retrieval system,
				//  or transmitted in any form or by any means without the express written
				//  consent of Intel Corporation.
				//
				//*************************************************************
				//  Filename:  SIO.asi
				//
				//  ACPI ASL source file for Super IO device
				//
				//
				//  This section defines the
				//  OperationRegion necessary for this i/o.
				//
				
				
				//------------------------------------------------------------------------
				// !!! BELOW ARE GENERIC SIO CONTROL METHODS. DO NOT REQUIRE MODIFICATIONS
				//----------------------------------------------------------------------
				//  Set of Field names to be used to access SIO configuration space.
					OperationRegion(SMCF,	//Name of Operation Region for SuperIO device
						SystemIO,	//Type of address space
						0x2E,		//Offset to start of region
						2)		//Size of region in bytes
								//End of Operation Region
					Field(SMCF, ByteAcc, NoLock,Preserve){
						INXF, 8,	//Field named INDX is 8 bit wide
						DATF, 8 	//Field DATA is 8 bit wide
					}
				
				//----------------------------------------------------------------------
				//  Set of Field names to be used to access SIO configuration space.
				//----------------------------------------------------------------------
					IndexField(INXF, DATF, ByteAcc, NoLock, Preserve){
						// Global Configuration Registers:
						//
						Offset(7),
						LDNF, 8,  // Logical Device Number
				
						Offset(0x20),
						DIDF, 8, // Super IO Device ID register
				
						//
						// Per-Device Configuration Registers:
						//
						Offset(0x30),
						ACTF, 8, // Active register
				
						Offset(0x60),
						AHFF, 8, // Primary i/o base address, high byte
						ALFF, 8, //  low byte
				
						Offset(0x70),
						INTF, 8, // Primary IRQ register
				
						Offset(0x71),
						INSF, 8, // IRQ type select (some devices)
				
						Offset(0x74),
						DMCF, 8, // Primary DMA channel (some devices)
					}			//End of indexed field
				
				
				//------------------------------------------------------------------------
				// Enter Config Mode, Select LDN
				// Arg0 : Logical Device number
				//------------------------------------------------------------------------
				
					Method(ENFF, 1){
						Store(0xa5, INXF)
				        Store(0xa5, INXF)
						Store(Arg0, LDNF)	//Select LDN
					}
				
				
				//------------------------------------------------------------------------
				// Exit Config Mode
				//------------------------------------------------------------------------
					Method(EXFF, 0){
						Store(0xaa, INXF)
					}
				
				
				/*++
				  This file contains an 'Intel Peripheral Driver' and is        
				  licensed for Intel CPUs and chipsets under the terms of your  
				  license agreement with Intel or your vendor.  This file may   
				  be modified by the user, subject to additional terms of the   
				  license agreement                                             
				--*/
				//  Copyright (c)  2001 - 2015 Intel Corporation.  All rights reserved.
				//
				//  This software and associated documentation (if any) is furnished under 
				//  a license and may only be used or copied in accordance with the terms 
				//  of the license.  Except as permitted by such license, no part of this 
				//  software or documentation may be reproduced, stored in a retrieval system, 
				//  or transmitted in any form or by any means without the express written 
				//  consent of Intel Corporation.
				//
				//*************************************************************
				//  Filename:  SOL.asi
				//
				//  File contains ASL source code to control a typical UART/COM port
				//
				//*************************************************************
				//
				
				
				//
				// Check Check Global NVS flag to see if SOL is supported.
				//
				Method(NOSL) {
				
				    //
				    // Check if IPMI support is enabled
				    //
				    If (IPEN) {
				        Return(0x00)
				    }
				    Else {
				        Return(0x01)
				    }     
				}
				// Denverton AptioV override start - EIP#258527
				// Renaming UAR1 to CUR1 (Chipset UART 1) to avoid name colision from COM in SIO modules
				Device(CUR1) {  // 550A COM Port
				// Denverton AptioV override end - EIP#258527
				    
				    NAME(_HID, EISAID("PNP0501"))  // PnP Device ID
					Name(_UID, 3)			// Generic ID for COMA
				
				    //*****************************************************
				    // Method _STA:  Return Status
				    //*****************************************************
				    Method(_STA,0,NotSerialized) { // Return Status of the UART
				
				        //
				        // Check if SOL is disabled and if it is then return 0 to effectively
				        // hide serial from the OS.
				        //
				        If (NOSL()){
				           Return (0x00)
				        }
				
				        // Enter Configuration Mode and Select the UART1 (Logical Device #2)
				        ENFF(0x02)
				
				        //
				        // First, read the Activate register.
				        // If this register is TRUE, then that means
				        // that the device is Present & Active.
				        //
				        If (ACTF) {
				            // Leave Configuration Mode
				            EXFF()
				
				            // Return result -- 
				            //      Device is Present & Active
				            //      did *NOT* fail self-test
				            //      SHOULD be shown to user
				            Return(0x0F)
				        } 
				        
				        //
				        // OK, so the device isn't Active, so check
				        // and see if it's at least Present.
				        //
				        Else {
				            //
				            // If the I/O Address is non-zero, then the device
				            // is Present.  Test for zero by OR'ing together
				            // the high and low bytes of the address.
				            //
				            If (LOr(AHFF,ALFF)) {
				                // Leave Configuration Mode
				                EXFF()
				
				                //
				                // Return result -- 
				                //      Device is Present, but not Active
				                //      did *NOT* fail self-test
				                //      SHOULD be shown to user
				                //
				                Return(0x0D)
				            }
				
				            Else {
				                // Leave Configuration Mode
				                EXFF()
				
				                // Return result -- Device not even Present 
				                Return(0x00)
				            }
				        }
				    } // end of Method _STA    
				
				
				    //*****************************************************
				    //  Method _DIS:  Disable the device    
				    //*****************************************************
				    Method(_DIS,0,NotSerialized) { // Disable Method 
				        // Enter Configuration Mode and Select the UART1 (Logical Device #2)
				        ENFF(0x02)
				        
				        // Set the Activate Register to zero to disable device
				        Store(0x00,ACTF)
				
				        // Leave Configuration Mode
				        EXFF()
				    }
				
				    //*****************************************************
				    //  Method _CRS:  Return Current Resource Settings
				    //*****************************************************
				    Method(_CRS,0,Serialized) { 
				        Name(BUF0,ResourceTemplate()
				            {
				            IO(Decode16,0x3F8,0x3F8,0x08,0x08)
				            IRQNoFlags(){4}
				            })
				        //
				        // Create some ByteFields in the Buffer in order to
				        // permit saving values into the data portions of
				        // each of the descriptors above.
				        //
				        CreateByteField (BUF0, 0x02, IOLO) // IO Port Low
				        CreateByteField (BUF0, 0x03, IOHI) // IO Port Hi
				        CreateByteField (BUF0, 0x04, IORL) // IO Port Low
				        CreateByteField (BUF0, 0x05, IORH) // IO Port High
				        CreateWordField (BUF0, 0x09, IRQL) // IRQ
				        
				        // Enter Configuration Mode and Select the UART1 (Logical Device #2)
				        ENFF(0x02)
				
				        //
				        // Get the IO setting from the chip, and copy it
				        // to both the min & max for the IO descriptor.
				        //
				        
				        // Low Bytes:
				        Store(ALFF, IOLO)    // min.
				        Store(ALFF, IORL)    // max.
				
				        // High Bytes:
				        Store(AHFF, IOHI)   // min.
				        Store(AHFF, IORH)   // max.
				
				        //
				        // Get the IRQ setting from the chip, and shift
				        // it into the Descriptor byte.
				        //
				        Store(0x01,Local0)
				        ShiftLeft(Local0,INTF,IRQL)
				
				        // Leave Configuration Mode
				        EXFF()
				        Return(BUF0) // return the result
				    
				    } // end _CRS Method
				
				    //*****************************************************
				    //  Method _PRS:  Return Possible Resource Settings
				    //*****************************************************
				    Method(_PRS, 0, Serialized)          // Possible Resource
				    {
				       Name(BUF0,ResourceTemplate()
				       {
				         // Good configuration for Legacy O/S and sub-optional for ACPI O/S
				         StartDependentFn(0,2)
				         {
				          IO(Decode16,0x3E8,0x3E8,0x01,0x08) 
				          IRQNoFlags(){5}
				         }
				         EndDependentFn()
				       })
				
				      Return(BUF0)      // Return Buf0 
				    }                 // End _PRS
				
				        
				
				    //*****************************************************
				    //  Method _SRS:  Set Resource Setting
				    //*****************************************************
				    Method(_SRS,1,NotSerialized) {    // Set Resource Settings
				        // ARG0 is PnP Resource String to set 
				        
				        //
				        // Define offsets into descriptor to match value 
				        // returned by descriptors in _PRS method
				        //
				        CreateByteField (Arg0, 0x02, IOLO) // IO Port Low
				        CreateByteField (Arg0, 0x03, IOHI) // IO Port Hi
				        
				        CreateWordField (Arg0, 0x09, IRQL) // IRQ
				
				
				        // Enter Configuration Mode and Select the UART (Logical Device #2)
				        ENFF(0x02)
				
				        // Set the IO Base Address
				        Store(IOLO, ALFF)
				        Store(IOHI, AHFF)
				
				        FindSetRightBit(IRQL,INTF)// Set IRQ
				        If (LNotEqual(IRQL,Zero)) {Decrement(INTF)}
				        
				        // Activate the Device
				        Store(0x01,ACTF)
				
				        // Leave Configuration Mode
				        EXFF()
				
				    } // end _SRS Method
				
				// Since the (WOR) Wake on Modem Ring is not required
				// remove the '_PRW' and 'WOR from S5'.
				/*
				//Implement the serial port 1 _PRW method (GPE 0x08 - ICH9 RI wake from S5).    
				    //_*****************************************************
				    //  Method _PRW:  Power Resources for Wake
				    //_***************************************************** 
				    // GPE 0x08 - ICH9 RI wake from S5.
				    //
				    Name(_PRW,Package(){0x08,0x05})
				//
				*/
				//
				
				} // end of Device UAR1        
				
				// end of file SOL.ASI
				

				
				
				

	
	//---------------------------------------------------------------------------
	// Begin SIO Device behind LPC brg object scope
	//---------------------------------------------------------------------------
				Device(SIO1) {
					Name(_HID, EISAID("PNP0C02"))	// System board resources device node ID
					Name(_UID,0x0)	// Unique ID
				
	//---------------------------------------------------------------------------
	//Include file(s) for the device NCT6683D
	//---------------------------------------------------------------------------
					// THIS FILE IS INCLUDED to South Bridge device scope
					//*************************************************************************
					//*************************************************************************
					//**                                                                     **
					//**        (C)Copyright 1985-2013, American Megatrends, Inc.            **
					//**                                                                     **
					//**                       All Rights Reserved.                          **
					//**                                                                     **
					//**      5555 Oakbrook Parkway, Suite 200, Norcross, GA 30093           **
					//**                                                                     **
					//**                       Phone: (770)-246-8600                         **
					//**                                                                     **
					//*************************************************************************
					//*************************************************************************
					//<AMI_FHDR_START>
					//
					// Name:  <NCT6683DDEV.asl>
					//
					// Description: Define SIO Device for ACPI OS.
					//
					//<AMI_FHDR_END>
					//*************************************************************************
					//Scope(\_SB.PCI0.SBRG) {
					//-----------------------------------------------------------------------
					// SET OF COMMON DATA/CONTROL METHODS USED FOR ALL LDN BASED SIO DEVICES
					//-----------------------------------------------------------------------
					// LIST of objects defined in this file:
					// SIO specific: SIOR - Device node (_HID=0c02, UID=SPIO), SIO index/DAta IO access & SIO GPIO address space if available
					// SIO specific: DCAT - Table correspondence the LDNs to Device order in Routing Table.
					// SIO specific: ENFG & EXFG - Control methods to Enter and Exit configuration mode. ENFG & EXFG correspondingly
					// SIO specific: LPTM - current parralel port mode
					// SIO specific: UHID - PnP ID for given Serial port
					// SIO specific: SIOS - SIO Chipset specific code called from _PTS
					// SIO specific: SIOW - SIO Chipset specific code called from _WAK
					// SIO specific: SIOH - SIO event handler, to be called from correspondent _Lxx method
					// SIO specific: PowerResources & _PR0 object to control Power management for FDC, LPT, UART1,2.
					//
					// Generic :OpRegion & common Fields to access SIO configuration space
					// Generic :CGLD - Convert Device category to LDN
					// Generic :DSTA - Get device status according to ACTR register in LD IO space
					// Generic :DCNT - Enable/Disable Decoding of Device resources, Route/Release resources to LPC bus
					// Generic :DCRS - Returns Byte stream of device's Current resources
					// Generic :DSRS - Configures new Resources to be decoded by a Device
					// Device node:Motherboard resources
					// SIO index/DAta IO access & SIO GPIO address space if available
					//====================================================================================
					//Following commented line will be included in PciTree.asl 
					//Device(SIO1) {
					//    Name(_HID, EISAID("PNP0C02"))       // System board resources device node ID
					//    Name(_UID,0x111)                    // Unique ID. First IO use 0x111, Second IO use 0x222 ...
					//====================================================================================
					    Name(CRS, ResourceTemplate(){
					        IO(Decode16, 0, 0, 0, 0, IOI)   // Index/Data Io address
					        IO(Decode16, 0, 0, 0, 0, IO1)   // GP IO space
					        IO(Decode16, 0, 0, 0, 0, IO2)   // PME IO space
					        IO(Decode16, 0, 0, 0, 0, IO3)   // HWM IO space
					    }) // end CRS
					
					    Method (_CRS, 0){
					        // Reserve Super I/O Configuration Port
					        // 0x0 to 0xF0 already reserved
					        // 0x3F0 - 0x3F1 are reserved in FDC
					        If(LAnd(LLess(SP1O, 0x3F0), LGreater(SP1O, 0x0F0))){
					            CreateWordField(CRS, ^IOI._MIN, GPI0)
					            CreateWordField(CRS, ^IOI._MAX, GPI1)
					            CreateByteField(CRS, ^IOI._LEN, GPIL)
					            Store(SP1O, GPI0)    //Index/Data Base address
					            Store(SP1O, GPI1)
					            Store(0x02, GPIL)    //IO range
					        }
					
					        // Reserve SIO GP IO space
					        If(IO1B){
					            CreateWordField(CRS, ^IO1._MIN, GP10)
					            CreateWordField(CRS, ^IO1._MAX, GP11)
					            CreateByteField(CRS, ^IO1._LEN, GPL1)
					            Store(IO1B, GP10)    //GP IO base address
					            Store(IO1B, GP11)
					            Store(IO1L, GPL1)    //IO range
					        }
					
					        // Reserve SIO PME IO space
					        If(IO2B){
					            CreateWordField(CRS, ^IO2._MIN, GP20)
					            CreateWordField(CRS, ^IO2._MAX, GP21)
					            CreateByteField(CRS, ^IO2._LEN, GPL2)
					            Store(IO2B, GP20)    //PME IO base address
					            Store(IO2B, GP21)
					            Store(IO2L, GPL2)    //IO range
					        }
					        
					        // Reserve SIO HWM IO space
					        If(IO3B){
					            CreateWordField(CRS, ^IO3._MIN, GP30)
					            CreateWordField(CRS, ^IO3._MAX, GP31)
					            CreateByteField(CRS, ^IO3._LEN, GPL3)
					            Store(IO3B, GP30)    //HWM IO base address
					            Store(IO3B, GP31)
					            Store(IO3L, GPL3)    //IO range
					        }
					        Return(CRS)
					    }    //End _CRS
					
					    //---------------------------------------------------------------------
					    // Table correspondence the LDNs to Device order in Routing Table
					    // Device type selection is achieved by picking the value from DCAT Package by Offset = LDN
					    //----------------------------------------------------------------------
					    // Elements in the package contain LDN numbers for each category of devices.
					    // Default value 0xFF -> no device present.
					    // Make sure number of elements not less or equal to largest LDN
					    Name (DCAT, Package(0x15){
					    // AMI_TODO: fill the table with the present LDN
					    // LDN number, 0xFF if device not present
					    // We keep category 0x00~0x0F as SIO_DEV_STATUS layout in AmiGenericSio.h to Update IOST 
					        0x02,    // 0x00 - Serial A (SP1)
					        0x03,    //   01 - Serial B (SP2)
					        0x01,    //   02 - LPT
					        0xFF,    //   03 - FDD
					        0xFF,    //   04 - SB16 Audio
					        0xFF,    //   05 - MIDI
					        0xFF,    //   06 - MSS Audio
					        0xFF,    //   07 - AdLib sound (FM synth)
					        0xFF,    //   08 - Game port #1
					        0xFF,    //   09 - Game port #2
					        0x05,    //   0A - KBC 60 & 64
					        0xFF,    //   0B - EC 62 & 66
					        0xFF,    //   0C - Reserved 
					        0xFF,    //   0D - Reserved
					        0x05,    //   0E - PS/2 Mouse
					        0xFF,    //   0F - Reserved
					//----add your other device,if no,please cut and modify Package number----------//
					        0x06,    //   10 - CIR
					        0xFF,    //   11 - Serial C (SP3) 
					        0xFF,    //   12 - Serial D (SP4)
					        0xFF,    //   13 - Serial E (SP5)
					        0xFF,    //   14 - Serial F (SP6)
					    })
					
					    //---------------------------------------------------------------------
					    // Mutex object to sincronize the access to Logical devices
					    //---------------------------------------------------------------------
					    Mutex(MUT0, 0)    
					
					    //---------------------------------------------------------------------
					    // Enter Config Mode, Select LDN
					    // Arg0 : Logical Device number
					    //---------------------------------------------------------------------
					    Method(ENFG, 1) {
					        Acquire(MUT0, 0xFFF)
					        //AMI_TODO: enter config mode and Select LDN.
					        Store(ENTK, INDX)
					        Store(ENTK, INDX)
					        Store(Arg0, LDN)    //Select LDN
					    }
					
					    //---------------------------------------------------------------------
					    // Exit Config Mode
					    //---------------------------------------------------------------------
					    Method(EXFG, 0) {
					        //AMI_TODO: exit config mode
					        Store(EXTK, INDX)
					        Release(MUT0)
					    }
					
					    //---------------------------------------------------------------------
					    // Return current LPT mode : 0-plain LPT, non Zero-ECP mode
					    // Arg0 : Device LDN
					    //---------------------------------------------------------------------
					    Method(LPTM, 1){
					        ENFG(CGLD(Arg0))        //Enter Config Mode, Select LDN
					        //AMI_TODO: if it's ECP mode .
					        And(OPT0, 0x02, Local0) //ECP Mode?
					        EXFG()                  //Exit Config Mode
					        Return(Local0)
					    }
					
					//-------------------------------------------------------------------------
					// !!! BELOW ARE GENERIC SIO CONTROL METHODS. DO NOT REQUIRE MODIFICATIONS
					//-------------------------------------------------------------------------
					
					//<AMI_THDR_START>
					//------------------------------------------------------------------------
					// Name: IOID
					//
					// Type: OperationRegion
					//
					// Description:    Operation Region to point to SuperIO configuration space
					//
					// Notes: OpeRegion address is defined by 'SP1O' global name. 
					//  'SPIO' is a field isnside AML_Exchange data area defined in SDL file.
					//
					// Referrals: BIOS, AMLDATA
					//
					//-------------------------------------------------------------------------
					//<AMI_THDR_END>
					    //---------------------------------------------------------------------
					    //  Set of Field names to be used to access SIO configuration space.
					    //---------------------------------------------------------------------
					    OperationRegion(IOID,   // Name of Operation Region for SuperIO device
					        SystemIO,           // Type of address space
					        SP1O,               // Offset to start of region
					        2)                  // Size of region in bytes
					                            // End of Operation Region
					    Field(IOID, ByteAcc, NoLock,Preserve){
					        INDX, 8,            // Field named INDX is 8 bit wide
					        DATA, 8             // Field DATA is 8 bit wide
					    }
					
					    //---------------------------------------------------------------------
					    //  Set of Field names to be used to access SIO configuration space.
					    //---------------------------------------------------------------------
					    IndexField(INDX, DATA, ByteAcc, NoLock, Preserve){
					        Offset(0x07),
					        LDN, 8,         //Logical Device Number
					
					        Offset(0x21),
					        SCF1, 8,        //Set SCF1 
					        Offset(0x22),
					        SCF2, 8,        //Set SCF2 
					        Offset(0x23),
					        SCF3, 8,        //Set SCF3 
					        Offset(0x24),
					        SCF4, 8,        //Set SCF4 
					        Offset(0x25),
					        SCF5, 8,        //Set SCF5 
					        Offset(0x26),
					        SCF6, 8,        //Set SCF6 
					        Offset(0x29),
					        CKCF, 8,        //Multi Function Select 1 Register
					        Offset(0x30),
					        ACTR, 8,        //Activate register
					        Offset(0x60),
					        IOAH, 8,        //Base I/O High addr
					        IOAL, 8,        //Base I/O Low addr
					        IOH2, 8,        //Base2 I/O High addr
					        IOL2, 8,        //Base2 I/O Low addr
					        Offset(0x70),
					        INTR, 4,        //IRQ
					        INTT, 4,        //IRQ type
					        Offset(0x74),
					        DMCH, 8,        //DMA channel
					        Offset(0xE0),
					        RGE0, 8,        //Option Register E0
					        RGE1, 8,        //Option Register E1
					        RGE2, 8,        //Option Register E2
					        RGE3, 8,        //Option Register E3
					        RGE4, 8,        //Option Register E4
					        RGE5, 8,        //Option Register E5
					        RGE6, 8,        //Option Register E6
					        RGE7, 8,        //Option Register E7
					        RGE8, 8,        //Option Register E8
					        RGE9, 8,        //Option Register E9
					        Offset(0xF0),
					        OPT0, 8,        //Option register 0xF0
					        OPT1, 8,        //Option register 0xF1
					        OPT2, 8,        //Option register 0xF2
					        OPT3, 8,        //Option register 0xF3
					        OPT4, 8,        //Option register 0xF4
					        OPT5, 8,        //Option register 0xF5
					        OPT6, 8,        //Option register 0xF6
					        OPT7, 8,        //Option register 0xF7
					        OPT8, 8,        //Option register 0xF8
					        OPT9, 8,        //Option register 0xF9
					        OPTA, 8,        //Option register 0xFA
					        OPTB, 8,        //Option register 0xFB
					        OPTC, 8,        //Option register 0xFC
					    }        //End of indexed field
					
					//<AMI_PHDR_START>
					//------------------------------------------------------------------------
					// Procedure:    CGLD
					// Description:  Convert Device Category to Device's LDN
					// Input: Arg0 : Device category #
					// Output: LDN
					//-------------------------------------------------------------------------
					//<AMI_PHDR_END>
					    Method(CGLD, 1) {
					        Return(DeRefOf(Index(DCAT, Arg0)))    // Return LDN
					    }
					
					
					//<AMI_PHDR_START>
					//------------------------------------------------------------------------
					// Procedure:    DSTA
					// Description:  GET SIO DEVICE STATUS according to ACTR/IOST(category0x00~0x0F) return values
					//               GET SIO DEVICE STATUS according to ACTR/IOAH+IOAL/IOH2+IOL2(category>0x0F)
					// Input: Arg0 : Device category #
					// Output: Device Status
					//-------------------------------------------------------------------------
					//<AMI_PHDR_END>
					    Method(DSTA, 1) {
					
					        // IO Device presence status is determined during first _STA invocation. 
					        // If "Activate" bit is set during first _STA invocation, IO device 
					        // present status is stored into IOST global variable.
					        // IOST global variable contains the bit mask of all enabled Io devices.
					        ENFG(CGLD(Arg0))        //Enter Config Mode, Select LDN
					        Store(ACTR, Local0)     //Local0=ACTR
					        Or(ShiftLeft(IOAH, 8),IOAL,Local1) //Local1=Base 1
					        EXFG()                            //Exit Config Mode
					
					        // LDN's not decoded, Device not present.
					        If(LEqual(Local0, 0xFF)) {Return(0x0)}    
					
					        //Assume register(ACTR) bit0 is "Active" bit.
					        //AMI_TODO: If register(ACTR) non-bit0 is "Active" bit, change below code.
					        And(Local0, 1, Local0)  //Leave only "Activate" bit
					
					        // IOST only have 16 bits,IOST is for category 0x00~0x0F device
					        If(LLess(Arg0,0x10)) {Or(IOST, ShiftLeft(Local0, Arg0), IOST)}
					
					        // Update IO device status in IOST according to the category#
					        // Note. Once device is detected its status bit cannot be removed
					        If(Local0){ 
					            Return(0x0F)            // Device present & Active
					        }    
					        Else{
					            If(LLess(Arg0,0x10)){//by IOST check
					                // Check if IO device detected in Local0(IOST) bit mask
					                If(And(ShiftLeft(1, Arg0), IOST)){ Return(0x0D)}  // Device Detected & Not Active 
					                // IO bit not set in Local0: device is disabled during first 
					                // _STA(GSTA) invocationor disabled in BIOS Setup.
					                Else{ Return(0x00)}  // Device not present
					            }
					            Else{//by Base1 & Base2 check
					                If(Local1) { Return(0x0D)}  // Device Detected & Not Active
					                Return(0x00) // Device not present
					            }
					        }
					    } // End Of DSTA
					
					//<AMI_PHDR_START>
					//------------------------------------------------------------------------
					// Procedure:    DCNT
					// Description:  Enable/Disable Decoding of Device resources, Route/Release
					//               I/O & DMA Resources From, To EIO/LPC Bus
					// Input: Arg0 : Device catagory #
					//        Arg1 : 0/1 Disable/Enable resource decoding
					// Output:Nothing
					//-------------------------------------------------------------------------
					//<AMI_PHDR_END>
					    Method(DCNT, 2) {
					
					        ENFG(CGLD(Arg0))    //Enter Config Mode, Select LDN
					
					        // Route/Release DMA channel from/to being ISA/PCI mode
					        // Note. DMA channel 0 is currently not decoded, although it can be 
					        // used on some of SIO chipsets.
					        If(LAnd(LLess(DMCH,4), LNotEqual(And(DMCH, 3, Local1),0))){
					            rDMA(Arg0, Arg1, Increment(Local1))
					        }
					
					        Store(Arg1, ACTR)           // Update Activate Register
					        ShiftLeft(IOAH, 8, local1)  // Get IO Base address
					        Or(IOAL, Local1, Local1)
					
					        // Route/Release I/O resources from/to EIO/LPC Bus
					        // Arg0      Device Category
					        // Arg1      0/1 Disable/Enable resource decoding
					        // Arg2      Port to Route/Release
					        // Arg3      Port SIZE to Route 
					        RRIO(Arg0, Arg1, Local1, 0x08)
					
					        EXFG()              // Exit Config Mode
					    } // End DCNT
					
					//<AMI_THDR_START>
					//------------------------------------------------------------------------
					// Name: CRS1,CRS2,CRS3
					//
					// Type: ResourceTemplate
					//
					// Description: Current Resources Buffer for Generic SIO devices
					//
					// Notes: Note. DMA channel 0 is currently decoded as reserved,
					//        although, it can be used on some of SIO chipsets.
					//        Add DMA0 to _PRS if it is used
					//        Generic Resourse template for FDC, COMx, LPT and ECP Current Resource Settings
					//        (to be initialized and returned by _CRS)
					//-------------------------------------------------------------------------
					//<AMI_THDR_END>
					
					// CRS buffer with all kinds of resources
					Name(CRS1, ResourceTemplate(){
					    IO(Decode16, 0, 0, 1, 0, IO01)
					    IRQNoFlags(IRQ1) {}
					    DMA(Compatibility, NotBusMaster, Transfer8, DMA1) {}
					})
					CreateWordField(CRS1, IRQ1._INT, IRQM)    //IRQ mask 0x1
					CreateByteField(CRS1, DMA1._DMA, DMAM)    //DMA 0x4
					CreateWordField(CRS1, IO01._MIN, IO11)    //Range 1 Min Base Word 0x8
					CreateWordField(CRS1, IO01._MAX, IO12)    //Range 1 Max Base Word 0xa
					CreateByteField(CRS1, IO01._LEN, LEN1)    //Length 1 0xd
					
					// Extended CRS buffer with 2 IO ranges
					Name(CRS2, ResourceTemplate(){
					    IO(Decode16, 0, 0, 1, 0, IO02)
					    IO(Decode16, 0, 0, 1, 0, IO03)
					    IRQNoFlags(IRQ2) {}
					        DMA(Compatibility, NotBusMaster, Transfer8, DMA2) {}
					})
					CreateWordField(CRS2, IRQ2._INT, IRQE)    //IRQ mask 0x1
					CreateByteField(CRS2, DMA2._DMA, DMAE)    //DMA 0x4
					CreateWordField(CRS2, IO02._MIN, IO21)    //Range 1 Min Base Word 0x8
					CreateWordField(CRS2, IO02._MAX, IO22)    //Range 1 Max Base Word 0xa
					CreateByteField(CRS2, IO02._LEN, LEN2)    //Length 1 0xd
					CreateWordField(CRS2, IO03._MIN, IO31)    //Range 2 Min Base Word 0x10
					CreateWordField(CRS2, IO03._MAX, IO32)    //Range 2 Max Base Word 0x12
					CreateByteField(CRS2, IO03._LEN, LEN3)    //Length 2 0x15
					
					//<AMI_PHDR_START>
					//------------------------------------------------------------------------
					// Procedure:    DCRS
					// Description:  Get FDC, LPT, ECP, UART, IRDA resources (_CRS)
					//               Returns Byte stream of Current resources. May contain Resources such:
					//               1 IRQ resource
					//               1 DMA resource
					//               1 IO Port
					// Input: Arg0 : Device catagory #
					//        Arg1 : Use/No-Use DMA
					// Output:       _CRS Resource Buffer 
					//-------------------------------------------------------------------------
					//<AMI_PHDR_END>
					    Method(DCRS, 2) {
					        ENFG(CGLD(Arg0))            //Enter Config Mode, Select LDN
					
					        // Write Current Settings into Buffer for 1st IO Descriptor
					        ShiftLeft(IOAH, 8, IO11)    //Get IO Base MSB
					        Or(IOAL, IO11, IO11)        //Get IO Base LSB
					        Store(IO11, IO12)           //Set Max Base Word
					
					        //Store(0x08, LEN1)
					        // adjust base/aligment size if base ports are 0x3bc/0x7bc
					        //If(LEqual(And(IO1L,0xff), 0xbc))
					        //If(And(IO11, 0x04)){
					        //    Store(0x04, LEN1)
					        //}
					        Store(0x08, LEN1)
					
					        // Write Current Settings into IRQ descriptor
					        If(INTR){
					            ShiftLeft(1, INTR, IRQM)
					        } 
					        Else{
					            Store(0, IRQM)          // No IRQ used
					        }
					
					        // Write Current Settings into DMA descriptor
					        // Note. DMA channel 0 is currently decoded as reserved,
					        // although, it can be used on some of SIO chipsets.
					        //If(Or(LGreater(DMCH,3), LEqual(And(DMCH, 3, Local1),0))){
					        If(LOr(LGreater(DMCH,3), LEqual(Arg1, 0))){
					            Store(0, DMAM)          // No DMA
					        } 
					        Else{
					            And(DMCH, 3, Local1)
					            ShiftLeft(1, Local1, DMAM)
					        }
					        EXFG()                      //Exit Config Mode
					        Return(CRS1)                //Return Current Resources
					    }
					
					//<AMI_PHDR_START>
					//------------------------------------------------------------------------
					// Procedure:    DCR2
					// Description:  Get FDC, LPT, ECP, UART, IRDA resources (_CRS)
					//               Returns Byte stream of Current resources. May contain Resources such:
					//               1 IRQ resource
					//               1 DMA resource
					//               2 IO Port
					// Input: Arg0 : Device catagory #
					//        Arg1 : Use/No-Use DMA
					// Output:      _CRS Resource Buffer 
					//-------------------------------------------------------------------------
					//<AMI_PHDR_END>
					    Method(DCR2, 2) {
					        ENFG(CGLD(Arg0))            //Enter Config Mode, Select LDN
					
					        // Write Current Settings into Buffer for 1st IO Descriptor
					        ShiftLeft(IOAH, 8, IO21)    //Get IO Base MSB
					        Or(IOAL, IO21, IO21)        //Get IO Base LSB
					        Store(IO21, IO22)           //Set Max Base Word
					        Store(0x08, LEN2)
					
					        // Write Current Settings into Buffer for 2nd IO Descriptor
					        ShiftLeft(IOH2, 8, IO31)    //Get IO Base MSB
					        Or(IOL2, IO31, IO31)        //Get IO Base LSB
					        Store(IO31, IO32)           //Set Max Base Word
					        Store(0x08, LEN3)
					
					        // Write Current Settings into IRQ descriptor
					        If(INTR){
					            ShiftLeft(1, INTR, IRQE)
					        } 
					        Else{
					            Store(0, IRQE)          // No IRQ used
					        }
					
					        // Write Current Settings into DMA descriptor
					        // Note. DMA channel 0 is currently decoded as reserved,
					        // although, it can be used on some of SIO chipsets.
					        //If(Or(LGreater(DMCH,3), LEqual(And(DMCH, 3, Local1),0))){
					        If(LOr(LGreater(DMCH,3), LEqual(Arg1, 0))){
					            Store(0, DMAE)          // No DMA
					        } Else {
					            And(DMCH, 3, Local1)
					            ShiftLeft(1, Local1, DMAE)
					        }
					
					        EXFG()                      //Exit Config Mode
					        Return(CRS2)                //Return Current Resources
					    }
					
					//<AMI_PHDR_START>
					//------------------------------------------------------------------------
					// Procedure:    DSRS
					// Description:  Set FDC, LPT, ECP, UART, IRDA resources (_SRS)
					//               Control method can be used for configuring devices with following resource order:
					//               1 IRQ resource
					//               1 DMA resource
					//               1 IO Port
					// Input: Arg0 : PnP Resource String to set
					//        Arg1 : Device catagory #
					// Output:       Nothing
					//-------------------------------------------------------------------------
					//<AMI_PHDR_END>
					    Method(DSRS, 2) {
					        If(And(LEqual(Arg1, 0x02),LPTM(Arg1) ) ) {        //LPT logical device? Extended LPT mode ?
					                DSR2(Arg0, Arg1)
					        } Else {
					            //Set resource for other devices from CRS1, or just for Parallel Port LPT Mode
					            CreateWordField(Arg0, ^IRQ1._INT, IRQM)    //IRQ mask 0x1
					            CreateByteField(Arg0, ^DMA1._DMA, DMAM)    //DMA 0x4
					            CreateWordField(Arg0, ^IO01._MIN, IO11)    //Range 1 Min Base Word 0x8
					    
					            ENFG(CGLD(Arg1))            //Enter Config Mode, Select LDN
					    
					            // Set Base IO Address
					            And(IO11, 0xFF, IOAL)       //Set IO Base LSB
					            ShiftRight(IO11, 0x8, IOAH) //Set IO Base MSB
					    
					            // Set IRQ
					            If(IRQM){
					                FindSetRightBit(IRQM, Local0)
					                Subtract(Local0, 1, INTR)
					            }Else{
					                Store(0, INTR)          //No IRQ used
					            }
					    
					            // Set DMA
					            If(DMAM){
					                FindSetRightBit(DMAM, Local0)
					                Subtract(Local0, 1, DMCH)
					            }Else{
					                Store(4, DMCH)          //No DMA
					            }
					    
					            EXFG()                      //Exit Config Mode
					    
					            // Enable ACTR
					            DCNT(Arg1, 1)               //Enable Device (Routing)
					    
					            Store(Arg1, Local2)
					            If (LGreater(Local2, 0)){Subtract(Local2, 1, Local2)}
					        }//Else end
					    }//Method DSRS end
					
					//<AMI_PHDR_START>
					//------------------------------------------------------------------------
					// Procedure:    DSR2
					// Description:  Set FDC, LPT, ECP, UART, IRDA resources (_SRS)
					//               Control method can be used for configuring devices with following resource order:
					//               1 IRQ resource
					//               1 DMA resource
					//               2 IO Port
					// Input: Arg0 : PnP Resource String to set
					//        Arg1 : Device catagory #
					// Output:       Nothing
					//-------------------------------------------------------------------------
					//<AMI_PHDR_END>
					    Method(DSR2, 2) {
					        CreateWordField(Arg0, ^IRQ2._INT, IRQE)    //IRQ mask 0x1
					        CreateByteField(Arg0, ^DMA2._DMA, DMAE)    //DMA 0x4
					        CreateWordField(Arg0, ^IO02._MIN, IO21)    //Range 1 Min Base Word 0x8
					        CreateWordField(Arg0, ^IO03._MIN, IO31)    //Range 1 Min Base Word 0x8
					
					        ENFG(CGLD(Arg1))                //Enter Config Mode, Select LDN
					
					        // Set Base IO Address
					        And(IO21, 0xFF, IOAL)           //Set IO1 Base LSB
					        ShiftRight(IO21, 0x8, IOAH)     //Set IO1 Base MSB
					
					        And(IO31, 0xFF, IOL2)           //Set IO2 Base LSB
					        ShiftRight(IO31, 0x8, IOH2)     //Set IO2 Base MSB
					
					        // Set IRQ
					        If(IRQE){
					            FindSetRightBit(IRQE, Local0)
					            Subtract(Local0, 1, INTR)
					        }Else{
					            Store(0, INTR)              //No IRQ used
					        }
					
					        // Set DMA
					        If(DMAE){
					            FindSetRightBit(DMAE, Local0)
					            Subtract(Local0, 1, DMCH)
					        }Else{
					            Store(4, DMCH)              //No DMA
					        }
					
					        EXFG()                          //Exit Config Mode
					
					        // Enable ACTR
					        DCNT(Arg1, 1)                   //Enable Device (Routing)
					
					        Store(Arg1, Local2)
					        If (LGreater(Local2, 0)){Subtract(Local2, 1, Local2)}
					    }
					
					//====================================================================================
					//Following commented line will be included in PciTree.asl 
					//} // End of SIO1
					//====================================================================================
					//**********************************************************************
					//**********************************************************************
					//**                                                                  **
					//**        (C)Copyright 1985-2013, American Megatrends, Inc.         **
					//**                                                                  **
					//**                       All Rights Reserved.                       **
					//**                                                                  **
					//**      5555 Oakbrook Parkway, Suite 200, Norcross, GA 30093        **
					//**                                                                  **
					//**                       Phone: (770)-246-8600                      **
					//**                                                                  **
					//**********************************************************************
					//**********************************************************************
					// THIS FILE IS INCLUDED to South Bridge device scope

					// THIS FILE IS INCLUDED to South Bridge device scope
					//*************************************************************************
					//*************************************************************************
					//**                                                                     **
					//**        (C)Copyright 1985-2013, American Megatrends, Inc.            **
					//**                                                                     **
					//**                       All Rights Reserved.                          **
					//**                                                                     **
					//**      5555 Oakbrook Parkway, Suite 200, Norcross, GA 30093           **
					//**                                                                     **
					//**                       Phone: (770)-246-8600                         **
					//**                                                                     **
					//*************************************************************************
					//*************************************************************************
					//<AMI_FHDR_START>
					//
					// Name:  <NCT6683DEVT.asl>
					//
					// Description: Define SIO Device for ACPI OS.
					//
					//<AMI_FHDR_END>
					//*************************************************************************
					//Scope(\_SB.PCI0.SBRG) {
					//-----------------------------------------------------------------------
					// SET OF COMMON DATA/CONTROL METHODS USED FOR ALL LDN BASED SIO DEVICES
					//-----------------------------------------------------------------------
					// SIO specific: SIOS - SIO Chipset specific code called from _PTS
					// SIO specific: SIOW - SIO Chipset specific code called from _WAK
					// SIO specific: SIOH - SIO event handler, to be called from correspondent _Lxx method
					// SIO specific: PowerResources & _PR0 object to control Power management for FDC, LPT, UART1,2.
					
					
					//-------------------------------------------------------------------------
					// SIO_PME WAKE UP EVENTS //
					//-------------------------------------------------------------------------
					// Following code is the workaround for wake up on RI/Key/Mouse events
					// are generated by some SuperIO. The wake up signal (SIO_PME) is
					// connected to one of GPIOs of south bridge chip.
					// Make sure the correspondent GPIO in south bridge is enabled to generate an SCI
					//-------------------------------------------------------------------------
					// Add Flag for Fix WakeUp Switch bug. 
					Name(PMFG, 0x00)    //PME wake ststus
					
					//-------------------------------------------------------------------------
					// SIOS - SIO Chipset specific code called from _PTS
					//-------------------------------------------------------------------------
					// input  - Arg0 : Sleep state #
					// output - nothing
					//-------------------------------------------------------------------------
					Method(SIOS, 1){
					    // Aware wake up events in SIO chip
					    Store("SIOS", Debug)
					
					    //AMI_TODO: 
					    // 1. select sleep state
					    If(LNotEqual(0x05, Arg0)){
					        ^ENFG(0x0A)                        //Set Logical Device 0A (PME)
					
					        // 2. clear PME Status
					        Store(0xFF, ^OPT9)   
					        Store(0xFF, ^OPTA) 
					
					        // 3. enable wake-up ; Enable Keyboard, PS/2 Mouse,    UART 1&2 to Generate PME.
					        if(\KBFG){
					            Or(^OPTB, 0x02, ^OPTB)    //enable Keyboard Wake-up bit
					            Or(^RGE4, 0x40, ^RGE4)
					        }        
					        Else{
					            And(^OPTB, 0xFD, ^OPTB)   //disable Keyboard Wake-up bit
					            And(^RGE4, 0xBF, ^RGE4)
					        }
					        if(\MSFG){
					            Or(^OPTB, 0x01, ^OPTB)    //enable Mouse Wake-up bit
					            Or(^RGE4, 0x80, ^RGE4)
					        }        
					        Else{
					            And(^OPTB, 0xFE, ^OPTB)   //disable Mouse Wake-up bit
					            And(^RGE4, 0x7F, ^RGE4)
					        }
					
					        // 4. Enable PME /wakeup
					        Or(^RGE3, 0x01, ^RGE3)
					
					        ^EXFG()
					    }
					}
					
					//-----------------------------------------------------------------------
					// SIOW - SIO Chipset specific code called from _WAK
					//-----------------------------------------------------------------------
					// input  - Sleep State #
					// output - nothing
					//-----------------------------------------------------------------------
					Method(SIOW, 1){
					    Store("SIOW", Debug)
					
					    //AMI_TODO: 
					    ^ENFG(0x0A)                    //Set Logical Device 04 (PME)
					
					    // 1. Clear Status
					    Store(^OPT9, PMFG)             // PMFG=PME  Wake Status
					    And(^OPT9, 0xFF, ^OPT9)   //Clear KBC Wake Event
					
					    // 2. Disable PME
					    And(^RGE3, 0xFE, ^RGE3)
					    And(^OPTB, 0x00, ^OPTB)    
					    And(^OPTC, 0x00, ^OPTC)  
					
					    ^EXFG()
					}
					
					//-----------------------------------------------------------------------
					// SIOH - SIO event handler, to be called from correspondent _Lxx method
					// in order to serve the SIO chipset side of wake up event
					//-----------------------------------------------------------------------
					// input  - nothing
					// output - nothing
					//-----------------------------------------------------------------------
					Method(SIOH, 0){
					    If(And(PMFG, 0x08)){
					        #if NCT6683D_KEYBOARD_PRESENT
					        Notify(PS2K, 0x2)    //KBD Wake up
					        #endif
					    }
					    If(And(PMFG, 0x10)){
					        #if NCT6683D_MOUSE_PRESENT
					        Notify(PS2M, 0x2)    //MOUSE Wake up
					        #endif
					    }
					}    //End Of SIOH
					
					//*************************************************************************
					//*************************************************************************
					//**                                                                     **
					//**        (C)Copyright 1985-2013, American Megatrends, Inc.            **
					//**                                                                     **
					//**                       All Rights Reserved.                          **
					//**                                                                     **
					//**      5555 Oakbrook Parkway, Suite 200, Norcross, GA 30093           **
					//**                                                                     **
					//**                       Phone: (770)-246-8600                         **
					//**                                                                     **
					//*************************************************************************
					//*************************************************************************

	
					Method(_PRW, 0) { Return(GPRW(0x1D, 3)) }	//Can wakeup on SIO Device PME from Sleep 3
				}
	
				Device(UAR1) {
					Name(_HID, EISAID("PNP0501"))	// Com1
					Name(_UID, 0x00)	// Unique ID.
					Name(LDN, 0x02)	// Logical Device Number
				
	//---------------------------------------------------------------------------
	//Include file(s) for the device Com1
	//---------------------------------------------------------------------------
					//*************************************************************************
					//*************************************************************************
					//**                                                                     **
					//**        (C)Copyright 1985-2009, American Megatrends, Inc.            **
					//**                                                                     **
					//**                       All Rights Reserved.                          **
					//**                                                                     **
					//**      5555 Oakbrook Parkway, Suite 200, Norcross, GA 30093           **
					//**                                                                     **
					//**                       Phone: (770)-246-8600                         **
					//**                                                                     **
					//*************************************************************************
					//*************************************************************************
					//
					//*************************************************************************
					// $Header: $
					//
					// $Revision: $
					//
					// $Date: $
					//*************************************************************************
					//<AMI_FHDR_START>
					//
					// Name:  <UART1.ASL>
					//
					// Description: Define ACPI method or namespce For Super IO
					//
					//<AMI_FHDR_END>
					//*************************************************************************
					// UART1 //
					// Category # :0x00
					//Device(UAR1) {
					//  Name(_HID, EISAID("PNP0501"))    //PnP Device ID 16550 Type
					//	Name(_UID, 1)	//Generic ID for COMA
					
					// Use the following if not using SI1P or only have 1 SIO	
					//	Method(_HID, 0)	{Return(^^SIO1.UHID(0))}	//PnP Device ID
						Method(_STA, 0) {Return(^^SIO1.DSTA(0))}	//Get UART status
						Method(_DIS, 0) {^^SIO1.DCNT(0, 0)}			//Disable UART
						Method(_CRS, 0) {Return(^^SIO1.DCRS(0, 0))}	//Get UART current resources
						Method(_SRS, 1) {^^SIO1.DSRS(Arg0, 0)} 		//Set UART recources
					
					// Use the following if using SI1P
					//	Method(_HID, 0) {	//PnP Device ID
					//		if(SI1P){Return(^^SIO1.UHID(0))}
					//		else{Return(^^SIO2.UHID(0))}
					//	}
					//	Method(_STA, 0) {	//Get UART status
					//		if(SI1P){Return(^^SIO1.DSTA(0))}
					//		else{Return(^^SIO2.DSTA(0))}
					//	}
					//	Method(_DIS, 0) {	//Disable UART
					//		if(SI1P){^^SIO1.DCNT(0, 0)}
					//		else{^^SIO2.DCNT(0, 0)}
					//	}
					//	Method(_CRS, 0) {	//Get UART current resources
					//		if(SI1P){Return(^^SIO1.DCRS(0, 0))}
					//		else{Return(^^SIO2.DCRS(0, 0))}
					//	}
					//	Method(_SRS, 1) {	//Set UART resources
					//		if(SI1P){^^SIO1.DSRS(Arg0, 0)}
					//		else{^^SIO2.DSRS(Arg0, 0)}
					//	}
					
					//-----------------------------------------------------------------------
					// UART1 Possible Resources
					//-----------------------------------------------------------------------
					//NOTE: _PRS MUST be the NAME not a METHOD object 
					//to have GENERICSIO.C working right! 
					//-----------------------------------------------------------------------
						Name(_PRS, ResourceTemplate() {
							StartDependentFn(0, 0) {
								IO(Decode16, 0x3F8, 0x3F8, 1, 8)
								IRQNoFlags() {4}
								DMA(Compatibility, NotBusMaster, Transfer8) {}
							}
							StartDependentFnNoPri() {
								IO(Decode16, 0x3F8, 0x3F8, 1, 8)
								IRQNoFlags() {3,4,5,7,9,10,11,12}
								DMA(Compatibility, NotBusMaster, Transfer8) {}
							}
							StartDependentFnNoPri() {
								IO(Decode16, 0x2F8, 0x2F8, 1, 8)
								IRQNoFlags() {3,4,5,7,9,10,11,12}
								DMA(Compatibility, NotBusMaster, Transfer8) {}
							}
							StartDependentFnNoPri() {
								IO(Decode16, 0x3E8, 0x3E8, 1, 8)
								IRQNoFlags() {3,4,5,7,9,10,11,12}
								DMA(Compatibility, NotBusMaster, Transfer8) {}
							}
							StartDependentFnNoPri() {
								IO(Decode16, 0x2E8, 0x2E8, 1, 8)
								IRQNoFlags() {3,4,5,7,9,10,11,12}
								DMA(Compatibility, NotBusMaster, Transfer8) {}
							}
							EndDependentFn()
						})
					//} // End Of UAR1
					//-----------------------------------------------------------------------
					
					//*************************************************************************
					//*************************************************************************
					//**                                                                     **
					//**        (C)Copyright 1985-2008, American Megatrends, Inc.            **
					//**                                                                     **
					//**                       All Rights Reserved.                          **
					//**                                                                     **
					//**      5555 Oakbrook Parkway, Suite 200, Norcross, GA 30093           **
					//**                                                                     **
					//**                       Phone: (770)-246-8600                         **
					//**                                                                     **
					//*************************************************************************
					//*************************************************************************

	
				}	//End Scope for Com1
	
				Device(SGPI) {
					Name(_HID, EISAID("PNP0C08"))	// Gpio
					Name(_UID, 0x00)	// Unique ID.
					Name(LDN, 0x07)	// Logical Device Number
				
	//---------------------------------------------------------------------------
	//Include file(s) for the device Gpio
	//---------------------------------------------------------------------------
					
					Method(_STA,0){
					    //Device not decoding any resources and disabled.
					    Return(0x00) 
					}

	
				}	//End Scope for Gpio
	
				Device(SCPI) {
					Name(_HID, EISAID("PNP0C08"))	// Acpi
					Name(_UID, 0x01)	// Unique ID.
					Name(LDN, 0x0A)	// Logical Device Number
				
	//---------------------------------------------------------------------------
	//Include file(s) for the device Acpi
	//---------------------------------------------------------------------------
					
					Method(_STA,0){
					    //Device not decoding any resources and disabled.
					    Return(0x00) 
					}

	
				}	//End Scope for Acpi
	
				Device(IOEC) {
					Name(_HID, EISAID("PNP0C08"))	// EcSpace
					Name(_UID, 0x02)	// Unique ID.
					Name(LDN, 0x0B)	// Logical Device Number
				
	//---------------------------------------------------------------------------
	//Include file(s) for the device EcSpace
	//---------------------------------------------------------------------------
					
					Method(_STA,0){
					    //Device not decoding any resources and disabled.
					    Return(0x00) 
					}

	
				}	//End Scope for EcSpace
	
			} // end "LpcBridge"
	
			Device(PEX0) { // PCI Express Port 0
				Name(_ADR, 0x00090000)
				Method(_PRW, 0) { Return(GPRW(0x09, 4)) }	// can wakeup from S4 state
				Method(_PRT,0) {
					If(PICM) { Return(AG03) }// APIC mode
					Return (PG03) // PIC Mode
				} // end _PRT
	
				Device(SLT0) { // PCI Express Slot 0
					Name(_ADR, 0x0000FFFF)
				} // end "PCI Express Slot 0"
	
			} // end "PCI Express Port 0"
	
			Device(PEX1) { // PCI Express Port 1
				Name(_ADR, 0x000A0000)
				Method(_PRW, 0) { Return(GPRW(0x09, 4)) }	// can wakeup from S4 state
				Method(_PRT,0) {
					If(PICM) { Return(AG04) }// APIC mode
					Return (PG04) // PIC Mode
				} // end _PRT
	
				Device(SLT1) { // PCI Express Slot 1
					Name(_ADR, 0x0000FFFF)
				} // end "PCI Express Slot 1"
	
			} // end "PCI Express Port 1"
	
			Device(PEX2) { // PCI Express Port 2
				Name(_ADR, 0x000B0000)
				Method(_PRW, 0) { Return(GPRW(0x09, 4)) }	// can wakeup from S4 state
				Method(_PRT,0) {
					If(PICM) { Return(AG06) }// APIC mode
					Return (PG06) // PIC Mode
				} // end _PRT
	
				Device(SLT2) { // PCI Express Slot 2
					Name(_ADR, 0x0000FFFF)
				} // end "PCI Express Slot 2"
	
			} // end "PCI Express Port 2"
	
			Device(PEX3) { // PCI Express Port 3
				Name(_ADR, 0x000C0000)
				Method(_PRW, 0) { Return(GPRW(0x09, 4)) }	// can wakeup from S4 state
				Method(_PRT,0) {
					If(PICM) { Return(AG08) }// APIC mode
					Return (PG08) // PIC Mode
				} // end _PRT
	
				Device(SLT3) { // PCI Express Slot 3
					Name(_ADR, 0x0000FFFF)
				} // end "PCI Express Slot 3"
	
			} // end "PCI Express Port 3"
	
			Device(PEX4) { // PCI Express Port 4
				Name(_ADR, 0x000E0000)
				Method(_PRW, 0) { Return(GPRW(0x09, 4)) }	// can wakeup from S4 state
				Method(_PRT,0) {
					If(PICM) { Return(AG0A) }// APIC mode
					Return (PG0A) // PIC Mode
				} // end _PRT
	
				Device(SLT4) { // PCI Express Slot 4
					Name(_ADR, 0x0000FFFF)
				} // end "PCI Express Slot 4"
	
			} // end "PCI Express Port 4"
	
			Device(PEX5) { // PCI Express Port 5
				Name(_ADR, 0x000F0000)
				Method(_PRW, 0) { Return(GPRW(0x09, 4)) }	// can wakeup from S4 state
				Method(_PRT,0) {
					If(PICM) { Return(AG0C) }// APIC mode
					Return (PG0C) // PIC Mode
				} // end _PRT
	
				Device(SLT5) { // PCI Express Slot 5
					Name(_ADR, 0x0000FFFF)
				} // end "PCI Express Slot 5"
	
			} // end "PCI Express Port 5"
	
			Device(PEX6) { // PCI Express Port 6
				Name(_ADR, 0x00100000)
				Method(_PRW, 0) { Return(GPRW(0x09, 4)) }	// can wakeup from S4 state
				Method(_PRT,0) {
					If(PICM) { Return(AG0E) }// APIC mode
					Return (PG0E) // PIC Mode
				} // end _PRT
	
				Device(SLT6) { // PCI Express Slot 6
					Name(_ADR, 0x0000FFFF)
				} // end "PCI Express Slot 6"
	
			} // end "PCI Express Port 6"
	
			Device(PEX7) { // PCI Express Port 7
				Name(_ADR, 0x00110000)
				Method(_PRW, 0) { Return(GPRW(0x09, 4)) }	// can wakeup from S4 state
				Method(_PRT,0) {
					If(PICM) { Return(AG10) }// APIC mode
					Return (PG10) // PIC Mode
				} // end _PRT
	
				Device(SLT7) { // PCI Express Slot 7
					Name(_ADR, 0x0000FFFF)
				} // end "PCI Express Slot 7"
	
			} // end "PCI Express Port 7"
	
			Device(SMB1) { // SMBus Controller 1
				Name(_ADR, 0x00120000)
			} // end "SMBus Controller 1"
	
			Device(SAT0) { // SATA controller 0
				Name(_ADR, 0x00130000)
			} // end "SATA controller 0"
	
			Device(SAT1) { // SATA controller 1
				Name(_ADR, 0x00140000)
			} // end "SATA controller 1"
	
			Device(XHC1) { // XHCI USB controller
				Name(_ADR, 0x00150000)
	
	//---------------------------------------------------------------------------
	//Include file(s) for the device XHCI USB controller
	//---------------------------------------------------------------------------
				/**@file
				
				@copyright
				 Copyright (c) 2010 - 2017 Intel Corporation. All rights reserved
				 This software and associated documentation (if any) is furnished
				 under a license and may only be used or copied in accordance
				 with the terms of the license. Except as permitted by the
				 license, no part of this software or documentation may be
				 reproduced, stored in a retrieval system, or transmitted in any
				 form or by any means without the express written consent of
				 Intel Corporation.
				 This file contains an 'Intel Peripheral Driver' and is uniquely
				 identified as "Intel Reference Module" and is licensed for Intel
				 CPUs and chipsets under the terms of your license agreement with
				 Intel or your vendor. This file may be modified by the user, subject
				 to additional terms of the license agreement.
				
				@par Specification Reference:
				**/
				External(\_SB.PCI0.XHC1.PS0X, MethodObj) 		    
				External(\_SB.PCI0.XHC1.PS3X, MethodObj) 		    
				External(\_SB.PCI0.XHC1.RHUB.PS0X, MethodObj) 	
				External(\_SB.PCI0.XHC1.RHUB.PS2X, MethodObj) 	
				External(\_SB.PCI0.XHC1.RHUB.PS3X, MethodObj) 	
				External(\_SB.PCI0.XHC1.RHUB.INIR, MethodObj) 	
				External(\_SB.PCI0.XHC1.XHCS, MethodObj) 		    
				
				Scope(\_GPE) {
				  Method(_L6D, 0, Serialized) {
				    \_SB.PCI0.XHC1.GPEH()
				  }
				}
				
				
				Scope(\_SB.PCI0.XHC1) {
				
				
					//USB CFG space
				    OperationRegion(XPRT,PCI_Config,0x00,0x100)
				    Field(XPRT,AnyAcc,NoLock,Preserve)
				    {
				      DVID, 16,
				      Offset(0x74),
				      D0D3,  2,  // 0x74 BIT[1:0]
				          ,  6,
				      PMEE,  1,  // PME Enable
				          ,  6,
				      PMES,  1,  // PME Status
				    }
				
				    //
				    // Variable to store the maximum D state supported in S0.
				    //
				    Name (XFLT, 0)
				    //
				    // XHCI controller won't go into D3Hot during S0 until _DSM method is evaluated by filter driver.
				    //
				    Method(_DSM,4,serialized){
				    
				      //Ignore filter driver and dont allow D3 transitions
				      return(0)
				    }
				
				    Method(_S3D, 0, NotSerialized)
				    {
				      Return(3)
				    }
				    Method(_S4D, 0, NotSerialized)
				    {
				      Return(3)
				    }
				    Method(_S3W, 0, NotSerialized)
				    {
				      Return(3)
				    }
				    Method(_S4W, 0, NotSerialized)
				    {
				      Return(3)
				    }
				
				    //
				    // Once the filter driver is installed, D3 is allowed.
				    //
				    Method(_S0W, 0x0, NotSerialized)
				    {
				      If(LEqual(XFLT, Zero))
				      {
				        Return(0x0)
				      }
				      Else
				      {
				        Return(0x3)
				      }
				    }
				
				      Method(_PRW, 0)
				      {
				        Return (Package (0x02) {0x6D, 0x4})
				      }
				
				    Method(_DSW, 3)
				    {
				      Store(Arg0, PMEE)
				    }
				
				    Method(_INI) {
				      // _INI for RTD3 run conditionally if implemented in platform specific code
				      If(CondRefOf(\_SB.PCI0.XHC1.RHUB.INIR)) {      // _INI for RTD3
				        \_SB.PCI0.XHC1.RHUB.INIR()
				      }
				
				    }
				
				    //
				    // GPE handler for XHCI, this is part of _Lxx handler for bus 0 PME
				    //
				    Method(GPEH)
				    {
				      If(LEqual(DVID, 0xFFFF)) {
				        Return()
				      }
				      Store(PMES, Local0)
				      Store(1, PMES) // clear PME Status
				      If(LAnd(PMEE, Local0)) {
				        Notify(XHC1, 0x02)
				      }
				    }
				
				    OperationRegion(XHCP, SystemMemory, Add(\_SB.PCI0.GPCB(), 0xA8000), 0x100)
				
				    Field(XHCP,AnyAcc,Lock,Preserve)
				    {
				      Offset(0x4),
				      PDBM, 16,
				      Offset(0x10),
				      MEMB, 64
				    }
				
				    //
				    // USRA (USbR port Address), method for calculating address of first USBR port in XHCI controller
				    //
				    Method(USRA,0,Serialized) {
						Return (15)
					}
				
				    Name(XRST, Zero)
				
				    Method(_PS0,0,Serialized)
				    {
				
				      If(LEqual(^DVID,0xFFFF))
				      {
				        Return()
				      }
				
				      Store(^MEMB,Local2)         // Save MBAR
				      Store(^PDBM,Local1)         // Save CMD
				
				      And(^PDBM,Not(0x06),^PDBM)  // Clear MSE/BME
				
				      //
				      // Switch to D0
				      //
				      Store(0,^D0D3)
				
				      Store(\XWMB,^MEMB)          // Set MBAR
				      Or(Local1,0x0002,^PDBM)     // Set MSE
				
				      //
				      //
				      //
				
				      And(^PDBM,Not(0x02),^PDBM)  // Clear MSE
				
				      Store(Local2,^MEMB)         // Restore MBAR
				      Store(Local1,^PDBM)         // Restore CMD
				
				      //
				      // Call platform XHC PS0 method if present
				      //
				      If(CondRefOf(\_SB.PCI0.XHC1.PS0X))
				      {
				        \_SB.PCI0.XHC1.PS0X()
				      }
				    }
				
				    Method(_PS3,0,Serialized)
				    {
				
				      If(LEqual(^DVID,0xFFFF))
				      {
				        Return()
				      }
				
				      Store(^MEMB,Local2)         // Save MBAR
				      Store(^PDBM,Local1)         // Save CMD
				
				      And(^PDBM,Not(0x06),^PDBM)  // Clear MSE/BME
				
				      //
				      // Switch back to D0
				      //
				      Store(0,^D0D3)
				
				      Store(\XWMB,^MEMB)          // Set MBAR
				      Or(Local1,0x0002,^PDBM)     // Set MSE
				
				      //
				      //
				      //
				
				
				      And(^PDBM,Not(0x02),^PDBM)  // Clear MSE
				
				      //
				      // Switch back to D3
				      //
				      Store(3,^D0D3)
				
				      Store(Local2,^MEMB)         // Restore MBAR
				      Store(Local1,^PDBM)         // Restore CMD
				
				      //
				      // Call platform XHC PS3 method if present
				      //
				
				      If(CondRefOf(\_SB.PCI0.XHC1.PS3X))
				      {
				        \_SB.PCI0.XHC1.PS3X()
				      }
				    }
				
				
				    // Apply S3 workaround.
				    // Arguments :
				    //  None
				    // Changes 8090 Bit 10 before S3.
				    //
				    Method(XHCS,0, Serialized) {
				      Store(^MEMB,Local2)         // Save MBAR
				      Store(^PDBM,Local1)         // Save CMD
				
				      And(^PDBM,Not(0x06),^PDBM)  // Clear MSE/BME
				
				      Store(\XWMB,^MEMB)          // Set MBAR
				      Or(Local1,0x0002,^PDBM)     // Set MSE
				
				      OperationRegion(MC11,SystemMemory,\XWMB,0x9000)
				      Field(MC11,DWordAcc,Lock,Preserve)
				      {
				        Offset(0x8090),   //  HC Transfer Manager - TRM
				            ,  10,
				        UCLI,  1,         // CLEAR IN EP
				      }
				
				      Store(0x1,UCLI)
				
				      And(^PDBM,Not(0x02),^PDBM)  // Clear MSE
				
				      Store(Local2,^MEMB)         // Restore MBAR
				      Store(Local1,^PDBM)         // Restore CMD
				
				    }
				
				    //
				    //
				    // Check for XHCI switch UUID
				    //
				    // Arguments:
				    //  Arg0 (Buffer) : UUID
				    //
				    // Returns:
				    //  1: It's valid UUID
				    //  0: Invalid UUID
				    //
				    Method(CUID,1,Serialized) {
				      If(LEqual(Arg0,ToUUID("7c9512a9-1705-4cb4-af7d-506a2423ab71"))) {
				        Return(1)
				      }
				      Return(0)
				    }
				
				    Device(RHUB)
				    {
				    
				    //
				    // Method for creating generic _PLD buffers
				    // _PLD contains lots of data, but for purpose of internal validation we care only about
				    // ports' visibility and pairing (this requires group position)
				    // so these are the only 2 configurable parameters (User Visible, Group Position)
				    //
				    Method(GPLD, 2, Serialized) {
				      Name(PCKG, Package() { Buffer(0x10) {} } )
				      CreateField(DerefOf(Index(PCKG,0)), 0, 7, REV)
				      Store(1,REV)
				      CreateField(DerefOf(Index(PCKG,0)), 64, 1, VISI)
				      Store(Arg0, VISI)
				      CreateField(DerefOf(Index(PCKG,0)), 87, 8, GPOS)
				      Store(Arg1, GPOS)
				
				
				      return (PCKG)
				    }
				
				    //
				    // Method for creating generic _UPC buffers
				    // Similar to _PLD, for internal testing we only care about 1 parameter (port connectable)
				    //
				    Method(GUPC, 1, Serialized) {
				      Name(PCKG, Package(4) { 0, 0xFF, 0, 0 } )
				      Store(Arg0,Index(PCKG,0))
				
				
				      return (PCKG)
				    }
				    
				    
				    
				      Name(_ADR, Zero)
				
				      // PS0 Method for xHCI Root Hub
				      Method(_PS0,0,Serialized)
				      {
				        If(LEqual(\_SB.PCI0.XHC1.DVID,0xFFFF))
				        {
				          Return()
				        }
				        //
				        // Call platform XHC.RHUB PS0 method if present.
				        //
				        If(CondRefOf(\_SB.PCI0.XHC1.RHUB.PS0X))
				        {
				          \_SB.PCI0.XHC1.RHUB.PS0X()
				        }
				      }
				  
				      // PS2 Method for xHCI Root Hub
				      Method(_PS2,0,Serialized)
				      {
				  
				        If(LEqual(\_SB.PCI0.XHC1.DVID,0xFFFF))
				        {
				          Return()
				        }
				        //
				        // Call platform XHC.RHUB PS2 method if present.
				        //
				        If(CondRefOf(\_SB.PCI0.XHC1.RHUB.PS2X))
				        {
				          \_SB.PCI0.XHC1.RHUB.PS2X()
				        }
				      }
				  
				      // PS3 Method for xHCI Root Hub
				      Method(_PS3,0,Serialized)
				      {
				  
				        If(LEqual(\_SB.PCI0.XHC1.DVID,0xFFFF))
				        {
				          Return()
				        }
				        //
				        // Call platform XHC.RHUB PS3 method if present.
				        //
				        If(CondRefOf(\_SB.PCI0.XHC1.RHUB.PS3X))
				        {
				          \_SB.PCI0.XHC1.RHUB.PS3X()
				        }
				  
				      }
				
				
				      Device(HS01)
				      {
				        Name(_ADR,0x00000001)
				  			Method(_UPC) { Return (GUPC(1)) }
				  	    Method(_PLD) {Return (GPLD(1,1))}
				      }
				
				      Device(HS02)
				      {
				        Name(_ADR,0x00000002)
				        Method(_UPC) { Return (GUPC(1)) }
				  			Method(_PLD) {Return (GPLD(1,2))}  
					    }
				
				      Device(HS03)
				      {
				        Name(_ADR,0x00000003)
				  			Method(_UPC) { Return (GUPC(1)) }
				  			Method(_PLD) {Return (GPLD(1,3))}     
					    }
				
				      Device(HS04)
				      {
				        Name(_ADR,0x00000004)
				  			Method(_UPC) { Return (GUPC(1)) }
				  			Method(_PLD) {Return (GPLD(1,4))} 	   
					    }
				
				      Device(SS01)
				      {
				        Name(_ADR,0x00000005)      
				  			Method(_UPC) { Return (GUPC(0)) }
				  			Method(_PLD) {Return (GPLD(0,0))} 		
					    }
				
				      Device(SS02)
				      {
				        Name(_ADR,0x00000006)      
				  			Method(_UPC) { Return (GUPC(0)) }
				  			Method(_PLD) {Return (GPLD(0,0))}
					    }
				
				      Device(SS03)
				      {
				        Name(_ADR,0x00000007)      
				  			Method(_UPC) { Return (GUPC(0)) }
				  			Method(_PLD) {Return (GPLD(0,0))}
					    }
				
				      Device(SS04)
				      {
				        Name(_ADR,0x00000008)      
				  			Method(_UPC) {  			
				  				Return (GUPC(U33C)) 
				  			}
				  			Method(_PLD) {
				  				Return (GPLD(U33V,U33G))
				 				}
					    }
				    } // device rhub
				} //scope
				

	
			} // end "XHCI USB controller"
	
			Device(UAR0) { // UART 0
				Name(_ADR, 0x001A0000)
			} // end "UART 0"
	
			Device(UAR1) { // UART 1
				Name(_ADR, 0x001A0001)
			} // end "UART 1"
	
			Device(UAR2) { // UART 2
				Name(_ADR, 0x001A0002)
			} // end "UART 2"
	
			Device(IEH1) { // IE HECI1
				Name(_ADR, 0x001B0000)
			} // end "IE HECI1"
	
			Device(IEH2) { // IE HECI2
				Name(_ADR, 0x001B0001)
			} // end "IE HECI2"
	
			Device(IEKT) { // IE - Keyboard and Text (KT)
				Name(_ADR, 0x001B0003)
			} // end "IE - Keyboard and Text (KT)"
	
			Device(IEH3) { // IE HECI3
				Name(_ADR, 0x001B0004)
			} // end "IE HECI3"
	
			Device(GREG) { // Global Register
				Name(_ADR, 0x00040000)
			} // end "Global Register"
	
			Device(RCEC) { // RCEC
				Name(_ADR, 0x00050000)
			} // end "RCEC"
	
			Device(VRP2) { // Virtual root port 2
				Name(_ADR, 0x00060000)
				Method(_PRT,0) {
					If(PICM) { Return(AG1F) }// APIC mode
					Return (PG1F) // PIC Mode
				} // end _PRT
	
				Device(IQAT) { // Intel QuickAssist Technology
					Name(_ADR, 0x0000FFFF)
				} // end "Intel QuickAssist Technology"
	
			} // end "Virtual root port 2"
	
			Device(VRP0) { // Virtual root port 0
				Name(_ADR, 0x00160000)
				Method(_PRT,0) {
					If(PICM) { Return(AG21) }// APIC mode
					Return (PG21) // PIC Mode
				} // end _PRT
	
				Device(LAN1) { // PXE Option ROM 1
					Name(_ADR, 0x00000001)
				} // end "PXE Option ROM 1"
	
			} // end "Virtual root port 0"
	
			Device(VRP1) { // Virtual root port 1
				Name(_ADR, 0x00170000)
				Method(_PRT,0) {
					If(PICM) { Return(AG22) }// APIC mode
					Return (PG22) // PIC Mode
				} // end _PRT
	
			} // end "Virtual root port 1"
	
			Device(HECI) { // ME HECI
				Name(_ADR, 0x00180000)
			} // end "ME HECI"
	
			Device(HEC2) { // ME HECI2
				Name(_ADR, 0x00180001)
			} // end "ME HECI2"
	
			Device(MEKT) { // MEKT on PCH
				Name(_ADR, 0x00180003)
			} // end "MEKT on PCH"
	
			Device(HEC3) { // ME HECI3
				Name(_ADR, 0x00180004)
			} // end "ME HECI3"
	
			Device(EMMC) { // eMMC
				Name(_ADR, 0x001C0000)
	
	//---------------------------------------------------------------------------
	//Include file(s) for the device eMMC
	//---------------------------------------------------------------------------
				/*++
				  This file contains an 'Intel Peripheral Driver' and is
				  licensed for Intel CPUs and chipsets under the terms of your
				  license agreement with Intel or your vendor.  This file may
				  be modified by the user, subject to additional terms of the
				  license agreement
				--*/
				/*++
				
				// Copyright (c) 2015, Intel Corporation. All rights reserved.
				// This software and associated documentation (if any) is furnished
				// under a license and may only be used or copied in accordance
				// with the terms of the license. Except as permitted by such
				// license, no part of this software or documentation may be
				// reproduced, stored in a retrieval system, or transmitted in any
				// form or by any means without the express written consent of
				// Intel Corporation.
				
				  Module Name:
				
				    Emmc.asi
				
				  Abstract:
				   EMMC resource descriptor
				
				--*/
				
				
				Device (EMMD)//EMMC Device
				{
				    Name (_ADR, 0x08)                      // _ADR: Address
				    Method (_RMV, 0, NotSerialized)        // _RMV: Removal Status
				    {
				        Return (Zero)
				    }
				}
	
			} // end "eMMC"
	
			Device(P2SB) { // Primary to Sideband Bridge
				Name(_ADR, 0x001F0001)
	
	//---------------------------------------------------------------------------
	//Include file(s) for the device Primary to Sideband Bridge
	//---------------------------------------------------------------------------
				/*++
				  This file contains an 'Intel Peripheral Driver' and is        
				  licensed for Intel CPUs and chipsets under the terms of your  
				  license agreement with Intel or your vendor.  This file may   
				  be modified by the user, subject to additional terms of the   
				  license agreement                                             
				--*/
				/*++
				  
				// Copyright (c) 2010, Intel Corporation. All rights reserved. 
				// This software and associated documentation (if any) is furnished
				// under a license and may only be used or copied in accordance
				// with the terms of the license. Except as permitted by such
				// license, no part of this software or documentation may be
				// reproduced, stored in a retrieval system, or transmitted in any
				// form or by any means without the express written consent of
				// Intel Corporation.
				  
				  Module Name:
				  
				    P2SB.asi
				  
				  Abstract:
				  
				  
				--*/
				
				
				OperationRegion(SBRB, PCI_Config, 0x10, 0x08)
				Field(SBRB, ANYACC, NOLOCK, PRESERVE)
				{
				    SBRL, 32,
				    SBRH, 32
				}
				

	
			} // end "Primary to Sideband Bridge"
	
			Device(PMC0) { // Power Management Controller
				Name(_ADR, 0x001F0002)
	
	//---------------------------------------------------------------------------
	//Include file(s) for the device Power Management Controller
	//---------------------------------------------------------------------------
				/*++
				  This file contains an 'Intel Peripheral Driver' and is        
				  licensed for Intel CPUs and chipsets under the terms of your  
				  license agreement with Intel or your vendor.  This file may   
				  be modified by the user, subject to additional terms of the   
				  license agreement                                             
				--*/
				/*++
				  
				// Copyright (c) 2015, Intel Corporation. All rights reserved. 
				// This software and associated documentation (if any) is furnished
				// under a license and may only be used or copied in accordance
				// with the terms of the license. Except as permitted by such
				// license, no part of this software or documentation may be
				// reproduced, stored in a retrieval system, or transmitted in any
				// form or by any means without the express written consent of
				// Intel Corporation.
				  
				  Module Name:
				  
				    PMC.asi
				  
				  Abstract:
				   PMC resource descriptor
				  
				--*/
				
				
				Device(PDRC)	// PMC Device Resource Consumption
				{
				  Name(_HID,EISAID("PNP0C02"))        
				
				  Name(_UID, 0x10)
				
				  Name(PMCR,ResourceTemplate()
				  {
				    // Denverton Aptiov override start
				    // IO(Decode16,FixedPcdGet16(PcdAcpiBaseAddress),FixedPcdGet16(PcdAcpiBaseAddress),0x1,0xFF) // ACPI Base.
				    IO(Decode16,0x1800,0x1800,0x1,0xFF) // ACPI Base.
				    // Denverton Aptiov override end
				    Memory32Fixed(ReadOnly, 0xFED03000, 0x1000) // PMC memory range
				
				  })
				
				  Method(_CRS, 0, Serialized)
				  {
				    return(PMCR)
				  }
				}

	
			} // end "Power Management Controller"
	
			Device(SMB0) { // Legacy SMBUS Controller
				Name(_ADR, 0x001F0004)
			} // end "Legacy SMBUS Controller"
	
			Device(SPI0) { // SPI controller
				Name(_ADR, 0x001F0005)
			} // end "SPI controller"
	
			Device(NPK0) { // Northpeak DFX
				Name(_ADR, 0x001F0007)
	
	//---------------------------------------------------------------------------
	//Include file(s) for the device Northpeak DFX
	//---------------------------------------------------------------------------
				/*++
				
				  Copyright (c) 2016 Intel Corporation. All rights reserved.
				
				  This software and associated documentation (if any) is furnished under 
				  a license and may only be used or copied in accordance with the terms 
				  of the license.  Except as permitted by such license, no part of this 
				  software or documentation may be reproduced, stored in a retrieval 
				  system, or transmitted in any form or by any means without the express 
				  written consent of Intel Corporation.
				
				  Module Name:    
				
				  Abstract:
				
				    NPK ASL device, objects and data
				
				--*/
				
				//Begin: NPK RTIT BAR Overlapping WA (HSD 1404869801)
				Scope(\_SB.PCI0.NPK0){
				    // Northpeak DFX
				    Method(_STA, 0, NotSerialized)
				    {
				      Return(0x0B)
				    }
				}
				//End: NPK RTIT BAR Overlapping WA (HSD 1404869801)
	
			} // end "Northpeak DFX"
	
		}	//PciRoot device scope Ends
	}	//End_SBScope
	//---------------------------------------------------------------------------
	// System Event handlers
	//---------------------------------------------------------------------------
		Scope(\_GPE){
			Method(_L09, 0) {
				Notify(\_SB.PCI0.PEX0, 0x02)
				Notify(\_SB.PCI0.PEX1, 0x02)
				Notify(\_SB.PCI0.PEX2, 0x02)
				Notify(\_SB.PCI0.PEX3, 0x02)
				Notify(\_SB.PCI0.PEX4, 0x02)
				Notify(\_SB.PCI0.PEX5, 0x02)
				Notify(\_SB.PCI0.PEX6, 0x02)
				Notify(\_SB.PCI0.PEX7, 0x02)
			}
		}
	
	//-------- DO NOT EDIT THIS FILE --------
	//
	// FILE WAS GENERATED AUTOMATICALY USING AMISDL v7.04.0274 (四月 26 2023,16:58:30)
	//
	//-------- DO NOT EDIT THIS FILE --------
	//****************************************************************************
	//****************************************************************************
	//**                                                                        **
	//**         (C)Copyright 1985 - 2023, American Megatrends, Inc.            **
	//**                                                                        **
	//**                          All Rights Reserved.                          **
	//**                                                                        **
	//**                    5555 Oakbrook Pkwy, Norcross, GA 30092              **
	//**                                                                        **
	//**                          Phone (770)-246-8600                          **
	//**                                                                        **
	//****************************************************************************
	//****************************************************************************

//==========================================================================
// Sleep states supported by Chipset/Board.
//----------------------------------------------------------------------
// SSx - BIOS setup controlled enabled _Sx Sleep state status
// Values to be written to SLP_TYPE register are provided by SBACPI.SDL (South Bridge ACPI ModulePart)
// This modules will be generated automaticaly based on $(A_Sx_PKG) presence and content
//==========================================================================
	Name(\_S0, Package(4){0x0,0x0,0,0})
	Name(\_S4, Package(4){0x6,0x0,0,0})
	Name(\_S5, Package(4){0x7,0x0,0,0})
//==========================================================================
// Global System Prepare To Sleep Method. (_PTS).
//----------------------------------------------------------------------
	Method(_PTS, 1) {
		If(Arg0) {	// Entering any sleep state

			\_SB.TPM.TPTS(Arg0)
			SIO_PTS(Arg0)
		}
	}
//==========================================================================
// Global System Wake from Sleep Method. (_WAK).
//----------------------------------------------------------------------
	Method(_WAK, 1) {

		SIO_WAK(Arg0)

		Return(WAKP)
	}
//==========================================================================
//Following objects will be added in ROOT scope (\.) of DSDT Name Space
//AFTER PCITREE.ASL which creates _SB_ scope
//==========================================================================

	/*++
	
	  Copyright (c)  2001 - 2016 Intel Corporation.  All rights reserved.
	
	  This software and associated documentation (if any) is furnished under 
	  a license and may only be used or copied in accordance with the terms 
	  of the license.  Except as permitted by such license, no part of this 
	  software or documentation may be reproduced, stored in a retrieval 
	  system, or transmitted in any form or by any means without the express 
	  written consent of Intel Corporation.
	
	  Module Name:
	
	    WHEAPlatform.asl
	
	  Abstract:
	
	    WHEA ASL device, objects and data
	
	--*/
	
	Scope(\) {
	
	        // Platform capability, bit 16=1 for WHEA. This has to be patched
	        // by WHEA driver
	
	        Name(\PCAP, 0x00010000)
	
	        // WHEA enabled flag
	        Name(\WHEN,0)
	
	}
	
	Scope(\_SB) {
	
	//
	// Operation region for GPI status bits
	//
	//OperationRegion (GSTS, SystemIO, 0x422, 1)
	
	OperationRegion (GSTS, SystemIO, 0x1822, 1)
	Field ( GSTS, ByteAcc, NoLock, Preserve) 
	      {
	       GP0  ,   1,
	             ,   7,
	       }
	OperationRegion (GINV, SystemIO, 0x82C, 1)
	Field (GINV, ByteAcc,NoLock,Preserve) 
	      {
	       GPIN  , 1,
	             ,7 ,
	      }
	
	OperationRegion (DBG0, SystemIO, 0x80, 2)
	Field (DBG0, ByteAcc,NoLock,Preserve) 
	      {
	       IO80, 8,
	       IO81, 8,
	      }
	
	
	    //
	    // WHEA
	    //
	
	    OperationRegion (IOB3, SystemIO, 0xB2, 2)  //MKF_SMIPORT
	    Field (IOB3, ByteAcc, NoLock, Preserve) {
	      SMIC, 8,                           // SW-SMI ctrl port
	      SMIS, 8,                           // SW-SMI status port
	    }
	
	/*
	;<AMI_PHDR_START>
	;------------------------------------------------------------------------
	;
	; Procedure:	OSFL
	;
	; Description:	OSFL object is used to detect the currently running OS
	; Input: Nothing
	; Output: OS type
	; running under 0 - Win 2000
	;               1 - Win 98/Se
	;               2 - Win Me
	;               3 - Linux
	;								4 - WinXP
	;								5 - Windows Server 2003				
	;								6 - FreeBSD		
	;								7 - HP-UX
	;								8 - OpenVMS		
	;               9..n - reserved
	;
	;-------------------------------------------------------------------------
	;<AMI_PHDR_END>
	*/
		Name(OSVR, Ones)					// Global Name, returns current OS version ID
		Method(OSFL, 0){
			if(LNotEqual(OSVR, Ones)) {Return(OSVR)}	// OS version was already detected
			if(LEqual(PICM,0)) {Store(0xAC, \_SB.IO80)}		// to indicate OS is running in ACPI PIC mode
			Store(1, OSVR)					// default - Win98
	//// Detect currently running OS
			if(CondRefOf(\_OSI,Local0))
			{
				If(\_OSI("Windows 2009")){Store(12, OSVR)}      // Windows Longhorn server ?
				ElseIf(\_OSI("Windows 2008")){Store(10, OSVR)}      // Windows Longhorn server ?
				ElseIf(\_OSI("Windows 2007")){Store(10, OSVR)}      // Windows Longhorn server ?
				ElseIf(\_OSI("Windows 2006")){Store(11, OSVR)       // Windows Vista
	               // Check for Longhorn server (Vista +SP1)
	               If (\_OSI("Windows 2006.1")){Store (10, OSVR)}}     // Longhorn server
				ElseIf (\_OSI("Windows 2001")){Store(4, OSVR)}
				ElseIf (\_OSI("Windows 2001.1")){Store(5, OSVR)}		
				ElseIf(\_OSI("FreeBSD")){Store(6, OSVR)}
				ElseIf(\_OSI("HP-UX")){Store(7, OSVR)}
				ElseIf(\_OSI("OpenVMS")){Store(8, OSVR)}
			} 
		Return(OSVR)
		}
	 
	
	
	        //////////
	        //
	        // WHEA Operational region for extended CMOS access
	        //
	        OperationRegion (CMOS, SystemIO, 0x70, 4)
	        Field (CMOS, ByteAcc, NoLock, Preserve)
	        {
	            IDX0, 7,
	            , 1,
	            DAT0, 8,
	            IDX1, 7,
	            , 1,
	            DAT1, 8
	        }
	        IndexField (IDX1, DAT1, ByteAcc, NoLock, Preserve)
	        {
	            Offset (0x48),    // Must Match Platform.h
	            OSF1, 32,          // PCAP Flag in CMOS              
	            OSF2, 32          // PCAP Flag in CMOS              
	        }
	
	//This method is used to turn on/off Whea support for BIOS 
	        //
	
	        Method (SWWE,1)   //SW SMI Whea Enable
	        {
	            Store(0, \_SB.SMIS)         //Save SMIS
	            Store(Arg0, \_SB.SMIC)         //Set parameter into SMIC 0x9E enable whea
	                                                       // 0x9D disable whea
	        } //end SWWE        
	
	
	//
	// Define WHEA device object with PNP0C33 (as per Whea platform guide 1.0) that will be 
	// used by OS to install WHEA driver.
	//
	        Device (WERR) {
	            Name(_HID, EISAID("PNP0C33"))   // WHEA Error device
			    Name (_UID, 0)
			    Method(_STA){
			          //SWWE(0x9E)
	                       If(LEqual(OSFL, 10)) {     // Check if Longhorn Windows server
	                          If(And(PCAP,0x00010000)) {
	                             Return(0x0F)
	                          }
	                       }
	                        If(LEqual(OSFL, 12)) {     // Check if Longhorn Windows server
	                          If(And(PCAP,0x00010000)) {
	                             Return(0x0F)
	                          }
	                       }
	                       
	                  
	                       Return(0x00) 
	
	      
		            }
	  
			    
	
			    
			    
	        }
	
	//
	// Our platform will generate SCI (on ICH GPI0 (SIO GPO62) to indicate
	// all Correctable/recovered errors. This GPE event will have to notify OS via WHEA device 
	// about the error.
	// Note: BIOS Error handler must build error data info before triggering SCI.
	//        
	// Denverton AptioV override start - EIP#300729
	#ifndef DTS_SUPPORT 
	   Method (\_GPE._L62, 0, NotSerialized) {
	      Store(0xBB, \_SB.IO80)
	      Notify (\_SB.WERR, 0x80)        // Notify a WHEA error event (actually for all CE's)
	   }
	#endif
	// Denverton AptioV override End - EIP#300729
	
	//
	// _OSC method will used by the OS the check platform capability for WHEA supprot. Also
	// OS will use to indicate BIOS to enable WHEA support. BIOS will also can deny OS's request
	// to enable WHEA if it's disable by platform or SKU policy (for e.g. WHEA disabled in Setup).
	//        
	
	//#if BUGGY_LH_OS
	
	/// For current LH OS build (buggy) only - WHEA stack in LH doesn't handle _OSC
	/// as per ACPI spec. Final LH release will fix that, till then use this code.
	
	        Method(_OSC , 4)
	
	        {
	            //Now it is OSC for WHEA
	            // Create DWORD Args from the Capabilities Buffer
	            //CreateDWordField(Arg3,0,CPB1)
	            CreateDWordField(Arg3,4,CPB2)
	
	            // Check for WHEA GUID
	            If(LEqual(Arg0, ToUUID("ed855e0c-6c90-47bf-a62a-26de0fc5ad5c")))
	            {
	
	              If(LEqual(OSFL, 12)) {     // Check if Longhorn Windows server
	                //Check WHEA supported by platform
	                If(And(\PCAP,0x00010000))
	                {
	                    // If OS not querying, enable WHEA in platform
	                    SWWE(0x9E)
	
	                    // Set WHEA enabled flag
	                    Store(0x0001, \WHEN)
	                    Return (Arg3)       // Whea supported
	                }
	              }
	            }
	
	            // Clear WHEA enabled flag
	            Store(0x0000, \WHEN)
	
	            // Set Unrecognized UUID
	            Or (CPB2, 0x0004, CPB2)
	            Return (Arg3)
	        }
	//end of "#if BUGGY_LH_OS"
	
	}   // end _SB scope
	

	//**********************************************************************
	//**********************************************************************
	//**                                                                  **
	//**        (C)Copyright 1985-2014, American Megatrends, Inc.         **
	//**                                                                  **
	//**                       All Rights Reserved.                       **
	//**                                                                  **
	//**      5555 Oakbrook Parkway, Suite 200, Norcross, GA 30093        **
	//**                                                                  **
	//**                       Phone: (770)-246-8600                      **
	//**                                                                  **
	//**********************************************************************
	//**********************************************************************
	
	/** @file RriorDma.asl
	  This file is for SB/LPC I/O and DMA route/release.
	   
	  This file contains set of ACPI control methods implementation for
	  South Bridge or LPC I/O and DMA route/release functions. It should
	  be included in the PCI device of SB/LPC controller.
	  
	*/
	
	/**
	  Convert UART port address to the decoded value in SB/LPC bridge. 
	  
	  This function is used for converting UART port address to the 
	  decoded value in SB/LPC registers.
	  
	  @param Arg0   Port to Route/Release
	  
	  @return UART port decoded value in the LPC bridge
	  
	**/
	
	    Method(UXDV, 1) {
	        Store(0xff, Local0) // Unknown
	        Switch (Add(Arg0, 0)) {
	            Case (0x3F8) { Store(0, Local0) }
	            Case (0x2F8) { Store(1, Local0) }
	            Case (0x220) { Store(2, Local0) }
	            Case (0x228) { Store(3, Local0) }
	            Case (0x238) { Store(4, Local0) }
	            Case (0x2E8) { Store(5, Local0) }
	            Case (0x338) { Store(6, Local0) }
	            Case (0x3E8) { Store(7, Local0) }
	        }
	        return (Local0)
	    }
	
	/**
	  Route/Release I/O ports to/from SB/LPC external I/O bus  
	  
	  This function is for route/release I/O ports to/from SB/LPC 
	  external I/O bus
	  
	  @param Arg0   Device Category
	                  0x00 - Serial A (Modem)
	                  0x01 - Serial B (IR)
	                  0x02 - LPT
	                  0x03 - FDD
	                  0x04 - SB16 Audio
	                  0x05 - Midi
	                  0x06 - Mss Audio
	                  0x07 - Adlib sound (FM synth)
	                  0x08 - Game 1 port
	                  0x09 - Game 2 port
	                  0x0A - KBC 60 & 64
	                  0x0B - EC 62 & 66
	                  0x0C - CNF1 2e & 2f (static location)
	                  0x0D - CNF2 4e & 4f (static location)
	                  0x0E - RESERVED
	                  0x0F - RESERVED
	                  0x10 - Generic I/O Range 1 // IRDA
	                  0x11 - Generic I/O Range 2
	                  0x12 - Generic I/O Range 3
	                  0x13 - Generic I/O Range 4
	  @param Arg1   1/0 Route/Release Mode
	  @param Arg2   Port to Route/Release 
	  @param Arg3   Port SIZE to Route (Optional) 
	  
	  @return Nothing
	  
	**/
	
	    Method(RRIO, 4) {
	/*
	        Switch (Add(Arg0, 0)) {
	            Case (0) {  // UART 0 or 2
	                Store(0, CALE) // Disable the decoding
	                Store (UXDV(Arg2), Local0)
	                If (LNotEqual(Local0, 0xff)) { Store(Local0, CADR)}
	                If (Arg1) { Store(1, CALE) }
	            }
	            Case (1) {  // UART 1 or 3
	                Store(0, CBLE) // Disable the decoding
	                Store (UXDV(Arg2), Local0)
	                If (LNotEqual(Local0, 0xff)) { Store(Local0, CBDR)}
	                If (Arg1) { Store(1, CBLE) }
	            }
	            Case (2) {  // LPT
	                Store(0, LTLE) // Disable the decoding
	                If (LEqual(Arg2, 0x378)) { Store(0, LTDR) }
	                If (LEqual(Arg2, 0x278)) { Store(1, LTDR) }
	                If (LEqual(Arg2, 0x3BC)) { Store(2, LTDR) }
	                If (Arg1) { Store(1, LTLE) }
	            }
	            Case (3) {  // FDD
	                Store(0, FDLE) // Disable the decoding
	                If (LEqual(Arg2, 0x3F0)) { Store(0, FDDR) }
	                If (LEqual(Arg2, 0x370)) { Store(1, FDDR) }
	                If (Arg1) { Store(1, FDLE) }
	            }
	            Case (8) {  // Game 1
	                If (LEqual(Arg2, 0x200)) {
	                    If (Arg1) { Store(1, GLLE) }
	                    Else { Store(0, GLLE) }
	                }
	                If (LEqual(Arg2, 0x208)) {
	                    If (Arg1) { Store(1, GHLE) }
	                    Else { Store(0, GHLE) }
	                }
	            }
	            Case (9) {  // Game 2
	                If (LEqual(Arg2, 0x200)) {
	                    If (Arg1) { Store(1, GLLE) }
	                    Else { Store(0, GLLE) }
	                }
	                If (LEqual(Arg2, 0x208)) {
	                    If (Arg1) { Store(1, GHLE) }
	                    Else { Store(0, GHLE) }
	                }
	            }
	            Case (10) {  // Keyboard Controller
	                If (LOr(LEqual(Arg2, 0x60), LEqual(Arg2, 0x64))) {
	                    If (Arg1) { Store(1, KCLE) }
	                    Else { Store(0, KCLE) }
	                }
	            }
	            Case (11) {  // MicroController
	                If (LOr(LEqual(Arg2, 0x62), LEqual(Arg2, 0x66))) {
	                    If (Arg1) { Store(1, MCLE) }
	                    Else { Store(0, MCLE) }
	                }
	            }
	            Case (12) {  // Super I/O Enable 1
	                If (LEqual(Arg2, 0x2E)) {
	                    If (Arg1) { Store(1, C1LE) }
	                    Else { Store(0, C1LE) }
	                }
	                If (LEqual(Arg2, 0x4E)) {
	                    If (Arg1) { Store(1, C2LE) }
	                    Else { Store(0, C2LE) }
	                }
	            }
	            Case (13) {  // Super I/O Enable 2
	                If (LEqual(Arg2, 0x2E)) {
	                    If (Arg1) { Store(1, C1LE) }
	                    Else { Store(0, C1LE) }
	                }
	                If (LEqual(Arg2, 0x4E)) {
	                    If (Arg1) { Store(1, C2LE) }
	                    Else { Store(0, C2LE) }
	                }
	            }
	
	        }
	*/        
	    }
	
	/**
	  Route DMA Channels to SB/LPC external I/O bus  
	  
	  This function is for route DMA Channels to SB/LPC 
	  external I/O bus
	  
	  @param Arg0   Device Category
	  @param Arg1   1/0 Route/Release Mode
	  @param Arg2   DMA channel to route (1 based) 
	  
	  @return Nothing
	  
	**/
	
	    Method(rDMA, 3) {
	    // Porting If needed.
	    }
	
	//**********************************************************************
	//**********************************************************************
	//**                                                                  **
	//**        (C)Copyright 1985-2014, American Megatrends, Inc.         **
	//**                                                                  **
	//**                       All Rights Reserved.                       **
	//**                                                                  **
	//**      5555 Oakbrook Parkway, Suite 200, Norcross, GA 30093        **
	//**                                                                  **
	//**                       Phone: (770)-246-8600                      **
	//**                                                                  **
	//**********************************************************************
	//**********************************************************************

	//**********************************************************************
	//**********************************************************************
	//**                                                                  **
	//**        (C)Copyright 1985-2014, American Megatrends, Inc.         **
	//**                                                                  **
	//**                       All Rights Reserved.                       **
	//**                                                                  **
	//**      5555 Oakbrook Parkway, Suite 200, Norcross, GA 30093        **
	//**                                                                  **
	//**                       Phone: (770)-246-8600                      **
	//**                                                                  **
	//**********************************************************************
	//**********************************************************************
	
	OperationRegion(PMIO, SystemIo, 0x188C, 1) // GPE0a_STS
	Field (PMIO, ByteAcc, NoLock, Preserve)
	{
	  RESV, 1,  // Reserved
	  HPST, 1,  // Hot Plug Status
	  SGPS, 1,  // Software GPE status
	}
	
	//Z121-001(1) - start
	OperationRegion(NCIO, SystemIo, 0x1884, 1) // GPE0a_STS
	Field (NCIO, ByteAcc, NoLock, Preserve)
	{
	  GPES, 1,  // GPE Status
	}
	//Z121-001(1) - end
	
	Scope(\_GPE) {
	  // Software GPE caused the event.
	  Method(_L62) {
	    // Clear the SWGPE Status Bit.
	    Store(1,SGPS)
	    // Handle the DTS Thermal Event.
	    Notify(\_TZ.TZ01,0x80)
	    
	    // Handle Whea Events
	    #ifdef WHEA_SUPPORT_FLAG
	      Store(0xBB, \_SB.IO80)
	      Notify (\_SB.WERR, 0x80)        // Notify a WHEA error event (actually for all CE's)
	    #endif
	  }
	//Z121-001(1) - start
	    Method(_L20, 0x0, Serialized)
	    {
	        Store(1,GPES)
	        Notify(\_SB.BTNS, 0x80)
	    }
	//Z121-001(1) - end
	}
	
	//Z121-001(1) - start
	Scope(\_SB) {
	        Device (BTNS)
	         {
	          Name (_HID, "NCS0001")
	         } // END BTNS
	}       //End Scope (_SB)
	//Z121-001(1) - end
	
	Scope (\_TZ) {
	ThermalZone (TZ01) {
	    // Return the temperature at which the OS must perform a Critcal
	    // Shutdown.
	    Method (_CRT) {
	      Return (Add(2732, Multiply(\CRTT, 10)))  
	    }
	
	    // Return the DTS Temperature to the OS.
	    Method (_TMP) {
	      // Return the Max ( BSP temp, AP temp)
	      If(LGreaterEqual(DTS1, DTS2))
	      {
	          Return(Add(2732, Multiply(DTS1, 10)))
	      }
	      Return(Add(2732, Multiply(DTS2, 10)))
	    } // End Method(_TMP)
	  } // End of ThermalZone (TZ01)
	} // End Scope (_TZ)
	
	
	//*************************************************************************
	//*************************************************************************
	//**                                                                     **
	//**        (C)Copyright 1985-2014, American Megatrends, Inc.            **
	//**                                                                     **
	//**                       All Rights Reserved.                          **
	//**                                                                     **
	//**      5555 Oakbrook Parkway, Suite 200, Norcross, GA 30093           **
	//**                                                                     **
	//**                       Phone: (770)-246-8600                         **
	//**                                                                     **
	//*************************************************************************
	//*************************************************************************


	//tpm.asl
	External(CRBI)
	    Device(\_SB.TPM)
	    {
	        Method(_HID, 0){		//PnP Device ID
	           If(TCMF)		
	           {
	              Return(EISAID("ZIT0101"))
	           }
	           Else
	           {
	               If(LEqual(TTDP, 0)){
	                    Return(EISAID("PNP0C31"))
	                }else{
	                    Return("MSFT0101")
	                }
	           }
	        }
	        
	#if defined (CID_SUPPORT) && (CID_SUPPORT == 1)
	        Method(_CID, 0){       //Redline RS2 changes; Added CID
	           If(LEqual(TCMF, 0))     
	           {
	               If(LEqual(TTDP, 0)){
	                    Return(EISAID("PNP0C31"))
	               }else{
	                    Return("MSFT0101")
	               }
	           }
	        }
	#endif
	       
	
		    Method(_STR,0)
	        {
	           If(LEqual(TTDP, 0)){
	                Return (Unicode ("TPM 1.2 Device"))
	           }else {
	                Return (Unicode ("TPM 2.0 Device"))
	           }
	        }
	        
		    Name(_UID,0x01)
		    
	      Name(CRST,ResourceTemplate()
		  {
	            Memory32Fixed (ReadOnly, 0x00000000, 0x1000,PCRB)
	            Memory32Fixed (ReadOnly, 0xFED70000, 0x1000,PCRC)
		  })
		  
		  Name(CRSD,ResourceTemplate()
	      {
	            Memory32Fixed (ReadWrite, 0xFED40000, 0x5000, PCRE)
	      })
	
	      Name(CRSI,ResourceTemplate()
		  {
	            Memory32Fixed (ReadWrite, 0xFED40000, 0x5000,PCRS)            
		  })
	      //
	      // Return the resource consumed by TPM device
	      //
	      Method(_CRS,0,Serialized)
		  {
	         If(LEqual(AMDT, 1))
	         {
	             CreateDWordField(CRST, ^PCRB._BAS, MTFB) // Min
	             CreateDWordField(CRST, ^PCRB._LEN, LTFB) // Length
	                   
	             Store(TPMB, MTFB)
	             Store(0x1000, LTFB)
	
	             CreateDWordField(CRST, ^PCRC._BAS, MTFC) // Min
	             CreateDWordField(CRST, ^PCRC._LEN, LTFC) // Length
	               
	             Store(TPMC, MTFC)
	             Store(0x1000, LTFC)
	            
	             Return (CRST)
	         }Else{
	            If(LEqual(DTPT,1))
	            {
	               CreateDWordField(CRSD, ^PCRE._BAS, MTFE) // Min
	               CreateDWordField(CRSD, ^PCRE._LEN, LTFE) // Length
	               
	               Store(0x0FED40000, MTFE)
	               Store(0x00005000, LTFE)
	                              
	               Return(CRSD)
	            }            
	            ElseIf(LEqual(TTPF, 1))
	            {
	               CreateDWordField(CRSI, ^PCRS._BAS, MTFD) // Min
	               CreateDWordField(CRSI, ^PCRS._LEN, LTFD) // Length
	               
	               Store(0x0FED40000, MTFD)
	               Store(0x00005000, LTFD)
	               Return (CRSI)
	            }ElseIf(LEqual(TTPF, 0))
	            {
	               CreateDWordField(CRSI, ^PCRS._BAS, MTFF) // Min
	               Store(TPMM, MTFF)
	               Return (CRSI)
	            }
	
	            Store(0x00000000, MTFE)
	            Store(0x00000000, LTFE)
	            Return (CRSI)  
	         }
	            Return (CRSI)
	      }
	
		  OperationRegion(TMMB, SystemMemory, 0x0FED40000, 0x5000)
		  Field(TMMB, ByteAcc, Lock, Preserve)
		  {
		    Offset(0x04),
		    LCST, 32,          // LOC_STATE
		    Offset(0x40),
	        CREQ, 32,          // CTRL_REQ
		    Offset(0x44), 
		    CSTS, 32,          // CTRL STS
		    Offset(0x4C),
		    SCMD, 32,          // CTRL STRT
		  }
	
	      OperationRegion (CRBD, SystemMemory, TPMM, 0x48)
	      Field (CRBD, AnyAcc, NoLock, Preserve)
	      {
	        Offset(0x04),
	        HERR, 32,
	        Offset (0x40),
	        HCMD, 32,
	        Offset(0x44), 
	        HSTS, 32,
	      }
	      
	
	      Method(_STA, 0){
		   	If(LEqual(TTDP, 0)){
	            If(TPMF){
	                 Return(0x0F)  // TPM Support 
	             }
	             Return(0x00)  // No TPM Support
	         }ElseIF(LEqual(TTDP, 1)){
	            If(TPMF){
	             Return(0x0F)  // TPM Support 
	            }
	            Return (0x00)
	         } 
	         Return (0x00)
		   }
	   
	       Method (STRT, 3, Serialized, 0, IntObj, {UnknownObj, UnknownObj, UnknownObj}) // IntObj, IntObj, PkgObj
	       {
	          OperationRegion (TPMR, SystemMemory, FTPM, 0x1000)
	          Field (TPMR, AnyAcc, NoLock, Preserve)
	          {
	            Offset(0x04),
	            FERR, 32,
	            Offset(0x0c),
	            BEGN, 32,
	          }
	          
	          Name (TIMR, 0)  
	          If( LNotEqual( ToInteger (Arg0), 0 ))
	          {
	            // For Tools check Arg0, do nothing...
	            // Return (1)   // 1: General Failure
	          }
			  
	          //
	          // Switch by function index
	          //
	          Switch (ToInteger (Arg1))
	          {
	              Case (0)
	              {
	                //
	                // Standard query, supports function 1-1
	                //
	                Return (Buffer () {0x03})
	              }
	              Case (1)
	              {   
	                Store(0, TIMR)
	                
	                If(LEqual(AMDT, 1))
	                {
	                  While(LAND(LEqual(BEGN, One), LLESS(TIMR, 0x200)))
	       		      {
	        			 If(LEqual(BEGN, One))
	    				 {
	    				   Sleep(0x1)
	    				   Increment(TIMR)
	    		         }
	    			  }
	
	                }Else{
	#if defined( ASL_TPM20_CRB_WITH_START_METHOD ) && (ASL_TPM20_CRB_WITH_START_METHOD == 1)
	
	                Store(0, TIMR);
	                //
	                // Wait STR bit clear, 90 sec for time out
	                //
	                While(LAND(LLessEqual(TIMR, 90000),LNotEqual(And(SCMD,0x00000001),0)))
	                {
	                    Sleep(1)
	                    Increment(TIMR)
	                }
	#else
	                  If(LEqual(Or(And(HSTS,0x00000002),And(HSTS,0x00000001)),0x00000003))
	                  {
	                    //
	                    // Trigger the FTPM_CMD interrupt
	                    //
	                    Store (0x00000001, HCMD)
	                  }              
	                  Else
	                  {
	                    //Set Error Bit
	                    Store(0x00000001,FERR)
	                    //Clear Start Bit
	                    Store(0x00000000,BEGN)
	                  }
	#endif
	
	              }
	              Return(Zero)
	           }    
	        }
		  
		    Return (1)    
		  }
	
	      Method (CRYF, 3, Serialized, 0, {BuffObj, PkgObj}, {UnknownObj, UnknownObj, UnknownObj}) // IntObj, IntObj, PkgObj
	      {
	        If( LNotEqual( ToInteger (Arg0), 1 ))
	        {
	          // For Tools check Arg0, do nothing...
	          // Return (Buffer () {0x00})  // 0: Failure
	        }
	          
	        //
	        // Switch by function index
	        //
	        Switch (ToInteger(Arg1))
	        {
	          Case (0)
	          {
	            //
	            // Standard query
	            //
	            Return (Buffer () {0x03})
	          }
	          Case (1)
	          {
	            //
	            // Return failure if no TPM present
	            //
	            Name(TPMV, Package () {0x01, Package () {0x1, 0x20}})
	            if (LEqual (_STA (), 0x00))
	            {
	              Return (Package () {0x00})
	            }
	            Return (TPMV)
	          }
	        }
	        Return (Buffer () {0})
	      }
	
	  }
	//**********************************************************************
	//<AMI_PHDR_START>
	//
	// Procedure:    _DSM PPI Method for TPM device 
	//
	// Description:  Implement Phisical Presence Interface using WordAcc
	//
	// Input:        \_SB.PCI0.LPCB.TP
	//
	// Output:      PPI result
	//
	// Modified:
	//
	// Referrals:
	//
	// Notes:
	//<AMI_PHDR_END>
	//**********************************************************************
	Scope(\_SB.TPM)
	{    
	    OperationRegion (TSMI, SystemIO, SMIA , 0x2) 
	    Field (TSMI, WordAcc, NoLock, Preserve) 
	    { 
	        SMI,16,
	    } 
	
	    OperationRegion (ATNV, SystemMemory, PPIM, PPIL)
	    Field (ATNV, AnyAcc, NoLock, Preserve)
	    {
	        RQST,   32, //   PPI Request
	        RCNT,   32, //   Most Recent PPI request
	        ERRO,   32, //   PPI operation Response
	        FLAG,   32, //   Function Request flag
	        MISC,   32, //   MISC
	        OPTN,   32, //   Optional PPI Request Parameter
	        SRSP,   32  //   PPI Function Request response
	    }
	
	
	    Method( _DSM , 4, Serialized)
	    {
	        if( LEqual(Arg0,ToUUID("3DDDFAA6-361B-4EB4-A424-8D10089D1653")))
	        {
	                switch(ToInteger(Arg2))            
	                {
	                    //
	                    // Function 0: Return supported functons
	                    //
	                    case(0)
	                    {
	                        return (Buffer() {0xff,0x01}) //support functions 0-6                       
	                    }
	
	                    //
	                    // Function 1: Ge PPI Version
	                    //
	                    case(1)
	                    {
	                        If (LEqual (PPIV, 0)) {
	                             return ("1.2")                        
	                        }Else{
	                             return ("1.3")                        
	                        }
	                    }
	
	                    //
	                    // Function 2: Submit TPM Operation request
	                    // Arg3[0]: Integer - Operation Value
	                    case(2)
	                    {
	                        Store(DeRefOf(Index(Arg3,0)), RQST)  //save request in temp flag
	                        Store (0, SRSP)
	                        Store(0x02, FLAG)  
	                        Store(OFST, TMF1)  
	                        Store (0, SRSP)                            
	                        Store(TMF1,SMI) 
	                        return(SRSP)
	                    }
	
	                    //
	                    // Function 3: Get pending TPM operation
	                    case(3)
	                    {
	                        Name(PPI1, Package(){0,0})
	                        Store(RQST, Index(PPI1,1))
	                        return(PPI1)
	                    }
	
	                    //
	                    // Function 4: Get platform-specific action to transition 
	                    // ot Pre-OS
	                    // Returns: 
	                    // 0: None
	                    // 1: Shutdown
	                    // 2: Reboot
	                    // 3: OS Vendor Specific
	                    case(4)
	                    {      
	                        return (TRST) //Shutdown                       
	                    }
	
	                    //
	                    // Function 5: Return TPM responce
	                    //    
	                    case(5)
	                    {
	                        Name(PPI2, Package(){0,0,0})
	                        Store (0, SRSP)  
	                        Store(0x05, FLAG)                           
	                        Store(OFST, SMI)
	                        Store (RCNT, Index (PPI2, 1))
	                        Store (ERRO, Index (PPI2, 2))
	                        return(PPI2) 
	                    }
	
	
	                    //
	                    // Function 6: Submit preferred user language
	                    // Ppi Spec 1.2 section 2.1.6      
	                    //  Arg3[0]: String  - preferred language code
	                    case(6)
	                    {
	                        return ( 0x03 ) //Not Implemented                             
	                    }
	                    
	                    
	                    //
	                    // Function 7: Submit TPM Operation Request to Pre-OS Environment 2
	                    // Ppi Spec 1.2 section 2.1.7   
	                    //  Arg3[0]: String  - preferred language code
	                    case(7)
	                    {
	                        Store(DeRefOf(Index(Arg3,0)), RQST)  //save request in temp flag
	                        Store(0x07, FLAG) 
	                        Store (0, OPTN) 
	                        If (LEqual (RQST, 23)) {
	                            ToInteger(DerefOf(Index(Arg3,0x01)),OPTN)
	                        }
	                        Store(OFST, TMF1)  
	                        Store (0, SRSP)                           
	                        Store(TMF1,SMI) 
	                        return(SRSP)
	                    }
	
	                    case(8)
	                    {
	                          Store(DeRefOf(Index(Arg3,0)), RQST)  //save request in temp flag          
	                          Store(0x08, FLAG)  
	                          Store(OFST, TMF1)
	                          Store (0, SRSP)                              
	                          Store(TMF1,SMI) 
	                          return (SRSP)
	                    }
	
	                    default { }                    
	                }
	        } else {if(LEqual(Arg0,
	        ToUUID("376054ED-CC13-4675-901C-4756D7F2D45D"))){
	            //
	            // Reset Atack Mitigation
	            //
	             switch(ToInteger(Arg2))            
	                {
	                    //
	                    // Function 0: Return supported funcitons
	                    //
	                    case(0)
	                    {
	                        return (Buffer() {0x3}) //support functions 0 and 1
	                    }
	
	                    //
	                    // Function 1: Set MOR Bit State
	                    //
	                    case(1)
	                    {   
	                        Store(DeRefOf(Index(Arg3,0)), RQST)  //save request in temp flag
	                        Store(0x09, FLAG) 
	                        Store(OFST, TMF1)                            
	                        Store (0, SRSP)                                
	                        Store(TMF1,SMI)  
	                        return(SRSP)
	                    }
	                    default { }                    
	                }
	            
	        }}               
	        // TPM2 ACPI Start Method
	        //
	        If(LEqual(Arg0, ToUUID ("cf8e16a5-c1e8-4e25-b712-4f54a96702c8")))
	        {
	          Return (CRYF (Arg1, Arg2, Arg3))
	        }
	
	        If(LEqual(Arg0, ToUUID ("6bbf6cab-5463-4714-b7cd-f0203c0368d4")))
	        {
	          Return (STRT (Arg1, Arg2, Arg3))
	        }
	        return (Buffer() {0})
	    }
	            
	        //
	        // PTS Reset MOR Bit When S4, S5
	        //
	    Method (TPTS, 1) 
	    {
	#if defined ASL_MOR_RESET_S4S5 && ASL_MOR_RESET_S4S5 == 1
	        Switch (ToInteger(Arg0))
	        {
	            case (4)    // S4
	            {
	                Store(0, RQST)  //save request in temp flag
	                Store(0x09, FLAG) 
	                Store (0, SRSP)
	                Store(OFST,SMI) 
	            }
	            case (5)    // S5
	            {
	                Store(0, RQST)  //save request in temp flag
	                Store(0x09, FLAG) 
	                Store (0, SRSP)
	                Store(OFST,SMI) 
	            }
	        }
	#endif
	// When OS is reboot/resume/shutdown, 
	// OS will execute the TPM_Shutdown command, 
	// But OS will not wait the TPM have already fininshed the internal command, 
	// we need to have some gap time for wait the TPM finished it internal command.
	#if defined ASL_TCG_WAIT_OS_TPM_READY && ASL_TCG_WAIT_OS_TPM_READY == 1  
	        Sleep(300);     // Sleep 300ms
	#endif
	    }
	}


}	// END ASL SCOPE

//-------- DO NOT EDIT THIS FILE --------
//
// FILE WAS GENERATED AUTOMATICALY USING AMISDL v7.04.0274 (四月 26 2023,16:58:30)
//
//-------- DO NOT EDIT THIS FILE --------
//****************************************************************************
//****************************************************************************
//**                                                                        **
//**         (C)Copyright 1985 - 2023, American Megatrends, Inc.            **
//**                                                                        **
//**                          All Rights Reserved.                          **
//**                                                                        **
//**                    5555 Oakbrook Pkwy, Norcross, GA 30092              **
//**                                                                        **
//**                          Phone (770)-246-8600                          **
//**                                                                        **
//****************************************************************************
//****************************************************************************

//
//-------- DO NOT EDIT THIS FILE --------
//****************************************************************************
//****************************************************************************
//**                                                                        **
//**         (C)Copyright 1985 - 2012, American Megatrends, Inc.            **
//**                                                                        **
//**                          All Rights Reserved.                          **
//**                                                                        **
//**                    5555 Oakbrook Pkwy, Norcross, GA 30092              **
//**                                                                        **
//**                          Phone (770)-246-8600                          **
//**                                                                        **
//****************************************************************************
//****************************************************************************
