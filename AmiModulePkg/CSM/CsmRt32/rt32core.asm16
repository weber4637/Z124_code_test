
	TITLE	RT32CORE.ASM -- RT32 module core file

;**********************************************************************
;**********************************************************************
;**                                                                  **
;**        (C)Copyright 1985-2013, American Megatrends, Inc.         **
;**                                                                  **
;**                       All Rights Reserved.                       **
;**                                                                  **
;**      5555 Oakbrook Parkway, Suite 200, Norcross, GA 30093        **
;**                                                                  **
;**                       Phone: (770)-246-8600                      **
;**                                                                  **
;**********************************************************************
;**********************************************************************
; $Header: /Alaska/SOURCE/Modules/CSM/Generic/RT32/rt32core.asm 3     1/25/08 2:23p Pats $
;
; $Revision: 3 $
;
; $Date: 1/25/08 2:23p $
;
;****************************************************************************

RT32 equ 1

include rt.equ
include mac32.mac
include pci.equ
include token.equ

.386

public stub_dummy_ret

;extproc	rth_pci_search_xlat
;extern rth_pci_search_func_xlat_32:near32
;extern rth_chipset_get_last_bus_32(stub_dummy_ret):near32
;extproc	rth_chipset_route_pci_irq

RT32_CSEG SEGMENT PARA PUBLIC USE32 'CODE'
	ASSUME	CS:RT32_CSEG

;---------------------------------------;
; BIOS32 Service Directory Signature    ;
;---------------------------------------;--------------------------------------;
; This structure marks the position of the BIOS32 Service Directory.  32 bit   ;
; runtime software will search E0000-FFFF0 for the ASCII signature "_32_"      ;
; to find this structure.  If the checksum of the structure is ok, then the 32 ;
; bit runtime software will use the 32 bit absolute address contained in this  ;
; structure to call the BIOS32 Service Directory Function.                     ;
;------------------------------------------------------------------------------;

BIOS32_SD_Signature	db '_32_'
;BIOS32_SD_EntryPoint	dd 000F0000h + offset RT32_CSEG:BIOS32_Service_Dir
BIOS32_SD_EntryPoint	dd 00h
BIOS32_SD_RevLevel	db 00h		;Rev 00 == PCI BIOS spec rev 2.0/2.1
BIOS32_SD_Length	db 01h		;In paragraphs
BIOS32_SD_CheckSum	db 00h		;Adjust so sum of this struc is 0
BIOS32_SD_Reserved	db 00h, 00h, 00h, 00h, 00h

; DO NOT MOVE THE FOLLOWING DATA AS IT IS AT A FIXED LOCATION
LastPciBus  db  0
            db 15 dup (0)   ; padding

;---------------------------------------;
; BIOS32_Service_Dir                    ;
;---------------------------------------;--------------------------------------;
; 32 Bit runtime software will call this function to detect the presence of,   ;
; and the entry point for a given 32 bit BIOS API.  Currently the only 32 bit  ;
; API supported by this directory is the 32 bit PCI runtime function API (in   ;
; real mode Int 1A B1xx and B4xx).                                             ;
;                                                                              ;
; Input:  EAX = 4 byte ASCII string describing the 32 bit BIOS API that caller ;
;               needs to access.  Only one value is currently valid:           ;
;                 "$PCI" or 49435024h : PCI BIOS 32 bit API                    ;
;          BL = Directory function number, currently only one function is      ;
;               supported: 00 - Returns entry point of given 32 bit BIOS API   ;
;                                                                              ;
; Output:  AL = Return code:                                                   ;
;                 00h = Requested API is present                               ;
;                 80h = Requested API is not present                           ;
;                 81h = BL contains an unsupported function number             ;
;         EBX = Absolute segment base of the requested API's entry point (used ;
;               to build a descriptor)                                         ;
;         ECX = The requested API's length (used to build a descriptor)        ;
;         EDX = Offset from base of the requested API's entry point (used to   ;
;               place a far call to the entry point)                           ;
;                                                                              ;
;                                                                              ;
; Destroys: Nothing                                                            ;
;------------------------------------------------------------------------------;
BIOS32_Service_Dir	proc far

	cmp	eax, 49435024h		; '$PCI'
	mov	al, 80h			;Return code for unknown API string
	jne	bios32_sd_done		;Br if unknown API string
	mov	al, 81h			;Return code for unknown function
	or	bl, bl
	jnz	bios32_sd_done		;Br if BL has unknown function number

	call	dummy			;Push EIP on stack
dummy:
	pop	ebx			;EBX = EIP = xxxx0000 + offset dummy
	sub	ebx, offset cs:dummy	;EBX = xxxx0000
	add	ebx, offset rtpci_32_entry
	mov	edx, ebx
	and	edx, 0FFFFh
	and	ebx, 0F0000h
	mov	ecx, 010000h		;Length of 32 bit PCI API
	mov	al, 0h			;Return code for success

bios32_sd_done:
	ret

BIOS32_Service_Dir	endp


;---------------------------------------;
; rtpci_32_entry                        ;
;---------------------------------------;--------------------------------------;
; This function is called by 32 bit runtime software to access the runtime PCI ;
; BIOS functions while in protected mode.                                      ;
;                                                                              ;
; Input:  AH = Major function number (B1h or B4h)                              ;
;         AL = Minor function number (upper bit must be set)                   ;
;         Other regs depend on which function is called                        ;
;                                                                              ;
; Output: CF = Set if error, clear if no error                                 ;
;         AX = Error code (0000 if no error)                                   ;
;         Other regs depend on which function is called                        ;
;                                                                              ;
; Destroys: Nothing                                                            ;
;------------------------------------------------------------------------------;
rtpci_32_entry	proc far
	pushf

	cmp	ah, 0B1h
	je	pci_32_b1xx		;Br if B1xx call

	mov	ah, RT_INVALID_FUNC
	stc
	jmp	pci_32_done		;Invalid function

pci_32_b1xx:
	cmp	al, 01h
	jne	pci_32_no_01
	call	rtpci_bios_present_32
	jmp	short pci_32_done

pci_32_no_01:
	cmp	al, 02h
	jne	pci_32_no_02
	call	rtpci_find_device_32
	jmp	short pci_32_done

pci_32_no_02:
	cmp	al, 03h
	jne	pci_32_no_03
	call	rtpci_find_class_32
	jmp	short pci_32_done

pci_32_no_03:
	cmp	al, 06h
	jne	pci_32_no_06
	call	rtpci_special_cycle_32
	jmp	short pci_32_done

pci_32_no_06:
	cmp	al, 08h
	jne	pci_32_no_08
	call	rtpci_read_cfg_byte_32
	jmp	short pci_32_done

pci_32_no_08:
	cmp	al, 09h
	jne	pci_32_no_09
	call	rtpci_read_cfg_word_32
	jmp	short pci_32_done

pci_32_no_09:
	cmp	al, 0Ah
	jne	pci_32_no_0A
	call	rtpci_read_cfg_dword_32
	jmp	short pci_32_done

pci_32_no_0A:
	cmp	al, 0Bh
	jne	pci_32_no_0B
	call	rtpci_write_cfg_byte_32
	jmp	short pci_32_done

pci_32_no_0B:
	cmp	al, 0Ch
	jne	pci_32_no_0C
	call	rtpci_write_cfg_word_32
	jmp	short pci_32_done

pci_32_no_0C:
	cmp	al, 0Dh
	jne	pci_32_no_0D
	call	rtpci_write_cfg_dword_32
	jmp	short pci_32_done

pci_32_no_0D:
	cmp	al, 0Eh
	jne	pci_32_no_0E
	call	rtpci_get_irq_options_32
	jmp	short pci_32_done

pci_32_no_0E:
	cmp	al, 0Fh
	jne	pci_32_no_0F
	call	rtpci_set_pci_irq_32
	jmp	short pci_32_done

pci_32_no_0F:
	mov	ah, RT_INVALID_FUNC
	stc				;Indicate failure

pci_32_done:
	jc	pci_32_error
	popf
	clc
pci_32_ret:
	ret

pci_32_error:
	popf
	stc
	jmp	short pci_32_ret

rtpci_32_entry	endp


;---------------------------------------;
; rtpci_bios_present                    ;
;---------------------------------------;--------------------------------------;
; This function is used to check if the BIOS supports the PCI runtime          ;
; interface and the version number and other information about the interface.  ;
;                                                                              ;
; NOTE: This function should only be called from RT.ASM.  All other            ;
; callers must call the rt_entry (in RT.ASM) with AH containing the proper     ;
; function number (see RT.EQU).                                                ;
;                                                                              ;
; Input:  Nothing                                                              ;
;                                                                              ;
; Output: CF = Set if error, cleared otherwise                                 ;
;         AH = Non zero return code if CF set (see RT.EQU)                     ;
;        EDX = ASCII string "PCI " (space in high byte)                        ;
;         BX = PCI spec version                                                ;
;         CL = Number of last bus PCI bus in system (see rtpci_get_bus_count)  ;
;         AL = Hardware mechanisms supported by this system:                   ;
;                 Bit 7-6: Reserved                                            ;
;                 Bit 5:   If 1, special cycle mechanism 2 is supported        ;
;                 Bit 4:   If 1, special cycle mechanism 1 is supported        ;
;                 Bit 3-2: Reserved                                            ;
;                 Bit 1:   If 1, configuration space mechanism 2 is supported  ;
;                 Bit 0:   If 1, configuration space mechanism 1 is supported  ;
;                                                                              ;
; Destroys: Nothing                                                            ;
;------------------------------------------------------------------------------;
defproc rtpci_bios_present
	callproc rth_pci_get_last_bus	;Returns last bus number in CL
;	mov	cl, 0
	callproc rth_pci_get_hw_mech	;Returns hardware mech bits in AL

	mov	edx, 20494350h		;ASCII string "PCI "
	mov	bx, PCI_SPEC_VERSION
	mov	ah, RT_NO_ERROR

	clc
	ret
endproc rtpci_bios_present

;---------------------------------------;
; rtpci_find_device                     ;
;---------------------------------------;--------------------------------------;
; This function is used to find the bus/device/function number of a device     ;
; given its Device/Vendor ID.                                                  ;
;                                                                              ;
; NOTE: This function should only be called from RT.ASM.  All other            ;
; callers must call the rt_entry (in RT.ASM) with AH containing the proper     ;
; function number (see RT.EQU).                                                ;
;                                                                              ;
; Input:  CX = PCI Device ID                                                   ;
;         DX = PCI Vendor ID                                                   ;
;         SI = Index (In case there are multiple devices with the same ID then ;
;              find the Nth one where SI is N)                                 ;
;                                                                              ;
; Output: CF = Set if error, cleared otherwise                                 ;
;         AH = Non zero return code if CF set (see RT.EQU)                     ;
;         BH = PCI bus number                                                  ;
;         BL = Device / Function number                                        ;
;              Bits 7-3: PCI device number                                     ;
;              Bits 2-0: Function number within the device                     ;
;                                                                              ;
; Destroys: Nothing                                                            ;
;------------------------------------------------------------------------------;
defproc rtpci_find_device
	cmp	dx, 0FFFFh		;Check for invalid vendor ID
	je	find_device_invalid	;Br if vendor ID is invalid

	push	edx

	shl	edx, 16			;Set EDX = dev/vend id (vend id in lsw)
	mov	dx, cx
	rol	edx, 16
	xor	bl, bl			;Search for dev/vend id
	callproc find_device
	mov	ah, RT_NO_ERROR
	jnc	find_device_done	;Br if device was found
	mov	ah, RT_PCI_DEV_NOT_FOUND

find_device_done:
	pop	edx
find_device_ret:
	ret

find_device_invalid:
	mov	ah, RT_PCI_BAD_VENDOR_ID
	stc
	jmp	short find_device_ret

endproc rtpci_find_device


;---------------------------------------;
; rtpci_find_class                      ;
;---------------------------------------;--------------------------------------;
; This function searches for PCI devices that match a given class code.        ;
;                                                                              ;
; NOTE: This function should only be called from RT.ASM.  All other            ;
; callers must call the rt_entry (in RT.ASM) with AH containing the proper     ;
; function number (see RT.EQU).                                                ;
;                                                                              ;
; Input: ECX = Class code in lower 3 bytes (see DIM.EQU for class codes)       ;
;         SI = Index (In case there are multiple devices with the same class   ;
;              code then find the Nth one where SI is N)                       ;
;                                                                              ;
; Output: CF = Set if error, cleared otherwise                                 ;
;         AH = Non zero return code if CF set (see RT.EQU)                     ;
;         BH = PCI bus number                                                  ;
;         BL = Device / Function number                                        ;
;              Bits 7-3: PCI device number                                     ;
;              Bits 2-0: Function number within the device                     ;
;                                                                              ;
; Destroys: Nothing                                                            ;
;------------------------------------------------------------------------------;
defproc rtpci_find_class
	push	edx

	mov	edx, ecx
	and	edx, 00FFFFFFh		;Zero out the upper byte
	cmp	edx, 00FFFFFFh
	stc
	je	find_class_invalid	;Br if finding a invalid class code

	mov	bl, 1			;Search for class code
	callproc find_device
	mov	ah, RT_NO_ERROR
	jnc	find_class_exit		;Br if device was found

find_class_invalid:
	mov	ah, RT_PCI_DEV_NOT_FOUND

find_class_exit:
	pop	edx
	ret
endproc rtpci_find_class


;---------------------------------------;
; rtpci_special_cycle                   ;
;---------------------------------------;--------------------------------------;
; This function is used to generate a special cycle on the specified PCI bus.  ;
; A special cycle "broadcasts" the data to all PCI devices on a bus.           ;
;                                                                              ;
; NOTE: This function should only be called from RT.ASM.  All other            ;
; callers must call the rt_entry (in RT.ASM) with AH containing the proper     ;
; function number (see RT.EQU).                                                ;
;                                                                              ;
; Input:  BH = PCI bus number                                                  ;
;        EDX = Special cycle data                                              ;
;                                                                              ;
; Output: CF = Set if error, cleared otherwise                                 ;
;         AH = Non zero return code if CF set (see RT.EQU)                     ;
;                                                                              ;
; Destroys: Nothing                                                            ;
;------------------------------------------------------------------------------;
defproc rtpci_special_cycle
	callproc rth_pci_special_cycle	;Call the hook function to do this
	ret
endproc rtpci_special_cycle


;---------------------------------------;
; rtpci_read_cfg_byte                   ;
;---------------------------------------;--------------------------------------;
; This function reads a byte from the configuration space of given device /    ;
; function.                                                                    ;
;                                                                              ;
; NOTE: This function should only be called from RT.ASM.  All other            ;
; callers must call the rt_entry (in RT.ASM) with AH containing the proper     ;
; function number (see RT.EQU).                                                ;
;                                                                              ;
; Input:  BH = PCI Bus number                                                  ;
;         BL = Device / Function number                                        ;
;              Bits 7-3: PCI device number                                     ;
;              Bits 2-0: Function number within the device                     ;
;         DI = Register number                                                 ;
;                                                                              ;
; Output: CF = Set if error, cleared otherwise                                 ;
;         AH = Non zero return code if CF set (see RT.EQU)                     ;
;         CL = Byte read from configuration space                              ;
;                                                                              ;
; Destroys: Nothing                                                            ;
;------------------------------------------------------------------------------;
defproc rtpci_read_cfg_byte
	push	si
	mov	si, PCI_REG_ADDRESS_BYTE
	test	di, si
					;(CORE0132.2)>
;	jnz	read_byte_bad_add	;Br if address is invalid
	jnz	read_byte_big_add	;Br if address is invalid
					;<(CORE0132.2)

	callproc rth_pci_read_cfg
	jc	read_byte_bad_add	;Br if error while reading
	mov	ah, RT_NO_ERROR
	clc

read_byte_ret:
	pop	si
	ret

read_byte_bad_add:
	stc
	mov	ah, RT_PCI_BAD_REG_ADD	;Indicate invalid address
	jmp	short read_byte_ret

					;(CORE0132.2)>
read_byte_big_add:
	call pci30_read_cfg_x 
	jmp	short read_byte_ret
					;<(CORE0132.2)
endproc rtpci_read_cfg_byte


;---------------------------------------;
; rtpci_read_cfg_word                   ;
;---------------------------------------;--------------------------------------;
; This function reads a word from the configuration space of given device /    ;
; function.                                                                    ;
;                                                                              ;
; NOTE: This function should only be called from RT.ASM.  All other            ;
; callers must call the rt_entry (in RT.ASM) with AH containing the proper     ;
; function number (see RT.EQU).                                                ;
;                                                                              ;
; Input:  BH = PCI Bus number                                                  ;
;         BL = Device / Function number                                        ;
;              Bits 7-3: PCI device number                                     ;
;              Bits 2-0: Function number within the device                     ;
;         DI = Register number (must be even address)                          ;
;                                                                              ;
; Output: CF = Set if error, cleared otherwise                                 ;
;         AH = Non zero return code if CF set (see RT.EQU)                     ;
;         CX = Word read from configuration space                              ;
;                                                                              ;
; Destroys: Nothing                                                            ;
;------------------------------------------------------------------------------;
defproc rtpci_read_cfg_word
	push	si
	mov	si, PCI_REG_ADDRESS_WORD
	test	di, si
					;(CORE0132.2)>
;	jnz	read_word_bad_add	;Br if address is invalid
	jnz	read_word_big_add	;Br if address is invalid
					;<(CORE0132.2)

	callproc rth_pci_read_cfg
	jc	read_word_bad_add	;Br if error while reading
	mov	ah, RT_NO_ERROR
	clc

read_word_ret:
	pop	si
	ret

read_word_bad_add:
	stc
	mov	ah, RT_PCI_BAD_REG_ADD	;Indicate invalid address
	jmp	short read_word_ret

					;(CORE0132.2)>
read_word_big_add:
	call pci30_read_cfg_x 
	jmp	short read_word_ret
					;<(CORE0132.2)
endproc rtpci_read_cfg_word


;---------------------------------------;
; rtpci_read_cfg_dword                  ;
;---------------------------------------;--------------------------------------;
; This function reads a dword from the configuration space of given device /   ;
; function.                                                                    ;
;                                                                              ;
; NOTE: This function should only be called from RT.ASM.  All other            ;
; callers must call the rt_entry (in RT.ASM) with AH containing the proper     ;
; function number (see RT.EQU).                                                ;
;                                                                              ;
; Input:  BH = PCI Bus number                                                  ;
;         BL = Device / Function number                                        ;
;              Bits 7-3: PCI device number                                     ;
;              Bits 2-0: Function number within the device                     ;
;         DI = Register number (must be dword aligned address)                 ;
;                                                                              ;
; Output: CF = Set if error, cleared otherwise                                 ;
;         AH = Non zero return code if CF set (see RT.EQU)                     ;
;        ECX = DWord read from configuration space                             ;
;                                                                              ;
; Destroys: Nothing                                                            ;
;------------------------------------------------------------------------------;
defproc rtpci_read_cfg_dword
	push	si
	mov	si, PCI_REG_ADDRESS_DWORD
	test	di, si
					;(CORE0132.2)>
;	jnz	read_dword_bad_add	;Br if address is invalid
	jnz	read_dword_big_add	;Br if address is invalid
					;<(CORE0132.2)

	callproc rth_pci_read_cfg
	jc	read_dword_bad_add	;Br if error while reading
	mov	ah, RT_NO_ERROR
	clc

read_dword_ret:
	pop	si
	ret

read_dword_bad_add:
	stc
	mov	ah, RT_PCI_BAD_REG_ADD	;Indicate invalid address
	jmp	short read_dword_ret

					;(CORE0132.2)>
read_dword_big_add:
	call pci30_read_cfg_x 
	jmp	short read_dword_ret
					;<(CORE0132.2)
endproc rtpci_read_cfg_dword


;---------------------------------------;
; rtpci_write_cfg_byte                  ;
;---------------------------------------;--------------------------------------;
; This function writes a byte to the configuration space of given device /     ;
; function.                                                                    ;
;                                                                              ;
; NOTE: This function should only be called from RT.ASM.  All other            ;
; callers must call the rt_entry (in RT.ASM) with AH containing the proper     ;
; function number (see RT.EQU).                                                ;
;                                                                              ;
; Input:  BH = PCI Bus number                                                  ;
;         BL = Device / Function number                                        ;
;              Bits 7-3: PCI device number                                     ;
;              Bits 2-0: Function number within the device                     ;
;         DI = Register number                                                 ;
;         CL = Byte to write to configuration space                            ;
;                                                                              ;
; Output: CF = Set if error, cleared otherwise                                 ;
;         AH = Non zero return code if CF set (see RT.EQU)                     ;
;                                                                              ;
; Destroys: Nothing                                                            ;
;------------------------------------------------------------------------------;
defproc rtpci_write_cfg_byte
	push	si
	mov	si, PCI_REG_ADDRESS_BYTE
	test	di, si
					;(CORE0132.2)>
;	jnz	write_byte_bad_add	;Br if address is invalid
	jnz	write_byte_big_add	;Br if address is invalid
					;<(CORE0132.2)

	callproc rth_pci_write_cfg
	jc	write_byte_bad_add	;Br if error while writing
	mov	ah, RT_NO_ERROR
	clc

write_byte_ret:
	pop	si
	ret

write_byte_bad_add:
	stc
	mov	ah, RT_PCI_BAD_REG_ADD	;Indicate invalid address
	jmp	short write_byte_ret

					;(CORE0132.2)>
write_byte_big_add:
	call 	pci30_write_cfg_x 
	jmp	short write_byte_ret
					;<(CORE0132.2)
endproc rtpci_write_cfg_byte


;---------------------------------------;
; rtpci_write_cfg_word                  ;
;---------------------------------------;--------------------------------------;
; This function writes a word to the configuration space of given device /     ;
; function.                                                                    ;
;                                                                              ;
; NOTE: This function should only be called from RT.ASM.  All other            ;
; callers must call the rt_entry (in RT.ASM) with AH containing the proper     ;
; function number (see RT.EQU).                                                ;
;                                                                              ;
; Input:  BH = PCI Bus number                                                  ;
;         BL = Device / Function number                                        ;
;              Bits 7-3: PCI device number                                     ;
;              Bits 2-0: Function number within the device                     ;
;         DI = Register number (must be even address)                          ;
;         CX = Word to write to configuration space                            ;
;                                                                              ;
; Output: CF = Set if error, cleared otherwise                                 ;
;         AH = Non zero return code if CF set (see RT.EQU)                     ;
;                                                                              ;
; Destroys: Nothing                                                            ;
;------------------------------------------------------------------------------;
defproc rtpci_write_cfg_word
	push	si
	mov	si, PCI_REG_ADDRESS_WORD
	test	di, si
					;(CORE0132.2)>
;	jnz	write_word_bad_add	;Br if address is invalid
	jnz	write_word_big_add	;Br if address is invalid
					;<(CORE0132.2)

	callproc rth_pci_write_cfg
	jc	write_word_bad_add	;Br if error while writing
	mov	ah, RT_NO_ERROR
	clc

write_word_ret:
	pop	si
	ret

write_word_bad_add:
	stc
	mov	ah, RT_PCI_BAD_REG_ADD	;Indicate invalid address
	jmp	short write_word_ret

					;(CORE0132.2)>
write_word_big_add:
	call 	pci30_write_cfg_x 
	jmp	short write_word_ret
					;<(CORE0132.2)
endproc rtpci_write_cfg_word


;---------------------------------------;
; rtpci_write_cfg_dword                 ;
;---------------------------------------;--------------------------------------;
; This function writes a dword to the configuration space of given device /    ;
; function.                                                                    ;
;                                                                              ;
; NOTE: This function should only be called from RT.ASM.  All other            ;
; callers must call the rt_entry (in RT.ASM) with AH containing the proper     ;
; function number (see RT.EQU).                                                ;
;                                                                              ;
; Input:  BH = PCI Bus number                                                  ;
;         BL = Device / Function number                                        ;
;              Bits 7-3: PCI device number                                     ;
;              Bits 2-0: Function number within the device                     ;
;         DI = Register number (must be dword aligned address)                 ;
;        ECX = DWord to write to configuration space                           ;
;                                                                              ;
; Output: CF = Set if error, cleared otherwise                                 ;
;         AH = Non zero return code if CF set (see RT.EQU)                     ;
;                                                                              ;
; Destroys: Nothing                                                            ;
;------------------------------------------------------------------------------;
defproc rtpci_write_cfg_dword
	push	si
	mov	si, PCI_REG_ADDRESS_DWORD
	test	di, si
					;(CORE0132.2)>
;	jnz	write_dword_bad_add	;Br if address is invalid
	jnz	write_dword_big_add	;Br if address is invalid
					;<(CORE0132.2)

	callproc rth_pci_write_cfg
	jc	write_dword_bad_add	;Br if error while writing
	mov	ah, RT_NO_ERROR
	clc

write_dword_ret:
	pop	si
	ret

write_dword_bad_add:
	stc
	mov	ah, RT_PCI_BAD_REG_ADD	;Indicate invalid address
	jmp	short write_dword_ret

					;(CORE0132.2)>
write_dword_big_add:
	call 	pci30_write_cfg_x 
	jmp	short write_dword_ret
					;<(CORE0132.2)
endproc rtpci_write_cfg_dword


;---------------------------------------;
; rtpci_get_irq_options                 ;
;---------------------------------------;--------------------------------------;
; This routine copies the system's PCI IRQ routing tables to a buffer provided ;
; by the caller.  It also returns a bitmap showing which IRQs (if any) are     ;
; hardwired to devices or slots on the PCI bus and are unavailable to other    ;
; devices (ISA, EISA, PnP ISA).                                                ;
;                                                                              ;
; Input:  DS = F000 (or selector pointing to F000 if called in 16-bit protected;
;              mode).  If called in 32-bit protected mode the DS selector will ;
;              be set to the same base as the CS selector and will not         ;
;              necessarily be F0000 (some software calls with DS = CS = 0 base);
;              This means that in the 32-bit code, no offset in CS should be   ;
;              accessed directly.  You must first get the value of EIP by      ;
;              making a call from a known offset and popping the return        ;
;              address, and then subtracting the offset of that address from   ;
;              the popped value.  The resulting value must be added to any     ;
;              CS:offset before that label is accessed.                        ;
;         ES:(E)DI = Pointer to the following structure supplied by caller:    ;
;                    dw = Size of caller's buffer that will accept routing     ;
;                         tables (16 bytes per slot are needed)                ;
;                    dd = Segment:Offset of caller's buffer                    ;
;                                                                              ;
; Output: CF = Set if caller's buffer is too small, cleared otherwise          ;
;         AH = Non zero return code if CF set (see RT.EQU)                     ;
;         BX = Bitmap of IRQs that are hardwired to devices or slots on the    ;
;              PCI bus (these IRQ cannot be used by any device other than PCI) ;
;                                                                              ;
; Destroys: Nothing                                                            ;
;------------------------------------------------------------------------------;
defproc rtpci_get_irq_options
	push	ecx			;Keep these AX and CX in this order
	push	ax
	push	esi
	push	edi
	push	es

	push	ebx
;	call	dummy			;Push EIP on stack
;dummy:
;	pop	ebx			;EBX = EIP = xxxx0000 + offset dummy
;	sub	ebx, offset cs:dummy	;EBX = xxxx0000

;	movzx	esi, WORD PTR [ebx+0E00Ah]	; ESI = Offset of rth_pci_device_limit.
	
;	add	esi, ebx		; ESI = ptr to rth_pci_device_limit.
;	movzx	ecx, byte ptr [esi+1]	; ECX = rth_pci_device_count.
;	mov	ax, word ptr [esi+2]	; AX = rth_pci_dedicated_irqs.
;	movzx	esi, WORD PTR [esi+4]	; ESI = offset of rth_pci_irq_routing_table.
;	add	esi, ebx		; ESI = ptr to rth_pci_irq_routing_table.

	mov	ebx, 0F0000h
	movzx	esi, WORD PTR [ebx+003Ah]
	add	esi, ebx
	movzx	ecx, word ptr [esi+6]	; ECX = size of header and routing table
	sub	ecx,20h			; remove size of header
	mov	ax, word ptr [esi+10]	; AX = rth_pci_dedicated_irqs.
	add	esi,20h			; point to routing table

	pop	ebx
	mov	bx, ax			; BX = rth_pci_dedicated_irqs.
	
;	shl	cx, 4			;CX = # of PCI devs * 16
	mov	ax, es:[edi]		;AX = size of caller's buffer
	mov	es:[edi], cx		;Write proper size into caller's struc
	cmp	ax, cx
	jb	irq_opt_buf_too_small	;Br if caller's buffer is too small

;	les	edi, es:[edi+2]		;ES:EDI = pointer to caller's buffer
	mov	edi, es:[edi+2]		;ES:EDI = pointer to caller's buffer

	rep	movsb			;Copy IRQ routing tables to caller's buf

	xor	ch, ch			;Indicate success
	clc

irq_opt_done:
	pop	es
	pop	edi
	pop	esi
	pop	ax
	mov	ah, ch
	pop	ecx
	ret

irq_opt_buf_too_small:
	mov	ch, RT_PCI_BUF_TOO_SMALL ;Failure due to buffer to small
	stc
	jmp	short irq_opt_done

endproc rtpci_get_irq_options


;---------------------------------------;
; rtpci_set_pci_irq                     ;
;---------------------------------------;--------------------------------------;
;                                                                              ;
; Input:  BH = PCI Bus number                                                  ;
;         BL = Device / Function number                                        ;
;              Bits 7-3: PCI device number                                     ;
;              Bits 2-0: Function number within the device                     ;
;         CL = Int Pin Number:                                                 ;
;              0Ah = Int A Pin      0Bh = Int B Pin                            ;
;              0Ch = Int A Pin      0Dh = Int B Pin                            ;
;         CH = IRQ level to route to the given bus/device/int pin              ;
;              00h = IRQ 0, ..., 0Fh = IRQ 15                                  ;
;              10h to FFh = Invalid                                            ;
;         DS = F000 (or selector pointing to F000 if called in 16-bit protected;
;              mode).  If called in 32-bit protected mode the DS selector will ;
;              be set to the same base as the CS selector and will not         ;
;              necessarily be F0000 (some software calls with DS = CS = 0 base);
;              This means that in the 32-bit code, no offset in CS should be   ;
;              accessed directly.  You must first get the value of EIP by      ;
;              making a call from a known offset and popping the return        ;
;              address, and then subtracting the offset of that address from   ;
;              the popped value.  The resulting value must be added to any     ;
;              CS:offset before that label is accessed.                        ;
;                                                                              ;
; Output: CF = Set if caller's buffer is too small, cleared otherwise          ;
;         AH = Non zero return code if CF set (see RT.EQU)                     ;
;                                                                              ;
; Destroys: Nothing                                                            ;
;------------------------------------------------------------------------------;
defproc rtpci_set_pci_irq
	push	cx
	push	dx

	cmp	ch, 0Fh
	ja	set_irq_error		;Br if IRQ level is invalid

	mov	dl, cl			;DL = Int Pin: 0Ah/0Bh/0Ch/0Dh
	sub	dl, 0Ah			;DL = Int Pin: 0/1/2/3
	cmp	dl, 3
	ja	set_irq_error		;Br if Int Pin is invalid
	inc	dl			;DL = Int Pin: 1/2/3/4

	push	ax
	mov	al, ch			;AL = IRQ level
	callproc rth_pci_route_irq
	pop	ax
	jc	set_irq_error		;Br if error setting PCI IRQ

	mov	ah, RT_NO_ERROR		;Indicate success

set_irq_done:
	pop	dx
	pop	cx
	ret

set_irq_error:
	stc				;Indicate error
	mov	ah, RT_PCI_SET_FAILED
	jmp	short set_irq_done
endproc rtpci_set_pci_irq


;---------------------------------------;
; rtpci_search_xlat                     ;
;---------------------------------------;--------------------------------------;
; This function translates a PCI device search index to a logical PCI device   ;
; number.                                                                      ;
;                                                                              ;
; Input:  BH = PCI bus number that is being searched                           ;
;         BL = PCI device search index in the range (0 - 1F)                   ;
;                                                                              ;
; Input:  BL = PCI device number in the range (0 - 1F)                         ;
;                                                                              ;
; Destroys: Nothing                                                            ;
;------------------------------------------------------------------------------;
defproc rtpci_search_xlat
	callproc rth_pci_search_xlat	;Call hook function to do the work
	ret
endproc rtpci_search_xlat

					;(CORE0061.1+)>
;---------------------------------------;
; rtpci_search_func_xlat                ;
;---------------------------------------;--------------------------------------;
; This function translates a PCI device search index to a logical PCI device   ;
; number.                                                                      ;
;                                                                              ;
; Input:  DL = PCI function search index in the range (7 - 0)                  ;
;                                                                              ;
; Output:  DL = PCI function number in the range (0 - 7)                       ;
;                                                                              ;
; Destroys: Nothing                                                            ;
;------------------------------------------------------------------------------;
defproc rtpci_search_func_xlat
	callproc rth_pci_search_func_xlat	;Call hook function to do the work
	ret
endproc rtpci_search_func_xlat
					;<(CORE0061.1)

;---------------------------------------;
; find_device                           ;
;---------------------------------------;--------------------------------------;
; This function is called by rtpci_find_device and rtpci_find_class to locate  ;
; a given device id or class code.                                             ;
;                                                                              ;
; Input:  BL = 0, if called by rtpci_find_device                               ;
;              1, if called by rtpci_find_class                                ;
;        EDX = If called by rtpci_find_device, contains the device/vendor ID   ;
;              to search for (vendor id in low word).                          ;
;              If called by rtpci_find_class, contains the class code to       ;
;              search for (in low 3 bytes, upper byte must be 0).              ;
;         SI = Index (In case there are multiple devices, then find the Nth    ;
;              one where SI is N)                                              ;
;                                                                              ;
; Output: CF = Set if error, cleared otherwise                                 ;
;         BH = PCI bus number of device (if found)                             ;
;         BL = PCI device/function number of device (if found)                 ;
;              Bits 7-3: PCI device number                                     ;
;              Bits 2-0: Function number within the device                     ;
;                                                                              ;
; Destroys: Nothing                                                            ;
;------------------------------------------------------------------------------;
defproc find_device
	push	ax
	push	ecx
	push	si
	push	di
	push	bp			;(CORE0061.1+)

	mov	al, bl			;Put caller flag into AL

	callproc rth_pci_get_last_bus	;Returns last bus number in CL
;	mov	cl, 0
	mov	bh, cl			;BH will be bus counter

find_dev_bus_loop:
	xor	bl, bl			;BL will be device index counter

find_dev_dev_loop:
	push	bx			;Save Bus # / Dev index
	callproc rtpci_search_xlat	;Returns device number
	shl	bl, 3			;Put device number in bits 7-3

	mov	di, PCI_REG_VENDID
	callproc rtpci_read_cfg_dword
	cmp	ecx, 0FFFFFFFFh
	je	find_dev_next_dev	;Br if IDs are FFFFFFFF

	;There is a device at this device num so now see if it is a
	;multi function device.  If so, step through all 8 functions.

	mov	di, PCI_REG_HEADER_TYPE
	callproc rtpci_read_cfg_byte
	mov	bp, 0000h		;single function (CORE0061.1+)
	test	cl, MULTI_FUNC_BIT
	jz	find_dev_single_func	;Br if device has single function
	or	bl, 7			;Must scan all functions (7-0)
	mov	bp, 8007h		;multi-function (CORE0061.1+)
find_dev_single_func:

find_dev_func_loop:
					;(CORE0061.1+)>
	test	bp, 8000h
	jz	@f			;br if not multifunction
	mov	bp, bx
	and	bl, 07h
	callproc rtpci_search_func_xlat	;Returns function number
	mov	ah, bl
	mov	bx, bp
	and	bl, 0F8h
	or	bl, ah
	or	bp, 8000h
@@:
					;<(CORE0061.1+)
	;Check the device at the current bus/dev/func number to see if it meets
	;the search criteria.  If it does, then check the instance counter in
	;SI, if it is 0 then we have found the device that we are looking for.

	or	al, al
	jnz	find_dev_class		;Br if we are looking for a class code

	mov	di, PCI_REG_VENDID
	callproc rtpci_read_cfg_dword
	jmp	short find_dev_do_comp

find_dev_class:
	mov	di, PCI_REG_REVID	;Read 3 class bytes plus rev id at once
	callproc rtpci_read_cfg_dword
	shr	ecx, 8			;Get rid of rev id, leaving class codes

find_dev_do_comp:
	cmp	ecx, edx		;EDX was passed in, ECX was just set
	jne	find_dev_next_func	;Br if not what we are looking for
	or	si, si
	jz	find_dev_found		;Br if instance counter is zero, success
	dec	si			;Otherwise look for another same device

find_dev_next_func:
					;(CORE0061.1+)>
	push	ax
	mov	ax, bp	
	mov	bl, al	
	pop	ax
					;<(CORE0061.1)
	test	bl, 7
	jz	find_dev_next_dev	;Br if searched through function 0
	dec	bl			;Try next function on the device
	jmp	short find_dev_func_loop

find_dev_next_dev:
	pop	bx			;Restore Bus # / Dev index
	inc	bl			;Next device index
	cmp	bl, MAX_PCI_DEVICE_NUM
	jbe	find_dev_dev_loop	;Br if more devices for this bus

					;(CORE0155)>
;	dec	bh			;Next bus number
;	jns	find_dev_bus_loop	;Br if more busses to search
;	stc				;Indicate device not found
	sub	bh, 1
	jnc	find_dev_bus_loop
					;<(CORE0155)
	jmp	short find_dev_exit

find_dev_found:
	pop	ax			;Remove Bus # / Dev index from stack
	clc
find_dev_exit:
	pop	bp			;(CORE0061.1+)
	pop	di
	pop	si
	pop	ecx
	pop	ax
	ret
endproc find_device

CFG_SPACE_INDEX_REG	equ	0CF8h	;For systems with config mechanism 1
CFG_SPACE_DATA_REG	equ	0CFCh

;---------------------------------------;
; rth_pci_route_irq                     ;
;---------------------------------------;--------------------------------------;
; This function is to physically route an IRQ to a PCI bus#/device#.           ;
; The IRQ level that must be routed should be one from the list that was       ;
; returned by dih_pci_get_irq_priority_map (see above).                        ;
;                                                                              ;
; NOTE: This function is assembled twice, once for real mode code, and once    ;
;       for 32 bit protected mode code.  All calls must be made using the      ;
;       callproc macro.  Do not modify and segment registers.                  ;
;                                                                              ;
; Input: AL = IRQ level to route to the PCI device                             ;
;        BL = Device/Function number to route IRQ to                           ;
;                Bits 7-3: PCI device number                                   ;
;                Bits 2-0: Function number within the device                   ;
;        BH = Bus number to route IRQ to                                       ;
;        DL = PCI Int pin that the device uses                                 ;
;             (01=IntA, 02=IntB, 03=IntC, 04=IntD).                            ;
;        DS = F000 (or selector pointing to F000 if called in 16-bit protected ;
;             mode).  If called in 32-bit protected mode the DS selector will  ;
;             be set to the same base as the CS selector and will not          ;
;             necessarily be F0000 (some software calls with DS = CS = 0 base) ;
;             This means that in the 32-bit code, no offset in CS should be    ;
;             accessed directly.  You must first get the value of EIP by       ;
;             making a call from a known offset and popping the return         ;
;             address, and then subtracting the offset of that address from    ;
;             the popped value.  The resulting value must be added to any      ;
;             CS:offset before that label is accessed.                         ;
;                                                                              ;
; Output: CF = Set if error, clear if successful                               ;
;                                                                              ;
; Destroys: Nothing                                                            ;
;------------------------------------------------------------------------------;
defproc rth_pci_route_irq
	pusha

	mov	ah, al			;Save IRQ level in AH
	callproc rth_pci_get_irq_reg	;Returns AL=chip reg, DX=IRQ bit map
	jc	route_irq_done		;Br if unknown device

	or	al, al
	stc				;Set CF in case this jz jumps
	jz	route_irq_done		;Br if Device/Int Pin is not connected
	cmp	al, 0F0h
	jae	route_irq_success	;Br if Device/Int Pin is hardwired
					;(CORE0153+)>
	push	ax
	mov	al, ah
	xor	ah, ah 
	bt	dx, ax
	pop	ax
	jc	valid_irq
	stc
	jmp	route_irq_done		;Br if Device/Int Pin is not connected
valid_irq:
					;<(CORE0153)
;----------------- Chipset dependent code starts here ------------------------

;  Program the chipset register in AL with the IRQ level in AH.
;  Also make sure this IRQ is set to level (or edge if needed) trigger.

	callproc rth_chipset_route_pci_irq; route IRQ

;----------------- Chipset dependant code ends here ---------------------------

route_irq_success:
	clc				;Indicate success
route_irq_done:
	popa
	ret
endproc rth_pci_route_irq


;---------------------------------------;
; rth_pci_get_irq_reg                   ;
;---------------------------------------;--------------------------------------;
; This function returns the chipset IRQ register that should be programmed in  ;
; order to route an IRQ to a given PCI device number / Int Pin number.  It     ;
; also returns a bitmap of IRQs that may be routed to the given Device/Int Pin.;
; This information is extracted from the PCI IRQ Routing Table above.          ;
;                                                                              ;
; NOTE: This function does not need to be modified for most platforms.         ;
;                                                                              ;
; NOTE: This function is assembled twice, once for real mode code, and once    ;
;       for 32 bit protected mode code.  All calls must be made using the      ;
;       callproc macro.  Do not modify and segment registers.                  ;
;                                                                              ;
; Input: BL = Device/Function number to route IRQ to                           ;
;                Bits 7-3: PCI device number                                   ;
;                Bits 2-0: Function number within the device                   ;
;        BH = Bus number to route IRQ to                                       ;
;        DL = PCI Int pin that the device uses                                 ;
;             (01=IntA, 02=IntB, 03=IntC, 04=IntD).                            ;
;        DS = F000 (or selector pointing to F000 if called in 16-bit protected ;
;             mode).  If called in 32-bit protected mode the DS selector will  ;
;             be set to the same base as the CS selector and will not          ;
;             necessarily be F0000 (some software calls with DS = CS = 0 base) ;
;             This means that in the 32-bit code, no offset in CS should be    ;
;             accessed directly.  You must first get the value of EIP by       ;
;             making a call from a known offset and popping the return         ;
;             address, and then subtracting the offset of that address from    ;
;             the popped value.  The resulting value must be added to any      ;
;             CS:offset before that label is accessed.                         ;
;                                                                              ;
; Output: CF = Set if error, clear if successful                               ;
;         AL = Chipset IRQ register number from rth_pci_irq_routing_table      ;
;              in the file RTH-PCI.ASM                                         ;
;         DX = Bitmap of IRQs that can be routed to the given Device/Int Pin.  ;
;                Bit 0: If set, chipset can route IRQ 0 to the device/pin      ;
;                ...     ...                                                   ;
;                Bit 15: If set, chipset can route IRQ 15 to the device/pin    ;
;                                                                              ;
; Destroys: Nothing                                                            ;
;------------------------------------------------------------------------------;
defproc rth_pci_get_irq_reg
	push	ebx
	push	ecx
	push	esi

ifndef RT32

	movzx	cx, byte ptr ds:rth_pci_device_count
	mov	esi, offset ds:rth_pci_irq_routing_table
else
	push	ebx			;Save Bus/Dev/Func #
;	call	dummy			;Push EIP on stack
;dummy:
;	pop	ebx			;EBX = EIP = xxxx0000 + offset dummy
;	sub	ebx, offset cs:dummy	;EBX = xxxx0000

;	movzx	esi, WORD PTR [ebx+0E00Ah]	; ESI = Offset of rth_pci_device_limit.
	
;	add	esi, ebx		; ESI = ptr to rth_pci_device_limit.
;	movzx	ecx, byte ptr [esi+1]	; ECX = rth_pci_device_count.
;
;	movzx	esi, WORD PTR [esi+4]	; ESI = offset of rth_pci_irq_routing_table.
;	add	esi, ebx		; ESI = ptr to rth_pci_irq_routing_table.

	mov	ebx, 0F0000h
	movzx	esi, WORD PTR [ebx+003Ah]
	add	esi, ebx
	movzx	ecx, word ptr [esi+6]	; ECX = size of header and routing table
	sub	ecx,20h		; remove size of header
	add	esi,20h		; point to routing table    
	shr	ecx,4		; convert size to count

	pop	ebx			;Restore Bus/Dev/Func #
endif

	and	bl, 0F8h		;Zero out function number
	xchg	bh, bl			;Swap Bus # and Dev # to match table

get_irq_next_dev:
	cmp	word ptr ((pci_irq_entry ptr [esi]).pirq_bus_number), bx
	je	get_irq_found_dev	;Br if found proper bus#/dev#
	add	esi, size pci_irq_entry	;ESI points to next entry in table
	loop	get_irq_next_dev
	stc				;Indicate error
	jmp	short get_irq_done

get_irq_found_dev:
	lea	esi, (pci_irq_entry ptr [esi]).pirq_inta_reg
	dec	dl			;DL = 0/1/2/3 for Int A/B/C/D
	mov	dh, dl
	shl	dl, 2			;DL = 0/4/8/C for Int A/B/C/D
	sub	dl, dh			;DL = 0/3/6/9 for Int A/B/C/D
	movzx	ebx, dl			;EBX = 0/3/6/9 for Int A/B/C/D
	add	esi, ebx		;ESI points to chipset reg value
	mov	al, byte ptr [esi]	;AL = chipset reg value
	mov	dx, word ptr [esi+1]	;DX = bitmap of routable IRQs
	clc

get_irq_done:
	pop	esi
	pop	ecx
	pop	ebx
	ret
	assume	ds:nothing
endproc rth_pci_get_irq_reg


;---------------------------------------;
; rth_pci_search_xlat                   ;	MOVED TO OEMRPCI.ASM
;---------------------------------------;
; rth_pci_get_last_bus                  ;
;---------------------------------------;--------------------------------------;
; This function returns the number of the last PCI bus in the system.  If the  ;
; system has one PCI bus this function should return 0.                        ;
;                                                                              ;
; NOTE: This function does not need to be modified for most platforms.         ;
;                                                                              ;
; NOTE: This function is assembled twice, once for real mode code, and once    ;
;       for 32 bit protected mode code.  All calls must be made using the      ;
;       callproc macro.  Do not modify and segment registers.                  ;
;                                                                              ;
; Input:  None                                                                 ;
;                                                                              ;
; Output: CL = Bus number of last PCI bus                                      ;
;                                                                              ;
; Destroys: Nothing                                                            ;
;------------------------------------------------------------------------------;
defproc	rth_pci_get_last_bus
    push    ebx
    call    dummy           ;Push EIP on stack
dummy:
    pop ebx         ;EBX = EIP = xxxx0000 + offset dummy
    sub ebx, offset cs:dummy    ;EBX = xxxx0000
    add ebx, offset LastPciBus
    mov cl, [ebx]
    pop ebx
    ret
;					;(BUG2581+)>
;					;(BUG2581.1)>
;;if	MKF_MULTI_HOST_BR
;	push	ax
;	mov	al, MKF_MULTI_HOST_BR
;	cmp	al, 0
;	pop	ax
;	je	@f
;	callproc rth_chipset_get_last_bus
;	ret
;@@:
;;else
;					;<(BUG2581.1)
;					;<(BUG2581)
;	push	ax
;	push	bx
;	push	dx
;	push	di
;	push	cx			;Keep this last on stack
;
;	xor	dl, dl			;Default Max Bus is 0
;	mov	bx, 0000h		;Bus 0 / Device 00 / Func 0
;last_bus_next_dev:
;					;(CORE0141)>
;comment ~
;	mov	di, PCI_REG_SUB_TYPE
;	callproc rtpci_read_cfg_word	;Returns Base class / Sub class in CX
;	jc	last_bus_skip_dev	;Br if error reading CFG space
;	cmp	cx, (BT_BRIDGE * 100h) + ST_PCI_BR
;	jne	last_bus_skip_dev	;Br if not a PCI-PCI bridge
;
;	mov	di, PPB_REG_SUB_BUS_NUM
;	callproc rtpci_read_cfg_byte	;Returns Subordinate bus # in CL
;	jc	last_bus_skip_dev	;Br if error reading CFG space
;	cmp	cl, dl
;	jbe	last_bus_skip_dev	;Br if <= current Max Bus #
;	mov	dl, cl			;Update Max Bus #
;~
;	mov	di, PCI_REG_VENDID
;	callproc rtpci_read_cfg_word	;Returns Vendor/Device IDs in CX
;	jc	last_bus_skip_dev	;Br if error reading CFG space
;	inc	cx
;	jz	last_bus_skip_dev	;Br if no device
;	mov	di, PCI_REG_HEADER_TYPE
;	callproc rtpci_read_cfg_byte	;Returns Header Type in CL
;	test	cl, MULTI_FUNC_BIT	; Multi-Func?
;	mov	dh, 0
;	jz	short check_is_p2p	; No, Skip..
;	mov	dh, 7
;check_is_p2p:
;	and	bl, NOT 07h
;	or	bl, dh
;	mov	di, PCI_REG_SUB_TYPE
;	callproc rtpci_read_cfg_word	;Returns Base class / Sub class in CX
;	jc	last_bus_skip_dev_func	;Br if error reading CFG space
;;	cmp	cx, (BT_BRIDGE * 100h) + ST_PCI_BR
;	cmp	cx, (6 * 100h) + 4
;	jne	last_bus_skip_dev_func	;Br if not a PCI-PCI bridge
;
;	mov	di, PPB_REG_SUB_BUS_NUM
;	callproc rtpci_read_cfg_byte	;Returns Subordinate bus # in CL
;	jc	last_bus_skip_dev_func	;Br if error reading CFG space
;	cmp	cl, dl
;	jbe	last_bus_skip_dev_func	;Br if <= current Max Bus #
;	mov	dl, cl			;Update Max Bus #
;last_bus_skip_dev_func:
;	dec	dh
;	jns	short check_is_p2p
;					;<(CORE0141)
;
;last_bus_skip_dev:
;	add	bl, 8			;Next PCI device
;	jnc	last_bus_next_dev	;Try device 00 - 1F (BL = 00 - F8)
;
;	pop	cx
;	mov	cl, dl
;	pop	di
;	pop	dx
;	pop	bx
;	pop	ax
;;endif	  				;(BUG2581+)(BUG2581.1-)
;	ret
endproc rth_pci_get_last_bus


;---------------------------------------;
; rth_pci_get_hw_mech                   ;
;---------------------------------------;--------------------------------------;
; This function returns the hardware mechanisms supported by this system.      ;
; Any of the following constants can be used:                                  ;
;     PCI_SPEC_CYCLE_M1, PCI_CFG_SPACE_M1                                      ;
;     PCI_SPEC_CYCLE_M2, PCI_CFG_SPACE_M2                                      ;
;                                                                              ;
; NOTE: This function is assembled twice, once for real mode code, and once    ;
;       for 32 bit protected mode code.  All calls must be made using the      ;
;       callproc macro.  Do not modify and segment registers.                  ;
;                                                                              ;
; Input:  None                                                                 ;
;                                                                              ;
; Output: AL = Hardware mechanisms supported by this system:                   ;
;                 Bit 7-6: Reserved                                            ;
;                 Bit 5:   If 1, special cycle mechanism 2 is supported        ;
;                 Bit 4:   If 1, special cycle mechanism 1 is supported        ;
;                 Bit 3-2: Reserved                                            ;
;                 Bit 1:   If 1, configuration space mechanism 2 is supported  ;
;                 Bit 0:   If 1, configuration space mechanism 1 is supported  ;
;                                                                              ;
; Destroys: Nothing                                                            ;
;------------------------------------------------------------------------------;
defproc	rth_pci_get_hw_mech
					;(CORE0185)>
;	mov	al, PCI_CFG_SPACE_M1	;Config mechanism 1 is default
	mov	al, MKF_PCI_CFG_HW_MECH	;Config mechanism 1 is default
					;<(CORE0185)
	ret
endproc rth_pci_get_hw_mech


;---------------------------------------;
; rth_pci_special_cycle                 ;
;---------------------------------------;--------------------------------------;
; This function is used to generate a special cycle on the specified PCI bus.  ;
; A special cycle "broadcasts" the data to all PCI devices on a bus.  The bus  ;
; number must be checked and carry should be set if the bus number is invalid. ;
;                                                                              ;
; NOTE: Special cycle is not supported here.  Modify this function only if     ;
;       special cycle support is needed.                                       ;
;                                                                              ;
; NOTE: This function is assembled twice, once for real mode code, and once    ;
;       for 32 bit protected mode code.  All calls must be made using the      ;
;       callproc macro.  Do not modify and segment registers.                  ;
;                                                                              ;
; Input:  BH = PCI bus number                                                  ;
;        EDX = Special cycle data                                              ;
;                                                                              ;
; Output: CF = Set if error, cleared otherwise                                 ;
;         AH = Non zero return code if CF set (see RT.EQU)                     ;
;                                                                              ;
; Destroys: Nothing                                                            ;
;------------------------------------------------------------------------------;
defproc	rth_pci_special_cycle
	mov	ah, RT_INVALID_FUNC
	stc
	ret
endproc rth_pci_special_cycle


;---------------------------------------;
; rth_pci_read_cfg                      ;
;---------------------------------------;--------------------------------------;
; This function reads a dword from the configuration space of given device /   ;
; function.  The bus number must be checked and carry should be set if the bus ;
; number is invalid.                                                           ;
;                                                                              ;
; NOTE: This function should only be called from RT-PCI.ASM.  All other        ;
; callers must call the rt_entry (in RT.ASM) with AH containing the proper     ;
; function number (see RT.EQU).                                                ;
;                                                                              ;
; Input:  BH = PCI Bus number                                                  ;
;         BL = Device / Function number                                        ;
;              Bits 7-3: PCI device number                                     ;
;              Bits 2-0: Function number within the device                     ;
;         DI = Register number (must be dword aligned address, this value has  ;
;              already been checked for validity)                              ;
;         SI = One of the following values: PCI_REG_ADDRESS_BYTE               ;
;              PCI_REG_ADDRESS_WORD, or PCI_REG_ADDRESS_DWORD                  ;
;                                                                              ;
; Output: ECX, CX, CL = Data read from configuration space (width depends on   ;
;                       value of SI on entry)                                  ;
;         CF = Set if error, cleared otherwise                                 ;
;                                                                              ;
; Destroys: Nothing                                                            ;
;------------------------------------------------------------------------------;
defproc rth_pci_read_cfg
	push	eax
	push	dx

	mov	ah, 80h			;Set enable bit
	mov	al, bh
	shl	eax, 16
	mov	ax, di			;Add in register offset part
	mov	ah, bl			;Add in dev/func num part
	and	al, 0FCh		;Make address dword aligned
	mov	dx, CFG_SPACE_INDEX_REG
	pushf				;Save current state of IF and CLI
	cli
	out	dx, eax			;Set the index

	mov	dx, di			;Get original config register address
	and	dx, 03h			;Isolate lower 2 bits
	add	dx, CFG_SPACE_DATA_REG	;Add offset (0/1/2/3) to data addr

	cmp	si, PCI_REG_ADDRESS_BYTE
	jne	read_cfg_try_word
	in	al, dx			;Read the config register
	mov	cl, al
	jmp	short read_cfg_done

read_cfg_try_word:
	cmp	si, PCI_REG_ADDRESS_WORD
	jne	read_cfg_try_dword
	in	ax, dx			;Read the config register
	mov	cx, ax
	jmp	short read_cfg_done

read_cfg_try_dword:
	in	eax, dx			;Read the config register
	mov	ecx, eax

read_cfg_done:
	popf				;Restore state of IF
	pop	dx
	pop	eax
	clc
	ret
endproc rth_pci_read_cfg


;---------------------------------------;
; rth_pci_write_cfg                     ;
;---------------------------------------;--------------------------------------;
; This function writes a dword to the configuration space of given device /    ;
; function.  The bus number must be checked and carry should be set if the bus ;
; number is invalid.                                                           ;
;                                                                              ;
; NOTE: This function should only be called from RT-PCI.ASM.  All other        ;
; callers must call the rt_entry (in RT.ASM) with AH containing the proper     ;
; function number (see RT.EQU).                                                ;
;                                                                              ;
; Input:  BH = PCI Bus number                                                  ;
;         BL = Device / Function number                                        ;
;              Bits 7-3: PCI device number                                     ;
;              Bits 2-0: Function number within the device                     ;
;         DI = Register number (must be dword aligned address, this value has  ;
;              already been checked for validity)                              ;
;         SI = One of the following values: PCI_REG_ADDRESS_BYTE               ;
;              PCI_REG_ADDRESS_WORD, or PCI_REG_ADDRESS_DWORD                  ;
;         ECX, CX, CL = Data to write to configuration space (width depends on ;
;                       value of SI)                                           ;
;                                                                              ;
; Output: CF = Set if error, cleared otherwise                                 ;
;                                                                              ;
; Destroys: Nothing                                                            ;
;------------------------------------------------------------------------------;
defproc	rth_pci_write_cfg
	push	eax
	push	dx

	mov	ah, 80h			;Set enable bit
	mov	al, bh
	shl	eax, 16
	mov	ax, di			;Add in register offset part
	mov	ah, bl			;Add in dev/func num part
	and	al, 0FCh		;Make address dword aligned
	mov	dx, CFG_SPACE_INDEX_REG
	pushf				;Save current state of IF and CLI
	cli
	out	dx, eax			;Set the index

	mov	dx, di			;Get original config register address
	and	dx, 03h			;Isolate lower 2 bits
	add	dx, CFG_SPACE_DATA_REG	;Add offset (0/1/2/3) to data addr

	cmp	si, PCI_REG_ADDRESS_BYTE
	jne	write_cfg_try_word
	mov	al, cl
	out	dx, al			;Write the config register
	jmp	short write_cfg_done

write_cfg_try_word:
	cmp	si, PCI_REG_ADDRESS_WORD
	jne	write_cfg_try_dword
	mov	ax, cx
	out	dx, ax			;Write the config register
	jmp	short write_cfg_done

write_cfg_try_dword:
	mov	eax, ecx
	out	dx, eax			;Write the config register

write_cfg_done:
	popf				;Restore state of IF
	pop	dx
	pop	eax
	clc
	ret

endproc rth_pci_write_cfg

					;(CORE0061.1+)>
stub_dummy_ret::
	ret

include RT-PCI30.asminc
include RT32SB.asminc

RT32_CSEG ENDS

END

;**********************************************************************
;**********************************************************************
;**                                                                  **
;**        (C)Copyright 1985-2013, American Megatrends, Inc.         **
;**                                                                  **
;**                       All Rights Reserved.                       **
;**                                                                  **
;**      5555 Oakbrook Parkway, Suite 200, Norcross, GA 30093        **
;**                                                                  **
;**                       Phone: (770)-246-8600                      **
;**                                                                  **
;**********************************************************************
;**********************************************************************
